{"Procedure":{"Name":"CLP","#comment":{},"ProductGroup":"SAS/OR","ProcedureHelp":{"#cdata":"Syntax: PROC CLP options ; \n    ACTIVITY activity specifications ; \n    ALLDIFF alldiff constraints ; \n    ARRAY array specifications ; \n    ELEMENT element constraints ; \n    FOREACH foreach constraints ; \n    GCC global cardinality constraints ; \n    LINCON linear constraints ; \n    REIFY reify constraints ; \n    REQUIRES resource requirement constraints ; \n    RESOURCE resource specifications ; \n    SCHEDULE schedule options ; \n    VARIABLE variable specifications ; \n\nThe CLP procedure is a finite-domain constraint programming solver for constraint \nsatisfaction problems (CSPs) with linear, logical, global, and scheduling constraints. \nIn addition to having an expressive syntax for representing CSPs, the solver features \npowerful built-in consistency routines and constraint propagation algorithms, a choice \nof nondeterministic search strategies, and controls for guiding the search mechanism \nthat enable you to solve a diverse array of combinatorial problems."},"ProcedureOptions":{"ProcedureOption":[{"ProcedureOptionName":"ACTDATA=|ACTIVITY=","ProcedureOptionHelp":{"#cdata":"[Syntax: ACTDATA= SAS-data-set | ACTIVITY=SAS-data-set] \n      \nIdentifies the input data set that defines the activities and temporal constraints. The temporal \nconstraints consist of time alignment-type constraints and precedence-type constraints."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"CONDATA=","ProcedureOptionHelp":{"#cdata":"[Syntax: CONDATA= SAS-data-set] \n      \nIdentifies the input data set that defines the linear constraints, variable types, and \nvariable bounds."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"DM=|DEM=","ProcedureOptionHelp":{"#cdata":"[Syntax: DM= m | DEM= m] \n      \nSpecifies the dead-end multiplier for the CSP. The dead-end multiplier is used to determine \nthe number of dead ends that are permitted before triggering a complete restart of the search \ntechnique in a scheduling environment"},"ProcedureOptionType":"V"},{"ProcedureOptionName":"DOMAIN=|DOM=","ProcedureOptionHelp":{"#cdata":"[Syntax: DOMAIN= [lb, ub] | DOM=[lb, ub]] \n      \nSpecifies the global domain of all variables to be the closed interval [lb, ub]."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"DPR=","ProcedureOptionHelp":{"#cdata":"[Syntax: DPR= n] \n      \nSpecifies an upper bound on the number of dead ends that are permitted before PROC CLP restarts \nor terminates the search, depending on whether or not a randomized search strategy is used. In \nthe case of a nonrandomized strategy, n is an upper bound on the number of allowable dead ends \nbefore terminating."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"FINDALLSOLNS|ALLSOLNS|FINDALL","ProcedureOptionHelp":{"#cdata":"Attempts to find all possible solutions to the CSP. When a randomized search strategy is used, it is \npossible to rediscover the same solution and end up with multiple instances of the same solution. \nThis is currently the case when you are solving scheduling-related problems. Therefore, this option \nis ignored when you are solving a scheduling-related problem."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"MAXSOLNS=","ProcedureOptionHelp":{"#cdata":"[Syntax: MAXSOLNS=n] \n      \nSpecifies the number of solution attempts to be generated for the CSP. The default \nvalue is 1. It is important to note, especially in the context of randomized strategies, \nthat an attempt could result in no solution, given the current controls on the search \nmechanism, such as the number of restarts and the number of dead-ends permitted. As a \nresult, the total number of solutions found might not match the MAXSOLNS= parameter."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"MAXTIME=","ProcedureOptionHelp":{"#cdata":"[Syntax: MAXTIME= m] \n      \nSpecifies an upper bound on the number of CPU seconds allocated for solving the \nproblem. Note that the time specified by the MAXTIME= option is checked only once \nat the end of each iteration. Therefore, the actual running time can be longer than \nthat specified by the MAXTIME= option. The difference depends on how long the last \niteration takes. If you do not specify this option, the procedure does not stop based \non the amount of time elapsed."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"NOPREPROCESS","ProcedureOptionHelp":{"#cdata":"Suppresses any preprocessing that would typically be performed for the problem."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"OUT=","ProcedureOptionHelp":{"#cdata":"[Syntax: OUT= SAS-data-set] \n      \nIdentifies the output data set that contains the solution(s) to the CSP, if any exist(s)."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"PREPROCESS","ProcedureOptionHelp":{"#cdata":"Permits any preprocessing that would typically be performed for the problem."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"RESDATA=|RESIN=","ProcedureOptionHelp":{"#cdata":"[Syntax: RESDATA= SAS-data-set] \n      \nIdentifies the input data set that defines the resources and their attributes such \nas capacity and resource pool membership. This information can be used in lieu of, \nor in combination with, the RESOURCE statement."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"RESTARTS=","ProcedureOptionHelp":{"#cdata":"[Syntax: RESTARTS= n] \n      \nSpecifies the number of restarts of the randomized search technique before terminating the \nprocedure. The default value is 3."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"SCHEDRES=","ProcedureOptionHelp":{"#cdata":"[Syntax: SCHEDRES= SAS-data-set (Experimental)] \n      \nIdentifies the output data set that contains the solutions to scheduling CSPs. \nThis data set contains the resource assignments of activities."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"SCHEDTIME=","ProcedureOptionHelp":{"#cdata":"[Syntax: SCHEDTIME= SAS-data-set (Experimental)] \n      \nIdentifies the output data set that contains the solutions to scheduling CSPs. \nThis data set contains the time assignments of activities."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"SCHEDULE=|SCHEDOUT=|","ProcedureOptionHelp":{"#cdata":"[Syntax: SCHEDULE=SAS-data-set (Experimental)] \n      \nIdentifies the output data set that contains the scheduling-related solution to the CSP, \nif one exists."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"SHOWPROGRESS","ProcedureOptionHelp":{"#cdata":"Prints a message to the log whenever a solution has been found. When a randomized strategy is used, \nthe number of restarts and dead ends that were required are also printed to the log. "},"ProcedureOptionType":"S"},{"ProcedureOptionName":"TIMETYPE=","ProcedureOptionHelp":{"#cdata":"Specifies the units for the value of the MAXTIME= option. The value of this option \ndetermines whether such time is CPU time or real time. The default value of this \noption is CPU."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"CPU","@Value2":"REAL"},"ProcedureOptionToolTips":{"@ToolTip1":"Specifies CPU time units for the value of the MAXTIME= option.","@ToolTip2":"Specifies REAL time units for the value of the MAXTIME= option."}},{"ProcedureOptionName":"USECONDATAVARS=","ProcedureOptionHelp":{"#cdata":"Specifies whether the numeric variables in the CONDATA= data set, with the exception \nof any reserved variables, are implicitly defined or not."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"0","@Value2":"1"},"ProcedureOptionToolTips":{"@ToolTip1":"Indicates that the numeric variables in the CONDATA= data set are not implicitly defined.","@ToolTip2":"Indicates that the numeric variables in the CONDATA= data set are implicitly defined, in  which case a VARIABLE statement is not necessary to define the variables in the data set."}},{"ProcedureOptionName":"VARASSIGN=","ProcedureOptionHelp":{"#cdata":"[Syntax: VARASSIGN= keyword | MIN] \n      \nSpecifies the value selection strategy. Currently there is only one value selection strategy. \nThe MIN strategy selects the minimum value from the domain of the selected variable."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"VARASSIGN=MIN","ProcedureOptionHelp":{"#cdata":"[Syntax: VARASSIGN= keyword | MIN] \n      \nSpecifies the value selection strategy. Currently there is only one value selection strategy. \nThe MIN strategy selects the minimum value from the domain of the selected variable."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"VARSELECT=","ProcedureOptionHelp":{"#cdata":"Specifies the variable selection strategy. Both static and dynamic strategies are available."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"FIFO","@Value2":"MAXCS","@Value3":"MINR","@Value4":"MAXC","@Value5":"MINRMAXC"},"ProcedureOptionToolTips":{"@ToolTip1":"[Static strategy]--Uses the first-in-first-out ordering of the variables as encountered by the procedure.","@ToolTip2":"[Static strategy]--Selects the variable with the maximum number of constraints.","@ToolTip3":"[Dynamic strategy]--Selects the variable with the smallest range (that is, the minimum value of upper  bound minus lower bound).","@ToolTip4":"[Dynamic strategy]--Selects the variable with the largest number of active constraints","@ToolTip5":"[Dynamic strategy]--Selects the variable with the smallest range, breaking ties by selecting one with  the largest number of active constraints."}}]},"ProcedureStatements":{"ProcedureStatement":[{"StatementName":"ACTIVITY","StatementHelp":{"#cdata":"Syntax: ACTIVITY specification <...> ;\n      \nAn ACTIVITY specification can be one of the following types: \n\n    activity <= ( <DUR=> duration <type=date ...>)> \n\n    (activity_list) <= ( <DUR=> duration <type=date ...>)> \n\nwhere duration is the activity duration and type is a keyword specifying an alignment-type \nconstraint on the activity (or activities) with respect to the date given by date. \n\nThe ACTIVITY statement defines one or more activities and the attributes of each activity, such as \nthe duration and any temporal constraints of the time alignment type. The default duration is 0. \n\nValid type keywords are as follows: \n\n  o SGE, start greater than or equal to date\n  o SLE, start less than or equal to date \n  o FGE, finish greater than or equal to date \n  o FLE, finish less than or equal to date \n\nYou can specify any combination of the preceding keywords. For example, to define \nactivities A1, A2, A3, B1, and B3 with duration 3, and to set the start time of \nthese activities equal to 10, you would specify the following: \n\n   activity (A1-A3 B1 B3) = ( dur=3 sge=10 sle=10 );"},"StatementOptions":null},{"StatementName":"ALLDIFF|ALLDIFFERENT","StatementHelp":{"#cdata":"Syntax: ALLDIFF (variables) <...> ; | ALLDIFFERENT (variables) <...> ;\n      \nThe ALLDIFF statement can have multiple specifications. Each specification defines \na unique global constraint on a set of variables requiring all of them to be different \nfrom each other. A global constraint is equivalent to a conjunction of elementary \nconstraints. \n\nFor example, the statements \n\n   var (X1-X3) A B;\n   alldiff (X1-X3) (A B);\n\nare equivalent to \n  \n  X1 \u2260 X2 AND\n  X2 \u2260 X3 AND\n  X1 \u2260 X3 AND\n   A \u2260 B       \n\nIf the variable list is empty, the ALLDIFF constraint applies to all the variables \ndeclared in the VAR statement."},"StatementOptions":null},{"StatementName":"ARRAY","StatementHelp":{"#cdata":"Syntax: ARRAY specification <...> ;\n      \nAn ARRAY specification is in a form as follows: \n\n    name[dimension](variables) \n\nThe ARRAY statement is used to associate a name with a list of variables. Each of \nthe variables in the variable list must be defined using a VAR statement. The ARRAY \nstatement is required when you are specifying a constraint by FOREACH statement."},"StatementOptions":null},{"StatementName":"ELEMENT","StatementHelp":{"#cdata":"Syntax: ELEMENT element_constraint-1 <...element_constraint-n> ; \nAn element_constraint is specified in the following form: \n\n  (index variable, (integer list), variable) \n\nThe ELEMENT statement specifies one or more element constraints. An element constraint \nenables you to define dependencies, not necessarily functional, between variables."},"StatementOptions":null},{"StatementName":"FOREACH","StatementHelp":{"#cdata":"Syntax: FOREACH (array, type, <offset>) ; \n      \nwhere array must be defined by using an ARRAY statement, type is a keyword that \ndetermines the type of the constraint, and offset is an integer. \n\nThe FOREACH statement iteratively applies a constraint over an array of variables. \nThe type of the constraint is determined by type. Currently, the only valid type \nkeyword is DIFF. The optional offset parameter is an integer and is interpreted in \nthe context of the constraint type. The default value of offset is zero."},"StatementOptions":null},{"StatementName":"LINCON|LINEAR","StatementHelp":{"#cdata":"Syntax: LINCON linear_constraint <, ...> ; | LINEAR linear_constraint <, ...> ; \n\nA linear_constraint is specified in the following form: \n\n    linear_term_1 operator linear_term_2 \n\nwhere a linear_term is of the form \n\n    ((<+|-> variable | number <* variable >)...) \n\nThe keyword operator can be one of the following: \n\n    <, \u2264, =,  \u2265 , >, <>, LE, EQ, GE, LT, GT, NE \n\nThe LINCON statement allows for a very general specification of linear constraints."},"StatementOptions":null},{"StatementName":"GCC","StatementHelp":{"#cdata":"Syntax: GCC global_cardinality_constraint-1 <...global_cardinality_constraint-n> ; \n      \nwhere global_cardinality_constraint is specified in the following form: \n\n  (variables) = ((v1,l1,u1)  <...(vn,ln,un)> <DL= dl> <DU= du> ) \n\nvi is a value in the domain of one of the variables, and li and ui are the lower \nand upper bounds on the number of variables assigned to vi. The values of dl and \ndu are the lower and upper bounds on the number of variables assigned to values \nin D outside of (v1,...,vn). \n\nThe GCC statement specifies one or more global cardinality constraints. A global \ncardinality constraint (GCC) is a constraint that consists of a set of variables  \n{xi,...,xn} and for each value v in D=Ui=1,...,nDom(xi), a pair of numbers lv and \nuv. A GCC is satisfied if and only if the number of times that a value v in D is \nassigned to the variables x1,...,xn is at least lv and at most uv."},"StatementOptions":null},{"StatementName":"REIFY","StatementHelp":{"#cdata":"Syntax: REIFY variable : (linear_constraint) <...> ; \nA linear_constraint is specified in the following form: \n\n    linear_term_1 operator linear_term_2 \n\nwhere a linear_term is of the form \n\n    ((<+|-> variable | number <* variable >)...) \n\nThe keyword operator can be one of the following: \n\n    <, \u2264, =,  \u2265 , >, <>, LE, EQ, GE, LT, GT, NE \n\nThe REIFY statement associates a binary variable with a linear constraint. The value \nof the binary variable is 1 or 0 depending on whether the linear constraint is satisfied \nor not, respectively. The linear constraint is said to be reified, and the binary variable \nis referred to as the control variable. As with the other variables, the control variable \nmust also be defined in a VAR statement or in the CONDATA= data set."},"StatementOptions":null},{"StatementName":"REQUIRES|REQ","StatementHelp":{"#cdata":"Syntax: REQUIRES resource_constraint-1 <...resource_constraint-n> ; \n      \nwhere resource_constraint is specified in the following form: \n\n  activity_specification = (resource_specification) <qty = > \n\nwhere\n\n  activity_specification: (activity | activity-1 <...activity-m>) \n\nand \n\n  resource_specification: (resource-1 <qty = > <...(,  OR) resource- <qty=>>) \n\nactivity_specification is a single activity or a list of activities that requires \nq units of the resource identified in resource_specification. resource_specification \nis a single resource or a list of resources, representing a choice of resource, along \nwith the equivalent required quantities for each resource. The default value of ri \nis 1. Alternate resource requirements are separated by a comma (,) or the keyword OR. \nThe qty= parameter outside the resource_specification acts as a multiplier to the qty= \nparameters inside the resource_specification. \n\nThe REQUIRES statement defines the potential activity assignments with respect to the \npool of resources. If an activity is not defined, the REQUIRES statement implicitly \ndefines the activity."},"StatementOptions":null},{"StatementName":"RESOURCE|RES","StatementHelp":{"#cdata":"Syntax: RESOURCE specification <...> ;  | RES specification <...> ; \n\nA RESOURCE specification is a single resource or a list of resources. \n\nThe RESOURCE statement specifies the names of all resources that are available to be \nallocated to the activities. The REQUIRES statement is necessary to specify the resource \nrequirements of an activity. Currently all resources are assumed to be unary resources \nin that their capacity is equal to one and they cannot be assigned to more than one \nactivity at any given time."},"StatementOptions":null},{"StatementName":"SCHEDULE|SCHED","StatementHelp":{"#cdata":"Syntax: SCHEDULE options ; | SCHED options ;"},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ACTASSIGN=","StatementOptionHelp":{"#cdata":"[Syntax: ACTASSIGN= keyword] \n          \nSpecifies the activity assignment strategy subject to the setting of the ACTSELECT= option."},"StatementOptionType":"V"},{"StatementOptionName":"ACTSELECT=","StatementOptionHelp":{"#cdata":"Specifies the activity selection strategy."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"LJRAND","@Value2":"RAND","@Value3":"MAXD","@Value4":"MINA","@Value5":"MINLS","@Value6":"RJRAND","@Value7":"DET","@Value8":"DMNLS"},"StatementOptionToolTips":{"@ToolTip1":"[Randomized selection strategy]                                      Selects an activity at random from those that begin prior to the earliest early  finish time. This is the default strategy.","@ToolTip2":"[Randomized selection strategy]                                      See the LJRAND selection strategy.","@ToolTip3":"[Randomized selection strategy]                                      Selects an activity at random from those that begin prior to the earliest early  finish time and that have maximum duration.","@ToolTip4":"[Randomized selection strategy]                                      Selects an activity at random from those that begin prior to the earliest early  finish time and that have the minimum number of resource assignments.","@ToolTip5":"[Randomized selection strategy]                                      Selects an activity at random from those that begin prior to the earliest early  finish time and that have a minimum late start date.","@ToolTip6":"[Randomized selection strategy]                                      Selects an activity at random from those that finish after the latest late start time.","@ToolTip7":"[Deterministic selection strategy]                                      Selects the first activity that begins prior to the earliest activity finish date.","@ToolTip8":"[Deterministic selection strategy]                                      Selects the activity with the earliest late start time."}},{"StatementOptionName":"DURATION=|SCHEDDUR=|DUR=","StatementOptionHelp":{"#cdata":"[Syntax: DURATION= dur | DUR= dur] \n          \nSpecifies the duration of the schedule."},"StatementOptionType":"V"},{"StatementOptionName":"EDGEFINDER=|EDGE=","StatementOptionHelp":{"#cdata":"[Syntax: EDGEFINDER <=eftype> | EDGE <=eftype>] \n          \nActivates the edge-finder consistency routines for scheduling problems. By default, \nthe EDGEFINDER= option is inactive. Specifying the EDGEFINDER= option determines \nwhether an activity must be the first or the last to be processed from a set of \nactivities requiring a given resource or set of resources and prunes the domain \nof activity as appropriate. Specifying EDGEFINDER by itself is equivalent to \nspecifying EDGEFINDER=LAST."},"StatementOptionType":"V","#text":"\n          StatementOptionValues Value1=\"FIRST\" Value2=\"LAST\" Value3=\"BOTH\" />\n          ","StatementOptionToolTips":{"@ToolTip1":"The edge-finder algorithm attempts to determine whether an activity must be processed  first from a set of activities requiring a given resource or set of resources and  prunes its domain as appropriate.","@ToolTip2":"The edge-finder algorithm attempts to determine whether an activity must be processed  last from a set of activities requiring a given resource or set of resources and prunes  its domain as appropriate.","@ToolTip3":"This is equivalent to specifying both FIRST and LAST. The edge-finder algorithm attempts  to determine which activities must be first and which activities must be last, and  updates their domains as necessary."}},{"StatementOptionName":"FINISH=|END=|FINISHBEFORE=","StatementOptionHelp":{"#cdata":"[Syntax: FINISH= finish] \n          \n Specifies the finish time for the schedule. The schedule finish time is an upper \n bound on the finish time of each activity (subject to time, precedence, and resource \n constraints). If you want to impose a tighter upper bound for an activity, you can do \n so either by using the FLE=  specification in an ACTIVITY statement or by using the \n _ALIGNDATE_ and _ALIGNTYPE_ variables in the ACTDATA= data set."},"StatementOptionType":"V"},{"StatementOptionName":"NOTFIRST=|NF=","StatementOptionHelp":{"#cdata":"[Syntax: NOTFIRST= level | NF= level] \n          \nActivates an extension of the edge-finder consistency routines for scheduling problems. \nBy default, the NOTFIRST= option is inactive. Specifying the NOTFIRST= option determines \nwhether an activity cannot be the first to be processed from a set of activities requiring \na given resource or set of resources and prunes its domain as appropriate."},"StatementOptionType":"V"},{"StatementOptionName":"NOTLAST=|NL=","StatementOptionHelp":{"#cdata":"[Syntax: NOTLAST= level] \n          \nActivates an extension of the edge-finder consistency routines for scheduling problems. \nBy default, the NOTLAST= option is inactive. Specifying the NOTLAST= option determines \nwhether an activity cannot be the last to be processed from a set of activities requiring \na given resource or set of resources and prunes its domain as appropriate."},"StatementOptionType":"V"},{"StatementOptionName":"START=|BEGIN=|STARTAFTER=","StatementOptionHelp":{"#cdata":"[Syntax: START= start | BEGIN=start] \n          \nSpecifies the start time for the schedule. The schedule start time is a lower bound on \nthe start time of each activity (subject to time, precedence, and resource constraints). \nIf you want to impose a tighter lower bound for an activity, you can do so either by \nusing the SGE= specification in an ACTIVITY statement or by using the _ALIGNDATE_ and \n_ALIGNTYPE_ variables in the ACTDATA= data set."},"StatementOptionType":"V"}]}},{"StatementName":"VARIABLE|VAR","StatementHelp":{"#cdata":"Syntax: VARIABLE var_specification-1 <...var_specification-n> ; \n\n      \nA var_specification-1 can be one of the following types: \n\n    variable <=[lower-bound <, upper-bound>]> \n\n    (variables) <=[lower-bound <, upper-bound>]> \n\nThe VARIABLE statement declares all the variables that are to be considered in the \nCSP and, optionally, defines their domains. Any variable domains defined in a VARIABLE \nstatement override the global variable domains defined using the DOMAIN= option in the \nPROC CLP statement as well as any bounds defined using the CONDATA= data set. If lower-\nbound is specified and upper-bound is omitted, the corresponding variables are considered \nas being assigned to lower-bound. The values of lower-bound and upper-bound can also be \nspecified as missing, in which case the appropriate values from the DOMAIN= specification \nare substituted."},"StatementOptions":null}]}}}