{"Procedure":{"Name":"CMDC","ProductGroup":"SAS ECONOMETRICS PROCEDURES","ProcedureHelp":{"#cdata":"Syntax: PROC CMDC <options>;\n    BY variables;\n    CLASS variable <(options)> <variable <(options)>> </ global-options>;\n    FREQ variable;\n    WEIGHT variable;\n    ID variables;\n    CHOICEID variables;\n    TIMEID <variables>;\n    MODEL dependent-variable = regressors </ model-options>;\n    MIXED <normal=variables> <uniform=variables> <lognormal=variables>; \n    OUTPUT <OUT=SAS-data-set> <keyword <=name>>\u2026\n      <keyword <=name>> </ options>;\n    INIT initialization1 < , initialization2 \u2026>;\n    BOUNDS bound1 [ , bound2 \u2026];\n    RESTRICT restriction1 [, restriction2 \u2026];\n    \nThe CMDC (Cloud-enabled Multinomial Discrete Choice) procedure is a cloud-enabled procedure that fits \nbinary and multinomial discrete choice models. Discrete choice models, also known as consumer choice \nmodels, qualitative choice models, are econometric models that describe and explain choices over time \namong a finite set of discrete alternatives. The decision makers could be consumers, households, firms \nor other agents. For example, a customer chooses which of several competing products to buy; a firm \ndecides which suppliers to use; a traveler decides which mode of transportations to reach a destination; \na high-school senior decides which colleges to attend."},"ProcedureOptions":{"ProcedureOption":[{"ProcedureOptionName":"DATA=","ProcedureOptionHelp":{"#cdata":"Syntax: DATA=SAS-data-set\n      \nSpecifies the input SAS data set. If the DATA= option is not specified, PROC CMDC uses \nthe most recently created SAS data set."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"CORRB","ProcedureOptionHelp":{"#cdata":"Prints the correlation matrix of the parameter estimates."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"COVB","ProcedureOptionHelp":{"#cdata":"Prints the covariance matrix of the parameter estimates."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"NOPRINT","ProcedureOptionHelp":{"#cdata":"Suppresses all printed output."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"PRINTALL","ProcedureOptionHelp":{"#cdata":"Requests all printing options."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"PRINTTIMING","ProcedureOptionHelp":{"#cdata":"Prints a timing report."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"PRINTINTERNALNAMES","ProcedureOptionHelp":{"#cdata":"Prints internal names assigned to parameters."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"COVEST=","ProcedureOptionHelp":{"#cdata":"Specifies the type of covariance matrix for the parameter estimates."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"OP","@Value2":"HESSIAN","@Value3":"QML"},"ProcedureOptionToolTips":{"@ToolTip1":"Specifies the covariance from the outer product matrix.","@ToolTip2":"Specifies the covariance from the Hessian matrix.","@ToolTip3":"Specifies the covariance from the outer product and Hessian matrices"}},{"ProcedureOptionName":"MAXFUNC=|MAXFU=","ProcedureOptionHelp":{"#cdata":"Syntax: MAXFUNC= | MAXFU=i \n          \nSpecifies the maximum number of function calls in the optimization process. The default is 1,000. \n\nThe optimization can terminate only after completing a full iteration. Therefore, the number of \nfunction calls that is actually performed can exceed the number that is specified by this option."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"MAXITER=|MAXIT=","ProcedureOptionHelp":{"#cdata":"Syntax: MAXITER=i | MAXIT=i \n          \n Specifies the maximum number of iterations in the optimization process. \n \n The default value is 200."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"MAXTIME=","ProcedureOptionHelp":{"#cdata":"Syntax: MAXTIME=r \n          \nSpecifies an upper limit of r seconds of CPU time for the optimization process. The default \nvalue is the largest floating-point double representation of your computer. The time specified \nby this option is checked only once at the end of each iteration. Therefore, the actual running \ntime can be much longer than r. The actual running time includes the remaining time needed to \nfinish the iteration and the time needed to generate the output of the results."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"METHOD=","ProcedureOptionHelp":{"#cdata":"Specifies the iterative minimization method to use. The default is METHOD=NEWRAP."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"CONGRA","@Value2":"DBLDOG","@Value3":"NONE","@Value4":"NEWRAP","@Value5":"NRRIDG","@Value6":"QUANEW","@Value7":"TRUREG"},"ProcedureOptionToolTips":{"@ToolTip1":"Specifies a conjugate-gradient method","@ToolTip2":"Specifies the double dogleg method","@ToolTip3":"Specifies that no optimization be performed beyond using the ordinary least squares method  to compute the parameter estimates. ","@ToolTip4":"Specifies the Newton-Raphson method (this is the default). ","@ToolTip5":"Specifies the Newton-Raphson Ridge method.","@ToolTip6":"Specifies the quasi-Newton method.","@ToolTip7":"Specifies the trust region method."}}]},"ProcedureStatements":{"ProcedureStatement":[{"StatementName":"BY","StatementHelp":{"#cdata":"Syntax: BY variable;\n\nA BY statement can be used with PROC CMDC to obtain separate analyses on observations in groups \ndefined by the BY variables.\n\nBY statement processing is not supported when the CMDC procedure runs alongside the database or \nalongside the Hadoop Distributed File System (HDFS). These modes are used if the input data are \nstored in a database or HDFS and the grid host is the appliance that houses the data."},"StatementOptions":null},{"StatementName":"CLASS","StatementHelp":{"#cdata":"Syntax: CLASS variable <(options)> <variable <(options)>> </ global-options>;\n\nThe CLASS statement names the classification variables to be used as explanatory variables in the analysis. \nThe CLASS statement must precede the MODEL statement."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"DESCENDING|DESC","StatementOptionHelp":{"#cdata":"Reverses the sort order of the classification variable. If both the DESCENDING and ORDER= options \nare specified, PROC BCHOICE orders the categories according to the ORDER= option and then reverses \nthat order."},"StatementOptionType":"S"},{"StatementOptionName":"MISSING","StatementOptionHelp":{"#cdata":"Treats missing values (., ._, .A, \u2026, .Z for numeric variables and blanks for character variables) \nas valid values for the CLASS variable. "},"StatementOptionType":"S"},{"StatementOptionName":"ORDER=","StatementOptionHelp":{"#cdata":"Specifies the sort order for the levels of classification variables. This ordering determines which \nparameters in the model correspond to each level in the data. By default, ORDER=FORMATTED. \nFor ORDER=FORMATTED and ORDER=INTERNAL, the sort order is machine-dependent. When ORDER=FORMATTED \nis in effect for numeric variables for which you have supplied no explicit format, the levels are \nordered by their internal values."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"FORMATTED","@Value2":"FREQ","@Value3":"INTERNAL"},"StatementOptionToolTips":{"@ToolTip1":"Levels sorted by the external formatted value, except for numeric variables with no explicit  format, which are sorted by their unformatted (internal) value.","@ToolTip2":"Levels sorted by the descending frequency count (levels that have more observations come ealier  in the order).","@ToolTip3":"Levels sorted by the unformatted value. The sort order is machine-dependent."}},{"StatementOptionName":"PARAM=","StatementOptionHelp":{"#cdata":"Specifies the parameterization method for the classification variable or variables."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"EFFECT","@Value2":"GLM","@Value3":"ORDINAL|THERMOMETER","@Value4":"POLYNOMIAL|POLY","@Value5":"REFERENCE|REF","@Value6":"ORTHEFFECT","@Value7":"ORTHORDINAL|ORTHOTHERM","@Value8":"ORTHPOLY","@Value9":"ORTHREF"},"StatementOptionToolTips":{"@ToolTip1":"Specifies effect coding.","@ToolTip2":"Specifies less-than-full-rank, reference-cell coding; this option can be used  only as a global option.","@ToolTip3":"Specifies the cumulative parameterization for an ordinal CLASS variable.","@ToolTip4":"Specifies polynomial coding.","@ToolTip5":"Specifies reference-cell coding.","@ToolTip6":"Orthogonalizes PARAM=EFFECT.","@ToolTip7":"Orthogonalizes PARAM=ORDINAL.","@ToolTip8":"Orthogonalizes PARAM=POLYNOMIAL.","@ToolTip9":"Orthogonalizes PARAM=REFERENCE."}},{"StatementOptionName":"REFERENCE=|REF=","StatementOptionHelp":{"#cdata":"Syntax: REFERENCE='level'|keyword | REF='level'|keyword \n\nSpecifies the reference level that is used when you specify a nonsingular parameterization. "},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"'<level>'","@Value2":"FIRST","@Value3":"LAST"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the level of the variable to use as the reference level. Specify the formatted value of the variable  if a format is assigned. Replace <level> with an actual value.","@ToolTip2":"Designates the first ordered level as reference.","@ToolTip3":"Designates the last ordered level as reference."}}]}},{"StatementName":"FREQ","StatementHelp":{"#cdata":"Syntax: FREQ variable;\n\n\nThe variable in the FREQ statement identifies a numeric variable in the data set that contains the \nfrequency of occurrence for each observation. Cloud-Enabled Analytics procedures that support the \nFREQ statement treat each observation as if it appeared f times, where the frequency value f is the \nvalue of the FREQ variable for the observation. If f is not an integer, then f is truncated to an \ninteger. If f is less than 1 or missing, the observation is not used in the analysis. When the FREQ \nstatement is not specified, each observation is assigned a frequency of 1."},"StatementOptions":null},{"StatementName":"WEIGHT","StatementHelp":{"#cdata":"Syntax: WEIGHT variable;\n\nThe variable in the WEIGHT statement is used as a weight to perform a weighted analysis of the data. \nObservations with nonpositive or missing weights are not included in the analysis. If a WEIGHT statement \nis not included, then all observations used in the analysis are assigned a weight of 1."},"StatementOptions":null},{"StatementName":"ID","StatementHelp":{"#cdata":"Syntax: ID variables;\n\nThe ID statement lists the following required one or more variables from the input data set that \nidentifies individual decision makers."},"StatementOptions":null},{"StatementName":"CHOICEID","StatementHelp":{"#cdata":"Syntax: CHOICEID variables;\n\nThe CHOICEID statement lists a required variable from the input data set that identifies the ID variable \nfor the alternatives."},"StatementOptions":null},{"StatementName":"TIMEID","StatementHelp":{"#cdata":"Syntax: TIMEID variables;\n\nThe TIMEID statement is an optional statement and it is only required when the input data set is a panel \ndata set. That is, there are repeated observations over time for each individual decision maker. In the \npanel data case, the TIMEID statement identifies the time variable in the input data set."},"StatementOptions":null},{"StatementName":"MODEL","StatementHelp":{"#cdata":"Syntax: MODEL response = <effects> </ model-options>;\n\nThe MODEL statement defines the statistical model in terms of a response variable (the target), \nmodel effects constructed from variables in the input data set, and options. The dependent variable \nmust be a decision variable which should have a binary value of 0 and 1, with 1 indicating the \nalternative chosen by the decision maker."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"NOINT","StatementOptionHelp":{"#cdata":"Requests that no intercept be included in the model. An common intercept is included by default. \nTo specify alternative-specific intercepts for a multinomial model, create dummy variables for \neach alternative except the base alternative and include these dummy variables in the model with \nNOINT option."},"StatementOptionType":"S"},{"StatementOptionName":"TYPE=","StatementOptionHelp":{"#cdata":"Syntax: TYPE=keyword \n          \nSpecifies the model type of the discrete choice model. "},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"CLOGIT","@Value2":"MLOGIT","@Value3":"PROBIT"},"StatementOptionToolTips":{"@ToolTip1":"Specifies a conditional logit model type.","@ToolTip2":"Specifies a mixed logit model type.","@ToolTip3":"Specifies a probit model type."}}]}},{"StatementName":"MIXED","StatementHelp":{"#cdata":"Syntax:MIXED variables;\n\nThe MIXED statement lists random variables for a mixed logit model. There three types of random \ndistributions are supported: normal, uniform or log normal distributions."},"StatementOptions":null},{"StatementName":"OUTPUT","StatementHelp":{"#cdata":"Syntax:OUTPUT <OUT=SAS-data-set> <keyword <=name>>\u2026<keyword <=name>> </ options>;\n\nThe OUTPUT statement creates a data set that contains observationwise statistics that are computed \nafter fitting the model. The variables in the input data set are not included in the output data \nset to avoid data duplication for large data sets; however, variables specified in the ID statement \nor COPYVAR= option are included.robabilities (P). The input data set must be sorted by the \nchoice variable(s) within each ID."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"OUT=|DATA=","StatementOptionHelp":{"#cdata":"Syntax: OUT=SAS-data-set |  DATA=SAS-data-set\n          \nSpecifies the name of the output data set. If the OUT= (or DATA=) option is omitted, the procedure \nuses the DATAn convention to name the output data set."},"StatementOptionType":"DV"},{"StatementOptionName":"LNIP|XBETA","StatementOptionHelp":{"#cdata":"Syntax: LNIP|XBETA <=name>\n          \nRequests a linear predictor \u03b7 = x'\u03b2."},"StatementOptionType":"RS|RV"},{"StatementOptionName":"PREDICTED|PRED|P","StatementOptionHelp":{"#cdata":"Syntax: PREDICTED | PRED | P\n          \nRequests predicted values (predicted probabilities of events) for the response variable."},"StatementOptionType":"RS|RV"},{"StatementOptionName":"COPYVAR=","StatementOptionHelp":{"#cdata":"Syntax: COPYVAR=variable | COPYVAR=(variables)\n          \nTransfers one or more variables from the input data set to the output data set."},"StatementOptionType":"V"}]}},{"StatementName":"BOUNDS","StatementHelp":{"#cdata":"Syntax: BOUNDS bound1 [, bound2 \u2026];\n\nThe BOUNDS statement imposes simple boundary constraints on the parameter estimates. You can specify \nany number of BOUNDS statements. \n\nEach bound is composed of parameters, constants, and inequality operators: \n\n  tem operator item [ operator item [ operator item \u2026] ]\n\nEach item is a constant, parameter, or list of parameters. Parameters associated with \na regressor variable are referred to by the name of the corresponding regressor variable. \nEach operator is \u2019<\u2019, \u2019>\u2019, \u2019\u2264\u2019, or \u2019\u2265\u2019."},"StatementOptions":null},{"StatementName":"INIT","StatementHelp":{"#cdata":"Syntax: INIT initialization1 < , initialization2 \u2026>;\n\nThe INIT statement sets initial values for parameters in the optimization.\n\nEach initialization is written as a parameter or parameter list, followed by an optional equal \nsign (=), followed by a number:\n\n  parameter <=> number"},"StatementOptions":null},{"StatementName":"RESTRICT","StatementHelp":{"#cdata":"Syntax: RESTRICT restriction1 [, restriction2 \u2026];\n\nThe RESTRICT statement imposes linear restrictions on the parameter estimates. You can specify \nany number of RESTRICT statements.\n\nEach restriction is written as an expression, followed by an equality operator (=) or an \ninequality operator (<, >, \u2264,  \u2265 ), followed by a second expression: \n\n  expression operator expression\n\nThe operator can be =, <, >, \u2264, or  \u2265 . \n\nRestriction expressions can be composed of parameter names, constants, and the following \noperators: times (*), plus (+), and minus (-). The restriction expressions must be a linear \nfunction of the variables."},"StatementOptions":null}]}}}