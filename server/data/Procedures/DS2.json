{"Procedure":{"Name":"DS2","ProductGroup":"BASE","ProcedureHelp":{"#cdata":"Syntax: PROC DS2 <table-server-connection-options> <option(s)>;   \n    <DS2 statements>\n    RUN |RUN CANCEL;\n    QUIT;\n\nData Step 2 (DS2), initially referred to as Table Server Programming Language (TSPL), \nis a new SAS proprietary programming language that is appropriate for advanced data manipulation \nand data modeling applications. The DS2 language combines traditional SAS DATA step processing \nwith the standard operations of SQL:1999 by integrating the two languages into one. DS2 supports \nthe ability to create, bulk load, and manipulate tables, create and execute stored routines.\n\nThe DS2 language driver is multi-threaded so that it takes advantage of parallel algorithms \nto increase the throughput of complex operations."},"ProcedureOptions":{"ProcedureOption":[{"ProcedureOptionName":"ANSIMODE","ProcedureOptionHelp":{"#cdata":"Specifies that nonexistent values are processed as ANSI SQL null values. By default, \nthe procedure processes nonexistent values as SAS missing values."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"BYPARTITION=","ProcedureOptionHelp":{"#cdata":"[Syntax: BYPARTITION=YES | NO]\n      \nDetermines whether the input data for the DS2 program is automatically re-partitioned when executed \ninside the database with in-database processing.\n      \nDefault\nYES"},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"YES","@Value2":"NO"},"ProcedureOptionToolTips":{"@ToolTip1":"Specifies that the input data is automatically re-partitioned by the first BY variable. All of the  BY groups are in the same data partition and processed by the same thread. Each thread does the BY  processing for the entire group of data.","@ToolTip2":"Specifies that the input data is not re-partitioned even if there is a BY statement in the DS2 program. Each group of data resides on different data partitions and is processed by different DS2 threads. Each thread gets partial data from a group, and each group is processed by multiple threads. The DS2 program must request the final aggregation of data."}},{"ProcedureOptionName":"DS2ACCEL=|INDB=","ProcedureOptionHelp":{"#cdata":"Syntax: DS2ACCEL=NO | YES \n      \nDetermines whether DS2 code is enabled for parallel processing in supported environments using the \nSAS In-Database Code Accelerator. The SAS In-Database Code Accelerator enables you to publish a DS2 \nthread program to the database and execute the thread program in parallel inside the database. If you \nare using Hadoop or Teradata, then the DS2 data program is also published and executed inside the database.\n      \nDefault:\nThe default is determined by the DS2ACCEL= system option. The default for the system option is NONE.\n\nInteractions\nINDB= is an alias for the PROC DS2 DS2ACCEL= option. Note that there is a change in the behavior from the \nprevious release in which the default value for the PROC DS2 INDB= option (now named DS2ACCEL=) enabled the \nSAS In-Database Code Accelerator to automatically trigger in-database processing. For the first maintenance \nrelease for SAS 9.4, the default has changed so that the SAS In-Database Code Accelerator is not executed \nin supported parallel environments. \n\nSpecifying the DS2ACCEL= option in the PROC DS2 statement takes precedence over the DS2ACCEL= system option.\n\nNote: The DS2ACCEL= system option can be restricted by a site administrator. If the system option is restricted, \nthen it cannot be overridden by the PROC DS2 DS2ACCEL= option."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"YES","@Value2":"NO"},"ProcedureOptionToolTips":{"@ToolTip1":"Enables DS2 code to execute in supported parallel environments.","@ToolTip2":"Disables DS2 code from executing in supported parallel environments. The DS2 code is executed in the Base SAS session."}},{"ProcedureOptionName":"ERRORSTOP","ProcedureOptionHelp":{"#cdata":"Specifies that the procedure stops executing if it encounters an error. In a batch \nor noninteractive session, ERRORSTOP instructs the procedure to stop executing \nthe statements but to continue checking the syntax after it has encountered an \nerror."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"NOERRORSTOP","ProcedureOptionHelp":{"#cdata":"Instructs the procedure to execute the statements and to continue checking the \nsyntax after an error occurs."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"EXEC","ProcedureOptionHelp":{"#cdata":"Specifies that a statement should be executed after its syntax is checked for accuracy. \n\nTip: NOEXEC is useful if you want to check the syntax of your SQL statements without \nexecuting the statements."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"NOEXEC","ProcedureOptionHelp":{"#cdata":"Specifies that a statement should not be executed after its syntax is checked \nfor accuracy. \n\nTip: NOEXEC is useful if you want to check the syntax of your SQL statements \nwithout executing the statements."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"LABEL","ProcedureOptionHelp":{"#cdata":"Specifies to use the column label or the column name as the column heading.\n\nInteraction: If a column does not have a label, the procedure uses the column's name as the column heading. \nInteraction: A column alias overwrites the label or column name as the column heading."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"NOLABEL","ProcedureOptionHelp":{"#cdata":"Specifies not to use the column label or the column name as the column heading."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"NUMBER","ProcedureOptionHelp":{"#cdata":"Specifies to include a column named ROW, which is the row (observation) number of \nthe data as the rows are retrieved.\n\nDefault: No row numbers."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"SCOND=","ProcedureOptionHelp":{"#cdata":"[Syntax: SCOND=WARNING | NONE | NOTE | ERROR]\n      \nSpecifies the level of messages that PROC DS2 displays in the SAS log for the DS2 variable declaration \nstrict mode, which requires that every variable must be declared in the DS2 program.\n      \nDefault:\nThe default is determined by the DS2SCOND= system option. The default for DS2SCOND= is WARNING. \n\nInteraction:\nSpecifying the SCOND= option in the PROC DS2 statement takes precedence over the DS2SCOND= system option."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"WARNING","@Value2":"NONE","@Value3":"NOTE","@Value4":"ERROR"},"ProcedureOptionToolTips":{"@ToolTip1":"Writes warning messages to the SAS log.","@ToolTip2":"No messages are written to the SAS log.","@ToolTip3":"Writes notes to the SAS log.","@ToolTip4":"Writes error messages to the SAS log."}},{"ProcedureOptionName":"STIMER","ProcedureOptionHelp":{"#cdata":"Specifies to write a subset of system performance statistics, such as time-elapsed \nstatistics, to the SAS log. When STIMER is in effect, the procedure writes to the \nSAS log a list of computer resources used for each step and the entire SAS session.\n\nDefault: No performance statistics are written to the SAS log. \n\nInteraction: If the SAS system option FULLSTIMER is in effect, the complete list of \ncomputer resources are written to the SAS log."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"STMTMEMLIMIT=","ProcedureOptionHelp":{"#cdata":"[Syntax: STMTMEMLIMIT=n | nM | nG]\n      \nSpecifies a limit for the amount of memory that is used for an underlying query (such as a SELECT statement), \nso that allocated memory is available to support other PROC DS2 operations. Specify the memory limit in \nmultiples of 1 (bytes); 1,048,576 (megabytes); or 1,073,741,824 (gigabytes). For example, the value 23m \nspecifies 24,117,248 bytes of memory.\n\nTip: Generally, specifying a memory limit is not necessary unless DS2 reports a memory problem error.\n      \n"},"ProcedureOptionType":"V"},{"ProcedureOptionName":"XCODE=","ProcedureOptionHelp":{"#cdata":"[Syntax: XCODE=ERROR | WARNING | IGNORE]\n      \nControls the behavior of the SAS session when an NLS transcoding failure occurs. Transcoding failures can \noccur during row input or output operations, or during string assignment. Transcoding is the process of \nconverting character data from one encoding to another encoding. \n      \nDefault: ERROR"},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"ERROR","@Value2":"WARNING","@Value3":"IGNORE"},"ProcedureOptionToolTips":{"@ToolTip1":"Specifies that a run-time error occurs, which causes row processing to halt. An error message is written to the SAS log.   This is the default behavior.","@ToolTip2":"Specifies that the incompatible character is set to a substitution character. A warning message is written to the SAS log.","@ToolTip3":"Specifies that the incompatible character is set to a substitution character. No messages are written to the SAS log."}}]},"ProcedureStatements":{"ProcedureStatement":[{"StatementName":"BY","StatementHelp":{"#cdata":"Syntax: [ BY [ DESCENDING ] column [ ... [ DESCENDING ] column ] ; \n      \nBY-group processing is a method of combining rows from one or more tables that are \ngrouped or ordered by values of one or more common columns. When a BY statement is \nspecified immediately after a SET statement, the SET statement interleaves the rows \nof the input tables in sorted order. The sort order or sort key is specified by the \ncolumn names in the BY statement.\n\nThe keyword DESCENDING can be used before the name of the column in the BY statement \nin order to sort that column in descending instead of ascending order.\n\nWhen a BY statement is used, internally DS2 requests the rows in sorted order. If \nthe rows are already sorted or indexed there is a high likelihood that a \"resorting\" \nof the data will not occur."},"StatementOptions":{"StatementOption":{"StatementOptionName":"DESCENDING","StatementOptionHelp":{"#cdata":"Specifies that the tables are sorted in descending order by the column that is specified. \nDESCENDING means largest to smallest for numeric columns, or reverse alphabetical for \ncharacter columns."},"StatementOptionType":"S"}}},{"StatementName":"SET FROM","StatementHelp":{"#cdata":"Syntax: SET FROM thread [ THREADS = threads ]; \n      \nThe SET FROM statement enables a DS2 program to run as a single thread or as multiple \nthreads. The thread name specified in a SET FROM statement references a DS2 program \nthread that has been created by a THREAD statement.\n\nNote: The SET FROM statement is best used in the RUN method to take advantage of the \nRUN method's implicit looping capability."},"StatementOptions":{"StatementOption":{"StatementOptionName":"THREADS=","StatementOptionHelp":{"#cdata":"Syntax: THREADS= threads\n          \nSpecifies the number of threads that are run for thread.\n\nRequirement: threads must be an integer value. \nTip: If threads is not present, the thread will run as a single thread."},"StatementOptionType":"V"}}},{"StatementName":"SET","StatementHelp":{"#cdata":"Syntax: SET < table-reference > [ ... < table-reference > ] ; \n      \nReads rows from one or more tables. \n\nEach time the SET statement executes, one row is read into the program data vector. \nSET reads all columns and all rows from the input tables unless you specify otherwise. \nA SET statement can contain multiple tables; a DS2 program can contain multiple SET \nstatements."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"SELECT","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"S","SubOptionsKeywords":"FROM|WHERE|AS|WHERE|NATURAL JOIN|INNER JOIN|OUTER JOIN|CROSS JOIN|LEFT JOIN|RIGHT JOIN|UNION JOIN|FULL JOIN|UNION|INTO|SELECT|HAVING|ALL|INSERT|CREATE|ORDER BY|GROUP BY"},{"StatementOptionName":"FROM","StatementOptionHelp":{"#cdata":"Syntax: SET FROM thread [ THREADS = threads ]; \n          \nRuns a DS2 program as one or more threads. \n\nThe SET FROM statement enables a DS2 program to run as a single thread or as multiple \nthreads. The thread name specified in a SET FROM statement references a DS2 program \nthread that has been created by a THREAD statement"},"StatementOptionType":"S"},{"StatementOptionName":"ALTER=","StatementOptionHelp":{"#cdata":"Syntax: ALTER=alter-password \n    \nSyntax Description:\nalter-password \n  must be a valid SAS name.\n \nDetails: \nThe ALTER= option applies only to a SAS data set. You can use this option to assign \na password or to access a read-protected, write-protected, or alter-protected file. \nWhen you replace a data set that is protected with an ALTER password, the new data \nset inherits the ALTER password. \n\nThe password is blotted out when the code is written in the SAS log. For example: \n\n  set a(alter=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"},{"StatementOptionName":"BUFNO=","StatementOptionHelp":{"#cdata":"Specifies the number of buffers to be allocated for processing a SAS data set. \n    \nSyntax: BUFNO= n | nK | hexX | MIN | MAX  \n\nSyntax Description:\n\nn | nK \n  specifies the number of buffers in multiples of 1 (bytes); 1,024 (kilobytes). For example, \n  a value of 8 specifies 8 buffers, and a value of 1k specifies 1024 buffers.\n\nhex \n  specifies the number of buffers as a hexadecimal value. You must specify the value beginning \n  with a number (0-9), followed by an X. For example, the value 2dx sets the number of buffers \n  to 45 buffers.\n\nMIN \n  sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value \n  for the operating environment. This is the default.\n\nMAX \n  sets the number of buffers to the maximum possible number in your operating environment, \n  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"hexX","@Value4":"MIN","@Value5":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the number of buffers in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the number of buffers in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the number of buffers as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip4":"Sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value  for the operating environment. This is the default.","@ToolTip5":"Sets the number of buffers to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."}},{"StatementOptionName":"BUFSIZE=","StatementOptionHelp":{"#cdata":"Specifies the size of a permanent buffer page for an output SAS data set. \n    \nSyntax: BUFSIZE= n | nK | nM | nG | hexX | MAX  \n\nSyntax Description:\n\nn | nK | nM | nG \nspecifies the page size in multiples of 1 (bytes); 1,024 (kilobytes); 1,048,576 (megabytes); \nor 1,073,741,824 (gigabytes). For example, a value of 8 specifies a page size of 8 bytes, and \na value of 4k specifies a page size of 4096 bytes. \n\nhexX \nspecifies the page size as a hexadecimal value. You must specify the value beginning with a \nnumber (0-9), followed by an X. For example, the value 2dx sets the page size to 45 bytes.\n\nMAX \nsets the page size to the maximum possible number in your operating environment, up to the \nlargest four-byte, signed integer, which is 231-1, or approximately 2 billion bytes."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"nM","@Value4":"nG","@Value5":"hexX","@Value6":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the page size in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the page size in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the page size in multiples of 1,048,576 (megabytes).  Replace n with an integer value.","@ToolTip4":"Specifies the page size in multiples of 1,073,741,824 (gigabytes).  Replace n with an integer value.","@ToolTip5":"Specifies the page size as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip6":"Sets the page size to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion bytes."}},{"StatementOptionName":"BULKLOAD=","StatementOptionHelp":{"#cdata":"Loads rows of data as one unit. Default value: NO  \n    \nSyntax: BULKLOAD=YES | NO  \n\nSyntax Description:\n\nYES \ncalls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.\n\nNO \nuses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Calls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.","@ToolTip2":"Uses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."}},{"StatementOptionName":"COMPRESS=","StatementOptionHelp":{"#cdata":"Specifies how observations are compressed in a new output SAS data set. \n    \nSyntax: COMPRESS=NO | YES | CHAR | BINARY  \n\nSyntax Description:\nNO \nspecifies that the observations in a newly created SAS data set are uncompressed (fixed-length records).\n\nYES | CHAR \nspecifies that the observations in a newly created SAS data set are compressed (variable-length records) \nby SAS using RLE (Run Length Encoding). RLE compresses observations by reducing repeated consecutive \ncharacters (including blanks) to two-byte or three-byte representations. \n\n  Alias: ON \n  Tip: Use this compression algorithm for character data. \n  Note:   COMPRESS=CHAR is accepted by Version 7 and later versions.  \n\nBINARY \n  specifies that the observations in a newly created SAS data set are compressed (variable-length records) \n  by SAS using RDC (Ross Data Compression). RDC combines run-length encoding and sliding-window compression \n  to compress the file.\n\n  Tip: This method is highly effective for compressing medium to large (several hundred bytes or larger) \n  blocks of binary data (numeric variables). Because the compression function operates on a single record \n  at a time, the record length needs to be several hundred bytes or larger for effective compression."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"NO","@Value2":"YES|ON","@Value3":"CHAR","@Value4":"BINARY"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the observations in a newly created SAS data set are uncompressed  (fixed-length records).","@ToolTip2":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.","@ToolTip3":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.   COMPRESS=CHAR is accepted by Version 7 and later versions.","@ToolTip4":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RDC (Ross Data Compression). RDC combines  run-length encoding and sliding-window compression to compress the file."}},{"StatementOptionName":"DBKEY=","StatementOptionHelp":{"#cdata":"Specifies a key column to optimize DBMS retrieval. Can improve performance when you \nare processing a join that involves a large DBMS table and a small SAS data set \nor DBMS table.\n    \nSyntax: DBKEY=([ ' ] column [ ' ] [... [ ' ] column [ ' ] ])  \n\nSyntax Description: \n\ncolumn \n  used by SAS to build an internal WHERE clause to search for matches in the DBMS table \n  based on the key column. For example:\n\n    select * from sas.a, dbms.b(dbkey=x) where a.x=b.x;\n    \nIn this example, DBKEY= specifies column x , which matches the key column designated in \nthe WHERE clause. However, if the DBKEY= column does NOT match the key column in the \nWHERE clause, then DBKEY= is not used."},"StatementOptionType":"TV"},{"StatementOptionName":"DBNULL=","StatementOptionHelp":{"#cdata":"Indicates whether NULL is a valid value for the specified columns when a table is created. \n    \nSyntax: DBNULL={ _ALL=YES | NO } | ( [column=YES | NO [ ... column=YES | NO ] ] )  \n\nSyntax Description: \n_ALL_ \n  specifies that the YES or NO applies to all columns in the table. (This is valid in \n  the interfaces to Informix, Oracle, Sybase, and Teradata only.)\n\nYES \n  specifies that the NULL value is valid for the specified columns in the DBMS table.\n\nNO \n  specifies that the NULL value is not valid for the specified columns in the DBMS table.\n\ncolumn \n  specifies the name of a column. \n\nDetails: \nThis option is valid only for creating DBMS tables. If you specify more than one column name, \nthe names must be separated with spaces.\n\nThe DBNULL= option processes values from left to right, so if you specify a column name twice, \nor if you use the _ALL_ value, the last value overrides the first value that is specified for \nthe column."},"StatementOptionType":"TV","SubOptionsKeywords":"_ALL_"},{"StatementOptionName":"DROP=","StatementOptionHelp":{"#cdata":"For an input table, excludes the specified columns from processing; for an output table, excludes the specified columns from being written to the table.\n    \nSyntax: DROP= ( column-list );  \n\nArguments: \ncolumn-list \n  specifies the names of the columns to omit from the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the format \n  col: are not supported. \n \nDetails: \nThe DROP= table option specifies that all columns in the column-list should not be included \nin the creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the drop attribute is specified, all columns not included in the drop \nstatement will be used to create columns in the output rows.\n\nIf the DROP= table option is associated with an input table, the columns are not available \nfor processing during program execution."},"StatementOptionType":"TV"},{"StatementOptionName":"ENCRYPT=","StatementOptionHelp":{"#cdata":"Specifies whether to encrypt an output SAS data set. \n    \nSyntax: ENCRYPT=YES | NO  \n\nSyntax Description:\nYES \n  encrypts the file. The encryption method uses passwords. At a minimum, you must specify \n  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because \n  the encryption method uses passwords, you cannot change any password on an encrypted data \n  set without re-creating the data set.\n\nNO \n  does not encrypt the file.\n\nCAUTION:\nRecord all passwords. \nIf you forget the password, you cannot reset it without assistance from SAS. The process \nis time-consuming and resource-intensive."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Encrypts the file. The encryption method uses passwords. At a minimum, you must specify  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because  the encryption method uses passwords, you cannot change any password on an encrypted data  set without re-creating the data set.","@ToolTip2":"Does not encrypt the file."}},{"StatementOptionName":"KEEP=","StatementOptionHelp":{"#cdata":"For an input table, specifies the columns to process; for an output table, specifies \nthe columns to write to the table. \n    \nSyntax: KEEP=( column-list );  \n\nArguments:\n\ncolumn-list \n  specifies the names of the columns to keep in the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the \n  format col: are not supported. \n  \nDetails: \nThe KEEP= table option specifies that all columns in the column-list should be included in \nthe creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the keep attribute is specified, all columns not included in the KEEP \nstatement will be dropped from the output rows.\n\nIf the KEEP= table option is associated with an input table, only the columns that are \nspecified by the KEEP= table option are available for processing during program execution."},"StatementOptionType":"TV"},{"StatementOptionName":"LABEL=","StatementOptionHelp":{"#cdata":"Specifies a label for a table.\n    \nSyntax: LABEL='label'  \n\nSyntax Description: \n\n'label' \n  specifies a text string of up to 256 characters. If the label text contains single \n  quotation marks, use double quotation marks around the label, or use two single \n  quotation marks in the label text and surround the string with single quotation \n  marks. To remove a label from a table, assign a label that is equal to a blank \n  that is enclosed in quotation marks.\n \nDetails: \nYou can use the LABEL= option on both input and output tables. When you use LABEL= \non input tables, it assigns a label for the table for the duration of the DS2 program. \nWhen it is specified for an output table, the label becomes a permanent part of that \ntable."},"StatementOptionType":"TV"},{"StatementOptionName":"LOCKTABLE=","StatementOptionHelp":{"#cdata":"Places shared or exclusive locks on tables. \n    \nSyntax: LOCKTABLE=SHARE | EXCLUSIVE  \n\nSyntax Description:\n\nSHARE \n  locks a table in shared mode, allowing other users or processes to read data from the \n  tables, but preventing users from updating data.\n\nEXCLUSIVE \n  locks a table exclusively, preventing other users from accessing any table that you open. \n\nDetails: \nYou can lock tables only if you are the owner or have been granted the necessary privilege. \n\nIf you access the BASE table driver through PROC DS2, the default value for the LOCKTABLE \noption is EXCLUSIVE. However, if you access the BASE table driver through a table server, \nor if you run your program locally with the SAS Table Server LIBNAME engine, the default \nvalue for the LOCKTABLE option is SHARE."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"SHARE","@Value2":"EXCLUSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Locks a table in shared mode, allowing other users or processes to read data from  the tables, but preventing users from updating data.","@ToolTip2":"Locks a table exclusively, preventing other users from accessing any table that you open."}},{"StatementOptionName":"OVERWRITE=","StatementOptionHelp":{"#cdata":"For a table, drops the output table before the replacement output table is populated \nwith rows; for packages and threads, drops the existing package or thread if a package \nor thread by the same name exists. \n    \nSyntax: OVERWRITE= YES | NO;  \n\nArguments: \n\nYES | NO \n  specifies whether the output table is deleted before a replacement output table \n  is created or whether a package or thread is dropped.\n\n  Default: NO \n\nCAUTION:\nFor tables, use the OVERWRITE=YES statement only with data that is backed up or \nwith data that you can reconstruct. Because the output table is deleted first, \ndata will be lost if a failure occurs while the output table is being written."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the output table is deleted before a replacement output table    is created or a package or thread is dropped.","@ToolTip2":"Specifies that the output table is not deleted before a replacement output table    is created or a package or thread is dropped."}},{"StatementOptionName":"PW=","StatementOptionHelp":{"#cdata":"Assigns a READ, WRITE, and ALTER password to a SAS file, and enables access to a password-protected SAS file. \n    \nSyntax: PW=password  \n\nSyntax Description:\npassword \n  must be a valid SAS name.\n\nDetails:\nThe PW= option applies to all types of SAS files. You can use this option to assign \na password to a SAS file or to access a password-protected SAS file.\n\nWhen replacing a SAS data set that is protected by an ALTER password, the new data \nset inherits the ALTER password. When the code is written to the SAS log the password \nis blotted out, for example: \n\n  drop thread job2 (pw=xxxxxxx);\n\nNote:   A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"},{"StatementOptionName":"READ=","StatementOptionHelp":{"#cdata":"Assigns a READ password to a SAS file that prevents users from reading the file, \nunless they enter the password. \n    \nSyntax: READ=read-password  \n\nSyntax Description: \nread-password \n  must be a valid SAS name. \n \nDetails: \nThe READ= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a read-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  declare package sales (read=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You  \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"},{"StatementOptionName":"RENAME=","StatementOptionHelp":{"#cdata":"Changes the name of a column.\n    \nSyntax: RENAME= (old-name { = | AS } new-name [... old-name { = | AS } new-name ] ) ;  \n\nArguments: \nold-name \n  the column you want to rename.\n\nnew-name \n  the new name of the column. It must be a valid name for the data source.\n \nDetails: \nThe RENAME= table option allows you to change the names of one or more columns.\n\nIf you use RENAME= when you create a table, the new column name is included in the output \ntable. If you use RENAME= on an input table, the new name is used in DS2 programming statements.\n\nIf you use RENAME= in the same DS2 program with either the DROP= or the KEEP= table option, \nthe DROP= and the KEEP= table options are applied before RENAME=. You must use the old name in \nthe DROP= and KEEP= table options. You cannot drop and rename the same column in the same statement.\n\nIn addition to changing the name of a column, RENAME= also changes the label for the column."},"StatementOptionType":"TV","SubOptionsKeywords":"AS"},{"StatementOptionName":"AS","StatementOptionHelp":{"#cdata":"Syntax: RENAME= (old-name AS new-name [... old-name AS new-name ] ) ;\n          \nSeparates the new-name from the old-name."},"StatementOptionType":"S"},{"StatementOptionName":"TYPE=","StatementOptionHelp":{"#cdata":"Specifies the data set type for a specially structured SAS data set. \n    \nSyntax: TYPE=data-set-type  \n\nSyntax Description: \ndata-set-type \n  specifies the special type of the data set.\n\nDetails: \nUse the TYPE= table option to create a special SAS data set in the proper format, \nor to identify the special type of the SAS data set in a procedure statement. \n\nYou can use the CONTENTS procedure to determine the type of a data set."},"StatementOptionType":"TV"},{"StatementOptionName":"WRITE=","StatementOptionHelp":{"#cdata":"Assigns a WRITE password to a SAS file that prevents users from writing to a file, \nunless they enter the password. \n    \nSyntax: WRITE=write-password  \n\nSyntax Description: \nwrite-password \n  must be a valid SAS name. \n \nDetails: \nThe WRITE= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a write-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  drop thread job2a (write=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"}],"#comment":{}}},{"StatementName":"DECLARE PACKAGE","StatementHelp":{"#cdata":"Syntax: DECLARE PACKAGE package [(table-options)] instance [ ( )] [... instance [ ( )]]; \n      \nCreates an instance of a package. \n\ntable-options \n  specifies optional arguments that the DS2 program applies when it creates a package.\n\ninstance \n  specifies a name that identifies an instance of the package."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"HASH","StatementOptionHelp":{"#cdata":"[Syntax: DECLARE PACKAGE HASH instance [ ( hashexp, 'datasource', 'ordered', 'duplicate' ) ];  \n      \nCreates an instance of a hash package. \n\ninstance \nspecifies a name that identifies an instance of the package. \n\nhashexp \n  is the hash package's internal table size, where the size of the hash table is 2^n. \n  The value of hashexp is used as a power-of-two exponent to create the hash table size.   \n'datasource' \n  is the name of a table or TSSQL query to load into the hash package. \n  The name of the table can be a literal or a character variable. The table name must \n  be enclosed in single quotation marks. \n'ordered' \n  specifies whether or how the data is returned in key-value order if you use the hash package \n  with a hash iterator package or if you use the hash package OUTPUT method.\n\nordered can be one of the following values: \n  'ascending' | 'a' \n  Data is returned in ascending key-value order. Specifying `ascending' is the same as specifying `yes'. \n  'descending' | 'd' \n  Data is returned in descending key-value order.\n  'YES' \n  Data is returned in ascending key-value order. Specifying `yes' is the same as specifying `ascending'.\n  'NO' \n  Data is returned in an undefined order.\n\n'duplicate' \n  determines whether to ignore duplicate keys when loading a table into the hash object. The \n  default is to store the first key and ignore all subsequent duplicates. \n  duplicate can be one of the following values: \n    'replace' \n    stores the last duplicate key record. \n    'error' \n    reports an error to the log if a duplicate key is found. \n    'add' \n    stores the first key record found and not any of the duplicates."},"StatementOptionType":"S"},{"StatementOptionName":"ITER","StatementOptionHelp":{"#cdata":"Syntax: DECLARE PACKAGE HITER instance [ ( 'hashname')];  \n      \nCreates an instance of a hash iterator package.\n\ninstance \n  specifies a name that identifies an instance of the package. \n  \n'hashname' \n  specifies the name of the hash package with which the hash iterator is associated."},"StatementOptionType":"S"},{"StatementOptionName":"ALTER=","StatementOptionHelp":{"#cdata":"Syntax: ALTER=alter-password \n    \nSyntax Description:\nalter-password \n  must be a valid SAS name.\n \nDetails: \nThe ALTER= option applies only to a SAS data set. You can use this option to assign \na password or to access a read-protected, write-protected, or alter-protected file. \nWhen you replace a data set that is protected with an ALTER password, the new data \nset inherits the ALTER password. \n\nThe password is blotted out when the code is written in the SAS log. For example: \n\n  set a(alter=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"},{"StatementOptionName":"BUFNO=","StatementOptionHelp":{"#cdata":"Specifies the number of buffers to be allocated for processing a SAS data set. \n    \nSyntax: BUFNO= n | nK | hexX | MIN | MAX  \n\nSyntax Description:\n\nn | nK \n  specifies the number of buffers in multiples of 1 (bytes); 1,024 (kilobytes). For example, \n  a value of 8 specifies 8 buffers, and a value of 1k specifies 1024 buffers.\n\nhex \n  specifies the number of buffers as a hexadecimal value. You must specify the value beginning \n  with a number (0-9), followed by an X. For example, the value 2dx sets the number of buffers \n  to 45 buffers.\n\nMIN \n  sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value \n  for the operating environment. This is the default.\n\nMAX \n  sets the number of buffers to the maximum possible number in your operating environment, \n  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"hexX","@Value4":"MIN","@Value5":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the number of buffers in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the number of buffers in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the number of buffers as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip4":"Sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value  for the operating environment. This is the default.","@ToolTip5":"Sets the number of buffers to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."}},{"StatementOptionName":"BUFSIZE=","StatementOptionHelp":{"#cdata":"Specifies the size of a permanent buffer page for an output SAS data set. \n    \nSyntax: BUFSIZE= n | nK | nM | nG | hexX | MAX  \n\nSyntax Description:\n\nn | nK | nM | nG \nspecifies the page size in multiples of 1 (bytes); 1,024 (kilobytes); 1,048,576 (megabytes); \nor 1,073,741,824 (gigabytes). For example, a value of 8 specifies a page size of 8 bytes, and \na value of 4k specifies a page size of 4096 bytes. \n\nhexX \nspecifies the page size as a hexadecimal value. You must specify the value beginning with a \nnumber (0-9), followed by an X. For example, the value 2dx sets the page size to 45 bytes.\n\nMAX \nsets the page size to the maximum possible number in your operating environment, up to the \nlargest four-byte, signed integer, which is 231-1, or approximately 2 billion bytes."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"nM","@Value4":"nG","@Value5":"hexX","@Value6":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the page size in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the page size in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the page size in multiples of 1,048,576 (megabytes).  Replace n with an integer value.","@ToolTip4":"Specifies the page size in multiples of 1,073,741,824 (gigabytes).  Replace n with an integer value.","@ToolTip5":"Specifies the page size as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip6":"Sets the page size to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion bytes."}},{"StatementOptionName":"BULKLOAD=","StatementOptionHelp":{"#cdata":"Loads rows of data as one unit. Default value: NO  \n    \nSyntax: BULKLOAD=YES | NO  \n\nSyntax Description:\n\nYES \ncalls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.\n\nNO \nuses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Calls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.","@ToolTip2":"Uses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."}},{"StatementOptionName":"COMPRESS=","StatementOptionHelp":{"#cdata":"Specifies how observations are compressed in a new output SAS data set. \n    \nSyntax: COMPRESS=NO | YES | CHAR | BINARY  \n\nSyntax Description:\nNO \nspecifies that the observations in a newly created SAS data set are uncompressed (fixed-length records).\n\nYES | CHAR \nspecifies that the observations in a newly created SAS data set are compressed (variable-length records) \nby SAS using RLE (Run Length Encoding). RLE compresses observations by reducing repeated consecutive \ncharacters (including blanks) to two-byte or three-byte representations. \n\n  Alias: ON \n  Tip: Use this compression algorithm for character data. \n  Note:   COMPRESS=CHAR is accepted by Version 7 and later versions.  \n\nBINARY \n  specifies that the observations in a newly created SAS data set are compressed (variable-length records) \n  by SAS using RDC (Ross Data Compression). RDC combines run-length encoding and sliding-window compression \n  to compress the file.\n\n  Tip: This method is highly effective for compressing medium to large (several hundred bytes or larger) \n  blocks of binary data (numeric variables). Because the compression function operates on a single record \n  at a time, the record length needs to be several hundred bytes or larger for effective compression."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"NO","@Value2":"YES|ON","@Value3":"CHAR","@Value4":"BINARY"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the observations in a newly created SAS data set are uncompressed  (fixed-length records).","@ToolTip2":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.","@ToolTip3":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.   COMPRESS=CHAR is accepted by Version 7 and later versions.","@ToolTip4":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RDC (Ross Data Compression). RDC combines  run-length encoding and sliding-window compression to compress the file."}},{"StatementOptionName":"DBKEY=","StatementOptionHelp":{"#cdata":"Specifies a key column to optimize DBMS retrieval. Can improve performance when you \nare processing a join that involves a large DBMS table and a small SAS data set \nor DBMS table.\n    \nSyntax: DBKEY=([ ' ] column [ ' ] [... [ ' ] column [ ' ] ])  \n\nSyntax Description: \n\ncolumn \n  used by SAS to build an internal WHERE clause to search for matches in the DBMS table \n  based on the key column. For example:\n\n    select * from sas.a, dbms.b(dbkey=x) where a.x=b.x;\n    \nIn this example, DBKEY= specifies column x , which matches the key column designated in \nthe WHERE clause. However, if the DBKEY= column does NOT match the key column in the \nWHERE clause, then DBKEY= is not used."},"StatementOptionType":"TV"},{"StatementOptionName":"DBNULL=","StatementOptionHelp":{"#cdata":"Indicates whether NULL is a valid value for the specified columns when a table is created. \n    \nSyntax: DBNULL={ _ALL=YES | NO } | ( [column=YES | NO [ ... column=YES | NO ] ] )  \n\nSyntax Description: \n_ALL_ \n  specifies that the YES or NO applies to all columns in the table. (This is valid in \n  the interfaces to Informix, Oracle, Sybase, and Teradata only.)\n\nYES \n  specifies that the NULL value is valid for the specified columns in the DBMS table.\n\nNO \n  specifies that the NULL value is not valid for the specified columns in the DBMS table.\n\ncolumn \n  specifies the name of a column. \n\nDetails: \nThis option is valid only for creating DBMS tables. If you specify more than one column name, \nthe names must be separated with spaces.\n\nThe DBNULL= option processes values from left to right, so if you specify a column name twice, \nor if you use the _ALL_ value, the last value overrides the first value that is specified for \nthe column."},"StatementOptionType":"TV","SubOptionsKeywords":"_ALL_"},{"StatementOptionName":"DROP=","StatementOptionHelp":{"#cdata":"For an input table, excludes the specified columns from processing; for an output table, excludes the specified columns from being written to the table.\n    \nSyntax: DROP= ( column-list );  \n\nArguments: \ncolumn-list \n  specifies the names of the columns to omit from the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the format \n  col: are not supported. \n \nDetails: \nThe DROP= table option specifies that all columns in the column-list should not be included \nin the creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the drop attribute is specified, all columns not included in the drop \nstatement will be used to create columns in the output rows.\n\nIf the DROP= table option is associated with an input table, the columns are not available \nfor processing during program execution."},"StatementOptionType":"TV"},{"StatementOptionName":"ENCRYPT=","StatementOptionHelp":{"#cdata":"Specifies whether to encrypt an output SAS data set. \n    \nSyntax: ENCRYPT=YES | NO  \n\nSyntax Description:\nYES \n  encrypts the file. The encryption method uses passwords. At a minimum, you must specify \n  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because \n  the encryption method uses passwords, you cannot change any password on an encrypted data \n  set without re-creating the data set.\n\nNO \n  does not encrypt the file.\n\nCAUTION:\nRecord all passwords. \nIf you forget the password, you cannot reset it without assistance from SAS. The process \nis time-consuming and resource-intensive."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Encrypts the file. The encryption method uses passwords. At a minimum, you must specify  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because  the encryption method uses passwords, you cannot change any password on an encrypted data  set without re-creating the data set.","@ToolTip2":"Does not encrypt the file."}},{"StatementOptionName":"KEEP=","StatementOptionHelp":{"#cdata":"For an input table, specifies the columns to process; for an output table, specifies \nthe columns to write to the table. \n    \nSyntax: KEEP=( column-list );  \n\nArguments:\n\ncolumn-list \n  specifies the names of the columns to keep in the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the \n  format col: are not supported. \n  \nDetails: \nThe KEEP= table option specifies that all columns in the column-list should be included in \nthe creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the keep attribute is specified, all columns not included in the KEEP \nstatement will be dropped from the output rows.\n\nIf the KEEP= table option is associated with an input table, only the columns that are \nspecified by the KEEP= table option are available for processing during program execution."},"StatementOptionType":"TV"},{"StatementOptionName":"LABEL=","StatementOptionHelp":{"#cdata":"Specifies a label for a table.\n    \nSyntax: LABEL='label'  \n\nSyntax Description: \n\n'label' \n  specifies a text string of up to 256 characters. If the label text contains single \n  quotation marks, use double quotation marks around the label, or use two single \n  quotation marks in the label text and surround the string with single quotation \n  marks. To remove a label from a table, assign a label that is equal to a blank \n  that is enclosed in quotation marks.\n \nDetails: \nYou can use the LABEL= option on both input and output tables. When you use LABEL= \non input tables, it assigns a label for the table for the duration of the DS2 program. \nWhen it is specified for an output table, the label becomes a permanent part of that \ntable."},"StatementOptionType":"TV"},{"StatementOptionName":"LOCKTABLE=","StatementOptionHelp":{"#cdata":"Places shared or exclusive locks on tables. \n    \nSyntax: LOCKTABLE=SHARE | EXCLUSIVE  \n\nSyntax Description:\n\nSHARE \n  locks a table in shared mode, allowing other users or processes to read data from the \n  tables, but preventing users from updating data.\n\nEXCLUSIVE \n  locks a table exclusively, preventing other users from accessing any table that you open. \n\nDetails: \nYou can lock tables only if you are the owner or have been granted the necessary privilege. \n\nIf you access the BASE table driver through PROC DS2, the default value for the LOCKTABLE \noption is EXCLUSIVE. However, if you access the BASE table driver through a table server, \nor if you run your program locally with the SAS Table Server LIBNAME engine, the default \nvalue for the LOCKTABLE option is SHARE."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"SHARE","@Value2":"EXCLUSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Locks a table in shared mode, allowing other users or processes to read data from  the tables, but preventing users from updating data.","@ToolTip2":"Locks a table exclusively, preventing other users from accessing any table that you open."}},{"StatementOptionName":"OVERWRITE=","StatementOptionHelp":{"#cdata":"For a table, drops the output table before the replacement output table is populated \nwith rows; for packages and threads, drops the existing package or thread if a package \nor thread by the same name exists. \n    \nSyntax: OVERWRITE= YES | NO;  \n\nArguments: \n\nYES | NO \n  specifies whether the output table is deleted before a replacement output table \n  is created or whether a package or thread is dropped.\n\n  Default: NO \n\nCAUTION:\nFor tables, use the OVERWRITE=YES statement only with data that is backed up or \nwith data that you can reconstruct. Because the output table is deleted first, \ndata will be lost if a failure occurs while the output table is being written."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the output table is deleted before a replacement output table    is created or a package or thread is dropped.","@ToolTip2":"Specifies that the output table is not deleted before a replacement output table    is created or a package or thread is dropped."}},{"StatementOptionName":"PW=","StatementOptionHelp":{"#cdata":"Assigns a READ, WRITE, and ALTER password to a SAS file, and enables access to a password-protected SAS file. \n    \nSyntax: PW=password  \n\nSyntax Description:\npassword \n  must be a valid SAS name.\n\nDetails:\nThe PW= option applies to all types of SAS files. You can use this option to assign \na password to a SAS file or to access a password-protected SAS file.\n\nWhen replacing a SAS data set that is protected by an ALTER password, the new data \nset inherits the ALTER password. When the code is written to the SAS log the password \nis blotted out, for example: \n\n  drop thread job2 (pw=xxxxxxx);\n\nNote:   A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"},{"StatementOptionName":"READ=","StatementOptionHelp":{"#cdata":"Assigns a READ password to a SAS file that prevents users from reading the file, \nunless they enter the password. \n    \nSyntax: READ=read-password  \n\nSyntax Description: \nread-password \n  must be a valid SAS name. \n \nDetails: \nThe READ= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a read-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  declare package sales (read=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You  \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"},{"StatementOptionName":"RENAME=","StatementOptionHelp":{"#cdata":"Changes the name of a column.\n    \nSyntax: RENAME= (old-name { = | AS } new-name [... old-name { = | AS } new-name ] ) ;  \n\nArguments: \nold-name \n  the column you want to rename.\n\nnew-name \n  the new name of the column. It must be a valid name for the data source.\n \nDetails: \nThe RENAME= table option allows you to change the names of one or more columns.\n\nIf you use RENAME= when you create a table, the new column name is included in the output \ntable. If you use RENAME= on an input table, the new name is used in DS2 programming statements.\n\nIf you use RENAME= in the same DS2 program with either the DROP= or the KEEP= table option, \nthe DROP= and the KEEP= table options are applied before RENAME=. You must use the old name in \nthe DROP= and KEEP= table options. You cannot drop and rename the same column in the same statement.\n\nIn addition to changing the name of a column, RENAME= also changes the label for the column."},"StatementOptionType":"TV","SubOptionsKeywords":"AS"},{"StatementOptionName":"AS","StatementOptionHelp":{"#cdata":"Syntax: RENAME= (old-name AS new-name [... old-name AS new-name ] ) ;\n          \nSeparates the new-name from the old-name."},"StatementOptionType":"S"},{"StatementOptionName":"TYPE=","StatementOptionHelp":{"#cdata":"Specifies the data set type for a specially structured SAS data set. \n    \nSyntax: TYPE=data-set-type  \n\nSyntax Description: \ndata-set-type \n  specifies the special type of the data set.\n\nDetails: \nUse the TYPE= table option to create a special SAS data set in the proper format, \nor to identify the special type of the SAS data set in a procedure statement. \n\nYou can use the CONTENTS procedure to determine the type of a data set."},"StatementOptionType":"TV"},{"StatementOptionName":"WRITE=","StatementOptionHelp":{"#cdata":"Assigns a WRITE password to a SAS file that prevents users from writing to a file, \nunless they enter the password. \n    \nSyntax: WRITE=write-password  \n\nSyntax Description: \nwrite-password \n  must be a valid SAS name. \n \nDetails: \nThe WRITE= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a write-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  drop thread job2a (write=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"}],"#comment":{}}},{"StatementName":"DECLARE PACKAGE HASH","StatementHelp":{"#cdata":"Syntax: DECLARE PACKAGE HASH instance [ ( hashexp, 'datasource', 'ordered', 'duplicate' ) ];  \n      \nCreates an instance of a hash package. \n\ninstance \nspecifies a name that identifies an instance of the package. \n\nhashexp \n  is the hash package's internal table size, where the size of the hash table is 2^n. \n  The value of hashexp is used as a power-of-two exponent to create the hash table size.   \n'datasource' \n  is the name of a table or TSSQL query to load into the hash package. \n  The name of the table can be a literal or a character variable. The table name must \n  be enclosed in single quotation marks. \n'ordered' \n  specifies whether or how the data is returned in key-value order if you use the hash package \n  with a hash iterator package or if you use the hash package OUTPUT method.\n\nordered can be one of the following values: \n  'ascending' | 'a' \n  Data is returned in ascending key-value order. Specifying `ascending' is the same as specifying `yes'. \n  'descending' | 'd' \n  Data is returned in descending key-value order.\n  'YES' \n  Data is returned in ascending key-value order. Specifying `yes' is the same as specifying `ascending'.\n  'NO' \n  Data is returned in an undefined order.\n\n'duplicate' \n  determines whether to ignore duplicate keys when loading a table into the hash object. The \n  default is to store the first key and ignore all subsequent duplicates. \n  duplicate can be one of the following values: \n    'replace' \n    stores the last duplicate key record. \n    'error' \n    reports an error to the log if a duplicate key is found. \n    'add' \n    stores the first key record found and not any of the duplicates."},"StatementOptions":null},{"StatementName":"DECLARE PACKAGE HITER","StatementHelp":{"#cdata":"Syntax: DECLARE PACKAGE HITER instance [ ( 'hashname')];  \n      \nCreates an instance of a hash iterator package. \n\ninstance \n  specifies a name that identifies an instance of the package. \n  \n'hashname' \n  specifies the name of the hash package with which the hash iterator is associated."},"StatementOptions":null},{"StatementName":"DECLARE THREAD","StatementHelp":{"#cdata":"Syntax: DECLARE THREAD thread [(table-options)] instance( argument ) [... instance ( argument )]; \n      \nCreates an instance of a thread. \n\nthread \nspecifies the thread name. thread can be one of these forms: \n\n   catalog.schema.thread  \n   schema.thread  \n   catalog.thread  \n   thread \n\n  catalog \n  is an implementation of the ANSI SQL standard for an SQL catalog, which is a data \n  container object that groups logically related schemas. The catalog is the first-level \n  (top) grouping mechanism in a data organization hierarchy that is used along with a \n  schema to provide a means of qualifying names. A catalog is a metadata object in a \n  SAS Metadata Repository.\n\n  schema \n  is an implementation of the ANSI SQL standard for an SQL schema, which is a data \n  container object that groups files such as tables and views and other objects \n  supported by a data source such as stored procedures. The schema provides a grouping \n  object that is used along with a catalog to provide a means of qualifying names.\n\n  thread \n  is the name of the thread.\n\n  Requirement: The thread name must match the name of a thread created in a THREAD \n  statement, or an error will occur.\n  Requirement: Thread naming conventions are based on the data source. \n\ntable-options \nspecifies optional arguments that the DS2 program applies when it creates a thread. \n\ninstance \nspecifies a name that identifies an instance of the thread.\n\nargument \nspecifies arguments used with instance-name."},"StatementOptions":{"#comment":{},"StatementOption":[{"StatementOptionName":"ALTER=","StatementOptionHelp":{"#cdata":"Syntax: ALTER=alter-password \n    \nSyntax Description:\nalter-password \n  must be a valid SAS name.\n \nDetails: \nThe ALTER= option applies only to a SAS data set. You can use this option to assign \na password or to access a read-protected, write-protected, or alter-protected file. \nWhen you replace a data set that is protected with an ALTER password, the new data \nset inherits the ALTER password. \n\nThe password is blotted out when the code is written in the SAS log. For example: \n\n  set a(alter=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"V"},{"StatementOptionName":"BUFNO=","StatementOptionHelp":{"#cdata":"Specifies the number of buffers to be allocated for processing a SAS data set. \n    \nSyntax: BUFNO= n | nK | hexX | MIN | MAX  \n\nSyntax Description:\n\nn | nK \n  specifies the number of buffers in multiples of 1 (bytes); 1,024 (kilobytes). For example, \n  a value of 8 specifies 8 buffers, and a value of 1k specifies 1024 buffers.\n\nhex \n  specifies the number of buffers as a hexadecimal value. You must specify the value beginning \n  with a number (0-9), followed by an X. For example, the value 2dx sets the number of buffers \n  to 45 buffers.\n\nMIN \n  sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value \n  for the operating environment. This is the default.\n\nMAX \n  sets the number of buffers to the maximum possible number in your operating environment, \n  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"hexX","@Value4":"MIN","@Value5":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the number of buffers in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the number of buffers in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the number of buffers as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip4":"Sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value  for the operating environment. This is the default.","@ToolTip5":"Sets the number of buffers to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."}},{"StatementOptionName":"BUFSIZE=","StatementOptionHelp":{"#cdata":"Specifies the size of a permanent buffer page for an output SAS data set. \n    \nSyntax: BUFSIZE= n | nK | nM | nG | hexX | MAX  \n\nSyntax Description:\n\nn | nK | nM | nG \nspecifies the page size in multiples of 1 (bytes); 1,024 (kilobytes); 1,048,576 (megabytes); \nor 1,073,741,824 (gigabytes). For example, a value of 8 specifies a page size of 8 bytes, and \na value of 4k specifies a page size of 4096 bytes. \n\nhexX \nspecifies the page size as a hexadecimal value. You must specify the value beginning with a \nnumber (0-9), followed by an X. For example, the value 2dx sets the page size to 45 bytes.\n\nMAX \nsets the page size to the maximum possible number in your operating environment, up to the \nlargest four-byte, signed integer, which is 231-1, or approximately 2 billion bytes."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"nM","@Value4":"nG","@Value5":"hexX","@Value6":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the page size in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the page size in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the page size in multiples of 1,048,576 (megabytes).  Replace n with an integer value.","@ToolTip4":"Specifies the page size in multiples of 1,073,741,824 (gigabytes).  Replace n with an integer value.","@ToolTip5":"Specifies the page size as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip6":"Sets the page size to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion bytes."}},{"StatementOptionName":"BULKLOAD=","StatementOptionHelp":{"#cdata":"Loads rows of data as one unit. Default value: NO  \n    \nSyntax: BULKLOAD=YES | NO  \n\nSyntax Description:\n\nYES \ncalls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.\n\nNO \nuses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Calls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.","@ToolTip2":"Uses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."}},{"StatementOptionName":"COMPRESS=","StatementOptionHelp":{"#cdata":"Specifies how observations are compressed in a new output SAS data set. \n    \nSyntax: COMPRESS=NO | YES | CHAR | BINARY  \n\nSyntax Description:\nNO \nspecifies that the observations in a newly created SAS data set are uncompressed (fixed-length records).\n\nYES | CHAR \nspecifies that the observations in a newly created SAS data set are compressed (variable-length records) \nby SAS using RLE (Run Length Encoding). RLE compresses observations by reducing repeated consecutive \ncharacters (including blanks) to two-byte or three-byte representations. \n\n  Alias: ON \n  Tip: Use this compression algorithm for character data. \n  Note:   COMPRESS=CHAR is accepted by Version 7 and later versions.  \n\nBINARY \n  specifies that the observations in a newly created SAS data set are compressed (variable-length records) \n  by SAS using RDC (Ross Data Compression). RDC combines run-length encoding and sliding-window compression \n  to compress the file.\n\n  Tip: This method is highly effective for compressing medium to large (several hundred bytes or larger) \n  blocks of binary data (numeric variables). Because the compression function operates on a single record \n  at a time, the record length needs to be several hundred bytes or larger for effective compression."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NO","@Value2":"YES|ON","@Value3":"CHAR","@Value4":"BINARY"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the observations in a newly created SAS data set are uncompressed  (fixed-length records).","@ToolTip2":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.","@ToolTip3":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.   COMPRESS=CHAR is accepted by Version 7 and later versions.","@ToolTip4":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RDC (Ross Data Compression). RDC combines  run-length encoding and sliding-window compression to compress the file."}},{"StatementOptionName":"DBKEY=","StatementOptionHelp":{"#cdata":"Specifies a key column to optimize DBMS retrieval. Can improve performance when you \nare processing a join that involves a large DBMS table and a small SAS data set \nor DBMS table.\n    \nSyntax: DBKEY=([ ' ] column [ ' ] [... [ ' ] column [ ' ] ])  \n\nSyntax Description: \n\ncolumn \n  used by SAS to build an internal WHERE clause to search for matches in the DBMS table \n  based on the key column. For example:\n\n    select * from sas.a, dbms.b(dbkey=x) where a.x=b.x;\n    \nIn this example, DBKEY= specifies column x , which matches the key column designated in \nthe WHERE clause. However, if the DBKEY= column does NOT match the key column in the \nWHERE clause, then DBKEY= is not used."},"StatementOptionType":"V"},{"StatementOptionName":"DBNULL=","StatementOptionHelp":{"#cdata":"Indicates whether NULL is a valid value for the specified columns when a table is created. \n    \nSyntax: DBNULL={ _ALL=YES | NO } | ( [column=YES | NO [ ... column=YES | NO ] ] )  \n\nSyntax Description: \n_ALL_ \n  specifies that the YES or NO applies to all columns in the table. (This is valid in \n  the interfaces to Informix, Oracle, Sybase, and Teradata only.)\n\nYES \n  specifies that the NULL value is valid for the specified columns in the DBMS table.\n\nNO \n  specifies that the NULL value is not valid for the specified columns in the DBMS table.\n\ncolumn \n  specifies the name of a column. \n\nDetails: \nThis option is valid only for creating DBMS tables. If you specify more than one column name, \nthe names must be separated with spaces.\n\nThe DBNULL= option processes values from left to right, so if you specify a column name twice, \nor if you use the _ALL_ value, the last value overrides the first value that is specified for \nthe column."},"StatementOptionType":"V","SubOptionsKeywords":"_ALL_"},{"StatementOptionName":"DROP=","StatementOptionHelp":{"#cdata":"For an input table, excludes the specified columns from processing; for an output table, excludes the specified columns from being written to the table.\n    \nSyntax: DROP= ( column-list );  \n\nArguments: \ncolumn-list \n  specifies the names of the columns to omit from the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the format \n  col: are not supported. \n \nDetails: \nThe DROP= table option specifies that all columns in the column-list should not be included \nin the creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the drop attribute is specified, all columns not included in the drop \nstatement will be used to create columns in the output rows.\n\nIf the DROP= table option is associated with an input table, the columns are not available \nfor processing during program execution."},"StatementOptionType":"V"},{"StatementOptionName":"ENCRYPT=","StatementOptionHelp":{"#cdata":"Specifies whether to encrypt an output SAS data set. \n    \nSyntax: ENCRYPT=YES | NO  \n\nSyntax Description:\nYES \n  encrypts the file. The encryption method uses passwords. At a minimum, you must specify \n  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because \n  the encryption method uses passwords, you cannot change any password on an encrypted data \n  set without re-creating the data set.\n\nNO \n  does not encrypt the file.\n\nCAUTION:\nRecord all passwords. \nIf you forget the password, you cannot reset it without assistance from SAS. The process \nis time-consuming and resource-intensive."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Encrypts the file. The encryption method uses passwords. At a minimum, you must specify  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because  the encryption method uses passwords, you cannot change any password on an encrypted data  set without re-creating the data set.","@ToolTip2":"Does not encrypt the file."}},{"StatementOptionName":"KEEP=","StatementOptionHelp":{"#cdata":"For an input table, specifies the columns to process; for an output table, specifies \nthe columns to write to the table. \n    \nSyntax: KEEP=( column-list );  \n\nArguments:\n\ncolumn-list \n  specifies the names of the columns to keep in the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the \n  format col: are not supported. \n  \nDetails: \nThe KEEP= table option specifies that all columns in the column-list should be included in \nthe creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the keep attribute is specified, all columns not included in the KEEP \nstatement will be dropped from the output rows.\n\nIf the KEEP= table option is associated with an input table, only the columns that are \nspecified by the KEEP= table option are available for processing during program execution."},"StatementOptionType":"V"},{"StatementOptionName":"LABEL=","StatementOptionHelp":{"#cdata":"Specifies a label for a table.\n    \nSyntax: LABEL='label'  \n\nSyntax Description: \n\n'label' \n  specifies a text string of up to 256 characters. If the label text contains single \n  quotation marks, use double quotation marks around the label, or use two single \n  quotation marks in the label text and surround the string with single quotation \n  marks. To remove a label from a table, assign a label that is equal to a blank \n  that is enclosed in quotation marks.\n \nDetails: \nYou can use the LABEL= option on both input and output tables. When you use LABEL= \non input tables, it assigns a label for the table for the duration of the DS2 program. \nWhen it is specified for an output table, the label becomes a permanent part of that \ntable."},"StatementOptionType":"V"},{"StatementOptionName":"LOCKTABLE=","StatementOptionHelp":{"#cdata":"Places shared or exclusive locks on tables. \n    \nSyntax: LOCKTABLE=SHARE | EXCLUSIVE  \n\nSyntax Description:\n\nSHARE \n  locks a table in shared mode, allowing other users or processes to read data from the \n  tables, but preventing users from updating data.\n\nEXCLUSIVE \n  locks a table exclusively, preventing other users from accessing any table that you open. \n\nDetails: \nYou can lock tables only if you are the owner or have been granted the necessary privilege. \n\nIf you access the BASE table driver through PROC DS2, the default value for the LOCKTABLE \noption is EXCLUSIVE. However, if you access the BASE table driver through a table server, \nor if you run your program locally with the SAS Table Server LIBNAME engine, the default \nvalue for the LOCKTABLE option is SHARE."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"SHARE","@Value2":"EXCLUSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Locks a table in shared mode, allowing other users or processes to read data from  the tables, but preventing users from updating data.","@ToolTip2":"Locks a table exclusively, preventing other users from accessing any table that you open."}},{"StatementOptionName":"OVERWRITE=","StatementOptionHelp":{"#cdata":"For a table, drops the output table before the replacement output table is populated \nwith rows; for packages and threads, drops the existing package or thread if a package \nor thread by the same name exists. \n    \nSyntax: OVERWRITE= YES | NO;  \n\nArguments: \n\nYES | NO \n  specifies whether the output table is deleted before a replacement output table \n  is created or whether a package or thread is dropped.\n\n  Default: NO \n\nCAUTION:\nFor tables, use the OVERWRITE=YES statement only with data that is backed up or \nwith data that you can reconstruct. Because the output table is deleted first, \ndata will be lost if a failure occurs while the output table is being written."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the output table is deleted before a replacement output table    is created or a package or thread is dropped.","@ToolTip2":"Specifies that the output table is not deleted before a replacement output table    is created or a package or thread is dropped."}},{"StatementOptionName":"PW=","StatementOptionHelp":{"#cdata":"Assigns a READ, WRITE, and ALTER password to a SAS file, and enables access to a password-protected SAS file. \n    \nSyntax: PW=password  \n\nSyntax Description:\npassword \n  must be a valid SAS name.\n\nDetails:\nThe PW= option applies to all types of SAS files. You can use this option to assign \na password to a SAS file or to access a password-protected SAS file.\n\nWhen replacing a SAS data set that is protected by an ALTER password, the new data \nset inherits the ALTER password. When the code is written to the SAS log the password \nis blotted out, for example: \n\n  drop thread job2 (pw=xxxxxxx);\n\nNote:   A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"V"},{"StatementOptionName":"READ=","StatementOptionHelp":{"#cdata":"Assigns a READ password to a SAS file that prevents users from reading the file, \nunless they enter the password. \n    \nSyntax: READ=read-password  \n\nSyntax Description: \nread-password \n  must be a valid SAS name. \n \nDetails: \nThe READ= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a read-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  declare package sales (read=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You  \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"V"},{"StatementOptionName":"RENAME=","StatementOptionHelp":{"#cdata":"Changes the name of a column.\n    \nSyntax: RENAME= (old-name { = | AS } new-name [... old-name { = | AS } new-name ] ) ;  \n\nArguments: \nold-name \n  the column you want to rename.\n\nnew-name \n  the new name of the column. It must be a valid name for the data source.\n \nDetails: \nThe RENAME= table option allows you to change the names of one or more columns.\n\nIf you use RENAME= when you create a table, the new column name is included in the output \ntable. If you use RENAME= on an input table, the new name is used in DS2 programming statements.\n\nIf you use RENAME= in the same DS2 program with either the DROP= or the KEEP= table option, \nthe DROP= and the KEEP= table options are applied before RENAME=. You must use the old name in \nthe DROP= and KEEP= table options. You cannot drop and rename the same column in the same statement.\n\nIn addition to changing the name of a column, RENAME= also changes the label for the column."},"StatementOptionType":"V","SubOptionsKeywords":"AS"},{"StatementOptionName":"AS","StatementOptionHelp":{"#cdata":"Syntax: RENAME= (old-name AS new-name [... old-name AS new-name ] ) ;\n          \nSeparates the new-name from the old-name."},"StatementOptionType":"S"},{"StatementOptionName":"TYPE=","StatementOptionHelp":{"#cdata":"Specifies the data set type for a specially structured SAS data set. \n    \nSyntax: TYPE=data-set-type  \n\nSyntax Description: \ndata-set-type \n  specifies the special type of the data set.\n\nDetails: \nUse the TYPE= table option to create a special SAS data set in the proper format, \nor to identify the special type of the SAS data set in a procedure statement. \n\nYou can use the CONTENTS procedure to determine the type of a data set."},"StatementOptionType":"V"},{"StatementOptionName":"WRITE=","StatementOptionHelp":{"#cdata":"Assigns a WRITE password to a SAS file that prevents users from writing to a file, \nunless they enter the password. \n    \nSyntax: WRITE=write-password  \n\nSyntax Description: \nwrite-password \n  must be a valid SAS name. \n \nDetails: \nThe WRITE= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a write-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  drop thread job2a (write=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"V"}]}},{"StatementName":"DO","StatementHelp":{"#cdata":"Syntax: DO [ < index-variable-clause > ] [ < conditional-clause > ] ;  \n  ...statement-list...\n  END [end-label ] ;  \n\nSpecifies a group of statements to be executed as a unit."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"WHILE","StatementOptionHelp":{"#cdata":"Executes statements in a DO-loop repetitively while a condition is true. \n          \nSyntax: \nDO WHILE (expression); \n...more SAS statements...  \nEND;"},"StatementOptionType":"S"},{"StatementOptionName":"UNTIL","StatementOptionHelp":{"#cdata":"Executes statements in a DO loop repetitively until a condition is true.\n          \nSyntax: \nDO UNTIL (expression); \n...more SAS statements...  \nEND;"},"StatementOptionType":"S"},{"StatementOptionName":"TO","StatementOptionHelp":{"#cdata":"Separates the start and stop integers or expressions that control the number of times the \nportion of the step between the iterative DO and END statements is processed."},"StatementOptionType":"S"},{"StatementOptionName":"BY","StatementOptionHelp":{"#cdata":"Precedes an increment integer (other than 0) or an expression that generates an integer to be \nadded to the value of the index variable in each iteration of the DO loop."},"StatementOptionType":"S"}]}},{"StatementName":"DO WHILE","StatementHelp":{"#cdata":"Executes statements in a DO-loop repetitively while a condition is true. \n          \nSyntax: \nDO WHILE (expression); \n...more SAS statements...  \nEND;"},"StatementOptions":null},{"StatementName":"DO UNTIL","StatementHelp":{"#cdata":"Executes statements in a DO loop repetitively until a condition is true.\n          \nSyntax: \nDO UNTIL (expression); \n...more SAS statements...  \nEND;"},"StatementOptions":null},{"StatementName":"DROP","StatementHelp":{"#cdata":"Syntax: DROP column-list;  \n      \nExcludes columns from output tables. \n\nThe DROP statement applies to all the tables that are created within the same DS2 program \nand can appear anywhere in the program. The columns in the DROP statement are available for \nprocessing in the DS2 program. If no DROP or KEEP statement appears, all tables that are \ncreated in the DS2 program contain all columns. Do not use both DROP and KEEP statements \nwithin the same DS2 program."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"PACKAGE","StatementOptionHelp":{"#cdata":"Removes a DS2 package. \n          \nSyntax: DROP PACKAGE package [(table-options)];  \n\nArguments: \npackage \n  specifies the name of the package to be removed.\n\ntable-options \n  specifies optional arguments that the DS2 program applies when it removes a package."},"StatementOptionType":"S"},{"StatementOptionName":"THREAD","StatementOptionHelp":{"#cdata":"Removes a DS2 program thread. \n          \nSyntax \nDROP THREAD thread [(table-options)];  \n\nArguments:\nthread \n  specifies the name of the thread to be removed.\n\ntable-options \n  specifies optional arguments that the DS2 program applies when it removes a thread."},"StatementOptionType":"S"}]}},{"StatementName":"KEEP","StatementHelp":{"#cdata":"Syntax: KEEP column-list; \n      \nIncludes columns in output tables. \n\nThe KEEP statement specifies that all columns in the column list should be included \nin the creation of output rows. If the KEEP attribute is specified, all columns not \nincluded in the KEEP statement will be dropped from the output rows. If no DROP or \nKEEP statement appears, all tables that are created in the DS2 program contain all \ncolumns. Do not use both DROP and KEEP statements within the same DS2 program."},"StatementOptions":null},{"StatementName":"DROP PACKAGE","StatementHelp":{"#cdata":"Syntax: DROP PACKAGE package [(table-options)]; \n      \nRemoves a DS2 package. \n\npackage \nspecifies the name of the package to be removed.\n\ntable-options \nspecifies optional arguments that the DS2 program applies when it removes a package."},"StatementOptions":{"#comment":{},"StatementOption":[{"StatementOptionName":"ALTER=","StatementOptionHelp":{"#cdata":"Syntax: ALTER=alter-password \n    \nSyntax Description:\nalter-password \n  must be a valid SAS name.\n \nDetails: \nThe ALTER= option applies only to a SAS data set. You can use this option to assign \na password or to access a read-protected, write-protected, or alter-protected file. \nWhen you replace a data set that is protected with an ALTER password, the new data \nset inherits the ALTER password. \n\nThe password is blotted out when the code is written in the SAS log. For example: \n\n  set a(alter=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"V"},{"StatementOptionName":"BUFNO=","StatementOptionHelp":{"#cdata":"Specifies the number of buffers to be allocated for processing a SAS data set. \n    \nSyntax: BUFNO= n | nK | hexX | MIN | MAX  \n\nSyntax Description:\n\nn | nK \n  specifies the number of buffers in multiples of 1 (bytes); 1,024 (kilobytes). For example, \n  a value of 8 specifies 8 buffers, and a value of 1k specifies 1024 buffers.\n\nhex \n  specifies the number of buffers as a hexadecimal value. You must specify the value beginning \n  with a number (0-9), followed by an X. For example, the value 2dx sets the number of buffers \n  to 45 buffers.\n\nMIN \n  sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value \n  for the operating environment. This is the default.\n\nMAX \n  sets the number of buffers to the maximum possible number in your operating environment, \n  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"hexX","@Value4":"MIN","@Value5":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the number of buffers in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the number of buffers in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the number of buffers as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip4":"Sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value  for the operating environment. This is the default.","@ToolTip5":"Sets the number of buffers to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."}},{"StatementOptionName":"BUFSIZE=","StatementOptionHelp":{"#cdata":"Specifies the size of a permanent buffer page for an output SAS data set. \n    \nSyntax: BUFSIZE= n | nK | nM | nG | hexX | MAX  \n\nSyntax Description:\n\nn | nK | nM | nG \nspecifies the page size in multiples of 1 (bytes); 1,024 (kilobytes); 1,048,576 (megabytes); \nor 1,073,741,824 (gigabytes). For example, a value of 8 specifies a page size of 8 bytes, and \na value of 4k specifies a page size of 4096 bytes. \n\nhexX \nspecifies the page size as a hexadecimal value. You must specify the value beginning with a \nnumber (0-9), followed by an X. For example, the value 2dx sets the page size to 45 bytes.\n\nMAX \nsets the page size to the maximum possible number in your operating environment, up to the \nlargest four-byte, signed integer, which is 231-1, or approximately 2 billion bytes."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"nM","@Value4":"nG","@Value5":"hexX","@Value6":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the page size in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the page size in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the page size in multiples of 1,048,576 (megabytes).  Replace n with an integer value.","@ToolTip4":"Specifies the page size in multiples of 1,073,741,824 (gigabytes).  Replace n with an integer value.","@ToolTip5":"Specifies the page size as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip6":"Sets the page size to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion bytes."}},{"StatementOptionName":"BULKLOAD=","StatementOptionHelp":{"#cdata":"Loads rows of data as one unit. Default value: NO  \n    \nSyntax: BULKLOAD=YES | NO  \n\nSyntax Description:\n\nYES \ncalls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.\n\nNO \nuses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Calls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.","@ToolTip2":"Uses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."}},{"StatementOptionName":"COMPRESS=","StatementOptionHelp":{"#cdata":"Specifies how observations are compressed in a new output SAS data set. \n    \nSyntax: COMPRESS=NO | YES | CHAR | BINARY  \n\nSyntax Description:\nNO \nspecifies that the observations in a newly created SAS data set are uncompressed (fixed-length records).\n\nYES | CHAR \nspecifies that the observations in a newly created SAS data set are compressed (variable-length records) \nby SAS using RLE (Run Length Encoding). RLE compresses observations by reducing repeated consecutive \ncharacters (including blanks) to two-byte or three-byte representations. \n\n  Alias: ON \n  Tip: Use this compression algorithm for character data. \n  Note:   COMPRESS=CHAR is accepted by Version 7 and later versions.  \n\nBINARY \n  specifies that the observations in a newly created SAS data set are compressed (variable-length records) \n  by SAS using RDC (Ross Data Compression). RDC combines run-length encoding and sliding-window compression \n  to compress the file.\n\n  Tip: This method is highly effective for compressing medium to large (several hundred bytes or larger) \n  blocks of binary data (numeric variables). Because the compression function operates on a single record \n  at a time, the record length needs to be several hundred bytes or larger for effective compression."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NO","@Value2":"YES|ON","@Value3":"CHAR","@Value4":"BINARY"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the observations in a newly created SAS data set are uncompressed  (fixed-length records).","@ToolTip2":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.","@ToolTip3":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.   COMPRESS=CHAR is accepted by Version 7 and later versions.","@ToolTip4":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RDC (Ross Data Compression). RDC combines  run-length encoding and sliding-window compression to compress the file."}},{"StatementOptionName":"DBKEY=","StatementOptionHelp":{"#cdata":"Specifies a key column to optimize DBMS retrieval. Can improve performance when you \nare processing a join that involves a large DBMS table and a small SAS data set \nor DBMS table.\n    \nSyntax: DBKEY=([ ' ] column [ ' ] [... [ ' ] column [ ' ] ])  \n\nSyntax Description: \n\ncolumn \n  used by SAS to build an internal WHERE clause to search for matches in the DBMS table \n  based on the key column. For example:\n\n    select * from sas.a, dbms.b(dbkey=x) where a.x=b.x;\n    \nIn this example, DBKEY= specifies column x , which matches the key column designated in \nthe WHERE clause. However, if the DBKEY= column does NOT match the key column in the \nWHERE clause, then DBKEY= is not used."},"StatementOptionType":"V"},{"StatementOptionName":"DBNULL=","StatementOptionHelp":{"#cdata":"Indicates whether NULL is a valid value for the specified columns when a table is created. \n    \nSyntax: DBNULL={ _ALL=YES | NO } | ( [column=YES | NO [ ... column=YES | NO ] ] )  \n\nSyntax Description: \n_ALL_ \n  specifies that the YES or NO applies to all columns in the table. (This is valid in \n  the interfaces to Informix, Oracle, Sybase, and Teradata only.)\n\nYES \n  specifies that the NULL value is valid for the specified columns in the DBMS table.\n\nNO \n  specifies that the NULL value is not valid for the specified columns in the DBMS table.\n\ncolumn \n  specifies the name of a column. \n\nDetails: \nThis option is valid only for creating DBMS tables. If you specify more than one column name, \nthe names must be separated with spaces.\n\nThe DBNULL= option processes values from left to right, so if you specify a column name twice, \nor if you use the _ALL_ value, the last value overrides the first value that is specified for \nthe column."},"StatementOptionType":"V","SubOptionsKeywords":"_ALL_"},{"StatementOptionName":"DROP=","StatementOptionHelp":{"#cdata":"For an input table, excludes the specified columns from processing; for an output table, excludes the specified columns from being written to the table.\n    \nSyntax: DROP= ( column-list );  \n\nArguments: \ncolumn-list \n  specifies the names of the columns to omit from the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the format \n  col: are not supported. \n \nDetails: \nThe DROP= table option specifies that all columns in the column-list should not be included \nin the creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the drop attribute is specified, all columns not included in the drop \nstatement will be used to create columns in the output rows.\n\nIf the DROP= table option is associated with an input table, the columns are not available \nfor processing during program execution."},"StatementOptionType":"V"},{"StatementOptionName":"ENCRYPT=","StatementOptionHelp":{"#cdata":"Specifies whether to encrypt an output SAS data set. \n    \nSyntax: ENCRYPT=YES | NO  \n\nSyntax Description:\nYES \n  encrypts the file. The encryption method uses passwords. At a minimum, you must specify \n  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because \n  the encryption method uses passwords, you cannot change any password on an encrypted data \n  set without re-creating the data set.\n\nNO \n  does not encrypt the file.\n\nCAUTION:\nRecord all passwords. \nIf you forget the password, you cannot reset it without assistance from SAS. The process \nis time-consuming and resource-intensive."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Encrypts the file. The encryption method uses passwords. At a minimum, you must specify  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because  the encryption method uses passwords, you cannot change any password on an encrypted data  set without re-creating the data set.","@ToolTip2":"Does not encrypt the file."}},{"StatementOptionName":"KEEP=","StatementOptionHelp":{"#cdata":"For an input table, specifies the columns to process; for an output table, specifies \nthe columns to write to the table. \n    \nSyntax: KEEP=( column-list );  \n\nArguments:\n\ncolumn-list \n  specifies the names of the columns to keep in the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the \n  format col: are not supported. \n  \nDetails: \nThe KEEP= table option specifies that all columns in the column-list should be included in \nthe creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the keep attribute is specified, all columns not included in the KEEP \nstatement will be dropped from the output rows.\n\nIf the KEEP= table option is associated with an input table, only the columns that are \nspecified by the KEEP= table option are available for processing during program execution."},"StatementOptionType":"V"},{"StatementOptionName":"LABEL=","StatementOptionHelp":{"#cdata":"Specifies a label for a table.\n    \nSyntax: LABEL='label'  \n\nSyntax Description: \n\n'label' \n  specifies a text string of up to 256 characters. If the label text contains single \n  quotation marks, use double quotation marks around the label, or use two single \n  quotation marks in the label text and surround the string with single quotation \n  marks. To remove a label from a table, assign a label that is equal to a blank \n  that is enclosed in quotation marks.\n \nDetails: \nYou can use the LABEL= option on both input and output tables. When you use LABEL= \non input tables, it assigns a label for the table for the duration of the DS2 program. \nWhen it is specified for an output table, the label becomes a permanent part of that \ntable."},"StatementOptionType":"V"},{"StatementOptionName":"LOCKTABLE=","StatementOptionHelp":{"#cdata":"Places shared or exclusive locks on tables. \n    \nSyntax: LOCKTABLE=SHARE | EXCLUSIVE  \n\nSyntax Description:\n\nSHARE \n  locks a table in shared mode, allowing other users or processes to read data from the \n  tables, but preventing users from updating data.\n\nEXCLUSIVE \n  locks a table exclusively, preventing other users from accessing any table that you open. \n\nDetails: \nYou can lock tables only if you are the owner or have been granted the necessary privilege. \n\nIf you access the BASE table driver through PROC DS2, the default value for the LOCKTABLE \noption is EXCLUSIVE. However, if you access the BASE table driver through a table server, \nor if you run your program locally with the SAS Table Server LIBNAME engine, the default \nvalue for the LOCKTABLE option is SHARE."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"SHARE","@Value2":"EXCLUSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Locks a table in shared mode, allowing other users or processes to read data from  the tables, but preventing users from updating data.","@ToolTip2":"Locks a table exclusively, preventing other users from accessing any table that you open."}},{"StatementOptionName":"OVERWRITE=","StatementOptionHelp":{"#cdata":"For a table, drops the output table before the replacement output table is populated \nwith rows; for packages and threads, drops the existing package or thread if a package \nor thread by the same name exists. \n    \nSyntax: OVERWRITE= YES | NO;  \n\nArguments: \n\nYES | NO \n  specifies whether the output table is deleted before a replacement output table \n  is created or whether a package or thread is dropped.\n\n  Default: NO \n\nCAUTION:\nFor tables, use the OVERWRITE=YES statement only with data that is backed up or \nwith data that you can reconstruct. Because the output table is deleted first, \ndata will be lost if a failure occurs while the output table is being written."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the output table is deleted before a replacement output table    is created or a package or thread is dropped.","@ToolTip2":"Specifies that the output table is not deleted before a replacement output table    is created or a package or thread is dropped."}},{"StatementOptionName":"PW=","StatementOptionHelp":{"#cdata":"Assigns a READ, WRITE, and ALTER password to a SAS file, and enables access to a password-protected SAS file. \n    \nSyntax: PW=password  \n\nSyntax Description:\npassword \n  must be a valid SAS name.\n\nDetails:\nThe PW= option applies to all types of SAS files. You can use this option to assign \na password to a SAS file or to access a password-protected SAS file.\n\nWhen replacing a SAS data set that is protected by an ALTER password, the new data \nset inherits the ALTER password. When the code is written to the SAS log the password \nis blotted out, for example: \n\n  drop thread job2 (pw=xxxxxxx);\n\nNote:   A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"V"},{"StatementOptionName":"READ=","StatementOptionHelp":{"#cdata":"Assigns a READ password to a SAS file that prevents users from reading the file, \nunless they enter the password. \n    \nSyntax: READ=read-password  \n\nSyntax Description: \nread-password \n  must be a valid SAS name. \n \nDetails: \nThe READ= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a read-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  declare package sales (read=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You  \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"V"},{"StatementOptionName":"RENAME=","StatementOptionHelp":{"#cdata":"Changes the name of a column.\n    \nSyntax: RENAME= (old-name { = | AS } new-name [... old-name { = | AS } new-name ] ) ;  \n\nArguments: \nold-name \n  the column you want to rename.\n\nnew-name \n  the new name of the column. It must be a valid name for the data source.\n \nDetails: \nThe RENAME= table option allows you to change the names of one or more columns.\n\nIf you use RENAME= when you create a table, the new column name is included in the output \ntable. If you use RENAME= on an input table, the new name is used in DS2 programming statements.\n\nIf you use RENAME= in the same DS2 program with either the DROP= or the KEEP= table option, \nthe DROP= and the KEEP= table options are applied before RENAME=. You must use the old name in \nthe DROP= and KEEP= table options. You cannot drop and rename the same column in the same statement.\n\nIn addition to changing the name of a column, RENAME= also changes the label for the column."},"StatementOptionType":"V","SubOptionsKeywords":"AS"},{"StatementOptionName":"AS","StatementOptionHelp":{"#cdata":"Syntax: RENAME= (old-name AS new-name [... old-name AS new-name ] ) ;\n          \nSeparates the new-name from the old-name."},"StatementOptionType":"S"},{"StatementOptionName":"TYPE=","StatementOptionHelp":{"#cdata":"Specifies the data set type for a specially structured SAS data set. \n    \nSyntax: TYPE=data-set-type  \n\nSyntax Description: \ndata-set-type \n  specifies the special type of the data set.\n\nDetails: \nUse the TYPE= table option to create a special SAS data set in the proper format, \nor to identify the special type of the SAS data set in a procedure statement. \n\nYou can use the CONTENTS procedure to determine the type of a data set."},"StatementOptionType":"V"},{"StatementOptionName":"WRITE=","StatementOptionHelp":{"#cdata":"Assigns a WRITE password to a SAS file that prevents users from writing to a file, \nunless they enter the password. \n    \nSyntax: WRITE=write-password  \n\nSyntax Description: \nwrite-password \n  must be a valid SAS name. \n \nDetails: \nThe WRITE= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a write-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  drop thread job2a (write=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"V"}]}},{"StatementName":"CONTINUE","StatementHelp":{"#cdata":"Syntax: CONTINUE; \n      \nStops processing the current DO loop iteration and resumes with the next iteration."},"StatementOptions":null},{"StatementName":"IF","StatementHelp":{"#cdata":"Syntax: IF expression THEN statement; \n  [ ELSE statement ;] \n  \nExecutes a statement for observations that meet specific conditions."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"THEN","StatementOptionHelp":{"#cdata":"If the conditions that are specified in the IF clause are met, the IF-THEN statement \nexecutes a SAS statement."},"StatementOptionType":"S"},{"StatementOptionName":"DO","StatementOptionHelp":{"#cdata":"Syntax: DO [ < index-variable-clause > ] [ < conditional-clause > ] ;  \n  ...statement-list...\n  END [end-label ] ;  \n\nSpecifies a group of statements to be executed as a unit."},"StatementOptionType":"S"},{"StatementOptionName":"TO","StatementOptionHelp":{"#cdata":"Separates the start and stop integers or expressions that control the number of times the \nportion of the step between the iterative DO and END statements is processed."},"StatementOptionType":"S"},{"StatementOptionName":"BY","StatementOptionHelp":{"#cdata":"Precedes an increment integer (other than 0) or an expression that generates an integer to be \nadded to the value of the index variable in each iteration of the DO loop."},"StatementOptionType":"S"},{"StatementOptionName":"CONTINUE","StatementOptionHelp":{"#cdata":"Stops processing the current DO loop iteration and resumes with the next iteration."},"StatementOptionType":"S"},{"StatementOptionName":"LEAVE","StatementOptionHelp":{"#cdata":"Syntax: LEAVE [ identifier ] ; \n      \nStops processing the current DO loop and transfers execution to either the statement \nfollowing the current DO statement, or a labeled DO statement that encloses the current \nDO statement."},"StatementOptionType":"S"}]}},{"StatementName":"ELSE","StatementHelp":{"#cdata":"If the condition in an IF-THEN statement is false and an ELSE statement is present, \nthen the ELSE action is carried out."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"IF","StatementOptionHelp":{"#cdata":"Syntax: ELSE IF expression THEN statement; \n\nExecutes a statement for observations that meet specific conditions."},"StatementOptionType":"S"},{"StatementOptionName":"THEN","StatementOptionHelp":{"#cdata":"If the conditions that are specified in the IF clause are met, the IF-THEN statement \nexecutes a SAS statement."},"StatementOptionType":"S"},{"StatementOptionName":"DO","StatementOptionHelp":{"#cdata":"Syntax: DO [ < index-variable-clause > ] [ < conditional-clause > ] ;  \n  ...statement-list...\n  END [end-label ] ;  \n\nSpecifies a group of statements to be executed as a unit."},"StatementOptionType":"S"},{"StatementOptionName":"TO","StatementOptionHelp":{"#cdata":"Separates the start and stop integers or expressions that control the number of times the \nportion of the step between the iterative DO and END statements is processed."},"StatementOptionType":"S"},{"StatementOptionName":"BY","StatementOptionHelp":{"#cdata":"Precedes an increment integer (other than 0) or an expression that generates an integer to be \nadded to the value of the index variable in each iteration of the DO loop."},"StatementOptionType":"S"},{"StatementOptionName":"CONTINUE","StatementOptionHelp":{"#cdata":"Stops processing the current DO loop iteration and resumes with the next iteration."},"StatementOptionType":"S"},{"StatementOptionName":"PUT","StatementOptionHelp":{"#cdata":"Syntax: PUT < put-list > [ ... <put-list> ] ; \n  <put-list>::=  'character-string' | <eq-expression> [ = ] [ [ : ] format [-L | -C | -R ] ]   \n  <eq-expression>::=  identifier | array-reference | this-expression \n      \nPrints values of program variables and constants to the log. \n\nArguments:\n'character-string' \nspecifies a string of text, enclosed in quotation marks, that is written to the SAS log.\n\nidentifier \nnames a variable whose value is written to the SAS log.\n\narray-reference \nspecifies an array element. The subscript can be any SAS expression that resolves to an \ninteger value when the PUT statement executes. Use the array subscript asterisk (*) to \nwrite all elements of the array.\n\nthis-expression \nspecifies a THIS expression.\n\n= \nIf an equal sign is added after a variable or array element, then the output is preceded \nby the variable or array element name and an equal sign.\n\n: \nenables you to specify a format that the PUT statement uses to write the variable value. \nAll leading and trailing blanks are deleted, and each value is followed by a single blank.\nRestriction: You must specify a format. \n\nformat \nspecifies a format to use when the data value is written to the SAS log. If you use a colon \nmodifier (:) with the format name, all leading and trailing blanks are deleted and each value \nis followed by a single blank. To override the default alignment, you can add an alignment \nspecification to a format:\n  -L left aligns the value.  \n  -C centers the value.  \n  -R right aligns the value.\n \nTip: Ensure that the format width provides enough space to write the value and any commas, \ndollar signs, decimal points, or other special characters that the format includes."},"StatementOptionType":"S"},{"StatementOptionName":"LEAVE","StatementOptionHelp":{"#cdata":"Syntax: LEAVE [ identifier ] ; \n      \nStops processing the current DO loop and transfers execution to either the statement \nfollowing the current DO statement, or a labeled DO statement that encloses the current \nDO statement."},"StatementOptionType":"S"}]}},{"StatementName":"DECLARE|DCL","StatementHelp":{"#cdata":"Syntax: DECLARE { <data-type> <variable-list> [ <having-clause> ] } ; \n      \nDeclares one or more DS2 variables or arrays."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"INTEGER|INT","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"BIGINT","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"IDENTITY","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"SMALLINT","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"TINYINT","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"DOUBLE","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"DOUBLE PRECISION","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"FLOAT","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"REAL","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"VARBINARY|BINARY VARYING","StatementOptionHelp":{"#cdata":"Specifies a varying-length binary variable.\n\nAlias: BINARY VARYING \n\nRequirement: If you specify VARBINARY, you must also specify the length of the binary \nvariable in bytes."},"StatementOptionType":"S"},{"StatementOptionName":"NCHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"NVARCHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"CHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"VARCHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"CHARACTER SET","StatementOptionHelp":{"#cdata":"[For use with CHAR and VARCHAR data types only]\n          \nSyntax: \nCHAR [ ( character-length ) ] [CHARACTER SET (character-set-identifier) ] \nVARCHAR [ ( character-length ) ] [CHARACTER SET (character-set-identifier) ]\n\nSpecifies character set encoding information for CHAR and VARCHAR data types."},"StatementOptionType":"S"},{"StatementOptionName":"TIME","StatementOptionHelp":{"#cdata":"Syntax: TIME (precision)\n          \nSpecifies a time variable. \n\nprecision \nspecifies the precision for a TIME data type.\n\nDefault: 0"},"StatementOptionType":"S"},{"StatementOptionName":"TIMESTAMP","StatementOptionHelp":{"#cdata":"Syntax: TIMESTAMP (precision) \n          \nSpecifies both a date and time variable. \n\nprecision \nspecifies the precision for a TIMESTAMP data type.\n\nDefault: 6"},"StatementOptionType":"S"},{"StatementOptionName":"DATE","StatementOptionHelp":{"#cdata":"Specifies a date variable."},"StatementOptionType":"S"},{"StatementOptionName":"HAVING","StatementOptionHelp":{"#cdata":"Syntax: HAVING <having-option> [... <having-option> ]  \n \nThe HAVING clause functions the same as the FORMAT, INFORMAT, and LABEL statements \nin Base SAS. However, in DS2, the attributes must be specified in the declaration \nstatement of the variable."},"StatementOptionType":"S"},{"StatementOptionName":"LABEL","StatementOptionHelp":{"#cdata":"[For HAVING clause only]\n          \nSyntax: LABEL 'string' | n'string' \n\nAssigns a descriptive label to the variable. The label can be a CHAR literal (string) \nor NCHAR literal (nstring)."},"StatementOptionType":"S"},{"StatementOptionName":"FORMAT","StatementOptionHelp":{"#cdata":"[For HAVING clause only] \n          \nSyntax: FORMAT format \n\nAssociates any valid DS2 format with the variable."},"StatementOptionType":"S"},{"StatementOptionName":"INFORMAT","StatementOptionHelp":{"#cdata":"[For HAVING clause only] \n          \nSyntax: INFORMAT informat \n\nAssociates any valid SAS informat with the variable."},"StatementOptionType":"S"},{"StatementOptionName":"PACKAGE","StatementOptionHelp":{"#cdata":"Creates an instance of a package. \n          \nSyntax:\n(1) DECLARE PACKAGE package [(table-options)] instance [ ( )] [... instance [ ( )]];  \n(2) DECLARE PACKAGE HASH instance [ ( hashexp, 'datasource', 'ordered', 'duplicate' ) ];  \n(3) DECLARE PACKAGE HITER instance [ ( 'hashname')];"},"StatementOptionType":"S"},{"StatementOptionName":"HASH","StatementOptionHelp":{"#cdata":"Specifies the name of the package as HASH to register the hash package \nfor use in a DS2 program."},"StatementOptionType":"RS"},{"StatementOptionName":"HITER","StatementOptionHelp":{"#cdata":"Specifies the name of the package as HITER to register the hash iterator package \nfor use in a DS2 program."},"StatementOptionType":"RS"}]}},{"StatementName":"VARARRAY","StatementHelp":{"#cdata":"Syntax: VARARRAY { <data-type> array-name {<array-bound> | * } <variable-list> [<having-clause>]} ; \n      \nDeclares one or more DS2 variable arrays."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"INTEGER|INT","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"BIGINT","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"IDENTITY","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"SMALLINT","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"TINYINT","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"DOUBLE","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"DOUBLE PRECISION","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"FLOAT","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"REAL","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"VARBINARY|BINARY VARYING","StatementOptionHelp":{"#cdata":"Specifies a varying-length binary variable.\n\nAlias: BINARY VARYING \n\nRequirement: If you specify VARBINARY, you must also specify the length of the binary \nvariable in bytes."},"StatementOptionType":"S"},{"StatementOptionName":"NCHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"NVARCHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"CHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"VARCHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"CHARACTER SET","StatementOptionHelp":{"#cdata":"[For use with CHAR and VARCHAR data types only]\n          \nSyntax: \nCHAR [ ( character-length ) ] [CHARACTER SET (character-set-identifier) ] \nVARCHAR [ ( character-length ) ] [CHARACTER SET (character-set-identifier) ]\n\nSpecifies character set encoding information for CHAR and VARCHAR data types."},"StatementOptionType":"S"},{"StatementOptionName":"TIME","StatementOptionHelp":{"#cdata":"Syntax: TIME (precision)\n          \nSpecifies a time variable. \n\nprecision \nspecifies the precision for a TIME data type.\n\nDefault: 0"},"StatementOptionType":"S"},{"StatementOptionName":"TIMESTAMP","StatementOptionHelp":{"#cdata":"Syntax: TIMESTAMP (precision) \n          \nSpecifies both a date and time variable. \n\nprecision \nspecifies the precision for a TIMESTAMP data type.\n\nDefault: 6"},"StatementOptionType":"S"},{"StatementOptionName":"DATE","StatementOptionHelp":{"#cdata":"Specifies a date variable."},"StatementOptionType":"S"},{"StatementOptionName":"HAVING","StatementOptionHelp":{"#cdata":"Syntax: HAVING <having-option> [... <having-option> ]  \n \nThe HAVING clause functions the same as the FORMAT, INFORMAT, and LABEL statements \nin Base SAS. However, in DS2, the attributes must be specified in the declaration \nstatement of the variable."},"StatementOptionType":"S"},{"StatementOptionName":"LABEL","StatementOptionHelp":{"#cdata":"[For HAVING clause only]\n          \nSyntax: LABEL 'string' | n'string' \n\nAssigns a descriptive label to the variable. The label can be a CHAR literal (string) \nor NCHAR literal (nstring)."},"StatementOptionType":"S"},{"StatementOptionName":"FORMAT","StatementOptionHelp":{"#cdata":"[For HAVING clause only] \n          \nSyntax: FORMAT format \n\nAssociates any valid DS2 format with the variable."},"StatementOptionType":"S"},{"StatementOptionName":"INFORMAT","StatementOptionHelp":{"#cdata":"[For HAVING clause only] \n          \nSyntax: INFORMAT informat \n\nAssociates any valid SAS informat with the variable."},"StatementOptionType":"S"},{"StatementOptionName":"PACKAGE","StatementOptionHelp":{"#cdata":"Creates an instance of a package. \n          \nSyntax:\n(1) DECLARE PACKAGE package [(table-options)] instance [ ( )] [... instance [ ( )]];  \n(2) DECLARE PACKAGE HASH instance [ ( hashexp, 'datasource', 'ordered', 'duplicate' ) ];  \n(3) DECLARE PACKAGE HITER instance [ ( 'hashname')];"},"StatementOptionType":"S"},{"StatementOptionName":"HASH","StatementOptionHelp":{"#cdata":"Specifies the name of the package as HASH to register the hash package \nfor use in a DS2 program."},"StatementOptionType":"RS"},{"StatementOptionName":"HITER","StatementOptionHelp":{"#cdata":"Specifies the name of the package as HITER to register the hash iterator package \nfor use in a DS2 program."},"StatementOptionType":"RS"}]}},{"StatementName":"GLOBAL","StatementHelp":{"#cdata":"Syntax: GLOBAL { <data-type> <variable-list> [ <having-clause> ] } ; \n      \nDeclares one or more global variables or arrays."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"INT|INTEGER","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"BIGINT","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"IDENTITY","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"SMALLINT","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"TINYINT","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"DOUBLE","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"DOUBLE PRECISION","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"FLOAT","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"REAL","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"VARBINARY","StatementOptionHelp":{"#cdata":"Specifies a varying-length binary variable.\n\nAlias: BINARY VARYING \n\nRequirement: If you specify VARBINARY, you must also specify the length of the binary \nvariable in bytes."},"StatementOptionType":"S"},{"StatementOptionName":"NCHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"NVARCHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"CHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"VARCHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"CHARACTER SET","StatementOptionHelp":{"#cdata":"[For use with CHAR and VARCHAR data types only]\n          \nSyntax: \nCHAR [ ( character-length ) ] [CHARACTER SET (character-set-identifier) ] \nVARCHAR [ ( character-length ) ] [CHARACTER SET (character-set-identifier) ]\n\nSpecifies character set encoding information for CHAR and VARCHAR data types."},"StatementOptionType":"S"},{"StatementOptionName":"TIME","StatementOptionHelp":{"#cdata":"Syntax: TIME (precision)\n          \nSpecifies a time variable. \n\nprecision \nspecifies the precision for a TIME data type.\n\nDefault: 0"},"StatementOptionType":"S"},{"StatementOptionName":"TIMESTAMP","StatementOptionHelp":{"#cdata":"Syntax: TIMESTAMP (precision) \n          \nSpecifies both a date and time variable. \n\nprecision \nspecifies the precision for a TIMESTAMP data type.\n\nDefault: 6"},"StatementOptionType":"S"},{"StatementOptionName":"DATE","StatementOptionHelp":{"#cdata":"Specifies a date variable."},"StatementOptionType":"S"},{"StatementOptionName":"HAVING","StatementOptionHelp":{"#cdata":"Syntax: HAVING <having-option> [... <having-option> ]  \n \nThe HAVING clause functions the same as the FORMAT, INFORMAT, and LABEL statements \nin Base SAS. However, in DS2, the attributes must be specified in the declaration \nstatement of the variable."},"StatementOptionType":"S"},{"StatementOptionName":"LABEL","StatementOptionHelp":{"#cdata":"[For HAVING clause only]\n          \nSyntax: LABEL 'string' | n'string' \n\nAssigns a descriptive label to the variable. The label can be a CHAR literal (string) \nor NCHAR literal (nstring)."},"StatementOptionType":"S"},{"StatementOptionName":"FORMAT","StatementOptionHelp":{"#cdata":"[For HAVING clause only] \n          \nSyntax: FORMAT format \n\nAssociates any valid DS2 format with the variable."},"StatementOptionType":"S"},{"StatementOptionName":"INFORMAT","StatementOptionHelp":{"#cdata":"[For HAVING clause only] \n          \nSyntax: INFORMAT informat \n\nAssociates any valid SAS informat with the variable."},"StatementOptionType":"S"}]}},{"StatementName":"DROP THREAD","StatementHelp":{"#cdata":"Syntax: DROP THREAD thread [(table-options)]; \n      \nRemoves a DS2 program thread. \n\nthread \nspecifies the name of the thread to be removed.\n\ntable-options \nspecifies optional arguments that the DS2 program applies when it removes a thread."},"StatementOptions":{"#comment":{},"StatementOption":[{"StatementOptionName":"ALTER=","StatementOptionHelp":{"#cdata":"Syntax: ALTER=alter-password \n    \nSyntax Description:\nalter-password \n  must be a valid SAS name.\n \nDetails:\nThe ALTER= option applies only to a SAS data set. You can use this option to assign \na password or to access a read-protected, write-protected, or alter-protected file. \nWhen you replace a data set that is protected with an ALTER password, the new data \nset inherits the ALTER password. \n\nThe password is blotted out when the code is written in the SAS log. For example: \n\n  set a(alter=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"},{"StatementOptionName":"BUFNO=","StatementOptionHelp":{"#cdata":"Specifies the number of buffers to be allocated for processing a SAS data set. \n    \nSyntax: BUFNO= n | nK | hexX | MIN | MAX  \n\nSyntax Description:\n\nn | nK \n  specifies the number of buffers in multiples of 1 (bytes); 1,024 (kilobytes). For example, \n  a value of 8 specifies 8 buffers, and a value of 1k specifies 1024 buffers.\n\nhex \n  specifies the number of buffers as a hexadecimal value. You must specify the value beginning \n  with a number (0-9), followed by an X. For example, the value 2dx sets the number of buffers \n  to 45 buffers.\n\nMIN \n  sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value \n  for the operating environment. This is the default.\n\nMAX \n  sets the number of buffers to the maximum possible number in your operating environment, \n  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"hexX","@Value4":"MIN","@Value5":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the number of buffers in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the number of buffers in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the number of buffers as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip4":"Sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value  for the operating environment. This is the default.","@ToolTip5":"Sets the number of buffers to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."}},{"StatementOptionName":"BUFSIZE=","StatementOptionHelp":{"#cdata":"Specifies the size of a permanent buffer page for an output SAS data set. \n    \nSyntax: BUFSIZE= n | nK | nM | nG | hexX | MAX  \n\nSyntax Description:\n\nn | nK | nM | nG \nspecifies the page size in multiples of 1 (bytes); 1,024 (kilobytes); 1,048,576 (megabytes); \nor 1,073,741,824 (gigabytes). For example, a value of 8 specifies a page size of 8 bytes, and \na value of 4k specifies a page size of 4096 bytes. \n\nhexX \nspecifies the page size as a hexadecimal value. You must specify the value beginning with a \nnumber (0-9), followed by an X. For example, the value 2dx sets the page size to 45 bytes.\n\nMAX \nsets the page size to the maximum possible number in your operating environment, up to the \nlargest four-byte, signed integer, which is 231-1, or approximately 2 billion bytes."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"nM","@Value4":"nG","@Value5":"hexX","@Value6":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the page size in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the page size in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the page size in multiples of 1,048,576 (megabytes).  Replace n with an integer value.","@ToolTip4":"Specifies the page size in multiples of 1,073,741,824 (gigabytes).  Replace n with an integer value.","@ToolTip5":"Specifies the page size as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip6":"Sets the page size to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion bytes."}},{"StatementOptionName":"BULKLOAD=","StatementOptionHelp":{"#cdata":"Loads rows of data as one unit. Default value: NO  \n    \nSyntax: BULKLOAD=YES | NO  \n\nSyntax Description:\n\nYES \ncalls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.\n\nNO \nuses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Calls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.","@ToolTip2":"Uses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."}},{"StatementOptionName":"COMPRESS=","StatementOptionHelp":{"#cdata":"Specifies how observations are compressed in a new output SAS data set. \n    \nSyntax: COMPRESS=NO | YES | CHAR | BINARY  \n\nSyntax Description:\nNO \nspecifies that the observations in a newly created SAS data set are uncompressed (fixed-length records).\n\nYES | CHAR \nspecifies that the observations in a newly created SAS data set are compressed (variable-length records) \nby SAS using RLE (Run Length Encoding). RLE compresses observations by reducing repeated consecutive \ncharacters (including blanks) to two-byte or three-byte representations. \n\n  Alias: ON \n  Tip: Use this compression algorithm for character data. \n  Note:   COMPRESS=CHAR is accepted by Version 7 and later versions.  \n\nBINARY \n  specifies that the observations in a newly created SAS data set are compressed (variable-length records) \n  by SAS using RDC (Ross Data Compression). RDC combines run-length encoding and sliding-window compression \n  to compress the file.\n\n  Tip: This method is highly effective for compressing medium to large (several hundred bytes or larger) \n  blocks of binary data (numeric variables). Because the compression function operates on a single record \n  at a time, the record length needs to be several hundred bytes or larger for effective compression."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"NO","@Value2":"YES|ON","@Value3":"CHAR","@Value4":"BINARY"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the observations in a newly created SAS data set are uncompressed  (fixed-length records).","@ToolTip2":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.","@ToolTip3":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.   COMPRESS=CHAR is accepted by Version 7 and later versions.","@ToolTip4":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RDC (Ross Data Compression). RDC combines  run-length encoding and sliding-window compression to compress the file."}},{"StatementOptionName":"DBKEY=","StatementOptionHelp":{"#cdata":"Specifies a key column to optimize DBMS retrieval. Can improve performance when you \nare processing a join that involves a large DBMS table and a small SAS data set \nor DBMS table.\n    \nSyntax: DBKEY=([ ' ] column [ ' ] [... [ ' ] column [ ' ] ])  \n\nSyntax Description: \n\ncolumn \n  used by SAS to build an internal WHERE clause to search for matches in the DBMS table \n  based on the key column. For example:\n\n    select * from sas.a, dbms.b(dbkey=x) where a.x=b.x;\n    \nIn this example, DBKEY= specifies column x , which matches the key column designated in \nthe WHERE clause. However, if the DBKEY= column does NOT match the key column in the \nWHERE clause, then DBKEY= is not used."},"StatementOptionType":"TV"},{"StatementOptionName":"DBNULL=","StatementOptionHelp":{"#cdata":"Indicates whether NULL is a valid value for the specified columns when a table is created. \n    \nSyntax: DBNULL={ _ALL=YES | NO } | ( [column=YES | NO [ ... column=YES | NO ] ] )  \n\nSyntax Description: \n_ALL_ \n  specifies that the YES or NO applies to all columns in the table. (This is valid in \n  the interfaces to Informix, Oracle, Sybase, and Teradata only.)\n\nYES \n  specifies that the NULL value is valid for the specified columns in the DBMS table.\n\nNO \n  specifies that the NULL value is not valid for the specified columns in the DBMS table.\n\ncolumn \n  specifies the name of a column. \n\nDetails: \nThis option is valid only for creating DBMS tables. If you specify more than one column name, \nthe names must be separated with spaces.\n\nThe DBNULL= option processes values from left to right, so if you specify a column name twice, \nor if you use the _ALL_ value, the last value overrides the first value that is specified for \nthe column."},"StatementOptionType":"TV","SubOptionsKeywords":"_ALL_"},{"StatementOptionName":"DROP=","StatementOptionHelp":{"#cdata":"For an input table, excludes the specified columns from processing; for an output table, excludes the specified columns from being written to the table.\n    \nSyntax: DROP= ( column-list );  \n\nArguments: \ncolumn-list \n  specifies the names of the columns to omit from the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the format \n  col: are not supported. \n \nDetails: \nThe DROP= table option specifies that all columns in the column-list should not be included \nin the creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the drop attribute is specified, all columns not included in the drop \nstatement will be used to create columns in the output rows.\n\nIf the DROP= table option is associated with an input table, the columns are not available \nfor processing during program execution."},"StatementOptionType":"TV"},{"StatementOptionName":"ENCRYPT=","StatementOptionHelp":{"#cdata":"Specifies whether to encrypt an output SAS data set. \n    \nSyntax: ENCRYPT=YES | NO  \n\nSyntax Description:\nYES \n  encrypts the file. The encryption method uses passwords. At a minimum, you must specify \n  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because \n  the encryption method uses passwords, you cannot change any password on an encrypted data \n  set without re-creating the data set.\n\nNO \n  does not encrypt the file.\n\nCAUTION:\nRecord all passwords. \nIf you forget the password, you cannot reset it without assistance from SAS. The process \nis time-consuming and resource-intensive."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Encrypts the file. The encryption method uses passwords. At a minimum, you must specify  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because  the encryption method uses passwords, you cannot change any password on an encrypted data  set without re-creating the data set.","@ToolTip2":"Does not encrypt the file."}},{"StatementOptionName":"KEEP=","StatementOptionHelp":{"#cdata":"For an input table, specifies the columns to process; for an output table, specifies \nthe columns to write to the table. \n    \nSyntax: KEEP=( column-list );  \n\nArguments:\n\ncolumn-list \n  specifies the names of the columns to keep in the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the \n  format col: are not supported. \n  \nDetails: \nThe KEEP= table option specifies that all columns in the column-list should be included in \nthe creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the keep attribute is specified, all columns not included in the KEEP \nstatement will be dropped from the output rows.\n\nIf the KEEP= table option is associated with an input table, only the columns that are \nspecified by the KEEP= table option are available for processing during program execution."},"StatementOptionType":"TV"},{"StatementOptionName":"LABEL=","StatementOptionHelp":{"#cdata":"Specifies a label for a table.\n    \nSyntax: LABEL='label'  \n\nSyntax Description: \n\n'label' \n  specifies a text string of up to 256 characters. If the label text contains single \n  quotation marks, use double quotation marks around the label, or use two single \n  quotation marks in the label text and surround the string with single quotation \n  marks. To remove a label from a table, assign a label that is equal to a blank \n  that is enclosed in quotation marks.\n \nDetails: \nYou can use the LABEL= option on both input and output tables. When you use LABEL= \non input tables, it assigns a label for the table for the duration of the DS2 program. \nWhen it is specified for an output table, the label becomes a permanent part of that \ntable."},"StatementOptionType":"TV"},{"StatementOptionName":"LOCKTABLE=","StatementOptionHelp":{"#cdata":"Places shared or exclusive locks on tables. \n    \nSyntax: LOCKTABLE=SHARE | EXCLUSIVE  \n\nSyntax Description:\n\nSHARE \n  locks a table in shared mode, allowing other users or processes to read data from the \n  tables, but preventing users from updating data.\n\nEXCLUSIVE \n  locks a table exclusively, preventing other users from accessing any table that you open. \n\nDetails: \nYou can lock tables only if you are the owner or have been granted the necessary privilege. \n\nIf you access the BASE table driver through PROC DS2, the default value for the LOCKTABLE \noption is EXCLUSIVE. However, if you access the BASE table driver through a table server, \nor if you run your program locally with the SAS Table Server LIBNAME engine, the default \nvalue for the LOCKTABLE option is SHARE."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"SHARE","@Value2":"EXCLUSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Locks a table in shared mode, allowing other users or processes to read data from  the tables, but preventing users from updating data.","@ToolTip2":"Locks a table exclusively, preventing other users from accessing any table that you open."}},{"StatementOptionName":"OVERWRITE=","StatementOptionHelp":{"#cdata":"For a table, drops the output table before the replacement output table is populated \nwith rows; for packages and threads, drops the existing package or thread if a package \nor thread by the same name exists. \n    \nSyntax: OVERWRITE= YES | NO;  \n\nArguments: \n\nYES | NO \n  specifies whether the output table is deleted before a replacement output table \n  is created or whether a package or thread is dropped.\n\n  Default: NO \n\nCAUTION:\nFor tables, use the OVERWRITE=YES statement only with data that is backed up or \nwith data that you can reconstruct. Because the output table is deleted first, \ndata will be lost if a failure occurs while the output table is being written."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the output table is deleted before a replacement output table    is created or a package or thread is dropped.","@ToolTip2":"Specifies that the output table is not deleted before a replacement output table    is created or a package or thread is dropped."}},{"StatementOptionName":"PW=","StatementOptionHelp":{"#cdata":"Assigns a READ, WRITE, and ALTER password to a SAS file, and enables access to a password-protected SAS file. \n    \nSyntax: PW=password  \n\nSyntax Description:\npassword \n  must be a valid SAS name.\n\nDetails:\nThe PW= option applies to all types of SAS files. You can use this option to assign \na password to a SAS file or to access a password-protected SAS file.\n\nWhen replacing a SAS data set that is protected by an ALTER password, the new data \nset inherits the ALTER password. When the code is written to the SAS log the password \nis blotted out, for example: \n\n  drop thread job2 (pw=xxxxxxx);\n\nNote:   A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"},{"StatementOptionName":"READ=","StatementOptionHelp":{"#cdata":"Assigns a READ password to a SAS file that prevents users from reading the file, \nunless they enter the password. \n    \nSyntax: READ=read-password  \n\nSyntax Description: \nread-password \n  must be a valid SAS name. \n \nDetails: \nThe READ= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a read-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  declare package sales (read=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You  \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"},{"StatementOptionName":"RENAME=","StatementOptionHelp":{"#cdata":"Changes the name of a column.\n    \nSyntax: RENAME= (old-name { = | AS } new-name [... old-name { = | AS } new-name ] ) ;  \n\nArguments: \nold-name \n  the column you want to rename.\n\nnew-name \n  the new name of the column. It must be a valid name for the data source.\n \nDetails: \nThe RENAME= table option allows you to change the names of one or more columns.\n\nIf you use RENAME= when you create a table, the new column name is included in the output \ntable. If you use RENAME= on an input table, the new name is used in DS2 programming statements.\n\nIf you use RENAME= in the same DS2 program with either the DROP= or the KEEP= table option, \nthe DROP= and the KEEP= table options are applied before RENAME=. You must use the old name in \nthe DROP= and KEEP= table options. You cannot drop and rename the same column in the same statement.\n\nIn addition to changing the name of a column, RENAME= also changes the label for the column."},"StatementOptionType":"TV","SubOptionsKeywords":"AS"},{"StatementOptionName":"AS","StatementOptionHelp":{"#cdata":"Syntax: RENAME= (old-name AS new-name [... old-name AS new-name ] ) ;\n          \nSeparates the new-name from the old-name."},"StatementOptionType":"S"},{"StatementOptionName":"TYPE=","StatementOptionHelp":{"#cdata":"Specifies the data set type for a specially structured SAS data set. \n    \nSyntax: TYPE=data-set-type  \n\nSyntax Description: \ndata-set-type \n  specifies the special type of the data set.\n\nDetails: \nUse the TYPE= table option to create a special SAS data set in the proper format, \nor to identify the special type of the SAS data set in a procedure statement. \n\nYou can use the CONTENTS procedure to determine the type of a data set."},"StatementOptionType":"TV"},{"StatementOptionName":"WRITE=","StatementOptionHelp":{"#cdata":"Assigns a WRITE password to a SAS file that prevents users from writing to a file, \nunless they enter the password. \n    \nSyntax: WRITE=write-password  \n\nSyntax Description: \nwrite-password \n  must be a valid SAS name. \n \nDetails: \nThe WRITE= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a write-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  drop thread job2a (write=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"}]}},{"StatementName":"ENDPACKAGE","StatementHelp":{"#cdata":"Syntax: ENDPACKAGE; \n      \nMarks the end of a PACKAGE statement. \n\nAlthough the ENDPACKAGE statement is not required, it can make the code easier to read."},"StatementOptions":null},{"StatementName":"ENDTHREAD","StatementHelp":{"#cdata":"Syntax: ENDTHREAD; \n      \nMarks the end of a THREAD statement. \n\nAlthough the ENDTHREAD statement is not required, it can make the code easier to read."},"StatementOptions":null},{"StatementName":"FORWARD","StatementHelp":{"#cdata":"Syntax: FORWARD method [ ...method ]; \n      \nIndicates that the method definition follows the method expression. \n\nmethod \nspecifies the name of the method to be defined."},"StatementOptions":null},{"StatementName":"GOTO","StatementHelp":{"#cdata":"Syntax: GOTO label; \n      \nTransfers execution immediately to a labeled statement. \n\nThe destination label for the GOTO statement must be within the same DS2 method. \nYou must specify the label argument or an error will occur. Statement labels are \ndefined by using the Labels statement."},"StatementOptions":null},{"StatementName":"LEAVE","StatementHelp":{"#cdata":"Syntax: LEAVE [ identifier ] ; \n      \nStops processing the current DO loop and transfers execution to either the statement \nfollowing the current DO statement, or a labeled DO statement that encloses the current \nDO statement."},"StatementOptions":null},{"StatementName":"METHOD","StatementHelp":{"#cdata":"Syntax: METHOD method ( [ <parameter > [ ,... < parameter > ] ] )  \n    [ RETURNS data-type ]>; \n    ... method-body ...  \n  END; \n\nDefines a block of code that can be called and executed multiple times."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"RETURNS","StatementOptionHelp":{"#cdata":"Syntax: RETURNS data-type \n          \nSpecifies the data type of the value that the method returns. The type \ncan be any valid character, numeric, or date type."},"StatementOptionType":"S"},{"StatementOptionName":"INIT","StatementOptionHelp":{"#cdata":"Calls a DS2 system method where program initializations can take place.\n          \n Syntax: \n METHOD INIT();  \n END;  \n\nWithout Arguments\nThe METHOD INIT statement has no arguments. If you try to pass arguments, an error will occur.\n\nDetails: \nTypically, the INIT method will contain any initialization code such as variable initialization \nor opening of tables. Code in the INIT method will run once at the beginning of the DS2 program. \nBefore the INIT method has run, variables in the program data vector which have not been retained \n'(by using the RETAIN statement) will be set to either SAS missing values or null values depending \non whether you are in SAS mode or ANSI mode. \n\nEvery DS2 program will contain, either implicitly or explicitly, the INIT, RUN, and TERM methods. \nIf you do not specify a METHOD INIT statement, DS2 will automatically provide one."},"StatementOptionType":"S"},{"StatementOptionName":"RUN","StatementOptionHelp":{"#cdata":"Syntax:  METHOD RUN();  END;  \n\nWithout Arguments:\nThe METHOD RUN statement has no arguments. If you try to pass arguments, an error \nwill occur.\n\nDetails: \nTypically, the RUN method will contain the main DS2 program code. The RUN method \nhas the same feature of automatic, implicit looping as the Base SAS DATA step. After \nthe RUN method has been executed one time, the RUN method either runs again or \ncontrol is passed to the TERM method.\n\nEvery DS2 program will contain, either implicitly or explicitly, the INIT, RUN, \nand TERM methods. If you do not specify a METHOD RUN statement, DS2 will \nautomatically provide one."},"StatementOptionType":"S"},{"StatementOptionName":"TERM","StatementOptionHelp":{"#cdata":"\n          \nSyntax:\n  METHOD TERM();  \n  END;  \n \nWithout Arguments:\nThe METHOD TERM statement has no arguments. If you try to pass arguments, an error \nwill occur.\n\nDetails:\nTypically, the TERM method will contain any finalization code such as writing data \nto the SAS log. Code in the TERM method will run once at the end of the DS2 program.\n\nEvery DS2 program will contain, either implicitly or explicitly, the INIT, RUN, and \nTERM methods. If you do not specify a METHOD TERM statement, DS2 will automatically\nprovide one."},"StatementOptionType":"S"},{"StatementOptionName":"INT|INTEGER","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"BIGINT","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"IDENTITY","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"SMALLINT","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"TINYINT","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"DOUBLE","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"DOUBLE PRECISION","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"FLOAT","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"REAL","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"VARBINARY|BINARY VARYING","StatementOptionHelp":{"#cdata":"Specifies a varying-length binary variable.\n\nAlias: BINARY VARYING \n\nRequirement: If you specify VARBINARY, you must also specify the length of the binary \nvariable in bytes."},"StatementOptionType":"S"},{"StatementOptionName":"NCHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"NVARCHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"CHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"VARCHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"TIME","StatementOptionHelp":{"#cdata":"Syntax: TIME (precision)\n          \nSpecifies a time variable. \n\nprecision \nspecifies the precision for a TIME data type.\n\nDefault: 0"},"StatementOptionType":"S"},{"StatementOptionName":"TIMESTAMP","StatementOptionHelp":{"#cdata":"Syntax: TIMESTAMP (precision) \n          \nSpecifies both a date and time variable. \n\nprecision \nspecifies the precision for a TIMESTAMP data type.\n\nDefault: 6"},"StatementOptionType":"S"},{"StatementOptionName":"DATE","StatementOptionHelp":{"#cdata":"Specifies a date variable."},"StatementOptionType":"S"}],"#comment":{}}},{"StatementName":"OUTPUT","StatementHelp":{"#cdata":"Syntax: OUTPUT [ { table [ ... table ] } | _ROWSET_ | _NULL_ ]; \n      \nWrites the current row to a table. \n\ntable \nspecifies the name of the table to which to write rows. table can be one of these forms. \n\n   catalog.schema.table-name  \n   schema.table-name  \n   catalog.table-name                \n   table-name  \n                                               \n  catalog \n  is an implementation of the ANSI SQL standard for an SQL catalog, which is a data \n  container object that groups logically related schemas. \n  \n  schema \n  is an implementation of the ANSI SQL standard for an SQL schema, which is a data \n  container object that groups files such as tables and views and other objects supported \n  by a data source such as stored procedures. \n  table-name \n  is the name of the table.\n\n  Restriction: All names specified in the OUTPUT statement must also appear in the TABLE statement. \n  Requirements: Table naming conventions are based on the datasource. \n  Tip: You can specify up to as many tables in the OUTPUT statement as you specified in the TABLE \n  statement for that DS2 program. \n  \n_ROWSET_ \nspecifies that the OUTPUT statement should not write rows to a table, but it should instead \nreturn table rows to the client application.\n\n_NULL_ \nspecifies that the OUTPUT statement should not write rows to either a table or the client application."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"_ROWSET_","StatementOptionHelp":{"#cdata":"Specifies that the OUTPUT statement should not write rows to a table, but it should \ninstead return table rows to the client application."},"StatementOptionType":"S"},{"StatementOptionName":"_NULL_","StatementOptionHelp":{"#cdata":"Specifies that the OUTPUT statement should not write rows to either a table or the \nclient application."},"StatementOptionType":"S"}]}},{"StatementName":"PACKAGE","StatementHelp":{"#cdata":"Syntax: (1) PACKAGE package [ / [SAS_ENCRYPT=YES|NO] [table-options]];  \n    ... package-body ...  \n \n  [ ENDPACKAGE ] ;  \n  \n(2) PACKAGE { HASH | HITER } / EXTENSION= 'HASH' | 'HITER';  \n    ... package-body ...  \n \n  [ ENDPACKAGE ] ;  \n\nCreates a DS2 package. \n\npackage \nspecifies the package name. package can be one of these forms. \n\n   catalog.schema.package  \n   schema.package  \n   catalog.package  \n   package \n\n  catalog \n  is an implementation of the ANSI SQL standard for an SQL catalog, which is a data container \n  object that groups logically related schemas. \n\n  schema \n  is an implementation of the ANSI SQL standard for an SQL schema, which is a data container \n  object that groups files such as tables and views and other objects supported by a data source \n  such as stored procedures. \n\n  package \n  is the name of the package.\n  Requirement: Package naming conventions are based on the data source."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"SAS_ENCRYPT=","StatementOptionHelp":{"#cdata":"Specifies the encryption algorithm. \n\nDefault: NO"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the SAS Proprietary algorithm.","@ToolTip2":"Specifies the Advanced Encryption Standard (AES) algorithm."}},{"StatementOptionName":"HASH","StatementOptionHelp":{"#cdata":"Specifies the name of the package as HASH to register the hash package \nfor use in a DS2 program."},"StatementOptionType":"RS"},{"StatementOptionName":"HITER","StatementOptionHelp":{"#cdata":"Specifies the name of the package as HITER to register the hash iterator package \nfor use in a DS2 program."},"StatementOptionType":"RS"},{"StatementOptionName":"EXTENSION=|EXT=","StatementOptionHelp":{"#cdata":"Specifies that the package is of type hash or hash iterator."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"'HASH'","@Value2":"'HITER'"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the package is of type hash.","@ToolTip2":"Specifies that the package is of type hash iterator."}},{"StatementOptionName":"ALTER=","StatementOptionHelp":{"#cdata":"Syntax: ALTER=alter-password \n    \nSyntax Description:\nalter-password \n  must be a valid SAS name.\n \nDetails: \nThe ALTER= option applies only to a SAS data set. You can use this option to assign \na password or to access a read-protected, write-protected, or alter-protected file. \nWhen you replace a data set that is protected with an ALTER password, the new data \nset inherits the ALTER password. \n\nThe password is blotted out when the code is written in the SAS log. For example: \n\n  set a(alter=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"V"},{"StatementOptionName":"BUFNO=","StatementOptionHelp":{"#cdata":"Specifies the number of buffers to be allocated for processing a SAS data set. \n    \nSyntax: BUFNO= n | nK | hexX | MIN | MAX  \n\nSyntax Description:\n\nn | nK \n  specifies the number of buffers in multiples of 1 (bytes); 1,024 (kilobytes). For example, \n  a value of 8 specifies 8 buffers, and a value of 1k specifies 1024 buffers.\n\nhex \n  specifies the number of buffers as a hexadecimal value. You must specify the value beginning \n  with a number (0-9), followed by an X. For example, the value 2dx sets the number of buffers \n  to 45 buffers.\n\nMIN \n  sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value \n  for the operating environment. This is the default.\n\nMAX \n  sets the number of buffers to the maximum possible number in your operating environment, \n  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"hexX","@Value4":"MIN","@Value5":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the number of buffers in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the number of buffers in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the number of buffers as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip4":"Sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value  for the operating environment. This is the default.","@ToolTip5":"Sets the number of buffers to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."}},{"StatementOptionName":"BUFSIZE=","StatementOptionHelp":{"#cdata":"Specifies the size of a permanent buffer page for an output SAS data set. \n    \nSyntax: BUFSIZE= n | nK | nM | nG | hexX | MAX  \n\nSyntax Description:\n\nn | nK | nM | nG \nspecifies the page size in multiples of 1 (bytes); 1,024 (kilobytes); 1,048,576 (megabytes); \nor 1,073,741,824 (gigabytes). For example, a value of 8 specifies a page size of 8 bytes, and \na value of 4k specifies a page size of 4096 bytes. \n\nhexX \nspecifies the page size as a hexadecimal value. You must specify the value beginning with a \nnumber (0-9), followed by an X. For example, the value 2dx sets the page size to 45 bytes.\n\nMAX \nsets the page size to the maximum possible number in your operating environment, up to the \nlargest four-byte, signed integer, which is 231-1, or approximately 2 billion bytes."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"nM","@Value4":"nG","@Value5":"hexX","@Value6":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the page size in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the page size in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the page size in multiples of 1,048,576 (megabytes).  Replace n with an integer value.","@ToolTip4":"Specifies the page size in multiples of 1,073,741,824 (gigabytes).  Replace n with an integer value.","@ToolTip5":"Specifies the page size as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip6":"Sets the page size to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion bytes."}},{"StatementOptionName":"BULKLOAD=","StatementOptionHelp":{"#cdata":"Loads rows of data as one unit. Default value: NO  \n    \nSyntax: BULKLOAD=YES | NO  \n\nSyntax Description:\n\nYES \ncalls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.\n\nNO \nuses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Calls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.","@ToolTip2":"Uses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."}},{"StatementOptionName":"COMPRESS=","StatementOptionHelp":{"#cdata":"Specifies how observations are compressed in a new output SAS data set. \n    \nSyntax: COMPRESS=NO | YES | CHAR | BINARY  \n\nSyntax Description:\nNO \nspecifies that the observations in a newly created SAS data set are uncompressed (fixed-length records).\n\nYES | CHAR \nspecifies that the observations in a newly created SAS data set are compressed (variable-length records) \nby SAS using RLE (Run Length Encoding). RLE compresses observations by reducing repeated consecutive \ncharacters (including blanks) to two-byte or three-byte representations. \n\n  Alias: ON \n  Tip: Use this compression algorithm for character data. \n  Note:   COMPRESS=CHAR is accepted by Version 7 and later versions.  \n\nBINARY \n  specifies that the observations in a newly created SAS data set are compressed (variable-length records) \n  by SAS using RDC (Ross Data Compression). RDC combines run-length encoding and sliding-window compression \n  to compress the file.\n\n  Tip: This method is highly effective for compressing medium to large (several hundred bytes or larger) \n  blocks of binary data (numeric variables). Because the compression function operates on a single record \n  at a time, the record length needs to be several hundred bytes or larger for effective compression."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NO","@Value2":"YES|ON","@Value3":"CHAR","@Value4":"BINARY"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the observations in a newly created SAS data set are uncompressed  (fixed-length records).","@ToolTip2":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.","@ToolTip3":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.   COMPRESS=CHAR is accepted by Version 7 and later versions.","@ToolTip4":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RDC (Ross Data Compression). RDC combines  run-length encoding and sliding-window compression to compress the file."}},{"StatementOptionName":"DBKEY=","StatementOptionHelp":{"#cdata":"Specifies a key column to optimize DBMS retrieval. Can improve performance when you \nare processing a join that involves a large DBMS table and a small SAS data set \nor DBMS table.\n    \nSyntax: DBKEY=([ ' ] column [ ' ] [... [ ' ] column [ ' ] ])  \n\nSyntax Description: \n\ncolumn \n  used by SAS to build an internal WHERE clause to search for matches in the DBMS table \n  based on the key column. For example:\n\n    select * from sas.a, dbms.b(dbkey=x) where a.x=b.x;\n    \nIn this example, DBKEY= specifies column x , which matches the key column designated in \nthe WHERE clause. However, if the DBKEY= column does NOT match the key column in the \nWHERE clause, then DBKEY= is not used."},"StatementOptionType":"V"},{"StatementOptionName":"DBNULL=","StatementOptionHelp":{"#cdata":"Indicates whether NULL is a valid value for the specified columns when a table is created. \n    \nSyntax: DBNULL={ _ALL=YES | NO } | ( [column=YES | NO [ ... column=YES | NO ] ] )  \n\nSyntax Description: \n_ALL_ \n  specifies that the YES or NO applies to all columns in the table. (This is valid in \n  the interfaces to Informix, Oracle, Sybase, and Teradata only.)\n\nYES \n  specifies that the NULL value is valid for the specified columns in the DBMS table.\n\nNO \n  specifies that the NULL value is not valid for the specified columns in the DBMS table.\n\ncolumn \n  specifies the name of a column. \n\nDetails: \nThis option is valid only for creating DBMS tables. If you specify more than one column name, \nthe names must be separated with spaces.\n\nThe DBNULL= option processes values from left to right, so if you specify a column name twice, \nor if you use the _ALL_ value, the last value overrides the first value that is specified for \nthe column."},"StatementOptionType":"V","SubOptionsKeywords":"_ALL_"},{"StatementOptionName":"DROP=","StatementOptionHelp":{"#cdata":"For an input table, excludes the specified columns from processing; for an output table, excludes the specified columns from being written to the table.\n    \nSyntax: DROP= ( column-list );  \n\nArguments: \ncolumn-list \n  specifies the names of the columns to omit from the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the format \n  col: are not supported. \n \nDetails: \nThe DROP= table option specifies that all columns in the column-list should not be included \nin the creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the drop attribute is specified, all columns not included in the drop \nstatement will be used to create columns in the output rows.\n\nIf the DROP= table option is associated with an input table, the columns are not available \nfor processing during program execution."},"StatementOptionType":"V"},{"StatementOptionName":"ENCRYPT=","StatementOptionHelp":{"#cdata":"Specifies whether to encrypt an output SAS data set. \n    \nSyntax: ENCRYPT=YES | NO  \n\nSyntax Description:\nYES \n  encrypts the file. The encryption method uses passwords. At a minimum, you must specify \n  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because \n  the encryption method uses passwords, you cannot change any password on an encrypted data \n  set without re-creating the data set.\n\nNO \n  does not encrypt the file.\n\nCAUTION:\nRecord all passwords. \nIf you forget the password, you cannot reset it without assistance from SAS. The process \nis time-consuming and resource-intensive."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Encrypts the file. The encryption method uses passwords. At a minimum, you must specify  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because  the encryption method uses passwords, you cannot change any password on an encrypted data  set without re-creating the data set.","@ToolTip2":"Does not encrypt the file."}},{"StatementOptionName":"KEEP=","StatementOptionHelp":{"#cdata":"For an input table, specifies the columns to process; for an output table, specifies \nthe columns to write to the table. \n    \nSyntax: KEEP=( column-list );  \n\nArguments:\n\ncolumn-list \n  specifies the names of the columns to keep in the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the \n  format col: are not supported. \n  \nDetails: \nThe KEEP= table option specifies that all columns in the column-list should be included in \nthe creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the keep attribute is specified, all columns not included in the KEEP \nstatement will be dropped from the output rows.\n\nIf the KEEP= table option is associated with an input table, only the columns that are \nspecified by the KEEP= table option are available for processing during program execution."},"StatementOptionType":"V"},{"StatementOptionName":"LABEL=","StatementOptionHelp":{"#cdata":"Specifies a label for a table.\n    \nSyntax: LABEL='label'  \n\nSyntax Description: \n\n'label' \n  specifies a text string of up to 256 characters. If the label text contains single \n  quotation marks, use double quotation marks around the label, or use two single \n  quotation marks in the label text and surround the string with single quotation \n  marks. To remove a label from a table, assign a label that is equal to a blank \n  that is enclosed in quotation marks.\n \nDetails: \nYou can use the LABEL= option on both input and output tables. When you use LABEL= \non input tables, it assigns a label for the table for the duration of the DS2 program. \nWhen it is specified for an output table, the label becomes a permanent part of that \ntable."},"StatementOptionType":"V"},{"StatementOptionName":"LOCKTABLE=","StatementOptionHelp":{"#cdata":"Places shared or exclusive locks on tables. \n    \nSyntax: LOCKTABLE=SHARE | EXCLUSIVE  \n\nSyntax Description:\n\nSHARE \n  locks a table in shared mode, allowing other users or processes to read data from the \n  tables, but preventing users from updating data.\n\nEXCLUSIVE \n  locks a table exclusively, preventing other users from accessing any table that you open. \n\nDetails: \nYou can lock tables only if you are the owner or have been granted the necessary privilege. \n\nIf you access the BASE table driver through PROC DS2, the default value for the LOCKTABLE \noption is EXCLUSIVE. However, if you access the BASE table driver through a table server, \nor if you run your program locally with the SAS Table Server LIBNAME engine, the default \nvalue for the LOCKTABLE option is SHARE."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"SHARE","@Value2":"EXCLUSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Locks a table in shared mode, allowing other users or processes to read data from  the tables, but preventing users from updating data.","@ToolTip2":"Locks a table exclusively, preventing other users from accessing any table that you open."}},{"StatementOptionName":"OVERWRITE=","StatementOptionHelp":{"#cdata":"For a table, drops the output table before the replacement output table is populated \nwith rows; for packages and threads, drops the existing package or thread if a package \nor thread by the same name exists. \n    \nSyntax: OVERWRITE= YES | NO;  \n\nArguments: \n\nYES | NO \n  specifies whether the output table is deleted before a replacement output table \n  is created or whether a package or thread is dropped.\n\n  Default: NO \n\nCAUTION:\nFor tables, use the OVERWRITE=YES statement only with data that is backed up or \nwith data that you can reconstruct. Because the output table is deleted first, \ndata will be lost if a failure occurs while the output table is being written."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the output table is deleted before a replacement output table    is created or a package or thread is dropped.","@ToolTip2":"Specifies that the output table is not deleted before a replacement output table    is created or a package or thread is dropped."}},{"StatementOptionName":"PW=","StatementOptionHelp":{"#cdata":"Assigns a READ, WRITE, and ALTER password to a SAS file, and enables access to a password-protected SAS file. \n    \nSyntax: PW=password  \n\nSyntax Description:\npassword \n  must be a valid SAS name.\n\nDetails:\nThe PW= option applies to all types of SAS files. You can use this option to assign \na password to a SAS file or to access a password-protected SAS file.\n\nWhen replacing a SAS data set that is protected by an ALTER password, the new data \nset inherits the ALTER password. When the code is written to the SAS log the password \nis blotted out, for example: \n\n  drop thread job2 (pw=xxxxxxx);\n\nNote:   A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"V"},{"StatementOptionName":"READ=","StatementOptionHelp":{"#cdata":"Assigns a READ password to a SAS file that prevents users from reading the file, \nunless they enter the password. \n    \nSyntax: READ=read-password  \n\nSyntax Description: \nread-password \n  must be a valid SAS name. \n \nDetails: \nThe READ= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a read-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  declare package sales (read=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You  \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"V"},{"StatementOptionName":"RENAME=","StatementOptionHelp":{"#cdata":"Changes the name of a column.\n    \nSyntax: RENAME= (old-name { = | AS } new-name [... old-name { = | AS } new-name ] ) ;  \n\nArguments: \nold-name \n  the column you want to rename.\n\nnew-name \n  the new name of the column. It must be a valid name for the data source.\n \nDetails: \nThe RENAME= table option allows you to change the names of one or more columns.\n\nIf you use RENAME= when you create a table, the new column name is included in the output \ntable. If you use RENAME= on an input table, the new name is used in DS2 programming statements.\n\nIf you use RENAME= in the same DS2 program with either the DROP= or the KEEP= table option, \nthe DROP= and the KEEP= table options are applied before RENAME=. You must use the old name in \nthe DROP= and KEEP= table options. You cannot drop and rename the same column in the same statement.\n\nIn addition to changing the name of a column, RENAME= also changes the label for the column."},"StatementOptionType":"V","SubOptionsKeywords":"AS"},{"StatementOptionName":"AS","StatementOptionHelp":{"#cdata":"Syntax: RENAME= (old-name AS new-name [... old-name AS new-name ] ) ;\n          \nSeparates the new-name from the old-name."},"StatementOptionType":"S"},{"StatementOptionName":"TYPE=","StatementOptionHelp":{"#cdata":"Specifies the data set type for a specially structured SAS data set. \n    \nSyntax: TYPE=data-set-type  \n\nSyntax Description: \ndata-set-type \n  specifies the special type of the data set.\n\nDetails: \nUse the TYPE= table option to create a special SAS data set in the proper format, \nor to identify the special type of the SAS data set in a procedure statement. \n\nYou can use the CONTENTS procedure to determine the type of a data set."},"StatementOptionType":"V"},{"StatementOptionName":"WRITE=","StatementOptionHelp":{"#cdata":"Assigns a WRITE password to a SAS file that prevents users from writing to a file, \nunless they enter the password. \n    \nSyntax: WRITE=write-password  \n\nSyntax Description: \nwrite-password \n  must be a valid SAS name. \n \nDetails: \nThe WRITE= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a write-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  drop thread job2a (write=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"V"}],"#comment":{}}},{"StatementName":"PUT","StatementHelp":{"#cdata":"Syntax: PUT < put-list > [ ... <put-list> ] ; \n  <put-list>::=  'character-string' | <eq-expression> [ = ] [ [ : ] format [-L | -C | -R ] ]   \n  <eq-expression>::=  identifier | array-reference | this-expression \n      \nPrints values of program variables and constants to the log. \n\nArguments:\n'character-string' \nspecifies a string of text, enclosed in quotation marks, that is written to the SAS log.\n\nidentifier \nnames a variable whose value is written to the SAS log.\n\narray-reference \nspecifies an array element. The subscript can be any SAS expression that resolves to an \ninteger value when the PUT statement executes. Use the array subscript asterisk (*) to \nwrite all elements of the array.\n\nthis-expression \nspecifies a THIS expression.\n\n= \nIf an equal sign is added after a variable or array element, then the output is preceded \nby the variable or array element name and an equal sign.\n\n: \nenables you to specify a format that the PUT statement uses to write the variable value. \nAll leading and trailing blanks are deleted, and each value is followed by a single blank.\nRestriction: You must specify a format. \n\nformat \nspecifies a format to use when the data value is written to the SAS log. If you use a colon \nmodifier (:) with the format name, all leading and trailing blanks are deleted and each value \nis followed by a single blank. To override the default alignment, you can add an alignment \nspecification to a format:\n  -L left aligns the value.  \n  -C centers the value.  \n  -R right aligns the value.\n \nTip: Ensure that the format width provides enough space to write the value and any commas, \ndollar signs, decimal points, or other special characters that the format includes."},"StatementOptions":null},{"StatementName":"RENAME","StatementHelp":{"#cdata":"Syntax: RENAME old-name = new-name [ ... old-name = new-name ];  \nRENAME old-name AS new-name [ ... old-name AS new-name ];  \n\nSpecifies new names for columns in output tables."},"StatementOptions":{"StatementOption":{"StatementOptionName":"AS","StatementOptionHelp":{"#cdata":"RENAME old-name AS new-name [ ... old-name AS new-name ];\n          \nSeparates the new-name from the old-name."},"StatementOptionType":"S"}}},{"StatementName":"RETAIN","StatementHelp":{"#cdata":"Syntax: (1) RETAIN;  \n (2) RETAIN column-list;  \n (3)RETAIN column-list < constant-value >;  \n (4) RETAIN column-list ( < constant-value > ... < constant-value > );  \n\nSpecifies that all columns in the column list should have their values retained during \neach execution of the RUN method. \n\nIf you do not specify any arguments, the RETAIN statement causes the values of all \ncolumns to be retained from one iteration of the DS2 program to the next."},"StatementOptions":null},{"StatementName":"RETURN","StatementHelp":{"#cdata":"Syntax: RETURN [ expression ]; \n      \nReturns execution from a method to the method caller. \n\nexpression \nspecifies any valid expression that returns a single value. The expression's type \nis evaluated, and if necessary, converted to the type specified in the METHOD statement's \nRETURNS clause. The value of expression is then passed back to the caller of the method."},"StatementOptions":null},{"StatementName":"SELECT","StatementHelp":{"#cdata":"Syntax: SELECT [ ( select-expression ) ];  \n    [ < when-list > [ ...< when-list> ] ] ;  \n    [ OTHERWISE statement-list ] ;  \n \n  END [ end-label ];  \n\nExecutes one of several statements or groups of statements. \n\nArguments:\n\n  select-expression \n  specifies an expression that evaluates to a single value of any type other than VARBINARY.\n\n  end-label \n  The END statement closes the SELECT statement. The optional end-label argument specifies \n  an identifier. This label, created by using the Labels statement, must match the label \n  immediately preceding the SELECT statement, or an error will occur.\n\n  when-expression \n  specifies any expression, including a compound expression.\n\n    Requirement: You must specify at least one when-expression. \n\n  statement-list \n  can be any executable statement or statements."},"StatementOptions":null},{"StatementName":"OTHERWISE","StatementHelp":{"#cdata":"Syntax: [OTHERWISE statement-list]; \n      \nAn optional OTHERWISE statement specifies a statement to be executed if no WHEN condition is met."},"StatementOptions":null},{"StatementName":"WHEN","StatementHelp":{"#cdata":"Syntax: WHEN ( when-expression ) [ statement-list ]  \n\nSELECT groups contain WHEN statements that identify DS2 statements that are executed \nwhen a particular condition is true. Use at least one WHEN statement in a SELECT group."},"StatementOptions":null},{"StatementName":"STOP","StatementHelp":{"#cdata":"Syntax: STOP; \n      \nStops execution of the current DS2 program. \n\nThe STOP statement causes processing of the current DS2 program to stop immediately \nand resume processing statements after the end of the current DS2 program."},"StatementOptions":null},{"StatementName":"DATA|TABLE","StatementHelp":{"#cdata":"Syntax: DATA | TABLE [ <table-expression> ] [... <table-expression> ] ;  \n    ... program-body ...  \n \n  [ ENDDATA; | ENDTABLE ; ]  \n\nBegins a DS2 program and provides names for any output tables. \n\n<table-expression>::=table (table-options)\n  | _ROWSET_ (table-options)\n  | _NULL_\n  \nWithout Arguments:\nIf you do not specify any table names with the DATA statement, then the DS2 program \nreturns table rows to the client application and no tables are created.\n\nArguments:\ntable \nspecifies the name of the table. table can be one of these forms. \n\n   catalog.schema.table-name  \n   schema.table-name  \n   catalog.table-name  \n   table-name \n   \nwhere:\n  catalog \n  is an implementation of the ANSI SQL standard for an SQL catalog, which is a data \n  container object that groups logically related schemas. \n\n  schema \n  is an implementation of the ANSI SQL standard for an SQL schema, which is a data \n  container object that groups files such as tables and views and other objects supported \n  by a data source such as stored procedures. \n\n  table-name \n  is the name of the table.\n\n  Requirements: Table naming conventions are based on the data source.\n\n_ROWSET_\nspecifies that the DATA statement should not create a table, but it should instead return \ntable rows to the client application.\n\n_NULL_\nspecifies that the DATA statement should not create a table or return rows to the client \napplication.\n\ntable-options\nspecifies optional arguments that the DS2 program applies when it writes rows to the output table."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"_ROWSET_","StatementOptionHelp":{"#cdata":"Specifies that the TABLE statement should not create a table, but it should instead \nreturn table rows to the client application."},"StatementOptionType":"S"},{"StatementOptionName":"_NULL_","StatementOptionHelp":{"#cdata":"Specifies that the TABLE statement should not create a table or return rows to the client application."},"StatementOptionType":"S"},{"StatementOptionName":"ALTER=","StatementOptionHelp":{"#cdata":"Syntax: ALTER=alter-password \n    \nSyntax Description:\nalter-password \n  must be a valid SAS name.\n \nDetails: \nThe ALTER= option applies only to a SAS data set. You can use this option to assign \na password or to access a read-protected, write-protected, or alter-protected file. \nWhen you replace a data set that is protected with an ALTER password, the new data \nset inherits the ALTER password. \n\nThe password is blotted out when the code is written in the SAS log. For example: \n\n  set a(alter=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"},{"StatementOptionName":"BUFNO=","StatementOptionHelp":{"#cdata":"Specifies the number of buffers to be allocated for processing a SAS data set. \n    \nSyntax: BUFNO= n | nK | hexX | MIN | MAX  \n\nSyntax Description:\n\nn | nK \n  specifies the number of buffers in multiples of 1 (bytes); 1,024 (kilobytes). For example, \n  a value of 8 specifies 8 buffers, and a value of 1k specifies 1024 buffers.\n\nhex \n  specifies the number of buffers as a hexadecimal value. You must specify the value beginning \n  with a number (0-9), followed by an X. For example, the value 2dx sets the number of buffers \n  to 45 buffers.\n\nMIN \n  sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value \n  for the operating environment. This is the default.\n\nMAX \n  sets the number of buffers to the maximum possible number in your operating environment, \n  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"hexX","@Value4":"MIN","@Value5":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the number of buffers in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the number of buffers in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the number of buffers as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip4":"Sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value  for the operating environment. This is the default.","@ToolTip5":"Sets the number of buffers to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."}},{"StatementOptionName":"BUFSIZE=","StatementOptionHelp":{"#cdata":"Specifies the size of a permanent buffer page for an output SAS data set. \n    \nSyntax: BUFSIZE= n | nK | nM | nG | hexX | MAX  \n\nSyntax Description:\n\nn | nK | nM | nG \nspecifies the page size in multiples of 1 (bytes); 1,024 (kilobytes); 1,048,576 (megabytes); \nor 1,073,741,824 (gigabytes). For example, a value of 8 specifies a page size of 8 bytes, and \na value of 4k specifies a page size of 4096 bytes. \n\nhexX \nspecifies the page size as a hexadecimal value. You must specify the value beginning with a \nnumber (0-9), followed by an X. For example, the value 2dx sets the page size to 45 bytes.\n\nMAX \nsets the page size to the maximum possible number in your operating environment, up to the \nlargest four-byte, signed integer, which is 231-1, or approximately 2 billion bytes."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"nM","@Value4":"nG","@Value5":"hexX","@Value6":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the page size in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the page size in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the page size in multiples of 1,048,576 (megabytes).  Replace n with an integer value.","@ToolTip4":"Specifies the page size in multiples of 1,073,741,824 (gigabytes).  Replace n with an integer value.","@ToolTip5":"Specifies the page size as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip6":"Sets the page size to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion bytes."}},{"StatementOptionName":"BULKLOAD=","StatementOptionHelp":{"#cdata":"Loads rows of data as one unit. Default value: NO  \n    \nSyntax: BULKLOAD=YES | NO  \n\nSyntax Description:\n\nYES \ncalls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.\n\nNO \nuses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Calls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.","@ToolTip2":"Uses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."}},{"StatementOptionName":"COMPRESS=","StatementOptionHelp":{"#cdata":"Specifies how observations are compressed in a new output SAS data set. \n    \nSyntax: COMPRESS=NO | YES | CHAR | BINARY  \n\nSyntax Description:\nNO \nspecifies that the observations in a newly created SAS data set are uncompressed (fixed-length records).\n\nYES | CHAR \nspecifies that the observations in a newly created SAS data set are compressed (variable-length records) \nby SAS using RLE (Run Length Encoding). RLE compresses observations by reducing repeated consecutive \ncharacters (including blanks) to two-byte or three-byte representations. \n\n  Alias: ON \n  Tip: Use this compression algorithm for character data. \n  Note:   COMPRESS=CHAR is accepted by Version 7 and later versions.  \n\nBINARY \n  specifies that the observations in a newly created SAS data set are compressed (variable-length records) \n  by SAS using RDC (Ross Data Compression). RDC combines run-length encoding and sliding-window compression \n  to compress the file.\n\n  Tip: This method is highly effective for compressing medium to large (several hundred bytes or larger) \n  blocks of binary data (numeric variables). Because the compression function operates on a single record \n  at a time, the record length needs to be several hundred bytes or larger for effective compression."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"NO","@Value2":"YES|ON","@Value3":"CHAR","@Value4":"BINARY"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the observations in a newly created SAS data set are uncompressed  (fixed-length records).","@ToolTip2":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.","@ToolTip3":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.   COMPRESS=CHAR is accepted by Version 7 and later versions.","@ToolTip4":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RDC (Ross Data Compression). RDC combines  run-length encoding and sliding-window compression to compress the file."}},{"StatementOptionName":"DBKEY=","StatementOptionHelp":{"#cdata":"Specifies a key column to optimize DBMS retrieval. Can improve performance when you \nare processing a join that involves a large DBMS table and a small SAS data set \nor DBMS table.\n    \nSyntax: DBKEY=([ ' ] column [ ' ] [... [ ' ] column [ ' ] ])  \n\nSyntax Description: \n\ncolumn \n  used by SAS to build an internal WHERE clause to search for matches in the DBMS table \n  based on the key column. For example:\n\n    select * from sas.a, dbms.b(dbkey=x) where a.x=b.x;\n    \nIn this example, DBKEY= specifies column x , which matches the key column designated in \nthe WHERE clause. However, if the DBKEY= column does NOT match the key column in the \nWHERE clause, then DBKEY= is not used."},"StatementOptionType":"TV"},{"StatementOptionName":"DBCREATE_TABLE_OPTS=","StatementOptionHelp":{"#cdata":"Syntax: DBCREATE_TABLE_OPTS= 'DBMS-option(s)' \n\nSpecifies DBMS-specific options to be added to the DATA statement.\n\nArguments:\nDBMS-option(s)\n  specifies one or more valid DBMS-specific options. If more than one option is specified, \n  the options should be separated in the same way as options are separated in the DBMS."},"StatementOptionType":"TV"},{"StatementOptionName":"DBNULL=","StatementOptionHelp":{"#cdata":"Indicates whether NULL is a valid value for the specified columns when a table is created. \n    \nSyntax: DBNULL={ _ALL=YES | NO } | ( [column=YES | NO [ ... column=YES | NO ] ] )  \n\nSyntax Description: \n_ALL_ \n  specifies that the YES or NO applies to all columns in the table. (This is valid in \n  the interfaces to Informix, Oracle, Sybase, and Teradata only.)\n\nYES \n  specifies that the NULL value is valid for the specified columns in the DBMS table.\n\nNO \n  specifies that the NULL value is not valid for the specified columns in the DBMS table.\n\ncolumn \n  specifies the name of a column. \n\nDetails: \nThis option is valid only for creating DBMS tables. If you specify more than one column name, \nthe names must be separated with spaces.\n\nThe DBNULL= option processes values from left to right, so if you specify a column name twice, \nor if you use the _ALL_ value, the last value overrides the first value that is specified for \nthe column."},"StatementOptionType":"TV","SubOptionsKeywords":"_ALL_"},{"StatementOptionName":"DROP=","StatementOptionHelp":{"#cdata":"For an input table, excludes the specified columns from processing; for an output table, excludes the specified columns from being written to the table.\n    \nSyntax: DROP= ( column-list );  \n\nArguments: \ncolumn-list \n  specifies the names of the columns to omit from the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the format \n  col: are not supported. \n \nDetails: \nThe DROP= table option specifies that all columns in the column-list should not be included \nin the creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the drop attribute is specified, all columns not included in the drop \nstatement will be used to create columns in the output rows.\n\nIf the DROP= table option is associated with an input table, the columns are not available \nfor processing during program execution."},"StatementOptionType":"TV"},{"StatementOptionName":"ENCRYPT=","StatementOptionHelp":{"#cdata":"Specifies whether to encrypt an output SAS data set. \n    \nSyntax: ENCRYPT=YES | NO  \n\nSyntax Description:\nYES \n  encrypts the file. The encryption method uses passwords. At a minimum, you must specify \n  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because \n  the encryption method uses passwords, you cannot change any password on an encrypted data \n  set without re-creating the data set.\n\nNO \n  does not encrypt the file.\n\nCAUTION:\nRecord all passwords. \nIf you forget the password, you cannot reset it without assistance from SAS. The process \nis time-consuming and resource-intensive."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Encrypts the file. The encryption method uses passwords. At a minimum, you must specify  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because  the encryption method uses passwords, you cannot change any password on an encrypted data  set without re-creating the data set.","@ToolTip2":"Does not encrypt the file."}},{"StatementOptionName":"ENCRYPTKEY=","StatementOptionHelp":{"#cdata":"Syntax: ENCRYPTKEY=[\" | ']key-value[\" | '] \n\nSpecifies a key value for AES encryption.\n\nArguments:\nkey-value\n  assigns an encrypt key value. The key value can be up to 64-bytes long. You are able to create \n  an ENCRYPTKEY= key value with or without quotation marks using the following rules:\n  \n  no quotation marks\n    \u2022alphanumeric characters and underscores only\n    \u2022up to 64-bytes\n    \u2022uppercase and lowercase letters\n    \u2022must start with a letter\n    \u2022no blank spaces\n    \u2022is not case-sensitive\n\n  single quotation marks\n    \u2022alphanumeric, special, and DBCS characters\n    \u2022up to 64-bytes\n    \u2022uppercase and lowercase letters\n    \u2022blank spaces, but not all blanks\n    \u2022is case-sensitive\n    \n  double quotation marks\n    \u2022alphanumeric, special, and DBCS characters\n    \u2022up to 64 bytes\n    \u2022uppercase and lowercase letters\n    \u2022enables macro resolution\n    \u2022blank spaces, but not all blanks\n    \u2022is case-sensitive"},"StatementOptionType":"TV"},{"StatementOptionName":"IN=","StatementOptionHelp":{"#cdata":"Syntax: IN=variable \n    \nArguments:\nvariable\n  names the new variable whose value indicates whether that input table contributed data to the \n  current row. Within a DS2 program, the value of the variable is 1 if the table contributed to \n  the current row, and 0 otherwise.\n\nInteraction:\n  If the variable is not explicitly declared, it is automatically declared in the local scope \n  of the SET or DATA statement as INTEGER.\nData type: BIGINT, INTEGER, SMALLINT, TINYINT"},"StatementOptionType":"TV"},{"StatementOptionName":"KEEP=","StatementOptionHelp":{"#cdata":"For an input table, specifies the columns to process; for an output table, specifies \nthe columns to write to the table. \n    \nSyntax: KEEP=( column-list );  \n\nArguments:\n\ncolumn-list \n  specifies the names of the columns to keep in the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the \n  format col: are not supported. \n  \nDetails: \nThe KEEP= table option specifies that all columns in the column-list should be included in \nthe creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the keep attribute is specified, all columns not included in the KEEP \nstatement will be dropped from the output rows.\n\nIf the KEEP= table option is associated with an input table, only the columns that are \nspecified by the KEEP= table option are available for processing during program execution."},"StatementOptionType":"TV"},{"StatementOptionName":"LABEL=","StatementOptionHelp":{"#cdata":"Specifies a label for a table.\n    \nSyntax: LABEL='label'  \n\nSyntax Description: \n\n'label' \n  specifies a text string of up to 256 characters. If the label text contains single \n  quotation marks, use double quotation marks around the label, or use two single \n  quotation marks in the label text and surround the string with single quotation \n  marks. To remove a label from a table, assign a label that is equal to a blank \n  that is enclosed in quotation marks.\n \nDetails: \nYou can use the LABEL= option on both input and output tables. When you use LABEL= \non input tables, it assigns a label for the table for the duration of the DS2 program. \nWhen it is specified for an output table, the label becomes a permanent part of that \ntable."},"StatementOptionType":"TV"},{"StatementOptionName":"LOCKTABLE=","StatementOptionHelp":{"#cdata":"Places shared or exclusive locks on tables. \n    \nSyntax: LOCKTABLE=SHARE | EXCLUSIVE  \n\nSyntax Description:\n\nSHARE \n  locks a table in shared mode, allowing other users or processes to read data from the \n  tables, but preventing users from updating data.\n\nEXCLUSIVE \n  locks a table exclusively, preventing other users from accessing any table that you open. \n\nDetails: \nYou can lock tables only if you are the owner or have been granted the necessary privilege. \n\nIf you access the BASE table driver through PROC DS2, the default value for the LOCKTABLE \noption is EXCLUSIVE. However, if you access the BASE table driver through a table server, \nor if you run your program locally with the SAS Table Server LIBNAME engine, the default \nvalue for the LOCKTABLE option is SHARE."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"SHARE","@Value2":"EXCLUSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Locks a table in shared mode, allowing other users or processes to read data from  the tables, but preventing users from updating data.","@ToolTip2":"Locks a table exclusively, preventing other users from accessing any table that you open."}},{"StatementOptionName":"OVERWRITE=","StatementOptionHelp":{"#cdata":"For a table, drops the output table before the replacement output table is populated \nwith rows; for packages and threads, drops the existing package or thread if a package \nor thread by the same name exists. \n    \nSyntax: OVERWRITE= YES | NO;  \n\nArguments: \n\nYES | NO \n  specifies whether the output table is deleted before a replacement output table \n  is created or whether a package or thread is dropped.\n\n  Default: NO \n\nCAUTION:\nFor tables, use the OVERWRITE=YES statement only with data that is backed up or \nwith data that you can reconstruct. Because the output table is deleted first, \ndata will be lost if a failure occurs while the output table is being written."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the output table is deleted before a replacement output table    is created or a package or thread is dropped.","@ToolTip2":"Specifies that the output table is not deleted before a replacement output table    is created or a package or thread is dropped."}},{"StatementOptionName":"PW=","StatementOptionHelp":{"#cdata":"Assigns a READ, WRITE, and ALTER password to a SAS file, and enables access to a password-protected SAS file. \n    \nSyntax: PW=password  \n\nSyntax Description:\npassword \n  must be a valid SAS name.\n\nDetails:\nThe PW= option applies to all types of SAS files. You can use this option to assign \na password to a SAS file or to access a password-protected SAS file.\n\nWhen replacing a SAS data set that is protected by an ALTER password, the new data \nset inherits the ALTER password. When the code is written to the SAS log the password \nis blotted out, for example: \n\n  drop thread job2 (pw=xxxxxxx);\n\nNote:   A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"},{"StatementOptionName":"READ=","StatementOptionHelp":{"#cdata":"Assigns a READ password to a SAS file that prevents users from reading the file, \nunless they enter the password. \n    \nSyntax: READ=read-password  \n\nSyntax Description: \nread-password \n  must be a valid SAS name. \n \nDetails: \nThe READ= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a read-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  declare package sales (read=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You  \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"},{"StatementOptionName":"RENAME=","StatementOptionHelp":{"#cdata":"Changes the name of a column.\n    \nSyntax: RENAME= (old-name { = | AS } new-name [... old-name { = | AS } new-name ] ) ;  \n\nArguments: \nold-name \n  the column you want to rename.\n\nnew-name \n  the new name of the column. It must be a valid name for the data source.\n \nDetails: \nThe RENAME= table option allows you to change the names of one or more columns.\n\nIf you use RENAME= when you create a table, the new column name is included in the output \ntable. If you use RENAME= on an input table, the new name is used in DS2 programming statements.\n\nIf you use RENAME= in the same DS2 program with either the DROP= or the KEEP= table option, \nthe DROP= and the KEEP= table options are applied before RENAME=. You must use the old name in \nthe DROP= and KEEP= table options. You cannot drop and rename the same column in the same statement.\n\nIn addition to changing the name of a column, RENAME= also changes the label for the column."},"StatementOptionType":"TV","SubOptionsKeywords":"AS"},{"StatementOptionName":"AS","StatementOptionHelp":{"#cdata":"Syntax: RENAME= (old-name AS new-name [... old-name AS new-name ] ) ;\n          \nSeparates the new-name from the old-name."},"StatementOptionType":"S"},{"StatementOptionName":"TYPE=","StatementOptionHelp":{"#cdata":"Specifies the data set type for a specially structured SAS data set. \n    \nSyntax: TYPE=data-set-type  \n\nSyntax Description: \ndata-set-type \n  specifies the special type of the data set.\n\nDetails: \nUse the TYPE= table option to create a special SAS data set in the proper format, \nor to identify the special type of the SAS data set in a procedure statement. \n\nYou can use the CONTENTS procedure to determine the type of a data set."},"StatementOptionType":"TV"},{"StatementOptionName":"WRITE=","StatementOptionHelp":{"#cdata":"Assigns a WRITE password to a SAS file that prevents users from writing to a file, \nunless they enter the password. \n    \nSyntax: WRITE=write-password  \n\nSyntax Description: \nwrite-password \n  must be a valid SAS name. \n \nDetails: \nThe WRITE= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a write-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  drop thread job2a (write=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"}],"#comment":{}}},{"StatementName":"THREAD","StatementHelp":{"#cdata":"Syntax: THREAD thread [ ( data-type variable [ , ... data-type variable ] ) ] [ / [SAS_ENCRYPT=YES|NO] [table-options]];  \n    ... thread-body ...  \n \n  [ ENDTHREAD ; ]  \n\nCreates a DS2 program thread. \n\nthread \nspecifies the thread name. thread can be one of these forms. \n\n   catalog.schema.thread  \n   schema.thread  \n   catalog.thread  \n   thread \n\n  catalog \n  is an implementation of the ANSI SQL standard for an SQL catalog, which is a data container \n  object that groups logically related schemas. \n\n  schema \n  is an implementation of the ANSI SQL standard for an SQL schema, which is a data container \n  object that groups files such as tables and views and other objects supported by a data source \n  such as stored procedures. \n\n  thread \n  is the name of the thread.\n  Requirement: Thread naming conventions are based on the data source."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"SAS_ENCRYPT=","StatementOptionHelp":{"#cdata":"Specifies the encryption algorithm. \n\nDefault: NO"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the SAS Proprietary algorithm.","@ToolTip2":"Specifies the Advanced Encryption Standard (AES) algorithm."}},{"StatementOptionName":"ALTER=","StatementOptionHelp":{"#cdata":"Syntax: ALTER=alter-password \n    \nSyntax Description:\nalter-password \n  must be a valid SAS name.\n \nDetails: \nThe ALTER= option applies only to a SAS data set. You can use this option to assign \na password or to access a read-protected, write-protected, or alter-protected file. \nWhen you replace a data set that is protected with an ALTER password, the new data \nset inherits the ALTER password. \n\nThe password is blotted out when the code is written in the SAS log. For example: \n\n  set a(alter=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"V"},{"StatementOptionName":"BUFNO=","StatementOptionHelp":{"#cdata":"Specifies the number of buffers to be allocated for processing a SAS data set. \n    \nSyntax: BUFNO= n | nK | hexX | MIN | MAX  \n\nSyntax Description:\n\nn | nK \n  specifies the number of buffers in multiples of 1 (bytes); 1,024 (kilobytes). For example, \n  a value of 8 specifies 8 buffers, and a value of 1k specifies 1024 buffers.\n\nhex \n  specifies the number of buffers as a hexadecimal value. You must specify the value beginning \n  with a number (0-9), followed by an X. For example, the value 2dx sets the number of buffers \n  to 45 buffers.\n\nMIN \n  sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value \n  for the operating environment. This is the default.\n\nMAX \n  sets the number of buffers to the maximum possible number in your operating environment, \n  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"hexX","@Value4":"MIN","@Value5":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the number of buffers in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the number of buffers in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the number of buffers as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip4":"Sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value  for the operating environment. This is the default.","@ToolTip5":"Sets the number of buffers to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."}},{"StatementOptionName":"BUFSIZE=","StatementOptionHelp":{"#cdata":"Specifies the size of a permanent buffer page for an output SAS data set. \n    \nSyntax: BUFSIZE= n | nK | nM | nG | hexX | MAX  \n\nSyntax Description:\n\nn | nK | nM | nG \nspecifies the page size in multiples of 1 (bytes); 1,024 (kilobytes); 1,048,576 (megabytes); \nor 1,073,741,824 (gigabytes). For example, a value of 8 specifies a page size of 8 bytes, and \na value of 4k specifies a page size of 4096 bytes. \n\nhexX \nspecifies the page size as a hexadecimal value. You must specify the value beginning with a \nnumber (0-9), followed by an X. For example, the value 2dx sets the page size to 45 bytes.\n\nMAX \nsets the page size to the maximum possible number in your operating environment, up to the \nlargest four-byte, signed integer, which is 231-1, or approximately 2 billion bytes."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"nM","@Value4":"nG","@Value5":"hexX","@Value6":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the page size in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the page size in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the page size in multiples of 1,048,576 (megabytes).  Replace n with an integer value.","@ToolTip4":"Specifies the page size in multiples of 1,073,741,824 (gigabytes).  Replace n with an integer value.","@ToolTip5":"Specifies the page size as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip6":"Sets the page size to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion bytes."}},{"StatementOptionName":"BULKLOAD=","StatementOptionHelp":{"#cdata":"Loads rows of data as one unit. Default value: NO  \n    \nSyntax: BULKLOAD=YES | NO  \n\nSyntax Description:\n\nYES \ncalls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.\n\nNO \nuses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Calls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.","@ToolTip2":"Uses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."}},{"StatementOptionName":"COMPRESS=","StatementOptionHelp":{"#cdata":"Specifies how observations are compressed in a new output SAS data set. \n    \nSyntax: COMPRESS=NO | YES | CHAR | BINARY  \n\nSyntax Description:\nNO \nspecifies that the observations in a newly created SAS data set are uncompressed (fixed-length records).\n\nYES | CHAR \nspecifies that the observations in a newly created SAS data set are compressed (variable-length records) \nby SAS using RLE (Run Length Encoding). RLE compresses observations by reducing repeated consecutive \ncharacters (including blanks) to two-byte or three-byte representations. \n\n  Alias: ON \n  Tip: Use this compression algorithm for character data. \n  Note:   COMPRESS=CHAR is accepted by Version 7 and later versions.  \n\nBINARY \n  specifies that the observations in a newly created SAS data set are compressed (variable-length records) \n  by SAS using RDC (Ross Data Compression). RDC combines run-length encoding and sliding-window compression \n  to compress the file.\n\n  Tip: This method is highly effective for compressing medium to large (several hundred bytes or larger) \n  blocks of binary data (numeric variables). Because the compression function operates on a single record \n  at a time, the record length needs to be several hundred bytes or larger for effective compression."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NO","@Value2":"YES|ON","@Value3":"CHAR","@Value4":"BINARY"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the observations in a newly created SAS data set are uncompressed  (fixed-length records).","@ToolTip2":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.","@ToolTip3":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.   COMPRESS=CHAR is accepted by Version 7 and later versions.","@ToolTip4":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RDC (Ross Data Compression). RDC combines  run-length encoding and sliding-window compression to compress the file."}},{"StatementOptionName":"DBKEY=","StatementOptionHelp":{"#cdata":"Specifies a key column to optimize DBMS retrieval. Can improve performance when you \nare processing a join that involves a large DBMS table and a small SAS data set \nor DBMS table.\n    \nSyntax: DBKEY=([ ' ] column [ ' ] [... [ ' ] column [ ' ] ])  \n\nSyntax Description: \n\ncolumn \n  used by SAS to build an internal WHERE clause to search for matches in the DBMS table \n  based on the key column. For example:\n\n    select * from sas.a, dbms.b(dbkey=x) where a.x=b.x;\n    \nIn this example, DBKEY= specifies column x , which matches the key column designated in \nthe WHERE clause. However, if the DBKEY= column does NOT match the key column in the \nWHERE clause, then DBKEY= is not used."},"StatementOptionType":"V"},{"StatementOptionName":"DBNULL=","StatementOptionHelp":{"#cdata":"Indicates whether NULL is a valid value for the specified columns when a table is created. \n    \nSyntax: DBNULL={ _ALL=YES | NO } | ( [column=YES | NO [ ... column=YES | NO ] ] )  \n\nSyntax Description: \n_ALL_ \n  specifies that the YES or NO applies to all columns in the table. (This is valid in \n  the interfaces to Informix, Oracle, Sybase, and Teradata only.)\n\nYES \n  specifies that the NULL value is valid for the specified columns in the DBMS table.\n\nNO \n  specifies that the NULL value is not valid for the specified columns in the DBMS table.\n\ncolumn \n  specifies the name of a column. \n\nDetails: \nThis option is valid only for creating DBMS tables. If you specify more than one column name, \nthe names must be separated with spaces.\n\nThe DBNULL= option processes values from left to right, so if you specify a column name twice, \nor if you use the _ALL_ value, the last value overrides the first value that is specified for \nthe column."},"StatementOptionType":"V","SubOptionsKeywords":"_ALL_"},{"StatementOptionName":"DROP=","StatementOptionHelp":{"#cdata":"For an input table, excludes the specified columns from processing; for an output table, excludes the specified columns from being written to the table.\n    \nSyntax: DROP= ( column-list );  \n\nArguments: \ncolumn-list \n  specifies the names of the columns to omit from the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the format \n  col: are not supported. \n \nDetails: \nThe DROP= table option specifies that all columns in the column-list should not be included \nin the creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the drop attribute is specified, all columns not included in the drop \nstatement will be used to create columns in the output rows.\n\nIf the DROP= table option is associated with an input table, the columns are not available \nfor processing during program execution."},"StatementOptionType":"V"},{"StatementOptionName":"ENCRYPT=","StatementOptionHelp":{"#cdata":"Specifies whether to encrypt an output SAS data set. \n    \nSyntax: ENCRYPT=YES | NO  \n\nSyntax Description:\nYES \n  encrypts the file. The encryption method uses passwords. At a minimum, you must specify \n  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because \n  the encryption method uses passwords, you cannot change any password on an encrypted data \n  set without re-creating the data set.\n\nNO \n  does not encrypt the file.\n\nCAUTION:\nRecord all passwords. \nIf you forget the password, you cannot reset it without assistance from SAS. The process \nis time-consuming and resource-intensive."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Encrypts the file. The encryption method uses passwords. At a minimum, you must specify  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because  the encryption method uses passwords, you cannot change any password on an encrypted data  set without re-creating the data set.","@ToolTip2":"Does not encrypt the file."}},{"StatementOptionName":"KEEP=","StatementOptionHelp":{"#cdata":"For an input table, specifies the columns to process; for an output table, specifies \nthe columns to write to the table. \n    \nSyntax: KEEP=( column-list );  \n\nArguments:\n\ncolumn-list \n  specifies the names of the columns to keep in the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the \n  format col: are not supported. \n  \nDetails: \nThe KEEP= table option specifies that all columns in the column-list should be included in \nthe creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the keep attribute is specified, all columns not included in the KEEP \nstatement will be dropped from the output rows.\n\nIf the KEEP= table option is associated with an input table, only the columns that are \nspecified by the KEEP= table option are available for processing during program execution."},"StatementOptionType":"V"},{"StatementOptionName":"LABEL=","StatementOptionHelp":{"#cdata":"Specifies a label for a table.\n    \nSyntax: LABEL='label'  \n\nSyntax Description: \n\n'label' \n  specifies a text string of up to 256 characters. If the label text contains single \n  quotation marks, use double quotation marks around the label, or use two single \n  quotation marks in the label text and surround the string with single quotation \n  marks. To remove a label from a table, assign a label that is equal to a blank \n  that is enclosed in quotation marks.\n \nDetails: \nYou can use the LABEL= option on both input and output tables. When you use LABEL= \non input tables, it assigns a label for the table for the duration of the DS2 program. \nWhen it is specified for an output table, the label becomes a permanent part of that \ntable."},"StatementOptionType":"V"},{"StatementOptionName":"LOCKTABLE=","StatementOptionHelp":{"#cdata":"Places shared or exclusive locks on tables. \n    \nSyntax: LOCKTABLE=SHARE | EXCLUSIVE  \n\nSyntax Description:\n\nSHARE \n  locks a table in shared mode, allowing other users or processes to read data from the \n  tables, but preventing users from updating data.\n\nEXCLUSIVE \n  locks a table exclusively, preventing other users from accessing any table that you open. \n\nDetails: \nYou can lock tables only if you are the owner or have been granted the necessary privilege. \n\nIf you access the BASE table driver through PROC DS2, the default value for the LOCKTABLE \noption is EXCLUSIVE. However, if you access the BASE table driver through a table server, \nor if you run your program locally with the SAS Table Server LIBNAME engine, the default \nvalue for the LOCKTABLE option is SHARE."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"SHARE","@Value2":"EXCLUSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Locks a table in shared mode, allowing other users or processes to read data from  the tables, but preventing users from updating data.","@ToolTip2":"Locks a table exclusively, preventing other users from accessing any table that you open."}},{"StatementOptionName":"OVERWRITE=","StatementOptionHelp":{"#cdata":"For a table, drops the output table before the replacement output table is populated \nwith rows; for packages and threads, drops the existing package or thread if a package \nor thread by the same name exists. \n    \nSyntax: OVERWRITE= YES | NO;  \n\nArguments: \n\nYES | NO \n  specifies whether the output table is deleted before a replacement output table \n  is created or whether a package or thread is dropped.\n\n  Default: NO \n\nCAUTION:\nFor tables, use the OVERWRITE=YES statement only with data that is backed up or \nwith data that you can reconstruct. Because the output table is deleted first, \ndata will be lost if a failure occurs while the output table is being written."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the output table is deleted before a replacement output table    is created or a package or thread is dropped.","@ToolTip2":"Specifies that the output table is not deleted before a replacement output table    is created or a package or thread is dropped."}},{"StatementOptionName":"PW=","StatementOptionHelp":{"#cdata":"Assigns a READ, WRITE, and ALTER password to a SAS file, and enables access to a password-protected SAS file. \n    \nSyntax: PW=password  \n\nSyntax Description:\npassword \n  must be a valid SAS name.\n\nDetails:\nThe PW= option applies to all types of SAS files. You can use this option to assign \na password to a SAS file or to access a password-protected SAS file.\n\nWhen replacing a SAS data set that is protected by an ALTER password, the new data \nset inherits the ALTER password. When the code is written to the SAS log the password \nis blotted out, for example: \n\n  drop thread job2 (pw=xxxxxxx);\n\nNote:   A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"V"},{"StatementOptionName":"READ=","StatementOptionHelp":{"#cdata":"Assigns a READ password to a SAS file that prevents users from reading the file, \nunless they enter the password. \n    \nSyntax: READ=read-password  \n\nSyntax Description: \nread-password \n  must be a valid SAS name. \n \nDetails: \nThe READ= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a read-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  declare package sales (read=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You  \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"V"},{"StatementOptionName":"RENAME=","StatementOptionHelp":{"#cdata":"Changes the name of a column.\n    \nSyntax: RENAME= (old-name { = | AS } new-name [... old-name { = | AS } new-name ] ) ;  \n\nArguments: \nold-name \n  the column you want to rename.\n\nnew-name \n  the new name of the column. It must be a valid name for the data source.\n \nDetails: \nThe RENAME= table option allows you to change the names of one or more columns.\n\nIf you use RENAME= when you create a table, the new column name is included in the output \ntable. If you use RENAME= on an input table, the new name is used in DS2 programming statements.\n\nIf you use RENAME= in the same DS2 program with either the DROP= or the KEEP= table option, \nthe DROP= and the KEEP= table options are applied before RENAME=. You must use the old name in \nthe DROP= and KEEP= table options. You cannot drop and rename the same column in the same statement.\n\nIn addition to changing the name of a column, RENAME= also changes the label for the column."},"StatementOptionType":"V","SubOptionsKeywords":"AS"},{"StatementOptionName":"AS","StatementOptionHelp":{"#cdata":"Syntax: RENAME= (old-name AS new-name [... old-name AS new-name ] ) ;\n          \nSeparates the new-name from the old-name."},"StatementOptionType":"S"},{"StatementOptionName":"TYPE=","StatementOptionHelp":{"#cdata":"Specifies the data set type for a specially structured SAS data set. \n    \nSyntax: TYPE=data-set-type  \n\nSyntax Description: \ndata-set-type \n  specifies the special type of the data set.\n\nDetails: \nUse the TYPE= table option to create a special SAS data set in the proper format, \nor to identify the special type of the SAS data set in a procedure statement. \n\nYou can use the CONTENTS procedure to determine the type of a data set."},"StatementOptionType":"V"},{"StatementOptionName":"WRITE=","StatementOptionHelp":{"#cdata":"Assigns a WRITE password to a SAS file that prevents users from writing to a file, \nunless they enter the password. \n    \nSyntax: WRITE=write-password  \n\nSyntax Description: \nwrite-password \n  must be a valid SAS name. \n \nDetails: \nThe WRITE= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a write-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  drop thread job2a (write=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"V"}],"#comment":{}}},{"StatementName":"ENDDATA|ENDTABLE","StatementHelp":{"#cdata":"Syntax: ENDDATA; | ENDTABLE; \n      \nMarks the end of a DATA|TABLE statement."},"StatementOptions":null},{"StatementName":"END","StatementHelp":{"#cdata":"Syntax: END; \n      \nMarks the end of a block of code."},"StatementOptions":null},{"StatementName":"RUN CANCEL","StatementHelp":{"#cdata":"Syntax: RUN CANCEL; \n      \nCancels the previous DS2 language statements.\n\nTip: The RUN CANCEL statement is useful if you enter a typographical error."},"StatementOptions":null},{"StatementName":"DS2_OPTIONS","StatementHelp":{"#cdata":"[Documentation not yet available.]"},"StatementOptions":null},{"StatementName":"REQUIRE","StatementHelp":{"#cdata":"[Documentation not yet available.]"},"StatementOptions":null},{"StatementName":"STORED PROGRAM","StatementHelp":{"#cdata":"[Documentation not yet available.]"},"StatementOptions":null},{"StatementName":"VARLIST","StatementHelp":{"#cdata":"Syntax:  VARLIST list-name [variable-list];\n      \nThe VARLIST statement creates a named variable list that can be used in multiple DS2 statements. For example: \n\n    varlist vars [ x1-x5 u v w ];\n \n    method run();\n      compute(vars);\n      pkg.doStuff(vars);\n    end;\n\nThe variable-list specifies the variables that are to be referenced by the list. For example, the following \nstatement creates a variable list named allvars that contains all the PDV variables in the DS2 program: \n\n    varlist allvars [ _all_ ]; \n    \nNote the VARLIST statement is limited to the global scope of the DS2 package or program. The VARLIST \nstatement cannot be used to create a local variable list."},"StatementOptions":null}]}}}