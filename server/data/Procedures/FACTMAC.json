{"Procedure":{"Name":"FACTMAC","ProductGroup":"CAS","ProcedureHelp":{"#cdata":"Syntax: PROC FACTMAC <options>; \n    CODE FILE=filename; \n    ID variables; \n    INPUT variables <LEVEL=NOMINAL>; \n    OUTPUT OUT=CAS-libref.data-table <options>; \n    SAVESTATE RSTORE=CAS-libref.data-table; \n    TARGET variable <LEVEL=INTERVAL>; \n    AUTOTUNE <options>; \n    \nThe FACTMAC procedure implements the factorization machine model in SAS Viya. The flexible factorization\nmachine model has applications in predictive modeling and recommendation (Rendle 2012).\nFactorization machines generalize matrix factorization, among other techniques. You can use the FACTMAC\nprocedure to read and write data in distributed form, and to perform factorization in parallel by making full\nuse of multicore computers or distributed computing environments."},"ProcedureOptions":{"ProcedureOption":[{"ProcedureOptionName":"DATA=","ProcedureOptionHelp":{"#cdata":"Syntax: DATA=CAS-libref.data-table\n      \nNames the input data table for PROC FACTMAC to use. CAS-libref.data-table is a two-level name,\nwhere\n\n  CAS-libref refers to a collection of information that is defined in the LIBNAME statement and\n    includes the caslib, which includes a path to the data, and a session identifier, which\n    defaults to the active session but which can be explicitly defined in the LIBNAME\n    statement.\n    \n  data-table specifies the name of the input data table."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"LEARNSTEP=","ProcedureOptionHelp":{"#cdata":"Syntax: LEARNSTEP=number \n      \nSpecifies the learning step size for the stochastic gradient descent (SGD) algorithm, where number is a\npositive real number. The learning step size controls the amount by which the factors are updated at\neach iteration.\n\nBy default, LEARNSTEP=0.001."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"MAXITER=","ProcedureOptionHelp":{"#cdata":"Syntax: MAXITER=number \n      \nSpecifies the maximum number of iterations for the algorithm to perform, where number is an integer\ngreater than or equal to 1. In each iteration of the SGD method, the factors are recomputed.\n\nBy default, MAXITER=1."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"NFACTORS=","ProcedureOptionHelp":{"#cdata":"Syntax: NFACTORS=number \n      \nSpecifies the number of factors to estimate for the model, where number is an integer greater than or\nequal to 1.\n\nBy default, NFACTORS=1."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"NONNEGATIVE","ProcedureOptionHelp":{"#cdata":"Performs nonnegative factorization, in which the estimated factors are greater than or equal to 0 and the estimated biases are 0.\n\nBy default, nonnegative factorization is not performed."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"NOPRINT","ProcedureOptionHelp":{"#cdata":"Suppresses ODS output."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"NTHREADS=","ProcedureOptionHelp":{"#cdata":"Syntax: NTHREADS=number-of-threads\n      \nSpecifies the number of threads to use for the computation, where number-of-threads can be from 1 to\n64, inclusive. The default value is the maximum number of available threads per computer."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"OUTMODEL=","ProcedureOptionHelp":{"#cdata":"Syntax: OUTMODEL=data-set\n      \nSpecifies the output model data set to contain the computed factor parameters. The output data set is\nstored in the Work library."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"SEED=","ProcedureOptionHelp":{"#cdata":"Syntax: SEED=random-seed\n      \nSpecifies an integer that is used to start the pseudorandom number generator. This option enables you\nto reproduce the same sample output, but only when NTHREADS=1. If you do not specify a seed or\nyou specify a value less than or equal to 0, the seed is generated from reading the time of day from the\ncomputer\u2019s clock.\n\nBy default, SEED=0."},"ProcedureOptionType":"V"}]},"ProcedureStatements":{"ProcedureStatement":[{"StatementName":"AUTOTUNE","StatementHelp":{"#cdata":"Syntax: AUTOTUNE < options > ;\n      \nThe AUTOTUNE statement searches for the best combination of values of the NFACTORS=, LEARNSTEP=, \nand MAXITER= options in the PROC FACTMAC statement. You cannot specify both the OUTPUT and AUTOTUNE \nstatements in the same run of PROC FACTMAC."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"EVALHISTORY=","StatementOptionHelp":{"#cdata":"Syntax: EVALHISTORY=ALL |LOG |NONE |TABLE \n          \nSpecifies how to report the evaluation history of the tuner."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"ALL","@Value2":"LOG","@Value3":"NONE","@Value4":"TABLE"},"StatementOptionToolTips":{"@ToolTip1":"Reports each evaluation in the log and creates the EvaluationHistory ODS table. ","@ToolTip2":"Prints the following information to the log for each evaluation: evaluation number, objective value, best objective value up to that point, evaluation time, and elapsed time since the beginning of the  tuning process.","@ToolTip3":"Suppresses reporting of evaluations in the log and does not create the EvaluationHistory ODS table.","@ToolTip4":"Creates the EvaluationHistory ODS table, which contains all evaluated points. The table contains columns  for the evaluation number, all tuning parameters, and the objective function value."}},{"StatementOptionName":"FRACTION=","StatementOptionHelp":{"#cdata":"Syntax: FRACTION=number\n          \nSpecifies the fraction of all data to be used for validation, where number must be between 0.01 and\n0.99, inclusive. If you specify this option, the tuner uses a single partition validation for finding the\nobjective value (validation error estimate). This option might not be advisable for small or unbalanced\ndata tables where the random assignment of the validation subset might not provide a good estimate of\nerror. For large, balanced data tables, a single validation partition is usually sufficient for estimating\nerror; a single partition is more efficient than cross validation in terms of the total execution time.\nBy default, FRACTION=0.3. You cannot specify this option in combination with the KFOLD= option."},"StatementOptionType":"V"},{"StatementOptionName":"KFOLD=","StatementOptionHelp":{"#cdata":"Syntax: KFOLD=number\n          \nSpecifies the number of partition folds in the cross validation process, where number must be between\n2 and 20, inclusive. If you specify this option, the tuner uses cross validation to find the objective value.\nIn cross validation, each model evaluation requires number of training executions (on number\u20131 data\nfolds) and number of scoring executions (on 1 hold-out fold). Thus, the evaluation time is increased by\napproximately number. For small to medium data tables or for unbalanced data tables, cross validation\nprovides on average a better representation of error across the entire data table (a better generalization\nerror).\nBy default, KFOLD=5. You cannot specify this option in combination with the FRACTION= option."},"StatementOptionType":"V"},{"StatementOptionName":"MAXEVALS=","StatementOptionHelp":{"#cdata":"Syntax: MAXEVALS=number \n          \nSpecifies the maximum number of configuration evaluations allowed for the tuner, where number\nmust be an integer greater than or equal to 3. When the number of evaluations is reached, the tuner\nterminates the search and returns the results. To produce a single objective function value (validation\nerror estimate), each configuration evaluation requires either a single model training and scoring\nexecution on a validation partition, or a number of training and scoring executions equal to the value of\nthe KFOLD= option for cross validation. The MAXEVALS= option might lead to termination before\nthe value of the MAXITER= option or the MAXTIME= option is reached.\nBy default, MAXEVALS=50."},"StatementOptionType":"V"},{"StatementOptionName":"MAXITER=","StatementOptionHelp":{"#cdata":"Syntax: MAXITER=number\n          \nSpecifies the maximum number of iterations of the optimization tuner, where number must be greater\nthan or equal to 1. Each iteration normally involves a number of objective evaluations up to the value\nof the POPSIZE= option. The MAXITER= option might lead to termination before the value of the\nMAXEVALS= option or the MAXTIME= option is reached.\nBy default, MAXITER=5."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=number\n          \nSpecifies the maximum time (in seconds) allowed for the tuner, where number must be greater than or\nequal to 1. When this value is reached, the tuner terminates the search and returns results. The actual\nrun time for optimization might be longer because it includes the remaining time needed to finish\nthe current evaluation. For long-running model training (large data tables), the actual run time might\nsignificantly exceed number. The MAXTIME= option might lead to termination before the value of\nthe MAXEVALS= option or the MAXITER= option is reached.\nBy default, MAXTIME=36000."},"StatementOptionType":"V"},{"StatementOptionName":"NSUBSESSIONWORKERS=","StatementOptionHelp":{"#cdata":"Syntax: NSUBSESSIONWORKERS=number \n          \nSpecifies the number of workers to use in parallel subsessions. When evaluating alternative configurations \nin parallel, a number of subsessions is created by the tuner, with each subsession potentially using multiple \nworkers. The number of workers used in a parallel subsession is determined by using either NSUBSESSIONWORKERS=number, \nif specified, or determined automatically based upon the size of the data."},"StatementOptionType":"V"},{"StatementOptionName":"NPARALLEL=","StatementOptionHelp":{"#cdata":"Syntax: NPARALLEL=number \n          \nSpecifies the number of evaluations to be performed in parallel, where number must be greater than or \nequal to 0. When SEARCHMETHOD=GA is specified, the value of number is equal to the value of the POPSIZE= \noption minus one. When SEARCHMETHOD=LHS or SEARCHMETHOD=RANDOM is specified, the value of number is equal \nto the value of SAMPLESIZE= option."},"StatementOptionType":"V"},{"StatementOptionName":"OBJECTIVE=","StatementOptionHelp":{"#cdata":"Syntax: OBJECTIVE=function \n          \nSpecifies which measure of model performance the tuner uses as the objective function.\n\nBy default, OBJECTIVE=MISC for nominal targets, and OBJECTIVE=MSE for interval targets."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"ASE","@Value2":"AUC","@Value3":"F05","@Value4":"F1","@Value5":"GAMMA","@Value6":"GINI","@Value7":"KS","@Value8":"MAE","@Value9":"MCE","@Value10":"MCLL","@Value11":"MISC","@Value12":"MSE","@Value13":"MSLE","@Value14":"RASE","@Value15":"RMAE","@Value16":"RMSLE","@Value17":"TAU"},"StatementOptionToolTips":{"@ToolTip1":"Uses average squared error as the objective function.","@ToolTip2":"Uses area under the curve as the objective function (nominal type only).","@ToolTip3":"Uses the F0.5 coefficient as the objective function (nominal type only). ","@ToolTip4":"Uses the F1 coefficient as the objective function (nominal type only).","@ToolTip5":"Uses the gamma coefficient as the objective function (nominal type only).","@ToolTip6":"Uses the Gini coefficient as the objective function (nominal type only). ","@ToolTip7":"Uses the Kolmogorov-Smirnov coefficient as the objective function (nominal type only).","@ToolTip8":"Uses the mean absolute error as the objective function (interval type only).","@ToolTip9":"Uses the misclassification rate as the objective function (nominal type only).","@ToolTip10":"Uses the multiclass log loss as the objective function (nominal type only).","@ToolTip11":"Uses the misclassification error percentage as the objective function (nominal type only).","@ToolTip12":"Uses the mean squared error as the objective function (interval type only).","@ToolTip13":"Uses the mean squared logarithmic error as the objective function (interval type only).","@ToolTip14":"Uses the root average squared error as the objective function.","@ToolTip15":"Uses the root mean absolute error as the objective function (interval type only).","@ToolTip16":"Uses the root mean squared logarithmic error as the objective function (interval type only).","@ToolTip17":"Uses the tau coefficient as the objective function (nominal type only)."}},{"StatementOptionName":"POPSIZE=","StatementOptionHelp":{"#cdata":"Syntax: POPSIZE=number\n          \nSpecifies the maximum number of evaluations in one iteration (population), where number must\nbe greater than or equal to 1. In some cases, the tuner algorithm might generate a number of new\nconfigurations smaller than number.\nBy default, POPSIZE=10."},"StatementOptionType":"V"},{"StatementOptionName":"SAMPLESIZE=","StatementOptionHelp":{"#cdata":"Syntax: SAMPLESIZE=number \n          \nSpecifies the total number of evaluations, where number must be greater than or equal to 1. \nYou can specify this option when SEARCHMETHOD=RANDOM or SEARCHMETHOD=LHS. This option is \nignored when SEARCHMETHOD=GA. \n\nBy default, SAMPLESIZE=50."},"StatementOptionType":"V"},{"StatementOptionName":"SEARCHMETHOD=","StatementOptionHelp":{"#cdata":"Syntax: SEARCHMETHOD=BAYESIAN| GA |LHS |RANDOM \n          \nSpecifies the search method to use for tuning.\n\nBy default, SEARCHMETHOD=GA."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"BAYESIAN","@Value2":"GA","@Value3":"LHS","@Value4":"RANDOM"},"StatementOptionToolTips":{"@ToolTip1":"Builds a Kriging surrogate model to approximate the objective value, and uses this surrogate model  for generating new alternative configurations at each iteration.","@ToolTip2":"Uses an initial Latin hypercube sample that seeds a genetic algorithm to generate a new population  of alternative configurations at each iteration.","@ToolTip3":"Uses a Latin hypercube to generate a single sample of configurations that is uniform in each tuning  parameter, but random in combinations.","@ToolTip4":"Generates a single sample of purely random configurations. "}},{"StatementOptionName":"TARGETEVENT=","StatementOptionHelp":{"#cdata":"Syntax: TARGETEVENT=string \n          \nSpecifies the target event to use for calculating the selected objective function. This option \nis ignored when the value of the OBJECTIVE= option is not AUC, F1, F05, GINI, GAMMA, TAU, or KS."},"StatementOptionType":"V"},{"StatementOptionName":"TUNINGPARAMETERS=","StatementOptionHelp":{"#cdata":"Syntax: TUNINGPARAMETERS=(suboption |\u2026|<suboption>) \nSyntax: TUNEPARMS=(suboption |\u2026|<suboption>) \n\nSpecifies which parameters to tune and which ranges to tune over. If USEPARAMETERS=STANDARD, \nthis option is ignored. \n\nFor more information about which tuning suboptions are available, see the specific procedure chapters."},"StatementOptionType":"V","SubOptionsKeywords":"NFACTORS|LB=|UB=|VALUES=|INIT=|EXCLUDE|LEARNSTEP|MAXITER"},{"StatementOptionName":"USEPARAMETERS=","StatementOptionHelp":{"#cdata":"Syntax: USEPARAMETERS=tuning-parameter-option \n          \nSpecifies how to handle the TUNINGPARAMETERS= option."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"STANDARD","@Value2":"CUSTOM","@Value3":"COMBINED"},"StatementOptionToolTips":{"@ToolTip1":"Tunes using the default bounds and initial values for all parameters.","@ToolTip2":"Tunes only the parameters that are specified in the TUNINGPARAMETERS= option.","@ToolTip3":"Tunes the parameters that are specified in the TUNINGPARAMETERS= option and uses default bounds  and initial values to tune all other parameters."}}]}},{"StatementName":"CODE","StatementHelp":{"#cdata":"Syntax: CODE FILE=filename; \n      \nThe CODE statement generates SAS DATA step code that mimics the computations that are performed. The\ngenerated SAS DATA step code can be used for scoring new observations. Only one CODE statement is\nprocessed. If you specify multiple CODE statements, only the first one is used. \n\nThe CODE statement is optional. If you do not include a CODE statement, no score code is generated."},"StatementOptions":{"StatementOption":{"StatementOptionName":"FILE=","StatementOptionHelp":{"#cdata":"Syntax: FILE=filename \n          \nSpecifies the filename of the file to write the SAS score code to."},"StatementOptionType":"V"}}},{"StatementName":"ID","StatementHelp":{"#cdata":"Syntax: ID variables;\n\nThe ID statement lists one or more variables that are to be copied from the input data table \nto the output data tables that are specified in the OUT= option in the OUTPUT statement and \nthe RSTORE= option in the SAVESTATE statement."},"StatementOptions":null},{"StatementName":"INPUT","StatementHelp":{"#cdata":"Syntax: INPUT variables < LEVEL=NOMINAL > ;\n      \nThe INPUT statement specifies the names of the variables to be used in the factorization. It names one or\nmore input variables that use common options. If you want to use different options for different variables,\nyou can specify multiple INPUT statements."},"StatementOptions":{"StatementOption":{"StatementOptionName":"LEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LEVEL=NOMINAL\n          \nSpecifies the level of measurement of the variables.\n\nPROC FACTMAC currently accepts only nominal input variables."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NOMINAL"},"StatementOptionToolTips":{"@ToolTip1":"Specifies NOMINAL input variables."}}}},{"StatementName":"OUTPUT","StatementHelp":{"#cdata":"Syntax:OUTPUT OUT=CAS-libref.data-table < options > ;\n      \nThe OUTPUT statement creates an output data table to contain the results of the procedure run."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=CAS-libref.data-table\n          \nNames the output data table for PROC FACTMAC to use. CAS-libref.data-table is a two-level name,\nwhere\n\n  CAS-libref refers to a collection of information that is defined in the LIBNAME statement and\n    includes the caslib, which includes a path to where the data table is to be stored, and\n    a session identifier, which defaults to the active session but which can be explicitly\n    defined in the LIBNAME statement. \n    \n  data-table specifies the name of the output data table."},"StatementOptionType":"V"},{"StatementOptionName":"COPYVAR=|COPYVARS=","StatementOptionHelp":{"#cdata":"Syntax: COPYVAR=variable | COPYVARS=(variables) \n          \nLists one or more variables from the input data table to be transferred to the output data table."},"StatementOptionType":"V"}]}},{"StatementName":"SAVESTATE","StatementHelp":{"#cdata":"Syntax: SAVESTATE RSTORE=CAS-libref.data-table;  \n      \nThe SAVESTATE statement creates an analytic store for the model and saves it as a binary object \nin a data table. You can use the analytic store in the ASTORE procedure to score new data."},"StatementOptions":{"StatementOption":{"StatementOptionName":"RSTORE=","StatementOptionHelp":{"#cdata":"Syntax: RSTORE=CAS-libref.data-table \n          \nSpecifies a data table in which to save the analytic store for the model. CAS-libref.data-table \nis a two-level name, where CAS-libref refers to the caslib and session identifier, and data-table \nspecifies the name of the output data table."},"StatementOptionType":"V"}}},{"StatementName":"TARGET","StatementHelp":{"#cdata":"Syntax: TARGET variable < LEVEL=INTERVAL > ;\n      \nThe TARGET statement names the target variable whose values PROC FACTMAC predicts. The target must\nbe interval and must be different from the variables in the INPUT statement."},"StatementOptions":{"StatementOption":{"StatementOptionName":"LEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LEVEL=INTERVAL\n          \nSpecifies the level of measurement of the variables."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"INTERVAL"},"StatementOptionToolTips":{"@ToolTip1":"Specifies INTERVAL target variables."}}}}]}}}