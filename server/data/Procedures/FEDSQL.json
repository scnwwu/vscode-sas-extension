{"Procedure":{"Name":"FEDSQL","ProductGroup":"BASE","#comment":{},"ProcedureHelp":{"#cdata":"Syntax: PROC FEDSQL <option(s)>; \n  \u2026FedSQL statements \n  QUIT; \n  \nSAS FedSQL is a SAS proprietary implementation of ANSI SQL:1999 core standard. It provides support \nfor new data types and other ANSI 1999 core compliance features and proprietary extensions. FedSQL \nprovides a scalable, threaded, high-performance way to access, manage, and share relational data in \nmultiple data sources. When possible, FedSQL queries are optimized with multi-threaded algorithms \nin order to resolve large-scale operations. \n\nFor applications, FedSQL provides a common SQL syntax across all data sources. That is, FedSQL \nis a vendor-neutral SQL dialect that accesses data from various data sources without having to \nsubmit queries in the SQL dialect that is specific to the data source. In addition, a single \nFedSQL query can target data in several data sources and return a single result table."},"ProcedureOptions":{"ProcedureOption":[{"ProcedureOptionName":"ANSIMODE","ProcedureOptionHelp":{"#cdata":"Specifies that nonexistent values are processed as ANSI SQL null values. By default, PROC FEDSQL \nprocesses nonexistent values as SAS missing values."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"AUTOCOMMIT","ProcedureOptionHelp":{"#cdata":"Specifies that updates are automatically committed (that is, saved to a table) after a default \nnumber of rows are updated, and whether rollback is available. \n\nDefault: All updates are committed immediately after each request is submitted, and no rollback is possible."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"NOAUTOCOMMIT","ProcedureOptionHelp":{"#cdata":"Specifies that updates are not automatically committed (that is, not saved to a table) after a default \nnumber of rows are updated.\n      \nRequirement: For data sources that do not support transactions, specifying NOAUTOCOMMIT returns an error. \nThe data sources that support transactions include Aster, DB2 for UNIX and PC Hosts, Greenplum, Microsoft \nSQL Server, MySQL, ODBC databases, and Sybase IQ."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"ERRORSTOP","ProcedureOptionHelp":{"#cdata":"Specifies that the procedure stops executing if it encounters an error. In a batch \nor noninteractive session, ERRORSTOP instructs the procedure to stop executing the \nstatements but to continue checking the syntax after it has encountered an error. \n\nDefault: NOERRORSTOP in an interactive SAS session; ERRORSTOP in a batch or noninteractive session\n\nTip: ERRORSTOP has an effect only when SAS is running in the batch or noninteractive \nexecution mode."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"NOERRORSTOP","ProcedureOptionHelp":{"#cdata":"Instructs the procedure to execute the statements and to continue checking the syntax after an error occurs.\n\nDefault: NOERRORSTOP in an interactive SAS session; ERRORSTOP in a batch or noninteractive session"},"ProcedureOptionType":"S"},{"ProcedureOptionName":"EXEC","ProcedureOptionHelp":{"#cdata":"Specifies that a statement should be executed after its syntax is checked for accuracy.\n\nDefault: EXEC"},"ProcedureOptionType":"S"},{"ProcedureOptionName":"NOEXEC","ProcedureOptionHelp":{"#cdata":"Specifies that a statement should not be executed after its syntax is checked for accuracy. \n      \nTip: NOEXEC is useful if you want to check the syntax of your FedSQL statements without executing the statements."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"LABEL","ProcedureOptionHelp":{"#cdata":"Specifies to use the column label or the column name as the column heading.\n      \nDefault: LABEL\n\nInteractions: If a column does not have a label, the procedure uses the column's name as the column heading.\nA column alias overwrites the label or column name as the column heading."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"NOLABEL","ProcedureOptionHelp":{"#cdata":"Specifies not to use the column label or the column name as the column heading.\n      \nDefault: LABEL"},"ProcedureOptionType":"S"},{"ProcedureOptionName":"NOPRINT","ProcedureOptionHelp":{"#cdata":"Suppresses the normal display of results. \n      \nInteraction: NOPRINT affects the value of the SQLOBS automatic macro variable, which contains the \nnumber of rows executed by a statement."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"NUMBER","ProcedureOptionHelp":{"#cdata":"Specifies to include a column named Row, which is the row (observation) number of the data as the rows are retrieved.\n      \nDefault: No row numbers."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"STIMER","ProcedureOptionHelp":{"#cdata":"Specifies to write a subset of system performance statistics, such as time-elapsed statistics, \nto the SAS log. When STIMER is in effect, the procedure writes to the SAS log a list of computer \nresources used for each step and the entire SAS session. \n\nDefault: No performance statistics are written to the SAS log. \n\nInteraction: If the SAS system option FULLSTIMER is in effect, the complete list of computer resources \nis written to the SAS log."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"XCODE=","ProcedureOptionHelp":{"#cdata":"[Syntax: XCODE=ERROR | WARNING | IGNORE]\n      \nControls the behavior of the SAS session when an NLS transcoding failure occurs. Transcoding failures can \noccur during row input or output operations, or during string assignment. Transcoding is the process of \nconverting character data from one encoding to another encoding. \n      \nDefault: ERROR"},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"ERROR","@Value2":"WARNING","@Value3":"IGNORE"},"ProcedureOptionToolTips":{"@ToolTip1":"Specifies that a run-time error occurs, which causes row processing to halt. An error message is written to the SAS log.   This is the default behavior.","@ToolTip2":"Specifies that the incompatible character is set to a substitution character. A warning message is written to the SAS log.","@ToolTip3":"Specifies that the incompatible character is set to a substitution character. No messages are written to the SAS log."}}]},"ProcedureStatements":{"ProcedureStatement":[{"StatementName":"ALTER TABLE","StatementHelp":{"#cdata":"Syntax: ALTER TABLE table [\\{OPTIONS SAS-table-option=value [, ...SAS-table-option=value] \\}] \n  ADD COLUMN <column-definition> [, ...<column-definition>]\n  | ADD CONSTRAINT <table-constraint>\n  | ALTER [COLUMN] <column-definition> [, ...<column-definition> ]\n  | DROP COLUMN column [, ...column] [FORCE]\n  | DROP CONSTRAINT constraint [, ...constraint]\n  | RENAME TO table\n  | RENAME column TO column\n  ; \n      \nAdds or drops table columns and modifies column definitions."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ADD COLUMN","StatementOptionHelp":{"#cdata":"Syntax: ADD COLUMN <column-definition> [, ...<column-definition>] \n          \nwhere:\n<column-definition>::= \n  column data-type [<column-constraint>] [ SET DEFAULT value | DROP DEFAULT ] \n\n<column-constraint>::= \n  CONSTRAINT constraint\n  { CHECK (search-condition) \n  | PRIMARY KEY\n  | UNIQUE\n  | NOT NULL }\n\nSpecifies to add a column to a table. \n\nData source: \nAster, DB2 under UNIX and PC, Greenplum, HAWQ, Hive, Impala, MDS, MySQL, Netezza, ODBC, \nOracle, PostgreSQL, SAP HANA, Sybase IQ, Teradata"},"StatementOptionType":"S","SubOptionsKeywords":"SET DEFAULT|DROP DEFAULT|CONSTRAINT|CHECK|PRIMARY KEY|UNIQUE|NOT NULL"},{"StatementOptionName":"ADD CONSTRAINT","StatementOptionHelp":{"#cdata":"Syntax: ADD CONSTRAINT <table-constraint>\n\nwhere:\n<table-constraint>::= \n  CONSTRAINT  constraint\n  { CHECK (search-condition) \n  | PRIMARY KEY (column [, \u2026column]) \n  | UNIQUE (column [, ...column]) \n  | <referential-constraint> } \n  [<constraint-check-time>]  \n  \n  <referential-constraint>::= \n    FOREIGN KEY (referencing-column [, ... referencing-column]) \n    REFERENCES referenced-table (referenced-column [, ...referenced-column]) \n\n  [<referential-trigger-action>]\n    <referential-trigger-action>::= \n    { [ON UPDATE <referential-action> [ON DELETE <referential-action>]] } \n    | { [ON DELETE <referential-action> [ON UPDATE <referential-action>]] } \n\n  <referential-action>::= \n    CASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION\n\n  <constraint-check-time>::= \n    { DEFERRABLE [INITIALLY DEFERRED | INITIALLY IMMEDIATE] } \n    | { [INITIALLY DEFERRED | INITIALLY IMMEDIATE] DEFERRABLE } \n    | INITIALLY DEFERRED\n    | { NOT DEFERRABLE [INITIALLY IMMEDIATE] } \n    | { [INITIALLY IMMEDIATE] NOT DEFERRABLE } \n  \nSpecifies to add an integrity constraint to one or more columns. \n\nData source: SAS data set, Aster, DB2 under UNIX and PC, Greenplum, HAWQ, MySQL, ODBC, Oracle, \n  PostgreSQL, SAP HANA, Sybase IQ, Teradata  \nNote: Constraint validation and enforcement is performed by the data source. You should be familiar \n  with data source\u2019s requirements before adding or dropping an integrity constraint."},"StatementOptionType":"S","SubOptionsKeywords":"CHECK|PRIMARY KEY|ON UPDATE|ON DELETE|CASCADE|RESTRICT|SET NULL|NO ACTION|SET DEFAULT|INITIALLY DEFERRED|DEFERRABLE|INITIALLY IMMEDIATE|NOT DEFERRABLE"},{"StatementOptionName":"ALTER COLUMN","StatementOptionHelp":{"#cdata":"Syntax: ALTER [COLUMN] <column-definition> [, ...<column-definition>] \n\nwhere:\n<column-definition>::= \n  column data-type [<column-constraint>] [ SET DEFAULT value | DROP DEFAULT ] \n\n<column-constraint>::= \n  CONSTRAINT constraint\n  { CHECK (search-condition) \n  | PRIMARY KEY\n  | UNIQUE\n  | NOT NULL }\n\nSpecifies to modify the definition of one or more columns. \n\nData source: Aster, DB2 under UNIX and PC, Greenplum, HAWQ, MDS, MySQL, Netezza, ODBC, Oracle, \n  PostgreSQL, Sybase IQ, Teradata"},"StatementOptionType":"S","SubOptionsKeywords":"CHECK|PRIMARY KEY|UNIQUE|NOT NULL"},{"StatementOptionName":"DROP COLUMN","StatementOptionHelp":{"#cdata":"Syntax: DROP COLUMN column [, ...column] [FORCE] \n\nSpecifies to delete the specified column from the table. When FORCE is specified, the column is dropped \nfrom the table without error processing. Use the FORCE keyword only when you are certain that dropping \nthe column without error processing will not negatively affect the table. \n\nData source: Aster, DB2 under UNIX and PC, Greenplum, HAWQ, Hive, MDS, MySQL, Netezza, ODBC, Oracle, \nPostgreSQL, SAP HANA, Sybase IQ, Teradata"},"StatementOptionType":"S","SubOptionsKeywords":"FORCE"},{"StatementOptionName":"DROP CONSTRAINT","StatementOptionHelp":{"#cdata":"Syntax: DROP CONSTRAINT constraint [, \u2026constraint] \n\nwhere:\nconstraint\n  specifies the name of the constraint to drop. \n\nSpecifies to delete an integrity constraint. \n\nData source: SAS data set, Aster, DB2 under UNIX and PC, Greenplum, HAWQ, ODBC, Oracle, PostgreSQL, \n  SAP HANA, Sybase IQ, Teradata"},"StatementOptionType":"S"},{"StatementOptionName":"RENAME","StatementOptionHelp":{"#cdata":"Changes the specified table or column name to a new name. The new name follows the TO keyword. \n\nData source: Aster, DB2 under UNIX and PC, Greenplum, HAWQ, MDS, Netezza, ODBC, Oracle, PostgreSQL, \nSAP HANA, Sybase IQ, Teradata "},"StatementOptionType":"S"},{"StatementOptionName":"TO","StatementOptionHelp":{"#cdata":"Syntax: "},"StatementOptionType":"S"}]}},{"StatementName":"BEGIN","StatementHelp":{"#cdata":"Syntax: BEGIN [TRANSACTION]; \n      \nMarks the beginning of a transaction that comprises multiple statements."},"StatementOptions":null},{"StatementName":"COMMIT","StatementHelp":{"#cdata":"Syntax: COMMIT [TRANSACTION];  \n      \nMakes changes that have been performed since the start of a transaction a permanent part of the database."},"StatementOptions":null},{"StatementName":"CREATE INDEX","StatementHelp":{"#cdata":"Syntax: CREATE [UNIQUE] INDEX index ON table\n(column [ASCENDING | DESCENDING ][, ...column]);   \n\nwhere:\nindex\n  specifies the name of the index. \n\ntable\n  specifies the name of the table that contains the column or columns to be indexed. \n\ncolumn\n  specifies the name of the column to which the index applies. Specify two or more column names \n  to create a composite index. \n\nCreates an index on columns in a specified table."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ON","StatementOptionHelp":{"#cdata":"[Syntax: ON table-name ( column <, ... column>)] \n          \nSpecifies a PROC SQL table."},"StatementOptionType":"S"},{"StatementOptionName":"ASCENDING|ASC","StatementOptionHelp":{"#cdata":"Rows are sorted from the smallest value to the largest value. This is the default value. \n\nNote: This option is not valid for Base data sets and SPD Engine data sets."},"StatementOptionType":"S"},{"StatementOptionName":"DESCENDING|DESC","StatementOptionHelp":{"#cdata":"Observations are sorted from the largest value to the smallest value. \n\nNote: This option is not valid for Base data sets and SPD Engine data sets."},"StatementOptionType":"S"}]}},{"StatementName":"CREATE UNIQUE INDEX","StatementHelp":{"#cdata":"Syntax: CREATE UNIQUE INDEX index ON table\n(column [ASCENDING | DESCENDING ][, ...column]);   \n\nwhere:\nUNIQUE\n  creates a unique index on a table.\n\nindex\n  specifies the name of the index. \n\ntable\n  specifies the name of the table that contains the column or columns to be indexed. \n\ncolumn\n  specifies the name of the column to which the index applies. Specify two or more column names \n  to create a composite index. \n\nCreates a unique index on columns in a specified table."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ON","StatementOptionHelp":{"#cdata":"[Syntax: ON table-name ( column <, ... column>)] \n          \nSpecifies a PROC SQL table."},"StatementOptionType":"S"},{"StatementOptionName":"ASCENDING|ASC","StatementOptionHelp":{"#cdata":"Rows are sorted from the smallest value to the largest value. This is the default value. \n\nNote: This option is not valid for Base data sets and SPD Engine data sets."},"StatementOptionType":"S"},{"StatementOptionName":"DESCENDING|DESC","StatementOptionHelp":{"#cdata":"Observations are sorted from the largest value to the smallest value. \n\nNote: This option is not valid for Base data sets and SPD Engine data sets."},"StatementOptionType":"S"}]}},{"StatementName":"CREATE TABLE","StatementHelp":{"#cdata":"Syntax: CREATE TABLE {table | _NULL_}\n  [\\{OPTIONS SAS-table-option=value \n  [...SAS-table-option=value] \\}] \n  | ( <column-definition> [, ...<column-definition> | <table-constraint>]) \n  | AS query-expression\n  ; \n\nwhere:\ntable\n  specifies a table to modify. table can be one of these forms:\n  \u2022 catalog.schema.table-name \n  \u2022 schema.table-name \n  \u2022 catalog.table-name \n  \u2022 table-name\n\n<column-definition>::= \n  column data-type [<column-constraint>] [DEFAULT value]\n  [HAVING [FORMAT format][INFORMAT informat][LABEL 'label']]\n<column-constraint>::= \n  CONSTRAINT constraint  { CHECK (search-condition) | PRIMARY KEY | UNIQUE | NOT NULL }\n\n<table-constraint>::= \n  CONSTRAINT  constraint { CHECK (search-condition) | PRIMARY KEY (column [, ...column]) \n    | UNIQUE (column [, ...column]) | <referential-constraint> } [<constraint-check-time>]\n<referential-constraint>::= \n  FOREIGN KEY (referencing-column [, ...referencing-column]) \n    REFERENCES referenced-table (referenced-column [, ...referenced-column]) [<referential-trigger-action>]\n<referential-trigger-action>::= \n  { ON UPDATE <referential-action> [ON DELETE <referential-action>] } \n  | { ON DELETE <referential-action> [ON UPDATE <referential-action>] } \n<referential-action>::= \n  CASCADE | SET NULL | SET DEFAULT | RESTRICT | NO ACTION\n<constraint-check-time>::= \n  { DEFERRABLE [INITIALLY DEFERRED | INITIALLY IMMEDIATE] } | { [INITIALLY DEFERRED | INITIALLY IMMEDIATE] DEFERRABLE } \n  | INITIALLY DEFERRED | { NOT DEFERRABLE [INITIALLY IMMEDIATE] } | { [INITIALLY IMMEDIATE] NOT DEFERRABLE } \ncolumn\n  specifies the name of the column. The column name is either a local or schema qualified name, using one of these forms: \n  \u2022 schema.column-name \n  \u2022 column-name\n\nCreates a new table."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"_NULL_","StatementOptionHelp":{"#cdata":"Specifies to test the performance of creating a table using the AS query-expression clause. FedSQL \ncreates the table internally as if it were to be saved, writing the normal progress messages. The \ntable creation appears to be successful. Once the query expression is complete, the table is discarded. \n\nInteraction: A SELECT select-list FROM _NULL_ statement returns an error.  \n"},"StatementOptionType":"RS","SubOptionsKeywords":"HAVING|CONSTRAINT|UNIQUE|FOREIGN KEY|REFERENCES|CHECK|PRIMARY KEY|ON UPDATE|ON DELETE|CASCADE|RESTRICT|SET NULL|NO ACTION|SET DEFAULT|INITIALLY DEFERRED|DEFERRABLE|INITIALLY IMMEDIATE|NOT DEFERRABLE"},{"StatementOptionName":"AS","StatementOptionHelp":{"#cdata":"Syntax: ...AS query-expression\n          \nSpecifies to create a new table from an existing table by selecting rows from the existing table using \na query expression. The column attributes, such as formats and labels, are copied from the existing table \nto the new table. \n\nquery-expression\n  specifies the SELECT statement that retrieves information from an existing table to use in creating a new table. \n\n  Requirement: The number of columns used in the SELECT statement must equal the number of columns in the table."},"StatementOptionType":"S"},{"StatementOptionName":"SELECT","StatementOptionHelp":{"#cdata":"SQL-expression keyword"},"StatementOptionType":"S"},{"StatementOptionName":"DISTINCT","StatementOptionHelp":{"#cdata":"SQL-expression keyword"},"StatementOptionType":"S"},{"StatementOptionName":"INTO","StatementOptionHelp":{"#cdata":"SQL-expression keyword"},"StatementOptionType":"S"},{"StatementOptionName":"FROM","StatementOptionHelp":{"#cdata":"SQL-expression keyword"},"StatementOptionType":"S"},{"StatementOptionName":"WHERE","StatementOptionHelp":{"#cdata":"SQL-expression keyword"},"StatementOptionType":"S"},{"StatementOptionName":"GROUP BY","StatementOptionHelp":{"#cdata":"SQL-expression keyword"},"StatementOptionType":"S"},{"StatementOptionName":"HAVING","StatementOptionHelp":{"#cdata":"SQL-expression keyword"},"StatementOptionType":"S"},{"StatementOptionName":"INTERSECT","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \nProduces rows that are common to both query results."},"StatementOptionType":"S"},{"StatementOptionName":"CORRESPONDING|CORR","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \nCauses PROC SQL to match the columns in table-expressions by name and not by \nordinal position."},"StatementOptionType":"S"},{"StatementOptionName":"EXCEPT","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \nProduces rows that are part of the first query only."},"StatementOptionType":"S"},{"StatementOptionName":"ALL","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \nThe set operators automatically eliminate duplicate rows from their output tables. \nThe optional ALL keyword preserves the duplicate rows, reduces the execution by one \nstep, and thereby improves the query-expression's performance."},"StatementOptionType":"S"},{"StatementOptionName":"UNION","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \nProduces all unique rows from both queries."},"StatementOptionType":"S"},{"StatementOptionName":"OUTER UNION","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \nConcatenates the query results."},"StatementOptionType":"S"},{"StatementOptionName":"INNER JOIN","StatementOptionHelp":{"#cdata":"Returns a result table for all the rows in a table that have one or more matching \nrows in the other tables, as specified by the sql-expression."},"StatementOptionType":"S"},{"StatementOptionName":"OUTER JOIN","StatementOptionHelp":{"#cdata":"Outer joins are inner joins that have been augmented with rows that did not match \nwith any row from the other table in the join. The three types of outer joins \nare left, right, and full."},"StatementOptionType":"S"},{"StatementOptionName":"LEFT JOIN","StatementOptionHelp":{"#cdata":"Has all the rows from the Cartesian product of the two tables for which the sql-expression \nis true, plus rows from the first table that do not match any row in the second (RIGHTTAB) \ntable."},"StatementOptionType":"S"},{"StatementOptionName":"RIGHT JOIN","StatementOptionHelp":{"#cdata":"Has all the rows from the Cartesian product of the two tables for which the sql-expression \nis true, plus rows from the second table that do not match any row in the first table."},"StatementOptionType":"S"},{"StatementOptionName":"FULL JOIN","StatementOptionHelp":{"#cdata":"Has all the rows from the Cartesian product of the two tables for which the sql-expression \nis true, plus rows from each table that do not match any row in the other table."},"StatementOptionType":"S"},{"StatementOptionName":"CROSS JOIN","StatementOptionHelp":{"#cdata":"A cross join returns as its result table the product of the two tables being joined."},"StatementOptionType":"S"},{"StatementOptionName":"UNION JOIN","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \nUsing a union join is similar to concatenating tables with the OUTER UNION set operator."},"StatementOptionType":"S"},{"StatementOptionName":"CHECK","StatementOptionHelp":{"#cdata":"[constraint][Syntax: CHECK (WHERE-clause)] \n          \nSpecifies that all rows in table-name satisfy the WHERE-clause."},"StatementOptionType":"S"},{"StatementOptionName":"NOT NULL","StatementOptionHelp":{"#cdata":"[constraint] \n          \nSpecifies that the column does not contain a null or missing value, including special \nmissing values."},"StatementOptionType":"S"},{"StatementOptionName":"PRIMARY KEY","StatementOptionHelp":{"#cdata":"[constraint] \n          \nSpecifies that the column is a primary key column, that is, a column that does \nnot contain missing values and whose values are unique."},"StatementOptionType":"S"},{"StatementOptionName":"UNIQUE","StatementOptionHelp":{"#cdata":"[constraint] \n          \nSpecifies that the values of the column must be unique. This constraint is identical \nto DISTINCT."},"StatementOptionType":"S"},{"StatementOptionName":"REFERENCES","StatementOptionHelp":{"#cdata":"[constraint]\n          \n[Syntax: REFERENCES table-name <ON DELETE referential-action > <ON UPDATE referential-action>\n            \nSpecifies that the column is a foreign key, that is, a column whose values are linked \nto the values of the primary key variable in another table (the table-name that is \nspecified for REFERENCES)."},"StatementOptionType":"S","SubOptionsKeywords":"ON DELETE|ON UPDATE"},{"StatementOptionName":"CONSTRAINT","StatementOptionHelp":{"#cdata":"[constraint-specification]\n          \n[Syntax: CONSTRAINT constraint-name constraint <MESSAGE='message-string' <MSGTYPE=message-type>>]"},"StatementOptionType":"S","SubOptionsKeywords":"MESSAGE=|MSGTYPE=|NEWLINE|USER|"},{"StatementOptionName":"ORDER BY","StatementOptionHelp":{"#cdata":"[Syntax: ORDER BY order-by-item] \n          \nSorts the rows in table-name by the values of each order-by-item."},"StatementOptionType":"S"},{"StatementOptionName":"OR","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates logical OR."},"StatementOptionType":"S"},{"StatementOptionName":"ON","StatementOptionHelp":{"#cdata":"[SQL expression keyword] \n          \nUsed in connection with JOIN expressions.\n\nExample:\nSELECT *  FROM   employee  LEFT OUTER JOIN department  \n  ON employee.DepartmentID = department.DepartmentID;"},"StatementOptionType":"S"},{"StatementOptionName":"EQ","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates equals"},"StatementOptionType":"S"},{"StatementOptionName":"NE","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates not equal"},"StatementOptionType":"S"},{"StatementOptionName":"GT","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates greater than"},"StatementOptionType":"S"},{"StatementOptionName":"LT","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates less than"},"StatementOptionType":"S"},{"StatementOptionName":"GE","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates greater than or equal to"},"StatementOptionType":"S"},{"StatementOptionName":"LE","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates less than or equal to"},"StatementOptionType":"S"},{"StatementOptionName":"EQT","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates equal to truncated strings (use with character operands only)"},"StatementOptionType":"S"},{"StatementOptionName":"GTT","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates greater than truncated strings"},"StatementOptionType":"S"},{"StatementOptionName":"LTT","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates less than truncated strings"},"StatementOptionType":"S"},{"StatementOptionName":"GET","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates greater than or equal to truncated strings"},"StatementOptionType":"S"},{"StatementOptionName":"LET","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates less than or equal to truncated strings"},"StatementOptionType":"S"},{"StatementOptionName":"NET","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates not equal to truncated strings"},"StatementOptionType":"S"},{"StatementOptionName":"LEFT","StatementOptionHelp":{"#cdata":"[SQL expression keyword] \n          \nUsed in connection with JOIN expressions.\n\nExample:\nSELECT *  FROM   employee  LEFT OUTER JOIN department  \n  ON employee.DepartmentID = department.DepartmentID;"},"StatementOptionType":"S"},{"StatementOptionName":"RIGHT","StatementOptionHelp":{"#cdata":"[SQL expression keyword] \n          \nUsed in connection with JOIN expressions.\n\nExample:\nSELECT *  FROM   employee  RIGHT OUTER JOIN department  \n  ON employee.DepartmentID = department.DepartmentID;"},"StatementOptionType":"S"},{"StatementOptionName":"BETWEEN","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nSelects rows where column values are within a range of values. \n\nSyntax:\nsql-expression <NOT> BETWEEN sql-expression AND sql-expression"},"StatementOptionType":"S"},{"StatementOptionName":"AND","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates logical AND."},"StatementOptionType":"S"},{"StatementOptionName":"NOT","StatementOptionHelp":{"#cdata":"[SQL expression operator]           \n          \nIndicates logical NOT."},"StatementOptionType":"S"},{"StatementOptionName":"IS","StatementOptionHelp":{"#cdata":"SQL expression operator"},"StatementOptionType":"S"},{"StatementOptionName":"CONTAINS","StatementOptionHelp":{"#cdata":"SQL expression operator"},"StatementOptionType":"S"},{"StatementOptionName":"EXISTS","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nSyntax: <NOT> EXISTS (query-expression) \n          \nTests if a subquery returns one or more rows. "},"StatementOptionType":"S"},{"StatementOptionName":"IN","StatementOptionHelp":{"#cdata":"[SQL expression operator]\n          \nTests set membership. \n\nSyntax:\nsql-expression <NOT> IN (query-expression | constant <, ... constant>)"},"StatementOptionType":"S"},{"StatementOptionName":"ASC","StatementOptionHelp":{"#cdata":"[Syntax: ORDER BY order-by-item <ASC|DESC><, ... order-by-item <ASC|DESC>>;] \n          \nSorts the rows in table-name by the values of each order-by-item in ascending order."},"StatementOptionType":"S"},{"StatementOptionName":"DESC","StatementOptionHelp":{"#cdata":"[Syntax: ORDER BY order-by-item <ASC|DESC><, ... order-by-item <ASC|DESC>>;] \n          \nSorts the rows in table-name by the values of each order-by-item in descending order."},"StatementOptionType":"S"},{"StatementOptionName":"CASE","StatementOptionHelp":{"#cdata":"Selects result values that satisfy specified conditions. \n          \nSyntax:\n  CASE <case-operand>  \n    WHEN when-condition THEN result-expression  \n    <...WHEN when-condition THEN result-expression>  \n    <ELSE result-expression>  \n    END"},"StatementOptionType":"S"},{"StatementOptionName":"WHEN","StatementOptionHelp":{"#cdata":"[Used in a CASE expression] \n          \nSyntax:\n  CASE <case-operand>  \n    WHEN when-condition THEN result-expression  \n    <...WHEN when-condition THEN result-expression>  \n    <ELSE result-expression>  \n    END"},"StatementOptionType":"S"},{"StatementOptionName":"THEN","StatementOptionHelp":{"#cdata":"[Used in a CASE expression] \n          \nSyntax:\n  CASE <case-operand>  \n    WHEN when-condition THEN result-expression  \n    <...WHEN when-condition THEN result-expression>  \n    <ELSE result-expression>  \n    END"},"StatementOptionType":"S"},{"StatementOptionName":"ELSE","StatementOptionHelp":{"#cdata":"[Used in a CASE expression] \n          \nSyntax:\n  CASE <case-operand>  \n    WHEN when-condition THEN result-expression  \n    <...WHEN when-condition THEN result-expression>  \n    <ELSE result-expression>  \n    END"},"StatementOptionType":"S"},{"StatementOptionName":"END","StatementOptionHelp":{"#cdata":"[Used in a CASE expression] \n          \nSyntax:\n  CASE <case-operand>  \n    WHEN when-condition THEN result-expression  \n    <...WHEN when-condition THEN result-expression>  \n    <ELSE result-expression>  \n    END"},"StatementOptionType":"S"}]}},{"StatementName":"CREATE VIEW","StatementHelp":{"#cdata":"Syntax: CREATE VIEW view [SECURITY security-type] AS query-expression; \n\nCreates a view of data from one or more tables or other views."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"SECURITY","StatementOptionHelp":{"#cdata":"[Syntax: SECURITY security-type\n\nSpecifies the type of security that will be enforced for the view. security-type can be one of the following values. \n\n  DEFINER\n    specifies that the view is run with the schema owner\u2019s credentials. \n  INVOKER\n    specifies that the view is run with the invoking user\u2019s credentials. \n\n  Default: If SECURITY is not used, security for the view defaults to INVOKER.  \n  \n  Restriction: Security is available only with SAS Federation Server. The SECURITY security-type argument \n  is ignored in a FedSQL request that is not directed to SAS Federation Server. For more information on the \n  security available through SAS Federation Server, see the documentation for SAS Federation Server."},"StatementOptionType":"S"},{"StatementOptionName":"AS","StatementOptionHelp":{"#cdata":"[Syntax: ...AS query-expression ...] \n          \nSQL keyword"},"StatementOptionType":"S"},{"StatementOptionName":"ORDER BY","StatementOptionHelp":{"#cdata":"[Syntax: <ORDER BY order-by-item<, ... order-by-item>> ] \n          \nSQL keyword"},"StatementOptionType":"S"},{"StatementOptionName":"OR","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates logical OR."},"StatementOptionType":"S"},{"StatementOptionName":"BETWEEN","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nSelects rows where column values are within a range of values. \n\nSyntax:\nsql-expression <NOT> BETWEEN sql-expression AND sql-expression"},"StatementOptionType":"S"},{"StatementOptionName":"AND","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates logical AND."},"StatementOptionType":"S"},{"StatementOptionName":"NOT","StatementOptionHelp":{"#cdata":"[SQL expression operator]           \n          \nIndicates logical NOT."},"StatementOptionType":"S"},{"StatementOptionName":"IS","StatementOptionHelp":{"#cdata":"SQL expression operator"},"StatementOptionType":"S"},{"StatementOptionName":"CONTAINS","StatementOptionHelp":{"#cdata":"SQL expression operator"},"StatementOptionType":"S"},{"StatementOptionName":"EXISTS","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nSyntax: <NOT> EXISTS (query-expression) \n          \nTests if a subquery returns one or more rows. "},"StatementOptionType":"S"},{"StatementOptionName":"IN","StatementOptionHelp":{"#cdata":"[SQL expression operator]\n          \nTests set membership. \n\nSyntax:\nsql-expression <NOT> IN (query-expression | constant <, ... constant>)"},"StatementOptionType":"S"},{"StatementOptionName":"LIKE","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nTests for a matching pattern. \n\nSyntax: \nsql-expression <NOT> LIKE sql-expression <ESCAPE character-expression>"},"StatementOptionType":"S"},{"StatementOptionName":"ASC","StatementOptionHelp":{"#cdata":"[Syntax: ORDER BY order-by-item <ASC|DESC><, ... order-by-item <ASC|DESC>>;] \n          \nSorts the rows by the values of each order-by-item in ascending order."},"StatementOptionType":"S"},{"StatementOptionName":"DESC","StatementOptionHelp":{"#cdata":"[Syntax: ORDER BY order-by-item <ASC|DESC><, ... order-by-item <ASC|DESC>>;] \n          \nSorts the rows by the values of each order-by-item in descending order."},"StatementOptionType":"S"},{"StatementOptionName":"USING","StatementOptionHelp":{"#cdata":"[Syntax: <USING libname-clause<, ... libname-clause>> ] \n          \nSQL keyword"},"StatementOptionType":"S","SubOptionsKeywords":"LIBNAME"},{"StatementOptionName":"SELECT","StatementOptionHelp":{"#cdata":"SQL-expression keyword"},"StatementOptionType":"S"},{"StatementOptionName":"DISTINCT","StatementOptionHelp":{"#cdata":"SQL-expression keyword or constraint"},"StatementOptionType":"S"},{"StatementOptionName":"INTO","StatementOptionHelp":{"#cdata":"SQL-expression keyword"},"StatementOptionType":"S"},{"StatementOptionName":"FROM","StatementOptionHelp":{"#cdata":"SQL-expression keyword"},"StatementOptionType":"S"},{"StatementOptionName":"WHERE","StatementOptionHelp":{"#cdata":"SQL-expression keyword"},"StatementOptionType":"S"},{"StatementOptionName":"GROUP BY","StatementOptionHelp":{"#cdata":"SQL-expression keyword"},"StatementOptionType":"S"},{"StatementOptionName":"HAVING","StatementOptionHelp":{"#cdata":"SQL-expression keyword"},"StatementOptionType":"S"},{"StatementOptionName":"INTERSECT","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \nProduces rows that are common to both query results."},"StatementOptionType":"S"},{"StatementOptionName":"UNION","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \nProduces all unique rows from both queries."},"StatementOptionType":"S"},{"StatementOptionName":"OUTER UNION","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \nConcatenates the query results."},"StatementOptionType":"S"},{"StatementOptionName":"INNER JOIN","StatementOptionHelp":{"#cdata":"Returns a result table for all the rows in a table that have one or more matching \nrows in the other tables, as specified by the sql-expression."},"StatementOptionType":"S"},{"StatementOptionName":"OUTER JOIN","StatementOptionHelp":{"#cdata":"Outer joins are inner joins that have been augmented with rows that did not match \nwith any row from the other table in the join. The three types of outer joins \nare left, right, and full."},"StatementOptionType":"S"},{"StatementOptionName":"LEFT JOIN","StatementOptionHelp":{"#cdata":"Has all the rows from the Cartesian product of the two tables for which the sql-expression \nis true, plus rows from the first table that do not match any row in the second (RIGHTTAB) \ntable."},"StatementOptionType":"S"},{"StatementOptionName":"RIGHT JOIN","StatementOptionHelp":{"#cdata":"Has all the rows from the Cartesian product of the two tables for which the sql-expression \nis true, plus rows from the second table that do not match any row in the first table."},"StatementOptionType":"S"},{"StatementOptionName":"FULL JOIN","StatementOptionHelp":{"#cdata":"Has all the rows from the Cartesian product of the two tables for which the sql-expression \nis true, plus rows from each table that do not match any row in the other table."},"StatementOptionType":"S"},{"StatementOptionName":"CROSS JOIN","StatementOptionHelp":{"#cdata":"A cross join returns as its result table the product of the two tables being joined."},"StatementOptionType":"S"},{"StatementOptionName":"UNION JOIN","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \nUsing a union join is similar to concatenating tables with the OUTER UNION set operator."},"StatementOptionType":"S"},{"StatementOptionName":"CORRESPONDING|CORR","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \nCauses PROC SQL to match the columns in table-expressions by name and not by \nordinal position."},"StatementOptionType":"S"},{"StatementOptionName":"ON","StatementOptionHelp":{"#cdata":"[SQL expression keyword] \n          \nUsed in connection with JOIN expressions.\n\nExample:\nSELECT *  FROM   employee  LEFT OUTER JOIN department  \n  ON employee.DepartmentID = department.DepartmentID;"},"StatementOptionType":"S"},{"StatementOptionName":"EQ","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates equals"},"StatementOptionType":"S"},{"StatementOptionName":"NE","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates not equal"},"StatementOptionType":"S"},{"StatementOptionName":"GT","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates greater than"},"StatementOptionType":"S"},{"StatementOptionName":"LT","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates less than"},"StatementOptionType":"S"},{"StatementOptionName":"GE","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates greater than or equal to"},"StatementOptionType":"S"},{"StatementOptionName":"LE","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates less than or equal to"},"StatementOptionType":"S"},{"StatementOptionName":"EQT","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates equal to truncated strings (use with character operands only)"},"StatementOptionType":"S"},{"StatementOptionName":"GTT","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates greater than truncated strings"},"StatementOptionType":"S"},{"StatementOptionName":"LTT","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates less than truncated strings"},"StatementOptionType":"S"},{"StatementOptionName":"GET","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates greater than or equal to truncated strings"},"StatementOptionType":"S"},{"StatementOptionName":"LET","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates less than or equal to truncated strings"},"StatementOptionType":"S"},{"StatementOptionName":"NET","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates not equal to truncated strings"},"StatementOptionType":"S"},{"StatementOptionName":"LEFT","StatementOptionHelp":{"#cdata":"[SQL expression keyword] \n          \nUsed in connection with JOIN expressions.\n\nExample:\nSELECT *  FROM   employee  LEFT OUTER JOIN department  \n  ON employee.DepartmentID = department.DepartmentID;"},"StatementOptionType":"S"},{"StatementOptionName":"RIGHT","StatementOptionHelp":{"#cdata":"[SQL expression keyword] \n          \nUsed in connection with JOIN expressions.\n\nExample:\nSELECT *  FROM   employee  RIGHT OUTER JOIN department  \n  ON employee.DepartmentID = department.DepartmentID;"},"StatementOptionType":"S"},{"StatementOptionName":"EXCEPT","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \nProduces rows that are part of the first query only."},"StatementOptionType":"S"},{"StatementOptionName":"ALL","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \nThe set operators automatically eliminate duplicate rows from their output tables. \nThe optional ALL keyword preserves the duplicate rows, reduces the execution by one \nstep, and thereby improves the query-expression's performance."},"StatementOptionType":"S"},{"StatementOptionName":"READ=","StatementOptionType":"V"},{"StatementOptionName":"WRITE=","StatementOptionType":"V"},{"StatementOptionName":"PW=","StatementOptionType":"V"}],"#comment":{}}},{"StatementName":"DELETE","StatementHelp":{"#cdata":"Syntax: DELETE FROM table [WHERE <search-condition>]; \n\nwhere:\ntable\n  specifies the table from which you are deleting rows. \n\n  Restriction: If row-level permissions are in effect for the table, you cannot delete rows from the \n  table. Row-level security is available only with SAS Federation Server. \n  Tip: You can use '.*' after the table name for compatibility with Microsoft Access tables.  \n\nDeletes rows from a table."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"FROM","StatementOptionHelp":{"#cdata":"Syntax: FROM table-name|sas/access-view|proc-sql-view \n          \nSpecifies the table/view that you are deleting rows from."},"StatementOptionType":"S"},{"StatementOptionName":"WHERE","StatementOptionHelp":{"#cdata":"Syntax: WHERE <search-condition>\n\nSpecifies any valid WHERE clause used to limit the number of rows that are deleted. \n\nTip: You can use parameter arrays in the WHERE statement."},"StatementOptionType":"S"}]}},{"StatementName":"DESCRIBE VIEW","StatementHelp":{"#cdata":"Syntax: DESCRIBE VIEW [\"catalog\".][\"schema\".]\"view\" \nDESCRIBE VIEW XML [\"catalog\".][\"schema\".]\"view\" \n\nwhere:\ncatalog\n  specifies the catalog that contains the view. \nschema\n  specifies the schema that contains the view. \nview\n  specifies the name of the view. \n\nUse DESCRIBE VIEW to retrieve standard SQL text from a view. Use DESCRIBE VIEW XML to retrieve \nSQL from a view as XML. This eliminates the need to implement a SQL parser on the client. \n\nYou must have ALTER VIEW privilege to run DESCRIBE VIEW on a secured view."},"StatementOptions":{"StatementOption":{"StatementOptionName":"XML","StatementOptionHelp":{"#cdata":"Syntax: DESCRIBE VIEW XML [\"catalog\".][\"schema\".]\"view\" \n          \nUse DESCRIBE VIEW XML to retrieve SQL from a view as XML. This eliminates the need to implement \na SQL parser on the client."},"StatementOptionType":"S"}}},{"StatementName":"DROP INDEX","StatementHelp":{"#cdata":"Syntax: DROP INDEX index [FROM table] [FORCE]; \n\nwhere:\nindex\n  specifies the name of the index to be removed. \n\nFROM table\n  specifies the name of the table where the index resides. \n\n  Requirements: For a SAS data set, SPD Engine data set, and MDS table, you must include the FROM table  \n    syntax in order to specify the name of the table where the index resides.  \n    For all data sources, you must include the FROM table syntax if you connected to the data source using \n    a data source name (DSN) that has SAS security enabled.  \n\nFORCE\n  specifies that the index is removed without error processing. Use the FORCE keyword only when you \n  are certain that removing the index without error processing will not negatively impact the table. \n\nDetails:\nIf you drop a composite index, then the index is removed for all the columns that are named in that index. \n\nNote: The DROP INDEX statement does not apply to indexes that were created by using the PRIMARY KEY or \nUNIQUE constraints of either the CREATE TABLE or ALTER TABLE statements, respectively. To remove those \nindexes, you must first remove the constraint by using the ALTER TABLE statement."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"FROM","StatementOptionHelp":{"#cdata":"Syntax: FROM table\n  \nSpecifies the name of the table where the index resides. \n\nRequirements: \nFor a SAS data set, SPD Engine data set, and MDS table, you must include the FROM table syntax in order \nto specify the name of the table where the index resides.  \n  \nFor all data sources, you must include the FROM table syntax if you connected to the data source using \na data source name (DSN) that has SAS security enabled."},"StatementOptionType":"S"},{"StatementOptionName":"FORCE","StatementOptionHelp":{"#cdata":"Specifies that the index is removed without error processing. Use the FORCE keyword only when you \nare certain that removing the index without error processing will not negatively impact the table."},"StatementOptionType":"S"}]}},{"StatementName":"DROP TABLE","StatementHelp":{"#cdata":"Syntax: DROP TABLE table [FORCE]; \n\nwhere:\ntable\n  specifies the name of the table to be removed. \n\n  Restriction: You cannot alter or drop an MDS table while it is referenced in another transaction or statement. \n  If a request fails, make sure other users are no longer using the table or have disconnected.  \n\nFORCE\n  specifies that the table is dropped without error processing. Use the FORCE keyword only when you \n  are certain that dropping the table without error processing is what you want to do. \n\nDetails:\nThe DROP TABLE statement removes a table definition and all the table's data, metadata, and indexes. \n\nIf you use the DELETE statement to remove all the rows in a table, the table still exists until it is \nremoved with the DROP TABLE statement. \n\nYou cannot use the DROP TABLE statement to remove a table that is referenced by a foreign key constraint. \nYou must drop the foreign key constraint first, and then remove the table. \n\nIf you remove a table with indexed columns, then all the indexes are automatically removed. If you drop \na composite index, then the index is removed for all the columns that are named in that index. \n\nYou should delete references in queries to any tables that you remove."},"StatementOptions":{"StatementOption":{"StatementOptionName":"FORCE","StatementOptionHelp":{"#cdata":"Specifies that the table is dropped without error processing. Use the FORCE keyword only when you \n  are certain that dropping the table without error processing is what you want to do."},"StatementOptionType":"S"}}},{"StatementName":"DROP VIEW","StatementHelp":{"#cdata":"Syntax: DROP VIEW view [FORCE]; \n\nwhere:\nview\n  specifies the name of the view to be removed. \n\nFORCE\n  specifies that the view is removed without error processing. \n\nDetails:\nA view can be considered a virtual table. The view is formed by running a query expression against \none or more tables. Dropping a view does not change any data in the database. Only the metadata that \nis associated with the view is deleted. \n\nAny view on a dropped table can be dropped explicitly by using the DROP VIEW statement."},"StatementOptions":{"StatementOption":{"StatementOptionName":"FORCE","StatementOptionHelp":{"#cdata":"Specifies that the view is removed without error processing."},"StatementOptionType":"S"}}},{"StatementName":"EXECUTE","StatementHelp":{"#cdata":"Syntax: EXECUTE(native-syntax) BY catalog; \n\nwhere:\nnative-syntax\n  specifies a native SQL query that can be run on the catalog\u2019s driver. The EXECUTE statement accepts \n  statements that produce a result set, as well as statements that do not produce a result set. \n\n  Restriction: PROC FEDSQL does not support native syntax that contains embedded bare semicolons. You can, \n  however, use the FedSQL language processor to run these statements.  \n  \n  Note: The SQL statement might be case-sensitive, depending on your data source, and it is passed to \n  the data source exactly as you enter it.  \n\ncatalog\n  specifies the name of a catalog in the existing FedSQL connection. \n\nDetails:\nThe EXECUTE statement is the only way that FedSQL provides to submit native SQL statements that do \nnot produce a result set to a DBMS. Native SQL can be used in the following statements: DDLs, UPDATE, \nSELECT, and bulk loads. \n\nA native connection for HDMD is a FedSQL connection."},"StatementOptions":{"StatementOption":{"StatementOptionName":"BY","StatementOptionHelp":{"#cdata":"[Syntax: BY catalog \n          \nSpecifies to execute by the name of a catalog in the existing FedSQL connection."},"StatementOptionType":"S"}}},{"StatementName":"INSERT INTO","StatementHelp":{"#cdata":"Syntax: INSERT INTO table {VALUES (value | NULL [, ...value | NULL])}; \n\nINSERT INTO table { (column [, ...column]) VALUES (value | NULL [, ...value | NULL]) }; \nINSERT INTO table { (column [, ...column]) [query-expression] }; \n\nwhere:\ntable\n  specifies the name of a table into which you are inserting rows. \nvalue\n  specifies a data value to insert into the table. \ncolumn\n  specifies the column into which you are inserting data. \n\n<query-expression> \n  specifies any valid query expression that returns rows and where the number of columns in each row \n  is the same as the number of items to be inserted."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"NULL","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"S"},{"StatementOptionName":"VALUES","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"S"},{"StatementOptionName":"AS","StatementOptionHelp":{"#cdata":"[Syntax: ...AS query-expression ...] \n          \nSQL keyword"},"StatementOptionType":"S"},{"StatementOptionName":"SELECT","StatementOptionHelp":{"#cdata":"SQL-expression keyword"},"StatementOptionType":"S"},{"StatementOptionName":"DISTINCT","StatementOptionHelp":{"#cdata":"SQL-expression keyword"},"StatementOptionType":"S"},{"StatementOptionName":"INTO","StatementOptionHelp":{"#cdata":"SQL-expression keyword"},"StatementOptionType":"S"},{"StatementOptionName":"FROM","StatementOptionHelp":{"#cdata":"SQL-expression keyword"},"StatementOptionType":"S"},{"StatementOptionName":"WHERE","StatementOptionHelp":{"#cdata":"SQL-expression keyword"},"StatementOptionType":"S"},{"StatementOptionName":"GROUP BY","StatementOptionHelp":{"#cdata":"SQL-expression keyword"},"StatementOptionType":"S"},{"StatementOptionName":"HAVING","StatementOptionHelp":{"#cdata":"SQL-expression keyword"},"StatementOptionType":"S"},{"StatementOptionName":"INTERSECT","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \nProduces rows that are common to both query results."},"StatementOptionType":"S"},{"StatementOptionName":"CORRESPONDING|CORR","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \nCauses PROC SQL to match the columns in table-expressions by name and not by \nordinal position."},"StatementOptionType":"S"},{"StatementOptionName":"EXCEPT","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \nProduces rows that are part of the first query only."},"StatementOptionType":"S"},{"StatementOptionName":"ALL","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \nThe set operators automatically eliminate duplicate rows from their output tables. \nThe optional ALL keyword preserves the duplicate rows, reduces the execution by one \nstep, and thereby improves the query-expression's performance."},"StatementOptionType":"S"},{"StatementOptionName":"UNION","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \nProduces all unique rows from both queries."},"StatementOptionType":"S"},{"StatementOptionName":"OUTER UNION","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \nConcatenates the query results."},"StatementOptionType":"S"},{"StatementOptionName":"INNER JOIN","StatementOptionHelp":{"#cdata":"Returns a result table for all the rows in a table that have one or more matching \nrows in the other tables, as specified by the sql-expression."},"StatementOptionType":"S"},{"StatementOptionName":"OUTER JOIN","StatementOptionHelp":{"#cdata":"Outer joins are inner joins that have been augmented with rows that did not match \nwith any row from the other table in the join. The three types of outer joins \nare left, right, and full."},"StatementOptionType":"S"},{"StatementOptionName":"LEFT JOIN","StatementOptionHelp":{"#cdata":"Has all the rows from the Cartesian product of the two tables for which the sql-expression \nis true, plus rows from the first table that do not match any row in the second (RIGHTTAB) \ntable."},"StatementOptionType":"S"},{"StatementOptionName":"RIGHT JOIN","StatementOptionHelp":{"#cdata":"Has all the rows from the Cartesian product of the two tables for which the sql-expression \nis true, plus rows from the second table that do not match any row in the first table."},"StatementOptionType":"S"},{"StatementOptionName":"FULL JOIN","StatementOptionHelp":{"#cdata":"Has all the rows from the Cartesian product of the two tables for which the sql-expression \nis true, plus rows from each table that do not match any row in the other table."},"StatementOptionType":"S"},{"StatementOptionName":"CROSS JOIN","StatementOptionHelp":{"#cdata":"A cross join returns as its result table the product of the two tables being joined."},"StatementOptionType":"S"},{"StatementOptionName":"UNION JOIN","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \nUsing a union join is similar to concatenating tables with the OUTER UNION set operator."},"StatementOptionType":"S"},{"StatementOptionName":"CHECK","StatementOptionHelp":{"#cdata":"[constraint][Syntax: CHECK (WHERE-clause)] \n          \nSpecifies that all rows in table-name satisfy the WHERE-clause."},"StatementOptionType":"S"},{"StatementOptionName":"NOT NULL","StatementOptionHelp":{"#cdata":"[constraint] \n          \nSpecifies that the column does not contain a null or missing value, including special \nmissing values."},"StatementOptionType":"S"},{"StatementOptionName":"PRIMARY KEY","StatementOptionHelp":{"#cdata":"[constraint] \n          \nSpecifies that the column is a primary key column, that is, a column that does \nnot contain missing values and whose values are unique."},"StatementOptionType":"S"},{"StatementOptionName":"UNIQUE","StatementOptionHelp":{"#cdata":"[constraint] \n          \nSpecifies that the values of the column must be unique. This constraint is identical \nto DISTINCT."},"StatementOptionType":"S"},{"StatementOptionName":"REFERENCES","StatementOptionHelp":{"#cdata":"[constraint]\n          \n[Syntax: REFERENCES table-name <ON DELETE referential-action > <ON UPDATE referential-action>\n            \nSpecifies that the column is a foreign key, that is, a column whose values are linked \nto the values of the primary key variable in another table (the table-name that is \nspecified for REFERENCES)."},"StatementOptionType":"S","SubOptionsKeywords":"ON DELETE|ON UPDATE"},{"StatementOptionName":"CONSTRAINT","StatementOptionHelp":{"#cdata":"[constraint-specification]\n          \n[Syntax: CONSTRAINT constraint-name constraint <MESSAGE='message-string' <MSGTYPE=message-type>>]"},"StatementOptionType":"S","SubOptionsKeywords":"MESSAGE=|MSGTYPE=|NEWLINE|USER|"},{"StatementOptionName":"ORDER BY","StatementOptionHelp":{"#cdata":"[Syntax: ORDER BY order-by-item] \n          \nSorts the rows in table-name by the values of each order-by-item."},"StatementOptionType":"S"},{"StatementOptionName":"OR","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates logical OR."},"StatementOptionType":"S"},{"StatementOptionName":"ON","StatementOptionHelp":{"#cdata":"[SQL expression keyword] \n          \nUsed in connection with JOIN expressions.\n\nExample:\nSELECT *  FROM   employee  LEFT OUTER JOIN department  \n  ON employee.DepartmentID = department.DepartmentID;"},"StatementOptionType":"S"},{"StatementOptionName":"EQ","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates equals"},"StatementOptionType":"S"},{"StatementOptionName":"NE","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates not equal"},"StatementOptionType":"S"},{"StatementOptionName":"GT","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates greater than"},"StatementOptionType":"S"},{"StatementOptionName":"LT","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates less than"},"StatementOptionType":"S"},{"StatementOptionName":"GE","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates greater than or equal to"},"StatementOptionType":"S"},{"StatementOptionName":"LE","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates less than or equal to"},"StatementOptionType":"S"},{"StatementOptionName":"EQT","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates equal to truncated strings (use with character operands only)"},"StatementOptionType":"S"},{"StatementOptionName":"GTT","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates greater than truncated strings"},"StatementOptionType":"S"},{"StatementOptionName":"LTT","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates less than truncated strings"},"StatementOptionType":"S"},{"StatementOptionName":"GET","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates greater than or equal to truncated strings"},"StatementOptionType":"S"},{"StatementOptionName":"LET","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates less than or equal to truncated strings"},"StatementOptionType":"S"},{"StatementOptionName":"NET","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates not equal to truncated strings"},"StatementOptionType":"S"},{"StatementOptionName":"LEFT","StatementOptionHelp":{"#cdata":"[SQL expression keyword] \n          \nUsed in connection with JOIN expressions.\n\nExample:\nSELECT *  FROM   employee  LEFT OUTER JOIN department  \n  ON employee.DepartmentID = department.DepartmentID;"},"StatementOptionType":"S"},{"StatementOptionName":"RIGHT","StatementOptionHelp":{"#cdata":"[SQL expression keyword] \n          \nUsed in connection with JOIN expressions.\n\nExample:\nSELECT *  FROM   employee  RIGHT OUTER JOIN department  \n  ON employee.DepartmentID = department.DepartmentID;"},"StatementOptionType":"S"},{"StatementOptionName":"BETWEEN","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nSelects rows where column values are within a range of values. \n\nSyntax:\nsql-expression <NOT> BETWEEN sql-expression AND sql-expression"},"StatementOptionType":"S"},{"StatementOptionName":"AND","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates logical AND."},"StatementOptionType":"S"},{"StatementOptionName":"NOT","StatementOptionHelp":{"#cdata":"[SQL expression operator]           \n          \nIndicates logical NOT."},"StatementOptionType":"S"},{"StatementOptionName":"IS","StatementOptionHelp":{"#cdata":"SQL expression operator"},"StatementOptionType":"S"},{"StatementOptionName":"CONTAINS","StatementOptionHelp":{"#cdata":"SQL expression operator"},"StatementOptionType":"S"},{"StatementOptionName":"EXISTS","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nSyntax: <NOT> EXISTS (query-expression) \n          \nTests if a subquery returns one or more rows. "},"StatementOptionType":"S"},{"StatementOptionName":"IN","StatementOptionHelp":{"#cdata":"[SQL expression operator]\n          \nTests set membership. \n\nSyntax:\nsql-expression <NOT> IN (query-expression | constant <, ... constant>)"},"StatementOptionType":"S"},{"StatementOptionName":"ASC","StatementOptionHelp":{"#cdata":"[Syntax: ORDER BY order-by-item <ASC|DESC><, ... order-by-item <ASC|DESC>>;] \n          \nSorts the rows in table-name by the values of each order-by-item in ascending order."},"StatementOptionType":"S"},{"StatementOptionName":"DESC","StatementOptionHelp":{"#cdata":"[Syntax: ORDER BY order-by-item <ASC|DESC><, ... order-by-item <ASC|DESC>>;] \n          \nSorts the rows in table-name by the values of each order-by-item in descending order."},"StatementOptionType":"S"},{"StatementOptionName":"CASE","StatementOptionHelp":{"#cdata":"Selects result values that satisfy specified conditions. \n          \nSyntax:\n  CASE <case-operand>  \n    WHEN when-condition THEN result-expression  \n    <...WHEN when-condition THEN result-expression>  \n    <ELSE result-expression>  \n    END"},"StatementOptionType":"S"},{"StatementOptionName":"WHEN","StatementOptionHelp":{"#cdata":"[Used in a CASE expression] \n          \nSyntax:\n  CASE <case-operand>  \n    WHEN when-condition THEN result-expression  \n    <...WHEN when-condition THEN result-expression>  \n    <ELSE result-expression>  \n    END"},"StatementOptionType":"S"},{"StatementOptionName":"THEN","StatementOptionHelp":{"#cdata":"[Used in a CASE expression] \n          \nSyntax:\n  CASE <case-operand>  \n    WHEN when-condition THEN result-expression  \n    <...WHEN when-condition THEN result-expression>  \n    <ELSE result-expression>  \n    END"},"StatementOptionType":"S"},{"StatementOptionName":"ELSE","StatementOptionHelp":{"#cdata":"[Used in a CASE expression] \n          \nSyntax:\n  CASE <case-operand>  \n    WHEN when-condition THEN result-expression  \n    <...WHEN when-condition THEN result-expression>  \n    <ELSE result-expression>  \n    END"},"StatementOptionType":"S"},{"StatementOptionName":"END","StatementOptionHelp":{"#cdata":"[Used in a CASE expression] \n          \nSyntax:\n  CASE <case-operand>  \n    WHEN when-condition THEN result-expression  \n    <...WHEN when-condition THEN result-expression>  \n    <ELSE result-expression>  \n    END"},"StatementOptionType":"S"}]}},{"StatementName":"ROLLBACK","StatementHelp":{"#cdata":"Syntax: ROLLBACK [TRANSACTION]; \n\nWhen your program has completed all of the statements in the transaction, you must explicitly terminate \nthe transaction using COMMIT or ROLLBACK. You use a ROLLBACK statement to roll back, or undo, the changes \nthat have been made since the start of the transaction. \n\nYou cannot roll back the changes to the database after a COMMIT statement is executed. \n\nThe ROLLBACK statement has an effect only when autocommit functionality is off. For most data sources, \nautocommit functionality is on by default. See the server administration documentation for information \nabout how to turn off autocommit functionality. \n\nNote: ROLLBACK has no effect on the SASHDAT data source. "},"StatementOptions":null},{"StatementName":"SELECT","StatementHelp":{"#cdata":"Syntax: SELECT <select-list> FROM <table-specification>\n  [WHERE <search-condition>] [GROUP BY <grouping-column>] [HAVING <search-condition>]\n  [ORDER BY <sort-specification>] [LIMIT {count | ALL}] [OFFSET number]"},"StatementOptions":{"StatementOption":[{"StatementOptionName":"FROM","StatementOptionHelp":{"#cdata":"Syntax: FROM <table-specification> [, ...<table-specification>]\n  <table-specification>::= \n    table [[AS] table-alias] | CONNECTION TO catalog (<native-syntax>) [[AS] alias]\n    | (<query-specification>) [AS] alias | <joined-table>\n\n  <joined-table>::= \n    <cross-join>  | <qualified-join>  | <natural-join>\n\n    <cross-join>::= \n      <table-specification> CROSS JOIN <table-specification>\n\n    <qualified-join>::= \n      <table-specification> [<join-type>] JOIN <table-specification> <join-specification>\n\n    <natural-join>::= \n      <table-specification> NATURAL [<join-type>] JOIN <table-specification>\n\n    <join-type>::= \n      INNER | LEFT [OUTER] | RIGHT [OUTER]  | FULL [OUTER]\n\n    <join-specification>::= \n      ON <search-condition>  | USING (column [, ...column]) \n          \nOptionally specifies source tables."},"StatementOptionType":"S","SubOptionsKeywords":"CONNECTION TO|CROSS|NATURAL|JOIN|INNER|LEFT|RIGHT|FULL|OUTER|AS|ON|USING"},{"StatementOptionName":"WHERE","StatementOptionHelp":{"#cdata":"Syntax: WHERE <search-condition\n          \nwhere:\n<search-condition>\n  specifies the conditions for the rows returned by the WHERE clause. \n\n<search-condition>::= \n  { \n    [NOT] {<sql-expression> | (<search-condition>)} \n    [{AND | OR} [NOT] {<sql-expression> | (<search-condition>)}]\n  } \n    [, ...{[NOT] {<sql-expression> | (<search-condition>)} \n    [{AND | OR} [NOT] {<sql-expression> | (<search-condition>)}]}]\n\n<sql-expression>::= \nexpression {operator | predicate} expression\n          \nSubsets the output based on specified conditions."},"StatementOptionType":"S"},{"StatementOptionName":"GROUP BY","StatementOptionHelp":{"#cdata":"Syntax: GROUP BY <grouping-column>\n          \nwhere:\nGROUP BY <grouping-column> [, ...<grouping-column>]\n\n<grouping-column>::= \n  column [, ...column] | column-position-number | <sql-expression>\n          \nSpecifies how to group the data for summarizing."},"StatementOptionType":"S"},{"StatementOptionName":"HAVING","StatementOptionHelp":{"#cdata":"Syntax: HAVING <search-condition>\n          \nwhere:\n<search-condition>\n  specifies the conditions for the rows returned by the HAVING clause. \n\n<search-condition>::= \n  { \n    [NOT] {<sql-expression> | (<search-condition>)} \n    [{AND | OR} [NOT] {<sql-expression> | (<search-condition>)}]\n  } \n    [, ...{[NOT] {<sql-expression> | (<search-condition>)} \n    [{AND | OR} [NOT] {<sql-expression> | (<search-condition>)}]}]\n\n<sql-expression>::= \nexpression {operator | predicate} expression\n          \nSubsets grouped data based on specified search conditions."},"StatementOptionType":"S"},{"StatementOptionName":"ORDER BY","StatementOptionHelp":{"#cdata":"ORDER BY <sort-specification> [, ...<sort-specification>]; \n\n<sort-specification>::= \n  {order-by-expression [ASC | DESC]} [, ...order-by-expression [ASC | DESC]]\n  | {order-by-expression [COLLATE collating-sequence-options]}\n  [, ...order-by-expression [COLLATE collating-sequence-options]]\n\nASC\n  orders the data in ascending order. This is the default order; if ASC or DESC are not specified, \n  the data is ordered in ascending order. \nDESC\n  orders the data in descending order. \nCOLLATE collating-sequence-options\n  specifies linguistic collation, which sorts characters according to rules of the specified language.\n  The collating-sequence-options argument can be one of the following values: \n    o DANISH | FINNISH | ITALIAN | NORWEGIAN | POLISH | SPANISH | SWEDISH\n    o LINGUISTIC [collating-rules] \n      collating-rules can be one of the following values: \n        ALTERNATE_HANDLING=SHIFTED\n          controls the handling of variable characters like spaces, punctuation, and symbols.\n        CASE_FIRST=\n          specify order of uppercase and lowercase letters.\n        COLLATION= BIG5HAN | DIRECT |GB2312HAN | PHONEBOOK | PINYIN | POSIX | STROKE | TRADITIONAL\n        LOCALE= locale_name\n          specifies the locale name in the form of a POSIX name(for example, ja_JP). \n        NUMERIC_COLLATION= ON | OFF\n          orders integer values within the text by the numeric value instead of characters used to represent the numbers. \n        STRENGTH=|LEVEL= PRIMARY | SECONDARY | TERTIARY | QUATERNARY | IDENTICAL\n          The value of strength is related to the collation level.    \n          \nSpecifies the order in which rows are returned in a result table."},"StatementOptionType":"S","SubOptionsKeywords":"ASC|DESC|COLLATE|ALTERNATE_HANDLING=|CASE_FIRST=|COLLATION=|LOCALE=|NUMERIC_COLLATION=|LEVEL="},{"StatementOptionName":"LIMIT","StatementOptionHelp":{"#cdata":"Syntax: LIMIT {count | ALL} \n\nwhere: \ncount\n  specifies the number of rows that the SELECT statement returns. \n\n  Tip: count can be an integer or any simple expression that resolves to an integer value.  \n\nALL\n  specifies that all rows are returned. \n\nDetails:\nThe LIMIT clause can be used alone or in conjunction with the OFFSET clause. The OFFSET clause \nspecifies the number of rows to skip before the SELECT statement starts to return rows. \n\nNote: When you use the LIMIT clause, it is recommended that you use an ORDER BY clause to create \nan ordered sequence. Otherwise you can get an unpredictable subset of a query's rows."},"StatementOptionType":"S","SubOptionsKeywords":"ALL"},{"StatementOptionName":"OFFSET","StatementOptionHelp":{"#cdata":"Syntax: OFFSET number\nwhere:\nnumber\n  specifies the number of rows to skip. \n\n  Tip: number can be an integer or any simple expression that resolves to an integer value.  \n\nDetails:\nThe OFFSET clause can be used alone or in conjunction with the LIMIT clause. The OFFSET clause \nspecifies the number of rows to skip before the SELECT statement starts to return rows. \n\nNote: When you use the OFFSET clause, it is recommended that you use an ORDER BY clause to \ncreate an ordered sequence. Otherwise you get an unpredictable subset of a query's rows."},"StatementOptionType":"S"},{"StatementOptionName":"UNION","StatementOptionHelp":{"#cdata":"Syntax: {<query-specification> | <query-expression>} \nUNION [ALL | DISTINCT] {<query-specification> | <query-expression>} \n\nArguments: \n<query-specification> | <query-expression>\n  specifies one or more SELECT statements that produces a virtual table. \n\nUNION\n  specifies that multiple result tables are combined and returned as a single result table. \nALL\n  specifies that all rows, including duplicates, are included in the result table. If not specified, all rows are returned. \nDISTINCT\n  specifies that only unique rows can appear in the result table. \n\nDetails:\nThe UNION set operator produces a table that contains all the unique rows that result from both queries. \nThat is, the result table contains rows produced by the first query, the second query, or both."},"StatementOptionType":"S","SubOptionsKeywords":"ALL|DISTINCT"},{"StatementOptionName":"EXCEPT","StatementOptionHelp":{"#cdata":"Syntax: {<query-specification> | <query-expression>} \n  EXCEPT \n  { \n    [ALL | DISTINCT]  | CORRESPONDING [BY (column [, ...column])]\n  }\n{<query-specification> | <query-expression>} \n\nArguments: \n<query-specification> | <query-expression>\n  specifies one or more SELECT statements that produces a virtual table. \n\nEXCEPT\n  specifies that multiple result tables are combined and only those rows that are in the first result \n  table and not in the second result table are included. \nALL\n  specifies that all rows, including duplicates, are included in the result table. If not specified, \n  all rows are returned. \nDISTINCT\n  specifies that only unique rows can appear in the result table. \nCORRESPONDING\n  specifies the columns to include in the query. \nBY\n  specifies that only these columns be included in the result table. \ncolumn\n  specifies the name of the column.\n\nDetails:\nThe EXCEPT set operator produces (from the first query) a result table that has unique rows that are\nnot in the second query. If the intermediate result from the first query has at least one occurrence \nof a row that is not in the intermediate result of the second query, then that row (from the first \nquery) is included in the result table. \n\nThe EXCEPT set operator automatically eliminates duplicate rows from its result tables. The optional \nALL keyword preserves the duplicate rows, reduces the execution by one step, and thereby improves the \nquery's performance. You use it when you want to display all the rows resulting from the query, rather \nthan just the unique rows. The ALL keyword is used only when a set operator is also specified."},"StatementOptionType":"S","SubOptionsKeywords":"DISTINCT|ALL|CORRESPONDING|BY"},{"StatementOptionName":"INTERSECT","StatementOptionHelp":{"#cdata":"Syntax: {<query-specification> | <query-expression>} \nINTERSECT \n  { \n    [ALL | DISTINCT]  | CORRESPONDING [BY (column [, ...column)]]\n  } {<query-specification> | <query-expression>} \n\nArguments: \n<query-specification> | <query-expression>\n  specifies one or more SELECT statements that produces a virtual table. \n\nINTERSECT\n  specifies that multiple result tables are combined and only those rows that are common to both \n  result tables are included. \n  \nALL\n  specifies that all rows, including duplicates, are included in the result table. If not specified, \n  all rows are returned. \n\nDISTINCT  specifies that only unique rows can appear in the result table. \n\nCORRESPONDING specifies the columns to include in the query. \n\nBY \nspecifies that only these columns to be included in the result table. \n\ncolumn \n  specifies the name of the column. \n\nDetails:\nThe INTERSECT operator produces a result table that has rows that are common to both tables. \n\nThe INTERSECT set operator automatically eliminates duplicate rows from its result tables. The optional \nALL keyword preserves the duplicate rows, reduces the execution by one step, and thereby improves the \nquery's performance. You use it when you want to display all the rows resulting from the query, rather \nthan just the unique rows. The ALL keyword is used only when a set operator is also specified."},"StatementOptionType":"S","SubOptionsKeywords":"DISTINCT|ALL|CORRESPONDING|BY"},{"StatementOptionName":"DISTINCT","StatementOptionHelp":{"#cdata":"Eliminates duplicate rows."},"StatementOptionType":"S"},{"StatementOptionName":"INTO","StatementOptionHelp":{"#cdata":"Stores the value of one or more columns for use later in another query \nor SAS statement."},"StatementOptionType":"S"},{"StatementOptionName":"AS","StatementOptionHelp":{"#cdata":"[Syntax: ...AS query-expression ...] \n          \nSQL keyword"},"StatementOptionType":"S"},{"StatementOptionName":"OR","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates logical OR."},"StatementOptionType":"S"},{"StatementOptionName":"ON","StatementOptionHelp":{"#cdata":"[SQL expression keyword] \n          \nUsed in connection with JOIN expressions.\n\nExample:\nSELECT *  FROM   employee  LEFT OUTER JOIN department  \n  ON employee.DepartmentID = department.DepartmentID;"},"StatementOptionType":"S"},{"StatementOptionName":"EQ","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates equals"},"StatementOptionType":"S"},{"StatementOptionName":"NE","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates not equal"},"StatementOptionType":"S"},{"StatementOptionName":"GT","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates greater than"},"StatementOptionType":"S"},{"StatementOptionName":"LT","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates less than"},"StatementOptionType":"S"},{"StatementOptionName":"GE","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates greater than or equal to"},"StatementOptionType":"S"},{"StatementOptionName":"LE","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates less than or equal to"},"StatementOptionType":"S"},{"StatementOptionName":"EQT","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates equal to truncated strings (use with character operands only)"},"StatementOptionType":"S"},{"StatementOptionName":"GTT","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates greater than truncated strings"},"StatementOptionType":"S"},{"StatementOptionName":"LTT","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates less than truncated strings"},"StatementOptionType":"S"},{"StatementOptionName":"GET","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates greater than or equal to truncated strings"},"StatementOptionType":"S"},{"StatementOptionName":"LET","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates less than or equal to truncated strings"},"StatementOptionType":"S"},{"StatementOptionName":"NET","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates not equal to truncated strings"},"StatementOptionType":"S"},{"StatementOptionName":"LEFT","StatementOptionHelp":{"#cdata":"[SQL expression keyword] \n          \nUsed in connection with JOIN expressions.\n\nExample:\nSELECT *  FROM   employee  LEFT OUTER JOIN department  \n  ON employee.DepartmentID = department.DepartmentID;"},"StatementOptionType":"S"},{"StatementOptionName":"RIGHT","StatementOptionHelp":{"#cdata":"[SQL expression keyword] \n          \nUsed in connection with JOIN expressions.\n\nExample:\nSELECT *  FROM   employee  RIGHT OUTER JOIN department  \n  ON employee.DepartmentID = department.DepartmentID;"},"StatementOptionType":"S"},{"StatementOptionName":"BETWEEN","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nSelects rows where column values are within a range of values. \n\nSyntax:\nsql-expression <NOT> BETWEEN sql-expression AND sql-expression"},"StatementOptionType":"S"},{"StatementOptionName":"AND","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nIndicates logical AND."},"StatementOptionType":"S"},{"StatementOptionName":"NOT","StatementOptionHelp":{"#cdata":"[SQL expression operator]           \n          \nIndicates logical NOT."},"StatementOptionType":"S"},{"StatementOptionName":"IS","StatementOptionHelp":{"#cdata":"SQL expression operator"},"StatementOptionType":"S"},{"StatementOptionName":"CONTAINS","StatementOptionHelp":{"#cdata":"SQL expression operator"},"StatementOptionType":"S"},{"StatementOptionName":"EXISTS","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nSyntax: <NOT> EXISTS (query-expression) \n          \nTests if a subquery returns one or more rows. "},"StatementOptionType":"S"},{"StatementOptionName":"IN","StatementOptionHelp":{"#cdata":"[SQL expression operator]\n          \nTests set membership. \n\nSyntax:\nsql-expression <NOT> IN (query-expression | constant <, ... constant>)"},"StatementOptionType":"S"},{"StatementOptionName":"LIKE","StatementOptionHelp":{"#cdata":"[SQL expression operator] \n          \nTests for a matching pattern. \n\nSyntax: \nsql-expression <NOT> LIKE sql-expression <ESCAPE character-expression>"},"StatementOptionType":"S"},{"StatementOptionName":"ASC","StatementOptionHelp":{"#cdata":"Orders the data in ascending order."},"StatementOptionType":"S"},{"StatementOptionName":"DESC","StatementOptionHelp":{"#cdata":"Orders the data in descending order."},"StatementOptionType":"S"},{"StatementOptionName":"INNER JOIN","StatementOptionHelp":{"#cdata":"Returns a result table for all the rows in a table that have one or more matching \nrows in the other tables, as specified by the sql-expression."},"StatementOptionType":"S"},{"StatementOptionName":"OUTER JOIN","StatementOptionHelp":{"#cdata":"Outer joins are inner joins that have been augmented with rows that did not match \nwith any row from the other table in the join. The three types of outer joins \nare left, right, and full."},"StatementOptionType":"S"},{"StatementOptionName":"LEFT JOIN","StatementOptionHelp":{"#cdata":"Has all the rows from the Cartesian product of the two tables for which the sql-expression  \nis true, plus rows from the first table that do not match any row in the second (RIGHTTAB) \ntable."},"StatementOptionType":"S"},{"StatementOptionName":"RIGHT JOIN","StatementOptionHelp":{"#cdata":"Has all the rows from the Cartesian product of the two tables for which the sql-expression \nis true, plus rows from the second table that do not match any row in the first table."},"StatementOptionType":"S"},{"StatementOptionName":"FULL JOIN","StatementOptionHelp":{"#cdata":"Has all the rows from the Cartesian product of the two tables for which the sql-expression \nis true, plus rows from each table that do not match any row in the other table."},"StatementOptionType":"S"},{"StatementOptionName":"CROSS JOIN","StatementOptionHelp":{"#cdata":"A cross join returns as its result table the product of the two tables being joined."},"StatementOptionType":"S"},{"StatementOptionName":"UNION JOIN","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \n Using a union join is similar to concatenating tables with the OUTER UNION set operator."},"StatementOptionType":"S"},{"StatementOptionName":"CORRESPONDING|CORR","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \nCauses PROC SQL to match the columns in table-expressions by name and not by \nordinal position."},"StatementOptionType":"S"},{"StatementOptionName":"ALL","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \nThe set operators automatically eliminate duplicate rows from their output tables. \nThe optional ALL keyword preserves the duplicate rows, reduces the execution by one \nstep, and thereby improves the query-expression's performance."},"StatementOptionType":"S"},{"StatementOptionName":"OUTER UNION","StatementOptionHelp":{"#cdata":"[SQL set operator keyword] \n          \nConcatenates the query results."},"StatementOptionType":"S"},{"StatementOptionName":"CASE","StatementOptionHelp":{"#cdata":"Selects result values that satisfy specified conditions. \n          \nSyntax:\n  CASE <case-operand>  \n    WHEN when-condition THEN result-expression  \n    <...WHEN when-condition THEN result-expression>  \n    <ELSE result-expression>  \n    END"},"StatementOptionType":"S"},{"StatementOptionName":"WHEN","StatementOptionHelp":{"#cdata":"[Used in a CASE expression] \n          \nSyntax:\n  CASE <case-operand>  \n    WHEN when-condition THEN result-expression  \n    <...WHEN when-condition THEN result-expression>  \n    <ELSE result-expression>  \n    END"},"StatementOptionType":"S"},{"StatementOptionName":"THEN","StatementOptionHelp":{"#cdata":"[Used in a CASE expression] \n          \nSyntax:\n  CASE <case-operand>  \n    WHEN when-condition THEN result-expression  \n    <...WHEN when-condition THEN result-expression>  \n    <ELSE result-expression>  \n    END"},"StatementOptionType":"S"},{"StatementOptionName":"ELSE","StatementOptionHelp":{"#cdata":"[Used in a CASE expression] \n          \nSyntax:\n  CASE <case-operand>  \n    WHEN when-condition THEN result-expression  \n    <...WHEN when-condition THEN result-expression>  \n    <ELSE result-expression>  \n    END"},"StatementOptionType":"S"},{"StatementOptionName":"END","StatementOptionHelp":{"#cdata":"[Used in a CASE expression] \n          \nSyntax:\n  CASE <case-operand>  \n    WHEN when-condition THEN result-expression  \n    <...WHEN when-condition THEN result-expression>  \n    <ELSE result-expression>  \n    END"},"StatementOptionType":"S"}]}},{"StatementName":"UPDATE","StatementHelp":{"#cdata":"Syntax: UPDATE table\n  {\n    SET column=<sql-expression> [, ...column=<sql-expression>]\n    | column=value-expression [, ...column=value-expression]\n  }\n[WHERE <sql-expression> | value-expression]; \n\nArguments:\ntable\n  specifies a table name.\ncolumn\n  specifies a column name. \n<sql-expression> \n  specifies any valid SQL expression. \nvalue-expression\n  specifies any valid value expression. \n\nDetails:\nThe UPDATE statement changes the values in all or part of an existing row in a table. \n\nThe SET clause specifies which columns to modify and the values to assign them. Columns that are not \nSET retain their previous values. In the SET clause, a column reference on the left side of the equal \nsign can also appear as part of the expression on the right side of the equal sign. The SET clause uses \nthe current value of the column in the expression. For example, you could use this expression to give \nemployees a $1,000 holiday bonus. \n\n  update payroll set salary = salary + 1000;"},"StatementOptions":{"StatementOption":[{"StatementOptionName":"SET","StatementOptionHelp":{"#cdata":"SET column=sql-expression <, ... column=sql-expression>"},"StatementOptionType":"S"},{"StatementOptionName":"WHERE","StatementOptionHelp":{"#cdata":"<WHERE sql-expression>;"},"StatementOptionType":"S"}]}}]}}}