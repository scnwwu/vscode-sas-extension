{"Procedure":{"Name":"FOREST","ProductGroup":"CAS","ProcedureHelp":{"#cdata":"Syntax: PROC FOREST <options>; \n    AUTOTUNE <options>; \n    CODE <options>; \n    CROSSVALIDATION <KFOLD=number>; \n    GROW criterion; \n    ID variables; \n    INPUT variables </ LEVEL=NOMINAL | INTERVAL>; \n    OUTPUT OUT=CAS-libref.data-table <option>; \n    PARTITION partition-option; \n    SAVESTATE RSTORE=CAS-libref.data-table; \n    TARGET variable </ LEVEL=NOMINAL | INTERVAL>; \n    WEIGHT variable; \n\nThe FOREST procedure creates a predictive model called a forest (which consists of several decision trees)\nin SAS Viya. A predictive model defines a relationship between input variables and a target variable. The\npurpose of a predictive model is to predict a target value from inputs. The FOREST procedure trains the\nmodel; that is, it creates the model by using training data in which the target values are known. The model\ncan then be applied to observations in which the target is unknown. If the predictions fit the new data well,\nthe model is said to generalize well. Good generalization is the primary goal for predictive tasks. A predictive\nmodel might fit the training data well but generalize poorly."},"ProcedureOptions":{"ProcedureOption":[{"ProcedureOptionName":"DATA=","ProcedureOptionHelp":{"#cdata":"Syntax: DATA=CAS-libref.data-table\n      \nNames the input data table for PROC FOREST to use. The default is the most recently created data\ntable. CAS-libref.data-table is a two-level name, where\n\n  CAS-libref refers to a collection of information that is defined in the LIBNAME statement and\n    includes the caslib, which includes a path to the data, and a session identifier, which\n    defaults to the active session but which can be explicitly defined in the LIBNAME\n    statement. \n    \n  data-table specifies the name of the input data table."},"ProcedureOptionType":"DV|RV"},{"ProcedureOptionName":"ASSIGNMISSING=","ProcedureOptionHelp":{"#cdata":"Syntax: ASSIGNMISSING= USEINSEARCH|MACSMALL|NONE  \n      \nSpecifies how PROC FOREST creates a default splitting rule that is used to handle missing values\nand unknown levels. An unknown level is a level of a categorical predictor that does not exist in the\ntraining data but is encountered during scoring.\n\nThis option controls how missing values are used in model training, and controls the creation of the\ndefault splitting rule.\n\nBy default, ASSIGNMISSING=USEINSEARCH."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"USEINSEARCH","@Value2":"MACSMALL","@Value3":"NONE"},"ProcedureOptionToolTips":{"@ToolTip1":"Treats a missing value as a separate, legitimate value in the search for a split for the primary splitting rule. Missing values in interval inputs are treated as a special level that is used during the split process. In the scoring phase, this default rule assigns missing interval inputs to the branch determined during forest growing, and unknown nominal levels to the largest branch in the split.","@ToolTip2":"Treats a missing value as a separate, legitimate value in the search for a split for the primary splitting rule. Missing values in interval inputs are treated as less than any other number. In the scoring phase, this default rule assigns missing interval inputs to the leftmost branch of the split, and unknown nominal levels to the largest branch in the split.","@ToolTip3":"Excludes observations that have any missing variables from training the forest model. In the scoring phase, this default rule assigns missing interval inputs to the leftmost branch of the split, and unknown and missing nominal levels to the largest branch in the split."}},{"ProcedureOptionName":"BINMETHOD=","ProcedureOptionHelp":{"#cdata":"Syntax: BINMETHOD=BUCKET | QUANTILE \n      \nSpecifies how to bin interval input variables prior to growing the forest model. The number of bins \nthat are created is determined by the NUMBIN= option."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"BUCKET","@Value2":"QUANTILE"},"ProcedureOptionToolTips":{"@ToolTip1":"Bins interval input variables into fixed-width bins.","@ToolTip2":"Bins interval input variables into bins according to their quantile. "}},{"ProcedureOptionName":"INBAGFRACTION=","ProcedureOptionHelp":{"#cdata":"Syntax: INBAGFRACTION=number\n      \nSpecifies the fraction of the random bootstrap sample of the training data to be used for growing each\ntree in the forest, where number is a value between 0 and 1.\n\nBy default, INBAGFRACTION=0.6. If you use the AUTOTUNE statement, this option is ignored"},"ProcedureOptionType":"V"},{"ProcedureOptionName":"INMODEL=","ProcedureOptionHelp":{"#cdata":"Syntax: INMODEL=< CAS-libref. >data-table\n      \nSpecifies the data table that you have previously saved as a forest model by using the OUTMODEL=\noption in a previous run of PROC FOREST. CAS-libref.data-table is a two-level name, where CASlibref\nrefers to the caslib and session identifier, and data-table specifies the name of the input data table."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"ISOLATION","ProcedureOptionHelp":{"#cdata":"Syntax: ISOLATION <(SAMPLEN=number)>\n      \nCreates an isolation forest for anomaly detection instead of creating a forest for target prediction. \n\nYou can specify the following option: \n  SAMPLEN=number \n    specifies the number of observations, sampled without replacement, to use in each tree of the isolation forest. \n    By default, SAMPLEN=100."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"LOH=","ProcedureOptionHelp":{"#cdata":"Syntax: LOH=L\nSpecifies a number of variables (L) that are preselected to consider for candidate splits for each node.\nThe variables are selected using the Loh method.\n\nIf L is less than the value of the VARS_TO_TRY= option (m), then the variables are selected from\namong the m variables. If L is greater than or equal to m, or if no L is specified, then the Loh method is\nnot used."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"MAXBRANCH=","ProcedureOptionHelp":{"#cdata":"Syntax: MAXBRANCH=b\n      \nSpecifies the maximum number of children per node in the tree. PROC FOREST tries to create this\nnumber of children unless it is impossible (for example, if a split variable does not have enough levels).\nBy default, MAXBRANCH=2."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"MAXDEPTH=","ProcedureOptionHelp":{"#cdata":"Syntax: MAXDEPTH=number\n      \nSpecifies the maximum depth of the tree to be grown."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"MINLEAFSIZE=","ProcedureOptionHelp":{"#cdata":"Syntax: MINLEAFSIZE=number\n      \nSpecifies the minimum number of observations that each child of a split must contain in the training\ndata table in order for the split to be considered.\nBy default, MINLEAFSIZE=1."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"MINUSEINSEARCH=","ProcedureOptionHelp":{"#cdata":"Syntax: MINUSEINSEARCH=number\n      \nSpecifies a threshold for using missing values in the split search when ASSIGNMISSING=\nUSEINSEARCH. If the number of observations in which the splitting variable has missing\nvalues is greater than or equal to number, then PROC FOREST uses the USEINSEARCH policy to\nhandle missing values for that variable.\n\nBy default, MINUSERINSEARCH=1."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"NOPRINT","ProcedureOptionHelp":{"#cdata":"Suppresses ODS output."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"NTREES=","ProcedureOptionHelp":{"#cdata":"Syntax: NTREES=number\n      \nSpecifies the number of trees to grow in the forest model.\n\nBy default, NTREES=100. If you use the AUTOTUNE statement, this option is ignored."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"NUMBIN=","ProcedureOptionHelp":{"#cdata":"Syntax: NUMBIN=number\n      \nSpecifies the number of bins in which to bin the interval input variables. PROC FOREST bins\ncontinuous predictors to a fixed bin size. This option controls the number of bins and thereby also the\nsize of the bins.\n\nBy default, NUMBIN=100."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"OUTMODEL=","ProcedureOptionHelp":{"#cdata":"Syntax: OUTMODEL=<CAS-libref. >data-table\n      \nSpecifies the data table to which you want to save the forest model. CAS-libref.data-table is a two-level\nname, where CAS-libref refers to the caslib and session identifier, and data-table specifies the name\nof the output data table."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"PRINTTARGET","ProcedureOptionHelp":{"#cdata":"Outputs tables that indicate generated columns in the OUT= table from the OUTPUT statement."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"RBAIMP","ProcedureOptionHelp":{"#cdata":"Creates a variable importance table by using random branch assignment (RBA). This table is created in\naddition to the normal variable importance table that is calculated using the residual sum of squares\n(RSS) error."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"SEED=","ProcedureOptionHelp":{"#cdata":"Syntax: SEED=number\n      \nSpecifies the initial seed for random number generation for model building. The value of number must\nbe an integer. If you do not specify a seed or you specify a value less than or equal to 0, the seed is\ngenerated from reading the time of day from the computer\u2019s clock."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"VARS_TO_TRY=|M=","ProcedureOptionHelp":{"#cdata":"Syntax: VARS_TO_TRY=m | M=m\n      \nSpecifies the number of input variables to consider splitting on in a node, where m ranges from 1 to the\nnumber of input variables.\n\nBy default, m is the square root of the number of input variables. If you use the AUTOTUNE statement,\nthis option is ignored."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"VII=|INTERACTIONIMP=","ProcedureOptionHelp":{"#cdata":"Syntax: VII=2|3 | INTERACTIONIMP=2|3 \n      \nCalculates the variable interaction importance, which is described in the section Variable \nnteraction Importance."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"2","@Value2":"3"},"ProcedureOptionToolTips":{"@ToolTip1":"Calculates the importance of all two-way variable interactions. ","@ToolTip2":"Calculates the importance of all three-way and all two-way variable interactions."}},{"ProcedureOptionName":"VOTE=","ProcedureOptionHelp":{"#cdata":"Syntax: VOTE=MAJORITY |PROBABILITY \n      \nSpecifies how to calculate the predicted probability of the target levels for a nominal target. \nThe predicted level is the level that has the highest predicted probability. This option affects \nthe scoring and fit statistics of the forest model.\n\nBy default, VOTE=PROBABILITY."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"MAJORITY","@Value2":"PROBABILITY"},"ProcedureOptionToolTips":{"@ToolTip1":"Specifies that the predicted probability of each target level is equal to the number of trees in the  forest that predicted that level as the target, divided by the total number of trees in the forest.","@ToolTip2":"Specifies that the predicted probability of each target level is equal to the probability of that  level averaged over each tree in the forest."}}]},"ProcedureStatements":{"ProcedureStatement":[{"StatementName":"AUTOTUNE","StatementHelp":{"#cdata":"Syntax: AUTOTUNE < options > ;\n      \nThe AUTOTUNE statement searches for the best combination of values of the NTREES=, VARS_TO_TRY=,\nand INBAGFRACTION= options in the PROC FOREST statement. (If you specify values for these options,\nthey are ignored.) You cannot specify the AUTOTUNE statement in the same procedure run with either the\nCROSSVALIDATION statement or the PARTITION statement."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"EVALHISTORY=","StatementOptionHelp":{"#cdata":"Syntax: EVALHISTORY=ALL |LOG |NONE |TABLE \n          \nSpecifies how to report the evaluation history of the tuner."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"ALL","@Value2":"LOG","@Value3":"NOE","@Value4":"TABLE"},"StatementOptionToolTips":{"@ToolTip1":"Reports each evaluation in the log and creates the EvaluationHistory ODS table. ","@ToolTip2":"Prints the following information to the log for each evaluation: evaluation number, objective value, best objective value up to that point, evaluation time, and elapsed time since the beginning of the  tuning process.","@ToolTip3":"Suppresses reporting of evaluations in the log and does not create the EvaluationHistory ODS table.","@ToolTip4":"Creates the EvaluationHistory ODS table, which contains all evaluated points. The table contains columns  for the evaluation number, all tuning parameters, and the objective function value."}},{"StatementOptionName":"FRACTION=","StatementOptionHelp":{"#cdata":"Syntax: FRACTION=number\n          \nSpecifies the fraction of all data to be used for validation, where number must be between 0.01 and\n0.99, inclusive. If you specify this option, the tuner uses a single partition validation for finding the\nobjective value (validation error estimate). This option might not be advisable for small or unbalanced\ndata tables where the random assignment of the validation subset might not provide a good estimate of\nerror. For large, balanced data tables, a single validation partition is usually sufficient for estimating\nerror; a single partition is more efficient than cross validation in terms of the total execution time.\nBy default, FRACTION=0.3. You cannot specify this option in combination with the KFOLD= option."},"StatementOptionType":"V"},{"StatementOptionName":"KFOLD=","StatementOptionHelp":{"#cdata":"Syntax: KFOLD=number\n          \nSpecifies the number of partition folds in the cross validation process, where number must be between\n2 and 20, inclusive. If you specify this option, the tuner uses cross validation to find the objective value.\nIn cross validation, each model evaluation requires number of training executions (on number\u20131 data\nfolds) and number of scoring executions (on 1 hold-out fold). Thus, the evaluation time is increased by\napproximately number. For small to medium data tables or for unbalanced data tables, cross validation\nprovides on average a better representation of error across the entire data table (a better generalization\nerror).\nBy default, KFOLD=5. You cannot specify this option in combination with the FRACTION= option."},"StatementOptionType":"V"},{"StatementOptionName":"MAXEVALS=","StatementOptionHelp":{"#cdata":"Syntax: MAXEVALS=number \n          \nSpecifies the maximum number of configuration evaluations allowed for the tuner, where number\nmust be an integer greater than or equal to 3. When the number of evaluations is reached, the tuner\nterminates the search and returns the results. To produce a single objective function value (validation\nerror estimate), each configuration evaluation requires either a single model training and scoring\nexecution on a validation partition, or a number of training and scoring executions equal to the value of\nthe KFOLD= option for cross validation. The MAXEVALS= option might lead to termination before\nthe value of the MAXITER= option or the MAXTIME= option is reached.\nBy default, MAXEVALS=50."},"StatementOptionType":"V"},{"StatementOptionName":"MAXITER=","StatementOptionHelp":{"#cdata":"Syntax: MAXITER=number\n          \nSpecifies the maximum number of iterations of the optimization tuner, where number must be greater\nthan or equal to 1. Each iteration normally involves a number of objective evaluations up to the value\nof the POPSIZE= option. The MAXITER= option might lead to termination before the value of the\nMAXEVALS= option or the MAXTIME= option is reached.\nBy default, MAXITER=5."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=number\n          \nSpecifies the maximum time (in seconds) allowed for the tuner, where number must be greater than or\nequal to 1. When this value is reached, the tuner terminates the search and returns results. The actual\nrun time for optimization might be longer because it includes the remaining time needed to finish\nthe current evaluation. For long-running model training (large data tables), the actual run time might\nsignificantly exceed number. The MAXTIME= option might lead to termination before the value of\nthe MAXEVALS= option or the MAXITER= option is reached.\nBy default, MAXTIME=36000."},"StatementOptionType":"V"},{"StatementOptionName":"NPARALLEL=","StatementOptionHelp":{"#cdata":"Syntax: NPARALLEL=number \n          \nSpecifies the number of evaluations to be performed in parallel, where number must be greater than or \nequal to 0. When SEARCHMETHOD=GA is specified, the value of number is equal to the value of the POPSIZE= \noption minus one. When SEARCHMETHOD=LHS or SEARCHMETHOD=RANDOM is specified, the value of number is equal \nto the value of SAMPLESIZE= option."},"StatementOptionType":"V"},{"StatementOptionName":"OBJECTIVE=","StatementOptionHelp":{"#cdata":"Syntax: OBJECTIVE=function \n          \nSpecifies which measure of model performance the tuner uses as the objective function.\n\nBy default, OBJECTIVE=MISC for nominal targets, and OBJECTIVE=MSE for interval targets."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"ASE","@Value2":"AUC","@Value3":"F05","@Value4":"F1","@Value5":"GAMMA","@Value6":"GINI","@Value7":"KS","@Value8":"MAE","@Value9":"MCE","@Value10":"MCLL","@Value11":"MISC","@Value12":"MSE","@Value13":"MSLE","@Value14":"RASE","@Value15":"RMAE","@Value16":"RMSLE","@Value17":"TAU"},"StatementOptionToolTips":{"@ToolTip1":"Uses average squared error as the objective function.","@ToolTip2":"Uses area under the curve as the objective function (nominal type only).","@ToolTip3":"Uses the F0.5 coefficient as the objective function (nominal type only). ","@ToolTip4":"Uses the F1 coefficient as the objective function (nominal type only).","@ToolTip5":"Uses the gamma coefficient as the objective function (nominal type only).","@ToolTip6":"Uses the Gini coefficient as the objective function (nominal type only). ","@ToolTip7":"Uses the Kolmogorov-Smirnov coefficient as the objective function (nominal type only).","@ToolTip8":"Uses the mean absolute error as the objective function (interval type only).","@ToolTip9":"Uses the misclassification rate as the objective function (nominal type only).","@ToolTip10":"Uses the multiclass log loss as the objective function (nominal type only).","@ToolTip11":"Uses the misclassification error percentage as the objective function (nominal type only).","@ToolTip12":"Uses the mean squared error as the objective function (interval type only).","@ToolTip13":"Uses the mean squared logarithmic error as the objective function (interval type only).","@ToolTip14":"Uses the root average squared error as the objective function.","@ToolTip15":"Uses the root mean absolute error as the objective function (interval type only).","@ToolTip16":"Uses the root mean squared logarithmic error as the objective function (interval type only).","@ToolTip17":"Uses the tau coefficient as the objective function (nominal type only)."}},{"StatementOptionName":"POPSIZE=","StatementOptionHelp":{"#cdata":"Syntax: POPSIZE=number\n          \nSpecifies the maximum number of evaluations in one iteration (population), where number must\nbe greater than or equal to 1. In some cases, the tuner algorithm might generate a number of new\nconfigurations smaller than number.\nBy default, POPSIZE=10."},"StatementOptionType":"V"},{"StatementOptionName":"SAMPLESIZE=","StatementOptionHelp":{"#cdata":"Syntax: SAMPLESIZE=number \n          \nSpecifies the total number of evaluations, where number must be greater than or equal to 1. \nYou can specify this option when SEARCHMETHOD=RANDOM or SEARCHMETHOD=LHS. This option is \nignored when SEARCHMETHOD=GA. \n\nBy default, SAMPLESIZE=50."},"StatementOptionType":"V"},{"StatementOptionName":"SEARCHMETHOD=","StatementOptionHelp":{"#cdata":"Syntax: SEARCHMETHOD=GA |LHS |RANDOM \n          \nSpecifies the search method to use for tuning.\n\nBy default, SEARCHMETHOD=GA."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"GA","@Value2":"LHS","@Value3":"RANDOM"},"StatementOptionToolTips":{"@ToolTip1":"Uses an initial Latin hypercube sample that seeds a genetic algorithm to generate a new population  of alternative configurations at each iteration.","@ToolTip2":"Uses a Latin hypercube to generate a single sample of configurations that is uniform in each tuning  parameter, but random in combinations.","@ToolTip3":"Generates a single sample of purely random configurations. "}},{"StatementOptionName":"TARGETEVENT=","StatementOptionHelp":{"#cdata":"Syntax: TARGETEVENT=string \n          \nSpecifies the target event to use for calculating the selected objective function. This option \nis ignored when the value of the OBJECTIVE= option is not AUC, F1, F05, GINI, GAMMA, TAU, or KS."},"StatementOptionType":"V"},{"StatementOptionName":"TUNINGPARAMETERS=","StatementOptionHelp":{"#cdata":"Syntax: TUNINGPARAMETERS=(suboption |\u2026|<suboption>) \nSyntax: TUNEPARMS=(suboption |\u2026|<suboption>) \n\nSpecifies which parameters to tune and which ranges to tune over. If USEPARAMETERS=STANDARD, \nthis option is ignored. \n\nFor more information about which tuning suboptions are available, see the specific procedure chapters."},"StatementOptionType":"V","SubOptionsKeywords":"NFACTORS|LB=|UB=|VALUES=|INIT=|EXCLUDE|LEARNSTEP|MAXITER"},{"StatementOptionName":"USEPARAMETERS=","StatementOptionHelp":{"#cdata":"Syntax: USEPARAMETERS=tuning-parameter-option \n          \nSpecifies how to handle the TUNINGPARAMETERS= option."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"STANDARD","@Value2":"CUSTOM","@Value3":"COMBINED"},"StatementOptionToolTips":{"@ToolTip1":"Tunes using the default bounds and initial values for all parameters.","@ToolTip2":"Tunes only the parameters that are specified in the TUNINGPARAMETERS= option.","@ToolTip3":"Tunes the parameters that are specified in the TUNINGPARAMETERS= option and uses default bounds  and initial values to tune all other parameters."}}]}},{"StatementName":"CODE","StatementHelp":{"#cdata":"Syntax:  CODE < options > ;\n      \nThe CODE statement writes SAS DATA step code for computing predicted values of the fitted model either\nto a file or to a catalog entry. This code can then be included in a DATA step to score new data."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"COMMENT","StatementOptionHelp":{"#cdata":"Adds comments to the generated code."},"StatementOptionType":"V"},{"StatementOptionName":"FILE=","StatementOptionHelp":{"#cdata":"Syntax: FILE=filename \n          \nNames the external file that saves the generated code. When enclosed in a quoted string (for example,\nFILE=\"c:nmydirnscorecode.sas\"), this option specifies the path and filename for writing the code to\nan external file. If you do not specify a path but your SAS client has a default path, then the code is\nwritten to an external file named filename at that location. You can also specify an unquoted filename\nof no more than eight characters. If the filename is assigned as a fileref in a Base SAS FILENAME\nstatement, the file specified in the FILENAME statement is opened; otherwise, if your SAS client has\na default path, an external file named filename is created.."},"StatementOptionType":"V"},{"StatementOptionName":"FORMATWIDTH=","StatementOptionHelp":{"#cdata":"Syntax: FORMATWIDTH=width\n          \nSpecifies the width to use in formatting derived numbers such as parameter estimates. You can specify\na value in the range 4 to 32; the default is 20."},"StatementOptionType":"V"},{"StatementOptionName":"INDENTSIZE=","StatementOptionHelp":{"#cdata":"Syntax: INDENTSIZE=n\n          \nSpecifies the number of spaces to indent the generated code. You can specify a value in the range 0 to\n10; the default is 3."},"StatementOptionType":"V"},{"StatementOptionName":"LABELID=","StatementOptionHelp":{"#cdata":"Syntax: LABELID=value\n          \nSpecifies a number used to construct array names and statement labels in the generated code. You can\nspecify a value in the range 0 to 1024; the default is randomly chosen."},"StatementOptionType":"V"},{"StatementOptionName":"LINESIZE=|LS=","StatementOptionHelp":{"#cdata":"Syntax: LINESIZE=value | LS=value\n          \nSpecifies the line size for the generated code. You can specify a value in the range 64 to 254; the default\nis 120."},"StatementOptionType":"V"},{"StatementOptionName":"NOTRIM","StatementOptionHelp":{"#cdata":"Bases comparisons of formatted values on the full format width, including blank padding. By default,\nblanks at the beginning and end of strings are ignored."},"StatementOptionType":"S"},{"StatementOptionName":"PCATALL","StatementOptionHelp":{"#cdata":"Generates probabilities for all levels of categorical response variables."},"StatementOptionType":"S"}]}},{"StatementName":"CROSSVALIDATION","StatementHelp":{"#cdata":"Syntax: CROSSVALIDATION <KFOLD=number > ;\n      \nThe CROSSVALIDATION statement performs a k-fold cross validation process to find the average estimated\nvalidation error. You cannot specify the CROSSVALIDATION statement if you specify either the\nAUTOTUNE statement or the PARTITION statement."},"StatementOptions":{"StatementOption":{"StatementOptionName":"KFOLD=","StatementOptionHelp":{"#cdata":"Syntax: KFOLD=number\n          \nSpecifies the number of partition folds in the cross validation process, where number must be between\n2 and 20, inclusive.\n\nBy default, KFOLD=5."},"StatementOptionType":"V","#text":" />\n        "}}},{"StatementName":"GROW","StatementHelp":{"#cdata":"Syntax: GROW criterion < (options) > ;\n      \nThe GROW statement specifies the criterion by which to split a parent node into child nodes. As it grows the\ntree, PROC FOREST calculates the specified criterion for each predictor variable and then splits on the\npredictor variable whose criterion is closest to the value specified for that criterion."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"CHAID","StatementOptionHelp":{"#cdata":"Syntax: CHAID < (options) >\n          \nFor categorical predictor variables, CHAID uses the value (as specified in the ALPHA= option) of a\nchi-square statistic (for a classification tree) or an F statistic (for a regression tree) to merge similar\nlevels of the predictor variable until the number of children in the proposed split reaches the number\nthat you specify in the MAXBRANCH= option. The p-values for the final split determine the variable\non which to split.\n\nFor continuous predictor variables, CHAID chooses the best single split until the number of children\nin the proposed split reaches the value that you specify in the MAXBRANCH= option.\n\nYou can specify the following options:\n  ALPHA=value\n    specifies the maximum p-value for a split to be considered.\n    By default, ALPHA=0.3.\n  BONFERRONI\n    requests a Bonferroni adjustment to the p-value for a variable after the split has been determined.\n    By default, no adjustment is made."},"StatementOptionType":"S","SubOptionsKeywords":"ALPHA=|BONFERRONI"},{"StatementOptionName":"CHISQUARE","StatementOptionHelp":{"#cdata":"Syntax: CHISQUARE < (options) >\n          \nUses a chi-square statistic to split each variable and then uses the p-values that correspond to the\nresulting splits to determine the splitting variable.\n\nYou can specify the following options:\n  ALPHA=value\n    specifies the maximum p-value for a split to be considered.\n    By default, ALPHA=0.3.\n  BONFERRONI\n    requests a Bonferroni adjustment to the p-value for a variable after the split has been determined.\n    By default, no adjustment is made."},"StatementOptionType":"S","SubOptionsKeywords":"ALPHA=|BONFERRONI"},{"StatementOptionName":"ENTROPY|GAIN","StatementOptionHelp":{"#cdata":"Syntax: ENTROPY (<options>)  | GAIN < option >\n          \nUses the gain in information (decrease in entropy) to split each variable and then to determine the split.\n\nYou can specify the following option:\n  MINENTROPY=number\n  MINGAIN=number\n   specifies the minimum gain value to validate a split."},"StatementOptionType":"S","SubOptionsKeywords":"MINENTROPY=|MINGAIN="},{"StatementOptionName":"GINI","StatementOptionHelp":{"#cdata":"Uses the decrease in the Gini index to split each variable and then to determine the split."},"StatementOptionType":"S"},{"StatementOptionName":"IGR","StatementOptionHelp":{"#cdata":"Uses the entropy metric to split each variable and then uses the information gain ratio to determine the\nsplit."},"StatementOptionType":"S"},{"StatementOptionName":"FTEST","StatementOptionHelp":{"#cdata":"Syntax: FTEST < (options) >\n          \nUses an F statistic to split each variable and then uses the resulting p-value to determine the split\nvariable.\n\nYou can specify the following options:\n  ALPHA=value\n    specifies the maximum p-value for a split to be considered.\n    By default, ALPHA=0.3.\n  BONFERRONI\n    requests a Bonferroni adjustment to the p-value for a variable after the split has been determined.\n    By default, no adjustment is made."},"StatementOptionType":"S","SubOptionsKeywords":"ALPHA=|BONFERRONI"},{"StatementOptionName":"RSS|VARIANCE","StatementOptionHelp":{"#cdata":"Uses the change in response variance to split each variable and then to determine the split."},"StatementOptionType":"S"}]}},{"StatementName":"ID","StatementHelp":{"#cdata":"Syntax: ID variables;\n\nThe ID statement lists one or more variables that are to be copied from the input data table \nto the output data tables that are specified in the OUT= option in the OUTPUT statement and \nthe RSTORE= option in the SAVESTATE statement."},"StatementOptions":null},{"StatementName":"INPUT","StatementHelp":{"#cdata":"Syntax: INPUT variables < / LEVEL=NOMINAL | INTERVAL > ;\n      \nThe INPUT statement names input variables that share common options. The INPUT statement can be\nrepeated."},"StatementOptions":{"StatementOption":{"StatementOptionName":"LEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LEVEL=BINARY | NOMINAL | ORDINAL | INTERVAL \n          \nSpecifies the level of measurement of the variables. \n\nBy default, LEVEL=INTERVAL for numeric variables, and LEVEL=NOMINAL for categorical character variables. \nBinary variables are considered to be nominal variables.\n\nBy default, LEVEL=INTERVAL for numeric variables and LEVEL=NOMINAL for categorical variables."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NOMINAL","@Value2":"INTERVAL"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the level of measurement of the variables is nominal.","@ToolTip4":"Specifies that the level of measurement of the variables is interval."}}}},{"StatementName":"OUTPUT","StatementHelp":{"#cdata":"Syntax: OUTPUT OUT=CAS-libref.data-table < option > ;\n      \nThe OUTPUT statement creates an output data table that contains the results of PROC FOREST."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=CAS-libref.data-table\nNames the output data table for PROC FOREST to use. CAS-libref.data-table is a two-level name,\nwhere\n\n  CAS-libref refers to a collection of information that is defined in the LIBNAME statement and\n    includes the caslib, which includes a path to where the data table is to be stored, and\n    a session identifier, which defaults to the active session but which can be explicitly\n    defined in the LIBNAME statement.\n    \n  data-table specifies the name of the output data table."},"StatementOptionType":"V"},{"StatementOptionName":"COPYVAR=|COPYVARS=","StatementOptionHelp":{"#cdata":"Syntax: COPYVAR=variable | COPYVARS=(variables)\n          \nLists one or more variables from the input data table to be transferred to the output data table."},"StatementOptionType":"V"}]}},{"StatementName":"PARTITION","StatementHelp":{"#cdata":"Syntax: PARTITION partition-option ;\n      \nThe PARTITION statement specifies how observations in the input data set are logically partitioned into\ndisjoint subsets for model training, validation, and testing."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"FRACTION","StatementOptionHelp":{"#cdata":"Syntax: FRACTION(< TEST=fraction > < VALIDATE=fraction > < SEED=number >)\n          \nRandomly assigns specified proportions of the observations in the input data table to the roles. You\nspecify the proportions for testing and validation by using the TEST= and VALIDATE= suboptions.\nIf you specify both the TEST= and VALIDATE= suboptions, then the sum of the specified fractions\nmust be less than 1 and the remaining fraction of the observations are assigned to the training role. The\nSEED= option specifies an integer that is used to start the pseudorandom number generator for random\npartitioning of data for training, testing, and validation. If you do not specify SEED=number or if\nnumber is less than or equal to 0, the seed is generated by reading the time of day from the computer\u2019s \nclock."},"StatementOptionType":"V","SubOptionsKeywords":"VALIDATE=|TEST=|SEED="},{"StatementOptionName":"ROLE=|ROLEVAR=","StatementOptionHelp":{"#cdata":"Syntax: ROLE=|ROLEVAR=variable (< TEST='value' > < TRAIN='value' > < VALIDATE='value' >)  \n\nNames the variable in the input data table whose values are used to assign roles to each observation.\nThis variable cannot also appear as an analysis variable in other statements or options. The TEST=,\nTRAIN=, and VALIDATE= suboptions specify the formatted values of this variable that are used to\nassign observation roles. If you do not specify the TRAIN= suboption, then all observations whose\nrole is not determined by the TEST= or VALIDATE= suboption are assigned to the training role."},"StatementOptionType":"V","SubOptionsKeywords":"TRAIN=|VALIDATE=|TEST="}]}},{"StatementName":"SAVESTATE","StatementHelp":{"#cdata":"Syntax: SAVESTATE RSTORE=CAS-libref.data-table;  \n      \nThe SAVESTATE statement creates an analytic store for the model and saves it as a binary object \nin a data table. You can use the analytic store in the ASTORE procedure to score new data."},"StatementOptions":{"StatementOption":{"StatementOptionName":"RSTORE=","StatementOptionHelp":{"#cdata":"Syntax: RSTORE=CAS-libref.data-table \n          \nSpecifies a data table in which to save the analytic store for the model. CAS-libref.data-table \nis a two-level name, where CAS-libref refers to the caslib and session identifier, and data-table \nspecifies the name of the output data table."},"StatementOptionType":"V"}}},{"StatementName":"TARGET","StatementHelp":{"#cdata":"Syntax: TARGET variable < / LEVEL=NOMINAL | INTERVAL > ;\n      \nThe TARGET statement names the variable whose values PROC FOREST tries to predict.\n\nBy default, LEVEL=INTERVAL for numeric variables and LEVEL=NOMINAL for categorical\nvariables."},"StatementOptions":{"StatementOption":{"StatementOptionName":"LEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LEVEL=NOMINAL | INTERVAL\n          \nSpecifies the level of measurement."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NOMINAL","@Value2":"INTERVAL"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the level of measurement of the variables is nominal.","@ToolTip2":"Specifies that the level of measurement of the variables is interval."}}}},{"StatementName":"WEIGHT","StatementHelp":{"#cdata":"Syntax: WEIGHT variable;\n\nThe variable in the WEIGHT statement is used as a weight to perform a weighted analysis of the data. \nObservations that have nonpositive or missing weights are not included in the analysis. If a WEIGHT \nstatement is not included, all observations that are used in the analysis are assigned a weight of 1."},"StatementOptions":null}]}}}