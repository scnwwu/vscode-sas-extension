{"Procedure":{"Name":"GA","ProductGroup":"SAS/OR","ProcedureHelp":{"#cdata":"Syntax: PROC GA options ; \n    ContinueFor Call; \n    Cross Call; \n    Dynamic_array Call; \n    EvaluateLC Call; \n    GetDimensions Call; \n    GetObjValues Call; \n    GetSolutions Call; \n    Initialize Call; \n    MarkPareto Call; \n    Mutate Call; \n    Objective Call; \n    PackBits Call; \n    Program Statements; \n    ReadChild Call; \n    ReadCompare Call; \n    ReadMember Call; \n    ReadParent Call; \n    ReEvaluate Call; \n    SetBounds Call; \n    SetCross Call; \n    SetCrossProb Call; \n    SetCrossRoutine Call; \n    SetElite Call; \n    SetEncoding Call; \n    SetFinalize Call; \n    SetMut Call; \n    SetMutProb Call; \n    SetMutRoutine Call; \n    SetObj Call; \n    SetObjFunc Call; \n    SetProperty Call; \n    SetSel Call; \n    SetUpdateRoutine Call;\n    \nGenetic algorithms are a family of local search algorithms that seek optimal solutions to problems \nby applying the principles of natural selection and evolution. Genetic algorithms can be applied to \nalmost any optimization problem and are especially useful for problems where other calculus-based \ntechniques do not work, such as when the objective function has many local optima, when it is not \ndifferentiable or continuous, or when solution elements are constrained to be integers or sequences. \nIn most cases genetic algorithms require more computation than specialized techniques that take advantage \nof specific problem structures or characteristics. However, for optimization problems with no such \ntechniques available, genetic algorithms provide a robust general method of solution."},"ProcedureOptions":{"ProcedureOption":[{"ProcedureOptionName":"DATA=","ProcedureOptionHelp":{"#cdata":"[Syntax: DATAn=SAS-data-set] \n      \nSpecifies a data set containing data required to specify the problem, where n is an integer \nfrom 1 to 5."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"FIRSTGEN=","ProcedureOptionHelp":{"#cdata":"[Syntax: FIRSTGEN=SAS-data-set] \n      \nSpecifies a SAS data set containing the initial solution generation."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"LASTGEN=","ProcedureOptionHelp":{"#cdata":"[Syntax: LASTGEN=SAS-data-set] \n      \nSpecifies a SAS data set into which the final solution generation is written."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"LIBRARY=","ProcedureOptionHelp":{"#cdata":"[Syntax: LIBRARY=library-list] \n      \nSpecifies a library or group of libraries for the procedure to search to resolve subroutine or function calls."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"MATRIX=","ProcedureOptionHelp":{"#cdata":"[Syntax: MATRIXn=SAS-data-set] \n      \nSpecifies a data set containing two-dimensional matrix data, where n is an integer from 1 to 5. \nA two-dimensional numeric array with the same name as the option is created and initialized from \nthe data set."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"MAXITER=","ProcedureOptionHelp":{"#cdata":"[Syntax: MAXITER=n] \n      \nSpecifies the maximum number of iterations to permit for the optimization process. A ContinueFor \ncall overrides a limit set by this option."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"NOVALIDATEWARNING=","ProcedureOptionHelp":{"#cdata":"[Syntax: NOVALIDATEWARNING=n] \n      \nControls the output of warning messages related to solution validation checking."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"SEED=","ProcedureOptionHelp":{"#cdata":"[Syntax: SEED=n] \n      \nSpecifies an initial seed to begin random number generation. This option is provided for reproducibility \nof results. If it is not specified, or if it is set to 0, a seed is chosen based on the system clock."},"ProcedureOptionType":"V"}]},"ProcedureStatements":{"ProcedureStatement":[{"StatementName":"CALL ContinueFor","StatementHelp":{"#cdata":"Syntax: call ContinueFor( niter );\n\nSets the number of additional iterations for the genetic algorithm optimization. \n\nniter         \nspecifies that the optimization continue for niter more iterations. To stop at the current \niteration, set niter to 0. "},"StatementOptions":null},{"StatementName":"CALL Cross","StatementHelp":{"#cdata":"Syntax: call Cross( selected, seg, type<, parameter1, parameter2, ...> );\n\nExecutes a genetic crossover operator from within a user subroutine. \n\nThe inputs to the subroutine are as follows: \n\n  selected \n  is an array that specifies the solutions to be crossed. \n\n  seg \n  is the desired segment of the solution to which the crossover operator should be applied. \n\n  type \n  is the type of crossover operator to apply, which also determines the number and type of parameters expected. \n  The accepted values for type and the corresponding parameters are:  \n    'arithmetic' real, integer   \n    'cycle'--sequence   \n    'heuristic'--real   \n    'null'--all encodings   \n    'order'--sequence   \n    'pmatch'--sequence   \n    'simple'--real, integer, Boolean  \n    'twopoint'--real, integer, Boolean  \n    'uniform'--real, integer, Boolean  \n    \n  parameter1-n \n  are optional parameters applicable to some operators."},"StatementOptions":null},{"StatementName":"CALL Dynamic_array","StatementHelp":{"#cdata":"Syntax: call Dynamic_array( arrayname, dim1<, dim2, ..., dim6> );\n\nAllocates a numeric array. \n\nThe inputs to the Dynamic_array call are as follows: \n\n  arrayname--is a previously declared array, whose dimensions are to be re-allocated. \n  dim--is the size of the first dimension. \n  dim2,...,dim6--are optional. Up to six dimensions can be specified. \n\nThe Dynamic_array call is normally used to allocate working arrays when the required size of the \narray is data-dependent. It is often useful in user routines for genetic operators or objective \nfunctions to avoid hard-coding array dimensions that might depend on segment length or population \nsize. The array to be allocated must first be declared in an ARRAY statement with the expected \nnumber of dimensions, as in the following example: \n  \n    subroutine sub(nx, ny); \n       array x[1] /nosym; \n       call dynamic_array(x, nx); \n       array xy[1,1] /nosym; \n       call dynamic_array(xy, nx, ny); \n       ..."},"StatementOptions":null},{"StatementName":"CALL EvaluateLC","StatementHelp":{"#cdata":"Syntax: call EvaluateLC( lc, results, sum, selected, seg<, child> );\n      \nEvaluates linear constraints. \n\nThe inputs to the EvaluateLC subroutine are as follows: \n\n  lc--is a two-dimensional array representing the linear constraints.\n\n  results--is a numeric array to receive the magnitude of the constraint violation for each linear \n    constraint. \n    \n  sum--is a variable to receive the sum of the constraint violations over all the constraints. \n\n  selected--is an array identifying the selected solution. \n\n  seg--is the segment of the solution to which the linear constraints apply.\n\n  child--is an optional parameter, and should be specified only when EvaluateLC is called from a \n    user crossover operator."},"StatementOptions":null},{"StatementName":"CALL GetDimensions","StatementHelp":{"#cdata":"Syntax: call GetDimensions( source, dest );\n\nThe inputs to the GetDimensions subroutine are as follows: \n\n  source--is the array variable whose dimensions are desired. \n  dest--is an array to receive the dimensions of source.\n\nThe GetDimensions subroutine is used to get the dimensions of an array passed into a user \nsubroutine. The input dest should be an array of one dimension, with at least as many \nelements as there are dimensions in source (a maximum of 6). Any extra elements in dest \nare filled with zeros."},"StatementOptions":null},{"StatementName":"CALL GetObjValues","StatementHelp":{"#cdata":"Syntax: call GetObjValues( dest, n );\n      \nThe inputs to the GetObjValues subroutine are as follows: \n\n  dest--is an array to receive the objective values. \n  n--is the number of objective values to get. \n\nThe GetObjValues subroutine is used to retrieve the objective values for the current solution \ngeneration. It can be called from a user update routine or finalize routine. If it is called \nfrom a finalize routine, and if the elite parameter from a SetElite call is 1 or greater, then \nthe first elite members of the population are the fittest of the population, and they are sorted \nin order, starting with the most fit. The input dest should be a dimensioned variable, with \ndimension greater than or equal to n."},"StatementOptions":null},{"StatementName":"CALL GetSolutions","StatementHelp":{"#cdata":"Syntax: call GetSolutions( sol, n, seg );\n      \nThe inputs to the GetSolutions subroutine are as follows: \n\n  sol--is an array to receive the solution elements. \n  n--is the number of solutions to get. \n  seg--is the segment of the solution to retrieve. \n\nThe GetSolutions subroutine is used to retrieve solutions from the current generation. \nYou would normally call it from an update or finalize subroutine for post processing\nor analysis. If the elite parameter has been set with a SetElite call, then the first \nelite members of the population are the fittest, and they are sorted in order, starting \nwith the most fit. The sol variable should have two dimensions, with the first dimension \nrepresenting the solution number, and the second representing the element within the \nsolution."},"StatementOptions":null},{"StatementName":"CALL Initialize","StatementHelp":{"#cdata":"Syntax: call Initialize( option, size <,option, size> ... );\n\nThe inputs to the Initialize subroutine are as follows: \n\n  option--is a string that specifies an initialization option. \n  size--is the number of solutions to create by using a given option. \n\nThe Initialize subroutine must be called to create the first solution generation, and can be used\nto reinitialize a solution population during the optimization process. The available options and \ntheir effect are as follows: \n\n  '_uniform_'--generate uniformly distributed solutions\n  '_dataset_'--read solutions from the data set specified in a FIRSTGEN= option. \n  'default'--read solutions from the data set specified in a FIRSTGEN= option, if one was specified. \n    If none was specified or the data set has fewer observations than requested, fill in the remaining \n  solution population by using the '_uniform_' option. \n  '_retain_'--bring forward the best solutions from the current generation. This option cannot be used \n    for the first initialization. \n  'user-routine'--Any string not matching the preceding options is interpreted to be a user-defined \n  initialization routine. See the section \"Defining a User Initialization Routine\" for information \n  about defining an initialization subroutine."},"StatementOptions":null},{"StatementName":"CALL MarkPareto","StatementHelp":{"#cdata":"Syntax: call MarkPareto( result, n, objectives, minmax );\n      \nThe MarkPareto call is used to identify the Pareto-optimal subset from a population of solutions. \n\nThe inputs to the MarkPareto call are as follows: \n\n  result--is a one-dimensional array to accept the results of the evaluation. Its size should be the \n    same as the size of the population being evaluated; result if solution i is Pareto optimal, and \n    0 otherwise. \n    \n  n--is a variable to receive the number of Pareto-optimal solutions. \n  \n  objectives--is a two-dimensional array that contains the multiple objective values for each solution. \n    It should be dimensioned [p,q], where p is the size of the population, and q is greater than or equal to \n    the number of objectives to be considered. \n    \n  minmax--is a one-dimensional array to specify how the objective values are to be used. It should be \n    of size q, where q is greater than or equal to the number of objectives to be considered."},"StatementOptions":null},{"StatementName":"CALL Mutate","StatementHelp":{"#cdata":"Syntax: call Mutate( selected, seg, type<, parameter1, parameter2, ...> );\n      \nExecutes a genetic mutation operator from within a user subroutine. \n\nThe inputs to the subroutine are as follows: \n\n  selected--is an array that specifies the solution to be mutated. \n  seg--is the desired segment of the solution to which the mutation should be applied. \n  type--is the type of mutation operator to apply, which also determines the number and type of parameters expected. \n  parameter1-n--are optional parameters applicable to some operators. \n\nThe accepted values for type and the corresponding parameters are summarized in Table 1.2. \n\n[Type] [Encodings] [Parameters]     \n'delta' real, integer delta, n   \n'invert' sequence     \n'swap' sequence n   \n'uniform' real, integer, Boolean np   \n\nThe parameters are as follows: \n  delta--is a vector of delta values for each component of the solution, used only for the Delta \n    mutation operator. \n  n--specifies the number of solution elements that should be mutated for the Delta operator, and \n    the number of swaps that should be made for the Swap operator. \n  np--specifies the number of solution elements that should be mutated, if np is integer; specifies \n  the mutation probability for each solution element if 0 < np < 1."},"StatementOptions":null},{"StatementName":"CALL PackBits","StatementHelp":{"#cdata":"Syntax: call PackBits( array, start, width, value );\n\nThe inputs to the PackBits subroutine are as follows: \n\n  array--is an array to which the value is to be assigned. \n  start--is the starting position for the bit assignments. \n  width--is the number of bits to assign. \n  value--is the value to be assigned to the bits. For a single bit, this should be 0 or 1. \n\nThe PackBits subroutine facilitates the assignment of bit values into an integer array, \neffectively using the integer array as an array of bits. One common use for this routine \nis within a user genetic operator subroutine to pack bit values into an integer vector \nsolution segment. The bit values assigned with the PackBits call can be retrieved with \nthe UnpackBits function. \n\nThe start parameter is the lowest desired bit position in the bit vector, where the least \nsignificant bit of value is to be stored. The start parameter can range in value from 1 to \nmaxbits, where maxbits is the product of 32 times the number of elements in the integer array."},"StatementOptions":null},{"StatementName":"CALL ReadChild","StatementHelp":{"#cdata":"Syntax: call ReadChild( selected, seg, n, values );\n\nThe inputs to the ReadChild subroutine are as follows: \n\n  selected--specifies the family (parents and children) obtained from the selection process. \n  seg--specifies the solution segment to be read. \n  n--specifies the child in the family from which to read the solution segment. \n  values--specifies an array to receive the solution elements. \n\nThe ReadChild call is used to obtain the solution values for manipulation within a user \ncrossover operator subroutine."},"StatementOptions":null},{"StatementName":"CALL ReadCompare","StatementHelp":{"#cdata":"Syntax: call ReadCompare( selected, seg, n, values );\n\nThe inputs to the ReadCompare subroutine are as follows: \n\n  selected--specifies the pair of solutions to be compared, obtained from the selection process. \n  seg--specifies the solution segment to be read. \n  n--specifies the solution (1 or 2) from which to read the segment. \n  values--specifies an array to receive the solution elements. \n\nThe ReadCompare call is used to obtain the solution values for manipulation within a user\nfitness comparison subroutine, which can be designated in a SetCompareRoutine call."},"StatementOptions":null},{"StatementName":"CALL ReadMember","StatementHelp":{"#cdata":"Syntax: call ReadMember( selected, seg, destination );\n\nThe inputs to the ReadMember subroutine are as follows: \n\n  selected--is a parameter passed to the user subroutine by the GA procedure, which points to the selected solution. \n  seg--specifies which segment of the solution to retrieve. \n  destination--specifies an array in which to store the solution elements. \n\nThe ReadMember call is used within a user objective function or mutation operator to obtain\nthe elements of a selected solution and write them into a specified vector. They can then be \nused to compute an objective value, or in the case of a mutation operator, manipulated and \nwritten back out with a WriteMember call. "},"StatementOptions":null},{"StatementName":"CALL ReadParent","StatementHelp":{"#cdata":"Syntax: call ReadParent( selected, seg, n, destination );\n      \nThe inputs to the ReadParent subroutine are as follows: \n\n  selected--is a parameter passed to the user subroutine by the GA procedure, \n    which points to the selected solution family. \n  seg--is the segment of the desired parent solution to be obtained. \n  n--is the number of the parent, starting at 1. \n  destination--is an array in which to store the solution elements. \n\nThe ReadParent subroutine is called inside a user crossover operator subroutine to obtain\nthe elements of selected parent solutions. Normally you would then manipulate and combine \nthe elements of the two parents and use a WriteChild call to create the child offspring and \ncomplete the action of the crossover operator."},"StatementOptions":null},{"StatementName":"CALL ReEvaluate","StatementHelp":{"#cdata":"Syntax: call ReEvaluate( <index>);\n\nThe inputs to the ReEvaluate subroutine are as follows: \n\n  index\n  is a numeric scalar or array that specifies the indices of the solutions to be updated.\n  The indices correspond to the order of the solutions obtained from a GetSolutions call. \n\nThe ReEvaluate call recomputes the objective values for the current generation. You do not\nnormally need to use this call, because the GA procedure evaluates the objective function\nduring the optimization process in the evaluation phase. This subroutine should be called \nfrom a user update or finalize routine if a parameter that affects the objective value or\nsolution is changed. The optional index parameter enables you to restrict the recomputation \nto the solution or subset of solutions specified. If the index parameter is not supplied, \nthen the objective values of all the solutions will be recomputed."},"StatementOptions":null},{"StatementName":"CALL SetBounds","StatementHelp":{"#cdata":"Syntax: call SetBounds( lower, upper <, seg> );\n\nThe inputs to the SetBounds subroutine are as follows: \n\n  lower--is a lower bound for the solution components. \n  upper--is an upper bound for the solution components. \n  seg--is optional, and specifies a segment of the solution to which the bounds apply. \n    If seg is not specified, then it defaults to a value of 1. \n\nThe SetBounds subroutine is used to establish upper and lower bounds on the solution space. \nIt applies only to integer and real encoding."},"StatementOptions":null},{"StatementName":"CALL SetCross","StatementHelp":{"#cdata":"Syntax: call SetCross( type<, seg><, pname, pvalue><, pname, pvalue>... );\n      \nThe inputs to the SetCross subroutine are as follows: \n\ntype--is the name of the crossover operator to be applied. \nseg--is optional, and specifies a segment of the solution to which the operator should be applied. \n  If seg is not specified, then it defaults to a value of 1. seg needs to be specified only if \n  multisegment encoding is used. \npname--is optional, and specifies the name of a particular property to be set for the crossover operator. \npvalue--specifies the value to be assigned to the corresponding property name.\n\nThe accepted values for type and the corresponding properties are:\n\n[type]  [encodings]  [properties]  \n'arithmetic' real, integer   \n'cycle' sequence   \n'heuristic' real   \n'order' sequence   \n'pmatch' sequence   \n'simple' real, integer, Boolean 'alpha' \n'twopoint' real, integer, Boolean 'alpha' \n'uniform' real, integer, Boolean 'alpha', 'p' \n\nThe SetCross routine is used to assign a standard crossover operator. For multisegment encoding, \nthe operator can be assigned to a particular solution segment with the seg parameter; otherwise\na default segment of 1 is assumed. "},"StatementOptions":null},{"StatementName":"CALL SetCrossProb","StatementHelp":{"#cdata":"Syntax: call SetCrossProb( p );\n\nThe input to the SetCrossProb subroutine is as follows: \n\n  p--is the crossover probability.\n\nThe SetCrossProb subroutine is used to set the crossover probability for the genetic algorithm \noptimization process. The crossover probability p should be between 0 and 1. Typical values for \nthis parameter range from 0.6 to 1.0. The crossover probability will be overridden if required \nby a SetElite call. The elite solutions are passed on to the next generation without undergoing \ncrossover, regardless of the crossover probability."},"StatementOptions":null},{"StatementName":"CALL SetCrossRoutine","StatementHelp":{"#cdata":"Syntax: call SetCrossRoutine( 'routine'<, nparents, nchildren>);\n\nThe inputs to the SetCrossRoutine subroutine are as follows: \n\n  routine--is the name of a subroutine you have defined, which is called when the mutation operator \n    is applied. This parameter must be a string literal; a variable is not accepted. \n  nparents--is optional, and specifies the number of parent solutions the operator requires. If not \n    specified, 2 is assumed. \n  nchildren--is optional, and specifies the number of children solutions the operator will generate. \n    If not specified, 2 is assumed. \n\nInstalls a user subroutine for the crossover operator."},"StatementOptions":null},{"StatementName":"CALL SetElite","StatementHelp":{"#cdata":"Syntax: call SetElite( elite ); \n      \nThe input to the SetElite subroutine is as follows: \n\n  elite--is the number of best solutions to be passed unmodified from the current solution \n    generation to the next. \n   \nThe SetElite subroutine is used to ensure that the best solutions encountered in the optimization\nare not lost by the random selection process. In pure tournament selection, although better solutions \nare more likely to be selected, it is also possible that any given solution will not be chosen to \nparticipate in a tournament, and even if it is selected, it might be modified by crossover or mutation. \nThe SetElite call modifies the optimization process such that the best elite solutions in the current \npopulation are exactly preserved and passed on to the next generation. This behavior is observed \nregardless of the crossover or mutation settings. When a SetElite call is made, the first elite\nsolutions in the population retrieved by a GetSolutions call or output to a data set are the fittest, \nand these elite solutions are sorted so that the most fit is first. In general, using the SetElite \ncall speeds the convergence of the optimization process. However, it can also lead to premature \nconvergence before a true global optimum is reached. If no SetElite call is made, a default elite \nvalue of 1 is used by the GA procedure to make sure that the best solution encountered in the \noptimization process is never lost."},"StatementOptions":null},{"StatementName":"CALL SetEncoding","StatementHelp":{"#cdata":"Syntax: call SetEncoding( encoding );\n\nThe input to the SetEncoding subroutine is as follows: \n\n  encoding--is a string used to specify the form of the solution. \n\nThe SetEncoding subroutine is used to establish the type of problem solution encoding. The encoding \nparameter should be a string of letter-number pairs, where the letter determines the type of encoding: \nI for integer, R for real-valued, S for sequences, and B for Boolean values. Each letter is followed \nby a number to indicate the number of components for that encoding. Multiple letter-number pairs can \nbe used to specify a multisegment encoding. For example, the following call specifies that solutions \nbe in the form of a 10-member integer vector: \n  \n    call SetEncoding('I10');  \n\nThe following call specifies that solutions have a 5-component integer segment and a 10-component \nreal-valued segment: \n  \n    call SetEncoding('I5R10');"},"StatementOptions":null},{"StatementName":"CALL SetFinalize","StatementHelp":{"#cdata":"Syntax: call SetFinalize( 'routine' );\n      \nThe input to the SetFinalize subroutine is as follows: \n\n  routine--is the name of a subroutine you have defined, which is called when the optimization \n    process ends. This parameter must be a string literal; a variable is not accepted. \n\nThe SetFinalize subroutine enables you to define a subroutine to be called at the end of the \noptimization process. You might use this subroutine to perform additional refinements of the \nbest solution, or you could generate and write out additional data for plots or reports."},"StatementOptions":null},{"StatementName":"CALL SetMut","StatementHelp":{"#cdata":"Syntax: call SetMut( type<, seg><, pname, pvalue><, pname, pvalue>... );\n\nThe inputs to the SetMut subroutine are as follows: \n\n  type--is the name of the mutation operator to be applied. \n  seg--is optional, and specifies a segment of the solution to which the operator should be applied. \n    If seg is not specified, then it defaults to a value of 1. seg needs to be specified only if \n    multisegment encoding is used. \n  pname--is optional, and specifies the name of a particular property to be set for the mutation operator. \n  pvalue--specifies the value to be assigned to the corresponding property name. \n  \nThe SetMut routine is used to assign a standard mutation operator. For multisegment encoding, \nthe operator can be assigned to a particular solution segment with the seg parameter; otherwise \na default segment of 1 is assumed. You can set different mutation operators for different segments \nwith multiple SetMut calls. When a mutation event occurs, all the operators will applied to the \nsame solution. If more than one SetMut call is made for the same segment, then the last call \nnullifies any previous call for that segment. Also, a SetMutRoutine call nullifies all previous \nSetMut calls, and a SetMut call nullifies a previous SetMutRoutine call. Properties for the chosen \nmutation operator can be set with optional pname-pvalue pairs. It is also possible to set or reset \noperator properties with a SetProperty call. \n\nThe accepted values for type and the corresponding properties are:\n\n[type]  [encodings]  [properties]  \n'delta' real, integer 'delta', 'nchange' \n'invert' sequence   \n'null' all encodings   \n'swap' sequence 'nswap' \n'uniform' real, integer, Boolean 'nchange','pchange'"},"StatementOptions":null},{"StatementName":"CALL SetMutProb","StatementHelp":{"#cdata":"Syntax: call SetMutProb( p );\n\nThe input to the SetMutProb subroutine is as follows: \n\n  p--is the mutation probability.\n\nThe SetMutProb subroutine is used to set the mutation probability for the genetic algorithm \noptimization. The probability p should be a number between 0 and 1, and is interpreted as the \nprobability that a solution in the next generation should have the mutation operator applied \nto it. If a SetElite call has been made, then the elite solutions do not undergo mutation. \nGenerally, a high mutation probability degrades the convergence of the genetic algorithm \noptimization, but some level of mutation is required to assure a thorough search and avoid \npremature convergence before the global optimum is found. Typical values for p are near 0.05 \nor less."},"StatementOptions":null},{"StatementName":"CALL SetMutRoutine","StatementHelp":{"#cdata":"Syntax: call SetMutRoutine( 'routine' );\n\nThe input to the SetMutRoutine subroutine is as follows: \n\n  routine--is the name of a subroutine you have defined, which is called when the mutation \n  operator is applied. This parameter must be a string literal; a variable is not accepted. \n\nThe SetMutRoutine call enables you to designate a subroutine you have defined to be used\nfor the mutation operator. Your subroutine will be called whenever the mutation operation \nis performed."},"StatementOptions":null},{"StatementName":"CALL SetObj","StatementHelp":{"#cdata":"Syntax: call SetObj( type, minmax, <, seg><, pname, pvalue><, pname, pvalue>... );\n\nThe inputs to the SetObj subroutine are as follows: \n\n  type--is the name of the objective function to be used. \n  minmax--is an indicator to maximize or minimize the objective. A value of 0 is used to specify \n    a minimization, and a value of 1 to specify maximizing the objective. \n  seg--is optional, and specifies a segment of the solution to which the objective function should \n    be applied. If seg is not specified, then it defaults to a value of 1. seg needs to be specified \n    only if multisegment encoding is used. \n  pname--is optional, and specifies the name of a particular property to be set for the objective function. \n  pvalue--specifies the value to be assigned to the corresponding property name. \n\nThe SetObj routine is used to assign a procedure-supplied objective function.  For multisegment \nencoding, the objective can be assigned to a particular solution segment with the seg parameter; \notherwise a default segment of 1 is assumed. If more than one SetObj call is made, then the last \ncall nullifies any previous call. Also, a SetObjFunc call nullifies all previous SetObj calls, \nand a SetObj call nullifies a previous SetObjFunc call. Properties for the chosen objective can \nbe set with optional pname-pvalue pairs. It is also possible to set or reset objective properties \nwith a SetProperty call."},"StatementOptions":null},{"StatementName":"CALL SetObjFunc","StatementHelp":{"#cdata":"Syntax: call SetObjFunc( 'fname', minmax );\n      \nThe inputs to the SetObjFunc subroutine are as follows: \n\n  fname--is the name of a user objective function. This parameter must be a literal string. \n  minmax--is set to 0 to minimize the objective, 1 to maximize. \n\nThe SetObjFunc subroutine is used to designate a user function to be the objective for the \noptimization process. The SetObjFunc call accepts a literal string only for the function name; \nyou cannot use a variable or expression."},"StatementOptions":null},{"StatementName":"CALL SetProperty","StatementHelp":{"#cdata":"Syntax: call SetProperty( optype <, seg>, pname, pvalue <, pname, pvalue>... );\n      \nThe inputs to the SetProperty subroutine are as follows: \n\n  optype--is the type of operator. It should have a value of 'cross' for a crossover operator, \n    'mut' for a mutation operator, 'obj' for an objective function, or 'sel' for a selector. \n  seg--is optional, used only for mutation and crossover operators, and specifies the segment \n    in which the operator resides. It is necessary only for multisegment encoding. The default \n    value if seg is not specified is 1. \n  pname--specifies the name of a particular property to be set. \n  pvalue--specifies the value to be assigned to the corresponding property name. Multiple property \n    name-value pairs can be supplied in a SetProperty call. \n\nThe SetProperty call is used to set or modify properties of a genetic operator, objective function, \nor a selector. It can be called anytime during the optimization process to dynamically adapt optimization \nparameters. For example, you might call SetProperty from a user update routine to reduce the magnitude of \nthe delta vector of a delta mutation operator as the optimization progresses to an optimum. "},"StatementOptions":null},{"StatementName":"CALL SetSel","StatementHelp":{"#cdata":"Syntax: call SetSel( selector <, pname, pvalue><, pname, pvalue>... );\n      \nThe inputs to the SetSel subroutine are as follows: \n\n  selector--is the type of selection strategy to be used. \n  pname--is optional, and specifies the name of a particular property to be set for the \n    selector operator. \n  pvalue--specifies the value to be assigned to the corresponding property name.\n  \nThe supported values for selector and the corresponding selector properties and their default \nvalues are:\n\n[Selector]  [Properties]  [Default values]  \n'tournament' 'size' 2 \n'duel' 'pbest' 0.8 \n\nThe SetSel call is used to specify a selector for the regeneration process, which selects members \nof the current generation to be propagated to the next."},"StatementOptions":null},{"StatementName":"CALL SetUpdateRoutine","StatementHelp":{"#cdata":"Syntax: call SetUpdateRoutine( 'routine' );\n      \nThe input to the SetUpdateRoutine subroutine is as follows: \n\n  routine--is the name of a subroutine you have defined that is called once during each iteration \n  of the optimization process. This parameter must be a string literal; a variable is not accepted. \n\nThe SetUpdate subroutine enables you to define a subroutine to be called at each iteration of the \noptimization process, in order to monitor the progress of the genetic algorithm, adjust optimization \nparameters, or perform calculations that\ndepend on the population as a whole."},"StatementOptions":null},{"StatementName":"CALL ShellSort","StatementHelp":{"#cdata":"Syntax: call ShellSort( x, <, by<, descend> > );\n      \nThe inputs to the ShellSort subroutine are as follows: \n\n  x--is a one or two dimensional array to be sorted. \n  by--is an optional numeric scalar or array that specifies the columns by which the array is to \n    be sorted. If not specified, column 1 is the default. \n  descend--is an optional numeric scalar or array used to specify which columns in the by parameter \n    are to be in descending order. Any columns not specified in a descend parameter will be in ascending\n    order. \n\nThe ShellSort subroutine sorts the x array by the columns specified in the by parameter, with the \nfirst column having highest precedence, and subsequent columns applied within the preceding by groups. \nSorting will be done in ascending order for each column unless that column is also specified in the \ndescend parameter. In general the ShellSort routine does not preserve the original order in case of \nties."},"StatementOptions":null},{"StatementName":"CALL Shuffle","StatementHelp":{"#cdata":"Syntax: call Shuffle( x );\n      \nThe input to the Shuffle subroutine is as follows: \n\n  x--is a numeric array to be randomly shuffled.\n\nThe Shuffle subroutine randomly rearranges the elements of the x array. One example of where it \nmight be used is in a user-supplied initialization routine, to generate a random sequence-encoded \nsolution segment."},"StatementOptions":null},{"StatementName":"CALL UpdateSolutions","StatementHelp":{"#cdata":"Syntax: call UpdateSolutions( sol, n, seg );\n      \nThe inputs to the UpdateSolutions subroutine are as follows: \n\n  sol--is an array containing the replacement solution elements. \n  n--is the number of solutions to update. \n  seg--is the segment of the solution to replace. \n\nThe UpdateSolutions subroutine is used to replace the values of the selected solution segment\nwith new values computed in an update routine. The update routine can be designated in a \nSetUpdateRoutine call. The UpdateSolutions call is often used to implement advanced strategies \nsuch as marking Pareto-optimal sets or employing local optimizations. The sol parameter should \nhave 2 dimensions. The first dimension represents the solution number, and should have a value \nof n or greater. The second dimension represents the element within the solution seg, and should \nbe equal to the segment size."},"StatementOptions":null},{"StatementName":"CALL WriteChild","StatementHelp":{"#cdata":"Syntax: call WriteChild( selected, seg, n, source );\n\nThe inputs to the WriteChild subroutine are as follows: \n\n  selected--is an array specifying the selected family of solutions. The selected array is normally \n    passed into the user subroutine that calls WriteChild, and should be passed unaltered to WriteChild. \n  seg--is the segment to which the elements are to be written. \n  n--is the child within the family to which the elements are to be written. A value of 1 is for the \n    first child, 2 for the second, and so on. \n    source--is an array containing the values to be written. \n\nThe WriteChild subroutine is called inside a user crossover operator subroutine to assign to the \nelements of a selected child solution. It is normally used to complete the action of the crossover \noperator."},"StatementOptions":null},{"StatementName":"CALL WriteMember","StatementHelp":{"#cdata":"Syntax: call WriteMember( selected, seg, source );\n\nThe inputs to the WriteMember subroutine are as follows: \n\n  selected--is an array specifying the selected family of solutions. The selected array is normally \n    passed into the user subroutine that calls WriteMember, and should be passed unaltered to WriteMember. \n  seg--is the segment to which the elements are to be written. \n  source--is an array containing the values to be written. \n\nAssigns values to a selected solution from within a user objective function or mutation operator. \nIt is normally used to complete the action of the objective function or mutation operator. "},"StatementOptions":null},{"StatementName":"CALL","StatementHelp":{"#cdata":"Syntax: CALL routine(parameter-1<, ...parameter-n>); \n      \nInvokes a SAS CALL routine. "},"StatementOptions":null},{"StatementName":"ABORT","StatementHelp":{"#cdata":"Syntax: ABORT; \n      \nTerminates the current DATA step, job, or SAS session."},"StatementOptions":null},{"StatementName":"DELETE","StatementHelp":{"#cdata":"Syntax: DELETE; \n      \nStops processing the current observation."},"StatementOptions":null},{"StatementName":"END","StatementHelp":{"#cdata":"Syntax: END; \n      \nEnds a DO group or SELECT group processing."},"StatementOptions":null},{"StatementName":"GOTO|GO TO","StatementHelp":{"#cdata":"Syntax: GOTO label;\n      \nJumps to a new statement."},"StatementOptions":null},{"StatementName":"IF","StatementHelp":{"#cdata":"Executes a SAS statement for observations that meet specific conditions. \n\nSyntax: \n(1) IF expression THEN statement; \n    <ELSE statement;> \n(2) IF condition;"},"StatementOptions":{"StatementOption":[{"StatementOptionName":"THEN","StatementOptionHelp":{"#cdata":"If the conditions that are specified in the IF clause are met, the IF-THEN statement executes a SAS \nstatement for observations that are read from a SAS data set, for records in an external file, or \nfor computed values."},"StatementOptionType":"S"},{"StatementOptionName":"DO","StatementOptionHelp":{"#cdata":"DO statement in an IF-THEN construct."},"StatementOptionType":"S"},{"StatementOptionName":"NOT","StatementOptionType":"S"},{"StatementOptionName":"OR","StatementOptionType":"S"},{"StatementOptionName":"AND","StatementOptionType":"S"}],"#comment":{}}},{"StatementName":"ELSE","StatementHelp":{"#cdata":"If the condition in an IF-THEN statement is false and an ELSE statement is present, \nthen the ELSE action is carried out."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"THEN","StatementOptionHelp":{"#cdata":"If the conditions that are specified in the IF clause are met, the IF-THEN statement executes a SAS \nstatement for observations that are read from a SAS data set, for records in an external file, or \nfor computed values."},"StatementOptionType":"S"},{"StatementOptionName":"IF","StatementOptionHelp":{"#cdata":"Executes a SAS statement for observations that meet specific conditions."},"StatementOptionType":"S"},{"StatementOptionName":"DO","StatementOptionHelp":{"#cdata":"DO statement in an IF-THEN/ELSE construct."},"StatementOptionType":"S"},{"StatementOptionName":"NOT","StatementOptionType":"S"},{"StatementOptionName":"OR","StatementOptionType":"S"},{"StatementOptionName":"AND","StatementOptionType":"S"}],"#comment":{}}},{"StatementName":"PUT","StatementHelp":{"#cdata":"Syntax: PUT <specification(s)><_ODS_><@|@@>; \n      \nWrites lines to the SAS log, to the SAS output window, or to an external location that is \nspecified in the most recent FILE statement."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"_INFILE_","StatementOptionHelp":{"#cdata":"Writes the last input data record that is read either from the current input file or from the data \nlines that follow a DATELINES statement."},"StatementOptionType":"S"},{"StatementOptionName":"_ALL_","StatementOptionHelp":{"#cdata":"Writes the values of all variables, which includes automatic variables, that are defined in the \ncurrent DATA step by using named output."},"StatementOptionType":"S"},{"StatementOptionName":"_ODS_","StatementOptionHelp":{"#cdata":"Moves data values for all columns (as defined by the ODS option in the FILE statement) into \na special buffer, from which it is eventually written to the data component. The ODS option \nin the FILE statement defines the structure of the data component that holds the results of \nthe DATA step."},"StatementOptionType":"S"},{"StatementOptionName":"OVERPRINT","StatementOptionHelp":{"#cdata":"Causes the values that follow the keyword OVERPRINT to print on the most recently written \noutput line."},"StatementOptionType":"S"},{"StatementOptionName":"_BLANKPAGE_","StatementOptionHelp":{"#cdata":"Advances the pointer to the first line of a new page, even when the pointer is positioned \non the first line and the first column of a new page."},"StatementOptionType":"S"},{"StatementOptionName":"_PAGE_","StatementOptionHelp":{"#cdata":"Advances the pointer to the first line of a new page. SAS automatically begins a new \npage when a line exceeds the current PAGESIZE= value."},"StatementOptionType":"S"}]}},{"StatementName":"RETURN","StatementHelp":{"#cdata":"Syntax: \n      \n(1) RETURN; \n      \nStops executing statements at the current point in the DATA step and returns to a predetermined \npoint in the step. \n\n(2) RETURN (expression);\n      \n Statement within a FUNCTION-ENDSUB block."},"StatementOptions":null},{"StatementName":"SELECT","StatementHelp":{"#cdata":"Executes one of several statements or groups of statements.\n      \nSyntax: \nSELECT <(select-expression)>;  \n  WHEN-1 (when-expression-1 <..., when-expression-n>) statement;  \n    <... WHEN-n (when-expression-1 <..., when-expression-n>) statement;>  \n      <OTHERWISE statement;> \nEND;"},"StatementOptions":null},{"StatementName":"WHEN","StatementHelp":{"#cdata":"SELECT groups contain WHEN statements that identify SAS statements that are executed when a particular \ncondition is true. Use at least one WHEN statement in a SELECT group.\n      \nSyntax: WHEN-1 (when-expression-1 <..., when-expression-n>) statement; "},"StatementOptions":{"StatementOption":{"StatementOptionName":"DO","StatementOptionType":"S"}}},{"StatementName":"OTHERWISE","StatementHelp":{"#cdata":"An optional OTHERWISE statement specifies a statement to be executed if no WHEN condition is met. \nAn END statement ends a SELECT group.\n\n      \nSyntax: \n  <... WHEN-n (when-expression-1 <..., when-expression-n>) statement;>  \n    <OTHERWISE statement;>"},"StatementOptions":null},{"StatementName":"STOP","StatementHelp":{"#cdata":"Syntax: STOP; \n      \nStops execution of the current DATA step."},"StatementOptions":null},{"StatementName":"WHERE","StatementHelp":{"#cdata":"Syntax: WHERE where-expression-1 \n  < logical-operator where-expression-n>; \n  \nSelects observations from SAS data sets that meet a particular condition."},"StatementOptions":null},{"StatementName":"DO","StatementHelp":{"#cdata":"Specifies a group of statements to be executed as a unit.\n      \nSyntax: \n(1) DO; \n...more SAS statements...  \nEND;  \n\n(2) DO index-variable=specification-1 <, ... specification-n>; \n... more SAS statements ...  \nEND;  \n\n(3) DO UNTIL (expression); \n...more SAS statements...  \nEND \n\n(4) DO WHILE (expression); \n...more SAS statements...  \nEND;"},"StatementOptions":{"StatementOption":[{"StatementOptionName":"UNTIL","StatementOptionHelp":{"#cdata":"Executes statements in a DO loop repetitively until a condition is true.\n          \nSyntax: \nDO UNTIL (expression); \n...more SAS statements...  \nEND"},"StatementOptionType":"S"},{"StatementOptionName":"WHILE","StatementOptionHelp":{"#cdata":"Executes statements in a DO-loop repetitively while a condition is true. \n          \nSyntax: \nDO WHILE (expression); \n...more SAS statements...  \nEND;"},"StatementOptionType":"S"},{"StatementOptionName":"OVER","StatementOptionType":"S"},{"StatementOptionName":"TO","StatementOptionHelp":{"#cdata":"Separates the start and stop integers or expressions that control the number of times the \nportion of the DATA step between the iterative DO and END statements is processed."},"StatementOptionType":"S"},{"StatementOptionName":"BY","StatementOptionHelp":{"#cdata":"Precedes an increment integer (other than 0) or an expression that generates an integer to be \nadded to the value of the index variable in each iteration of the DO loop."},"StatementOptionType":"S"}]}},{"StatementName":"ARRAY","StatementHelp":{"#cdata":"Syntax: ARRAY array-name[dimensions] </NOSYMBOLS | variable(s) | constant(s) | (initial-values)>;\n      \nAssociates a name with a list of variables and constants."},"StatementOptions":{"StatementOption":{"StatementOptionName":"NOSYMBOLS","StatementOptionHelp":{"#cdata":"Specifies that an array of numeric or character values be created without the associated \nelement variables. In this case, the only way you can access elements in the array is by \narray subscripting."},"StatementOptionType":"S"}}},{"StatementName":"FUNCTION","StatementHelp":{"#cdata":"Syntax: FUNCTION function-name(argument-1, ..., argument-n) <VARARGS> <$> <length> <KIND | GROUP='string'>;  \n        ... more-program-statements ...  \n        RETURN (expression);  \n      ENDSUB; \n \nSpecifies a subroutine declaration for a routine that returns a value."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"VARARGS","StatementOptionHelp":{"#cdata":"Specifies that the function supports a variable number of arguments.\nIf you specify VARARGS, then the last argument in the function must be an array."},"StatementOptionType":"S"},{"StatementOptionName":"KIND=|GROUP=","StatementOptionHelp":{"#cdata":"[Syntax: KIND= | GROUP='string'] \n          \nSpecifies a collection of items that have specific attributes."},"StatementOptionType":"V"}]}},{"StatementName":"SUBROUTINE","StatementHelp":{"#cdata":"Syntax: SUBROUTINE subroutine-name (argument-1, ..., argument-n) <VARARGS> <KIND | GROUP='string'>;   \n        OUTARGS out-argument-1, ..., out-argument-n;  \n        ... more-program-statements ...  \n      ENDSUB; \n\nDeclares (creates) an independent computational block of code that you can call \nusing a CALL statement."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"VARARGS","StatementOptionHelp":{"#cdata":"Specifies that the subroutine has a variable argument length. In this case, the last \nargument must be an array. The array accepts the variable arguments."},"StatementOptionType":"S"},{"StatementOptionName":"OUTARGS","StatementOptionHelp":{"#cdata":"Specifies arguments from the argument list that the subroutine should update."},"StatementOptionType":"S"},{"StatementOptionName":"KIND=|GROUP=","StatementOptionHelp":{"#cdata":"[Syntax: KIND= | GROUP='string'] \n          \nSpecifies a collection of items that have specific attributes."},"StatementOptionType":"V"}]}},{"StatementName":"OUTARGS","StatementHelp":{"#cdata":"Syntax: OUTARGS out-argument-1, ..., out-argument-n; \n      \nSpecifies arguments from the argument list that the subroutine should update."},"StatementOptions":null},{"StatementName":"ENDSUB","StatementHelp":{"#cdata":"Syntax: ENDSUB;\n      \nEnds a FUNCTION or SUBROUTINE statement block."},"StatementOptions":null}],"#comment":{}}}}