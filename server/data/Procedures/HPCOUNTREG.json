{"Procedure":{"Name":"HPCOUNTREG","ProductGroup":"ETS/HPA","#comment":{},"ProcedureHelp":{"#cdata":"Syntax: PROC HPCOUNTREG options ;\n    BOUNDS bound1 [ , bound2 . . . ] ;\n    FREQ freq-variable ;\n    INIT initvalue1 [ , initvalue2 . . . ] ;\n    MODEL dependent variable-variable = regressors / options ;\n    OUTPUT options ;\n    PERFORMANCE options ;\n    RESTRICT restriction1 [, restriction2 . . . ] ;\n    WEIGHT variable ;\n    ZEROMODEL dependent variable ~ zero-inflated regressors / options \n\nThe HPCOUNTREG procedure is a high-performance procedure to fit regression models on the SAS \nappliance in which the dependent variable takes nonnegative integer or count values. \nWith the HPCOUNTREG procedure you can read and write data in distributed form and perform \nanalyses in parallel in SMP or MPP mode. \n\nThe HPCOUNTREG procedure is specifically designed to operate in the high-performance distributed \nenvironment. By default, PROC HPCOUNTREG performs computations in multiple threads. In contrast, \nthe COUNTREG procedure executes in a single thread."},"ProcedureOptions":{"ProcedureOption":[{"ProcedureOptionName":"DATA=","ProcedureOptionHelp":{"#cdata":"[Syntax: DATA=SAS-data-set] \n      \nSpecifies the input SAS data set. If the DATA= option is not specified, PROC HPCOUNTREG \nuses the most recently created SAS data set."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"OUTEST=","ProcedureOptionHelp":{"#cdata":"[Syntax: OUTEST=SAS-data-set] \n      \nWrites the parameter estimates to an output data set."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"COVOUT","ProcedureOptionHelp":{"#cdata":"Writes the covariance matrix for the parameter estimates to the OUTEST= data set. \nThis option is valid only if the OUTEST= option is specified."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"CORRB","ProcedureOptionHelp":{"#cdata":"Prints the correlation matrix of the parameter estimates. This option\ncan also be specified in the MODEL statement."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"COVB","ProcedureOptionHelp":{"#cdata":"Prints the covariance matrix of the parameter estimates."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"ITPRINT","ProcedureOptionHelp":{"#cdata":"Prints the objective function and parameter estimates at each iteration. The objective function is the\nnegative log-likelihood function."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"NOPRINT","ProcedureOptionHelp":{"#cdata":"Suppresses all printed output."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"PRINTALL","ProcedureOptionHelp":{"#cdata":"Requests all printing options."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"COVEST=","ProcedureOptionHelp":{"#cdata":"Specifies the type of covariance matrix of the parameter estimates. The quasi-maximum \nlikelihood estimates are computed with COVEST=QML. The default is COVEST=HESSIAN."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"OP","@Value2":"HESSIAN","@Value3":"QML"},"ProcedureOptionToolTips":{"@ToolTip1":"Specifies the covariance from the outer product matrix.","@ToolTip2":"Specifies the covariance from the Hessian matrix.","@ToolTip3":"Specifies the covariance from the outer product and Hessian matrices."}},{"ProcedureOptionName":"METHOD=","ProcedureOptionHelp":{"#cdata":"Specifies the iterative minimization method to use. The default is METHOD=NRA."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"CG","@Value2":"DD","@Value3":"NRA","@Value4":"NRR","@Value5":"QN","@Value6":"TR","@Value7":"NONE"},"ProcedureOptionToolTips":{"@ToolTip1":"Specifies the conjugate-gradient method.","@ToolTip2":"Specifies the double dogleg method.","@ToolTip3":"Specifies the Newton-Raphson method (the default).","@ToolTip4":"Specifies the Newton-Raphson Ridge method.","@ToolTip5":"Specifies the quasi-Newton method.","@ToolTip6":"Specifies the trust region method.","@ToolTip7":"Specifies that no optimization be performed beyond using the ordinary least squares method to compute the parameter estimates."}},{"ProcedureOptionName":"ABSCONV=|ABSTOL=","ProcedureOptionHelp":{"#cdata":"[Syntax: ABSCONV= | ABSTOL=r] \n      \nSpecifies an absolute function convergence criterion."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"ABSFCONV=|ABSFTOL=","ProcedureOptionHelp":{"#cdata":"[Syntax: ABSFCONV=r<n> | ABSFTOL=r<n>] \n      \nSpecifies an absolute function convergence criterion."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"ABSGCONV=|ABSGTOL=","ProcedureOptionHelp":{"#cdata":"[Syntax: ABSGCONV=r<n> | ABSGTOL=r<n>] \n      \nSpecifies an absolute gradient convergence criterion. Termination requires the maximum \nabsolute gradient element to be small."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"ABSXCONV=|ABSXTOL=","ProcedureOptionHelp":{"#cdata":"[Syntax: ABSXCONV= | ABSXTOL=r<n>] \n      \nSpecifies the absolute parameter convergence criterion. Termination requires a small \nEuclidean distance between successive parameter vectors."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"DAMPSTEP=|DS=","ProcedureOptionHelp":{"#cdata":"[Syntax: DAMPSTEP | DS  <=r>] \n      \nSpecifies that the initial step-size value a\u2070 for each line search (used by the QUANEW, \nCONGRA, or NEWRAP technique) cannot be larger than r times the step-size value used in the \nformer iteration."},"ProcedureOptionType":"S|V"},{"ProcedureOptionName":"FCONV=|FTOL=","ProcedureOptionHelp":{"#cdata":"[Syntax: FCONV=r | FTOL=r] \n      \nSpecifies the relative function convergence criterion."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"FCONV2=|FTOL2=","ProcedureOptionHelp":{"#cdata":"[Syntax: FCONV2= | FTOL2=r <n>] \n      \nSpecifies a second function convergence criterion."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"FSIZE=","ProcedureOptionHelp":{"#cdata":"[Syntax:FSIZE=r] \n      \nSpecifies the FSIZE parameter of the relative function and relative gradient termination \ncriteria. The default value is r=0."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"GCONV=|GTOL=","ProcedureOptionHelp":{"#cdata":"[Syntax: GCONV=r | GTOL=r] \n      \nSpecifies the relative gradient convergence criterion."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"HESCAL=|HS=","ProcedureOptionHelp":{"#cdata":"Specifies the scaling version of the Hessian or crossproduct Jacobian matrix used in NRRIDG, \nTRUREG, LEVMAR, NEWRAP, or DBLDOG optimization."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"0","@Value2":"1","@Value3":"2","@Value4":"3"},"ProcedureOptionToolTips":{"@ToolTip1":"Specifies that no scaling is done.","@ToolTip2":"Specifies the Mor\u00e9 (1978) scaling update","@ToolTip3":"Specifies the Dennis, Gay, and Welsch (1981) scaling update","@ToolTip4":"Specifies that di is reset in each iteration"}},{"ProcedureOptionName":"INHESSIAN=","ProcedureOptionHelp":{"#cdata":"[Syntax: INHESSIAN<=r>] \n      \nSpecifies how the initial estimate of the approximate Hessian is defined for the quasi-Newton \ntechniques QUANEW and DBLDOG."},"ProcedureOptionType":"S|V"},{"ProcedureOptionName":"INSTEP=|SALPHA=|RADIUS=","ProcedureOptionHelp":{"#cdata":"[Syntax: INSTEP=r] \n      \nReduces the length of the first trial step during the line search of the first iterations."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"LINESEARCH=|LIS=|SMETHOD=|SM=","ProcedureOptionHelp":{"#cdata":"[Syntax: LINESEARCH | LIS | SMETHOD | SM=i] \n      \nSpecifies the line-search method for the CONGRA, QUANEW, and NEWRAP optimization techniques."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"1","@Value2":"2","@Value3":"3","@Value4":"4","@Value5":"5","@Value6":"6","@Value7":"7","@Value8":"8"},"ProcedureOptionToolTips":{"@ToolTip1":"Specifies a line-search method that needs the same number of function and gradient calls  for cubic interpolation and cubic extrapolation; this method is similar to one used by  the Harwell subroutine library.","@ToolTip2":"Specifies a line-search method that needs more function calls than gradient calls for quadratic  and cubic interpolation and cubic extrapolation; this method is implemented as shown in Fletcher  (1987) and can be modified to an exact line search by using the LSPRECISION= option.","@ToolTip3":"Specifies a line-search method that needs the same number of function and gradient calls for  cubic interpolation and cubic extrapolation; this method is implemented as shown in Fletcher  (1987) and can be modified to an exact line search by using the LSPRECISION= option.","@ToolTip4":"Specifies a line-search method that needs the same number of function and gradient calls for  stepwise extrapolation and cubic interpolation","@ToolTip5":"Specifies a line-search method that is a modified version of LIS=4.","@ToolTip6":"Specifies golden section line search (Polak 1971), which uses only function values for linear  approximation.","@ToolTip7":"Specifies bisection line search (Polak 1971), which uses only function values for linear  approximation.","@ToolTip8":"Specifies Armijo line-search technique (Polak 1971), which uses only function values for  linear approximation."}},{"ProcedureOptionName":"LSPRECISION=|LSP=|SPRECISION=|SP=","ProcedureOptionHelp":{"#cdata":"[Syntax: LSPRECISION=r | LSP=r | SPRECISION=r | SP=r] \n      \nSpecifies the degree of accuracy that should be obtained by the line-search algorithms \nLIS=2 and LIS=3. The default LSPRECISION= values are:\n\n  o For TECH=QUANEW UPDATE=DBFGS, BFGS: r = 0.4\n  o For TECH=QUANEW UPDATE=DDFP, DFP: r = 0.06 \n  o For TECH=CONGRA UPDATE=all r = 0.1\n  o For TECH=NEWRAP NO UPDATE: r = 0.9"},"ProcedureOptionType":"V"},{"ProcedureOptionName":"MAXFUNC=|MAXFU=","ProcedureOptionHelp":{"#cdata":"[Syntax: MAXFUNC=i | MAXFU=i] \n      \nRequires the number of function calls to be no larger than i. The default values are:\n\n  o For TECH= NEWRAP, NRRIDG, TRUREG: i=125 \n  o For TECH= DBLDOG, QUANEW: i=500 \n  o For TECH= CONGRA: i=1000\n  o For TECH= NMSIMP: i=3000"},"ProcedureOptionType":"V"},{"ProcedureOptionName":"MAXITER=|MAXIT=","ProcedureOptionHelp":{"#cdata":"[Syntax: MAXITER= | MAXIT=i <n>] \n      \nRequires the number of iterations to be no larger than i. The default values are:\n\n  o For TECH= LEVMAR, NEWRAP, NRRIDG, TRUREG: i=50 \n  o For TECH= DBLDOG, QUANEW: i=200 \n  o For TECH= CONGRA: i=400\n  o For TECH= NMSIMP: i=1000"},"ProcedureOptionType":"V"},{"ProcedureOptionName":"MAXSTEP=","ProcedureOptionHelp":{"#cdata":"[Syntax: MAXSTEP=r<n>] \n      \nSpecifies an upper bound for the step length of the line-search algorithms during the \nfirst n iterations."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"MAXTIME=","ProcedureOptionHelp":{"#cdata":"[Syntax: MAXTIME=r] \n      \nRequires the CPU time to be no larger than r. The default value of the MAXTIME= option \nis the largest double floating-point number on your computer."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"MINITER=|MINIT=","ProcedureOptionHelp":{"#cdata":"[Syntax: MINITER= | MINIT=i] \n      \nSpecifies the minimum number of iterations. The default value is 0."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"PALL|ALL","ProcedureOptionHelp":{"#cdata":"[Displays all optional output for optimization."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"PHISTORY|PHIS","ProcedureOptionHelp":{"#cdata":"Displays the optimization history. The PHISTORY option is set automatically if the PALL \nor PRINT option is set."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"PHISTPARMS","ProcedureOptionHelp":{"#cdata":"Display parameter estimates in each iteration."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"PINIT|PIN","ProcedureOptionHelp":{"#cdata":"Displays the initial values and derivatives (if available)."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"PSHORT","ProcedureOptionHelp":{"#cdata":"Restricts the amount of default output."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"PSUMMARY","ProcedureOptionHelp":{"#cdata":"Restricts the amount of default displayed output to a short form of iteration history and \nnotes, warnings, and errors."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"RESTART=|REST=","ProcedureOptionHelp":{"#cdata":"[Syntax: RESTART= | REST=i] \n      \nSpecifies that the QUANEW or CONGRA algorithm is restarted with a steepest descent/ascent \nsearch direction after at most i iterations, i > 0."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"SOCKET=","ProcedureOptionHelp":{"#cdata":"Specifies the fileref that contains the information needed for remote monitoring."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"TECHNIQUE=|TECH=|OMETHOD=|OM=","ProcedureOptionHelp":{"#cdata":"[Syntax: TECHNIQUE= | TECH=name | OMETHOD= | OM=name] \n      \nSpecifies the optimization technique."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"CONGRA","@Value2":"DBLDOG","@Value3":"NMSIMP","@Value4":"NEWRAP","@Value5":"NRRIDG","@Value6":"QUANEW","@Value7":"TRUREG","@Value8":"NONE"},"ProcedureOptionToolTips":{"@ToolTip1":"Chooses one of four different conjugate-gradient optimization algorithms, which can be more precisely  defined with the UPDATE= option and modified with the LINESEARCH= option.","@ToolTip2":"Performs a version of double-dogleg optimization, which uses the gradient to update an approximation  of the Cholesky factor of the Hessian.","@ToolTip3":"Performs a Nelder-Mead simplex optimization.","@ToolTip4":"Performs a usually stable but, for large problems, memory- and time-consuming Newton-Raphson  optimization technique. The algorithm combines a line-search algorithm with ridging, and it  can be modified with the LINESEARCH= option.","@ToolTip5":"Performs a usually stable but, for large problems, memory- and time-consuming Newton-Raphson  optimization technique. This algorithm does not perform a line search.","@ToolTip6":"Chooses one of four different quasi-Newton optimization algorithms that can be more precisely  defined with the UPDATE= option and modified with the LINESEARCH= option.","@ToolTip7":"Performs a usually very stable but, for large problems, memory- and time-consuming trust-region  optimization technique. The algorithm is implemented similar to Gay (1983) and Mor\u00e9 and Sorensen (1983).","@ToolTip8":"Does not perform any optimization. This option is similar to METHOD=NONE, but TECH=NONE also  computes and displays residuals and goodness of fit statistics."}},{"ProcedureOptionName":"UPDATE=","ProcedureOptionHelp":{"#cdata":"Specifies the update method for the quasi-Newton, double-dogleg, or conjugate-gradient \noptimization technique."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"BFGS","@Value2":"DBFGS","@Value3":"DDFP","@Value4":"DFP","@Value5":"PB","@Value6":"FR","@Value7":"PR","@Value8":"CD"},"ProcedureOptionToolTips":{"@ToolTip1":"Performs the original Broyden, Fletcher, Goldfarb, and Shanno (BFGS) update of the inverse  Hessian matrix.","@ToolTip2":"Performs the dual BFGS update of the Cholesky factor of the Hessian matrix. This is the default  update method.","@ToolTip3":"Performs the dual Davidon, Fletcher, and Powell (DFP) update of the Cholesky factor of the  Hessian matrix.","@ToolTip4":"Performs the original DFP update of the inverse Hessian matrix.","@ToolTip5":"Performs the automatic restart update method of Powell (1977) and Beale (1972).","@ToolTip6":"Performs the Fletcher-Reeves update (Fletcher 1987).","@ToolTip7":"Performs the Polak-Ribiere update (Fletcher 1987).","@ToolTip8":"Performs a conjugate-descent update of Fletcher (1987)."}},{"ProcedureOptionName":"XCONV=|XTOL=","ProcedureOptionHelp":{"#cdata":"[Syntax: XCONV= | XTOL=r <n>] \n      \nSpecifies the relative parameter convergence criterion. Termination requires a \nsmall relative parameter change in subsequent iterations."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"XSIZE=","ProcedureOptionHelp":{"#cdata":"[Syntax: XSIZE=r] \n      \nSpecifies the XSIZE parameter of the relative parameter termination criterion. The \ndefault value is r=0."},"ProcedureOptionType":"V"}],"#comment":{}},"ProcedureStatements":{"ProcedureStatement":[{"StatementName":"BOUNDS","StatementHelp":{"#cdata":"Syntax: BOUNDS bound1 [, bound2 ...] ; \n\nThe BOUNDS statement imposes simple boundary constraints on the parameter estimates. \nBOUNDS statement constraints refer to the parameters estimated by the HPCOUNTREG procedure. \nYou can specify any number of BOUNDS statements. \n\nEach bound is composed of parameter names, constants, and inequality operators:\n\n  item operator item [ operator item [ operator item ... ] ]\n  \nEach item is a constant, a parameter name, or a list of parameter names. Each operator is \u2019<\u2019, \u2019>\u2019, \u2019<=\u2019, or\n\u2019>=\u2019. Parameter names are as shown in the ESTIMATE column of the \u201cParameter Estimates\u201d table.\nYou can use both the BOUNDS statement and the RESTRICT statement to impose boundary constraints;\nhowever, the BOUNDS statement provides a simpler syntax for specifying these kinds of constraints."},"StatementOptions":null},{"StatementName":"FREQ","StatementHelp":{"#cdata":"Syntax: FREQ freq-variable ; \n      \nThe FREQ statement identifies a variable (freq-variable) that contains the frequency of occurrence of each\nobservation. PROC HPCOUNTREG treats each observation as if it appears n times, where n is the value\nof freq-variable for the observation. If the value for the observation is not an integer, it is truncated to an\ninteger. If the value is less than 1 or missing, the observation is not used in the model fitting. When the FREQ\nstatement is not specified, each observation is assigned a frequency of 1."},"StatementOptions":null},{"StatementName":"INIT","StatementHelp":{"#cdata":"Syntax: INIT initvalue1 [, initvalue2 ...] ; \n\nThe INIT statement sets initial values for parameters in the optimization. \n\nEach initvalue is written as a parameter or parameter list, followed by an optional \nequal sign (=), followed by a number: \n\n  parameter [=] number \n\nParameter names are as shown in the ESTIMATE column of the \u201cParameter Estimates\u201d table."},"StatementOptions":null},{"StatementName":"MODEL","StatementHelp":{"#cdata":"Syntax: MODEL dependent-variable = regressors </ options> ;\n\nThe MODEL statement specifies the dependent variable and independent regressor variables \nfor the regression model. The dependent count variable should take on only nonnegative \ninteger values in the input data set. PROC HPCOUNTREG rounds any positive noninteger count \nvalues to the nearest integer. PROC HPCOUNTREG discards any observations with a negative \ncount. \n\nOnly one MODEL statement can be specified."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"DIST=","StatementOptionHelp":{"#cdata":"Specifies a type of model to be analyzed. If you specify this option in both the MODEL statement \nand the PROC HPCOUNTREG statement, then only the value in the MODEL statement is used."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"POISSON","@Value2":"NEGBIN(P=1)","@Value3":"NEGBIN(P=2)","@Value4":"ZIPOISSON|ZIP","@Value5":"ZINEGBIN|ZINB"},"StatementOptionToolTips":{"@ToolTip1":"Poisson regression model","@ToolTip2":"Negative binomial regression model with a linear variance function","@ToolTip3":"Negative binomial regression model with a quadratic variance function","@ToolTip4":"Zero-inflated Poisson regression","@ToolTip5":"Zero-inflated negative binomial regression"}},{"StatementOptionName":"NOINT","StatementOptionHelp":{"#cdata":"Suppresses the intercept parameter."},"StatementOptionType":"S"},{"StatementOptionName":"OFFSET=","StatementOptionHelp":{"#cdata":"[Syntax: OFFSET=variable] \n          \nSpecifies a variable in the input data set to be used as an offset variable. The offset variable \nappears as a covariate in the model with its parameter restricted to 1."},"StatementOptionType":"V"},{"StatementOptionName":"CORRB","StatementOptionHelp":{"#cdata":"Prints the correlation matrix of the parameter estimates. It can also be specified in the \nPROC HPCOUNTREG statement."},"StatementOptionType":"S"},{"StatementOptionName":"COVB","StatementOptionHelp":{"#cdata":"Prints the covariance matrix of the parameter estimates. It can also be specified in the \nPROC HPCOUNTREG statement."},"StatementOptionType":"S"},{"StatementOptionName":"ITPRINT","StatementOptionHelp":{"#cdata":"Prints the objective function and parameter estimates at each iteration. The objective function \nis the negative log-likelihood function. It can also be specified in the PROC HPCOUNTREG statement."},"StatementOptionType":"S"},{"StatementOptionName":"NOPRINT","StatementOptionHelp":{"#cdata":"Suppresses all printed output."},"StatementOptionType":"S"},{"StatementOptionName":"PRINTALL","StatementOptionHelp":{"#cdata":"Requests all printing options. It can also be specified in the PROC HPCOUNTREG statement."},"StatementOptionType":"S"}]}},{"StatementName":"OUTPUT","StatementHelp":{"#cdata":"Syntax: OUTPUT <output-options> ; \n\nThe OUTPUT statement creates a new SAS data set containing all the variables in the input data set and, \noptionally, the estimates of x'\u03b2, the expected value of the response variable, and the probability \nthat the response variable will take on the current value."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"[Syntax: OUT=SAS-data-set] \n          \nNames the output data set."},"StatementOptionType":"DV"},{"StatementOptionName":"OUTVAR","StatementOptionHelp":{"#cdata":"[Syntax: OUTVAR(SAS-variable-names)] \n          \nAdds SAS variables to the output data set."},"StatementOptionType":"S"},{"StatementOptionName":"PRED=","StatementOptionHelp":{"#cdata":"[Syntax: PRED=name] \n          \nNames the variable containing the predicted value of the response variable."},"StatementOptionType":"V"},{"StatementOptionName":"PROB=","StatementOptionHelp":{"#cdata":"[Syntax: PROB=name] \n          \nNames the variable containing the probability of the response variable taking the \ncurrent value, Pr(Y=y)."},"StatementOptionType":"V"},{"StatementOptionName":"PROBCOUNT","StatementOptionHelp":{"#cdata":"[Syntax: PROBCOUNT(value1 < value2 . . . >)] \n          \nOutputs the probability of the response variable taking particular values. Each value should be a\nnonnegative integer. Nonintegers are rounded to the nearest integer. For value, you can also specify a\nlist of the form X TO Y BY Z. For example, PROBCOUNT(0 1 2 TO 10 BY 2 15) requests predicted\nprobabilities for counts 0, 1, 2, 4, 5, 6, 8, 10, and 15. This option is not available for the fixed- and\nrandom-effects panel models."},"StatementOptionType":"S"},{"StatementOptionName":"PROBZERO=","StatementOptionHelp":{"#cdata":"[Syntax: PROBZERO=name] \n          \nNames the variable containing the value that of \u03d5i, the probability that the response \nvariable will take on the value of zero as a result of the zero-generating process. \nIt is written to the output file only if the model is zero-inflated."},"StatementOptionType":"V"},{"StatementOptionName":"XBETA=","StatementOptionHelp":{"#cdata":"[Syntax: XBETA=name] \n          \nNames the variable containing estimates of x'\u03b2."},"StatementOptionType":"V"},{"StatementOptionName":"ZGAMMA=","StatementOptionHelp":{"#cdata":"[Syntax: ZGAMMA=name] \n          \nNames the variable containing estimates of z'Gamma."},"StatementOptionType":"V"}]}},{"StatementName":"RESTRICT","StatementHelp":{"#cdata":"Syntax: RESTRICT restriction1 [, restriction2 ...] ; \n\nThe RESTRICT statement is used to impose linear restrictions on the parameter estimates. \nYou can specify any number of RESTRICT statements. \n\nEach restriction is written as an expression, followed by an equality operator (=) or an \ninequality operator (<, >, <=, >=), followed by a second expression: \n\n  expression operator expression\n\nThe operator can be =, <, >, <=, or >=. \n\nRestriction expressions can be composed of parameter names, constants, and the operators \ntimes (*), plus (+), and minus (-). Parameter names are as shown in the ESTIMATE column of \nthe \u201cParameter Estimates\u201d table. The restriction expressions must be a linear function of \nthe variables. \n\nLagrange multipliers are reported in the \u201cParameter Estimates\u201d table for all the active \nlinear constraints. They are identified with the names Restrict1, Restrict2, and so on. \nThe probabilities of these Lagrange multipliers are computed using a beta distribution \n(LaMotte 1994). Nonactive, or nonbinding, restrictions have no effect on the estimation \nresults and are not noted in the output."},"StatementOptions":null},{"StatementName":"WEIGHT","StatementHelp":{"#cdata":"Syntax: WEIGHT variable </ option> ; \n      \nThe WEIGHT statement specifies a variable to supply weighting values to use for \neach observation in estimating parameters. The log likelihood for each observation \nis multiplied by the corresponding weight variable value. \n\nIf the weight of an observation is nonpositive, that observation is not used in \nthe estimation."},"StatementOptions":{"StatementOption":{"StatementOptionName":"NONORMALIZE","StatementOptionHelp":{"#cdata":"Does not normalize the weights. By default, the weights are normalized so that \nthey add up to the actual sample size."},"StatementOptionType":"S"}}},{"StatementName":"PERFORMANCE","StatementHelp":{"#cdata":"Syntax: PERFORMANCE < performance-options > ;\n      \nThe PERFORMANCE statement defines performance parameters for multithreaded and distributed \ncomputing, passes variables about the distributed computing environment, and requests detailed \nresults about the performance characteristics of the HPCOUNTREG procedure.\n\nWith the PERFORMANCE statement, you can also control whether PROC HPCOUNTREG executes in SMP \nor MPP mode."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"COMMIT=","StatementOptionHelp":{"#cdata":"Syntax: COMMIT=n\n          \nRequests that the High-Performance Analytics procedure write periodic updates to the \nSAS Log when observations are sent from the client to the appliance for distributed \nprocessing.\n\nHigh-Performance Analytics procedures do not have to use input data that are stored \nin the appliance. You can perform distributed computations regardless of the origin \nor format of the input data, provided the data are in a format that can be read by \nthe SAS System (for example, because a SAS/ACCESS engine is available)."},"StatementOptionType":"V"},{"StatementOptionName":"CPUCOUNT=","StatementOptionHelp":{"#cdata":"Syntax: CPUCOUNT=ACTUAL | num\n          \nSpecifies how many processors the procedure assumes are available on each host in the \ncomputing environment. num can be any integer from 1 to 256.\n\nCPUCOUNT=ACTUAL sets CPUCOUNT to the number of physical processors available. This number\ncan be less than the physical number of CPUs if the SAS process has been restricted by system\nadministration tools. Setting CPUCOUNT= to a number greater than the actual number of available\nCPUs might result in reduced performance. This option overrides the CPUCOUNT= SAS system\noption.\n\nIf a High-Performance Analytics procedure executes in SMP mode, this option refers to the client\nmachine of the SAS session. In MPP mode, this option applies to the nodes on the appliance."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"ACTUAL","@Value2":"<num>"},"StatementOptionToolTips":{"@ToolTip1":"Sets CPUCOUNT to the number of physical processors available. This number can be less than the physical number of CPUs if the SAS process has been restricted by system administration tools.","@ToolTip2":"Replace <num> with an actual number. Setting CPUCOUNT= to a number  greater than the actual number of available CPUs might result in reduced performance. This  option overrides the CPUCOUNT= SAS system option."}},{"StatementOptionName":"DATASERVER=","StatementOptionHelp":{"#cdata":"Syntax: DATASERVER=\u201cname\u201d\n          \nSpecifies the name of the server on Teradata systems as defined through the hosts file \nand as used in the LIBNAME statement for Teradata. For example, if the hosts file defines\n\n    myservercop1 33.44.55.66\n    \nas the server for Teradata, then a LIBNAME specification would be as follows:\n\n    libname TDLib teradata server=myserver user= password= database= ;\n    \nA PERFORMANCE statement to induce running alongside the Teradata server would specify the\nfollowing:\n\n    performance dataserver=\"myserver\";\n    \nIf the DATASERVER= option is specified, it overrides the GRIDDATASERVER environment \nvariable."},"StatementOptionType":"V"},{"StatementOptionName":"DETAILS","StatementOptionHelp":{"#cdata":"Requests a table that shows a timing breakdown of the procedure steps."},"StatementOptionType":"V"},{"StatementOptionName":"TIMEOUT=","StatementOptionHelp":{"#cdata":"Syntax: TIMEOUT=s\n          \nSpecifies the timeout in seconds for a High-Performance Analytics procedure to wait for a connection\nto the appliance and establish a connection back to the client. The default is s=120 seconds. If jobs\nare submitted to the appliance through workload management tools that might suspend access to the\nappliance for a longer period, you might want to increase the timeout value."},"StatementOptionType":"V"},{"StatementOptionName":"HOST=|GRIDHOST=","StatementOptionHelp":{"#cdata":"Syntax: HOST=\u201cname\u201d | GRIDHOST=\u201cname\u201d \n          \nSpecifies the name of the appliance host in single or double quotes. If the HOST= option \nis specified, it overrides the value of the GRIDHOST environment variable."},"StatementOptionType":"V"},{"StatementOptionName":"INSTALL=|INSTALLLOC=","StatementOptionHelp":{"#cdata":"Syntax: INSTALL=\u201cname\u201d | INSTALLLOC=\u201cname\u201d \n          \nSpecifies the directory in which the High-Performance Analytics shared libraries are \ninstalled on the appliance. Specifying the INSTALL= option overrides the GRIDINSTALLLOC \nenvironment variable."},"StatementOptionType":"V"},{"StatementOptionName":"NODES=|NNODES=","StatementOptionHelp":{"#cdata":"Syntax: NODES=n | NNODES=n\n          \nSpecifies the number of nodes in the distributed computing environment, provided that \nthe data are not processed alongside the database.\n\nIf you specify NODES=0, you indicate that you want to process the data in SMP mode on \nthe client machine. If the input data are not alongside the database, this is the default. \nThe High-Performance Analytics procedures then perform the analysis mutlithreaded on the client."},"StatementOptionType":"V"},{"StatementOptionName":"NTHREADS=","StatementOptionHelp":{"#cdata":"Syntax: NTHREADS=n \n          \nSpecifies the number of threads for analytic computations and overrides the SAS system option\nTHREADS | NOTHREADS. If you do not specify the NTHREADS= option, the number of threads\nare determined based on the number of CPUs on the host on which the analytic computations execute.\nThe algorithm by which a CPU count is converted to a thread count is specific to the High-\nPerformance Analytics procedure. Most procedures create one thread per CPU for the analytic computations.\nBy default, High-Performance Analytics procedures execute in multiple concurrent threads unless\nturned off by the NOTHREADS system option or you force single-threaded execution with\nNTHREADS=1. The largest number that can be specified for n is 256. Individual High-Performance\nAnalytics procedures can impose more stringent limits if called for by algorithmic considerations.\nYou can affect the determination of the CPU count with the CPUCOUNT= option in the PERFORMANCE\nstatement.\n\nNOTE: The SAS system options THREADS | NOTHREADS apply to the client machine on which\nthe SAS High-Performance Analytics procedures execute. They do not apply to the compute nodes\nin a distributed environment."},"StatementOptionType":"V"}]}},{"StatementName":"ZEROMODEL","StatementHelp":{"#cdata":"Syntax: ZEROMODEL dependent variable ~ zero-inflated regressors / options ; \n\nThe ZEROMODEL statement is required if either ZIP or ZINB is specified in the DIST= option in the\nMODEL statement. If ZIP or ZINB is specified, then the ZEROMODEL statement must follow immediately\nafter the MODEL statement. The dependent variable in the ZEROMODEL statement must be the same as \nthe dependent variable in the MODEL statement. \n\nThe zero-inflated (ZI) regressors appear in the equation that determines the probability (\u03d5i) of \na zero count. Each of these q variables has a parameter to be estimated in the regression."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"LINK=","StatementOptionHelp":{"#cdata":"Specifies the distribution function used to compute probability of zeros."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"LOGISTIC","@Value2":"NORMAL"},"StatementOptionToolTips":{"@ToolTip1":"Specifies logistic distribution.","@ToolTip2":"Specifies standard normal distribution."}},{"StatementOptionName":"OFFSET=","StatementOptionHelp":{"#cdata":"[Syntax: OFFSET=variable] \n          \nSpecifies a variable in the input data set to be used as a zero-inflated (ZI) offset \nvariable. The ZI offset variable is included as a term, with coefficient restricted \nto 1, in the equation that determines the probability (\u03d5i) of a zero count. The ZI \noffset variable cannot be the response variable, the offset variable (if any), or one \nof the explanatory variables. The name of the data set variable used as the ZI offset \nvariable is displayed in the \u201cModel Fit Summary\u201d output, where it is labeled as \n\u201cInf_offset\u201d."},"StatementOptionType":"V"}]}}]}}}