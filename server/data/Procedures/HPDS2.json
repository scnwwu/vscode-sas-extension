{"Procedure":{"Name":"HPDS2","ProductGroup":"HPA","#comment":{},"ProcedureHelp":{"#cdata":"Syntax: PROC HPDS2 < options > ;\n    PERFORMANCE performance-options ;\n    DATA DS2GTF.out ;\n      DS2 statements\n      METHOD RUN()\n      SET DS2GTF.in\n      END\n    ENDDATA ;\n    RUN ;\n    RUN CANCEL ;\n    QUIT ;\n    \nThe HPDS2 procedure enables you to submit DS2 language statements from a Base SAS session to a SAS\nHigh Performance Analytics grid for parallel execution. PROC HPDS2 verifies the syntactic correctness of\nthe DS2 source on the client machine before submitting it to the grid for execution. The output data created\nby the DS2 DATA statement can be output in either of the following ways: it can be written in parallel\nback to the grid data store or it can be returned to the client machine and directed to any data store that \nis supported by SAS.\n\nBecause the DS2 code is executed in parallel on separate grid nodes with single data partitions, there is\nseparate output from each node that is the result of processing only the local data partition. As a result,\nit might be necessary to use a second-stage program to aggregate the results from each node. The second\nstage can be executed on the SAS client by using the DS2 procedure, where the SET statement reads all\nrows created by the preceding parallel stage."},"ProcedureOptions":{"ProcedureOption":[{"ProcedureOptionName":"DATA=|IN=","ProcedureOptionHelp":{"#cdata":"Syntax: DATA= SAS-data-set\n      \nNames the SAS data set or database table to be used by PROC HPDS2. The default is the most recently\ncreated data set."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"OUTPUT=|OUT=","ProcedureOptionHelp":{"#cdata":"Syntax: OUTPUT= data-set\n      \nNames the SAS data set or database table created by PROC HPDS2."},"ProcedureOptionType":"V"}]},"ProcedureStatements":{"ProcedureStatement":[{"StatementName":"DATA|TABLE","StatementHelp":{"#cdata":"Syntax: DATA DS2GTF.out ;\nThe DATA statement indicates the beginning of the DS2 code block. The code block terminates with the\nENDDATA statement. \n\nA reference to the DS2 Grid Table Function driver (DS2GTF.out) must be included as part of the DATA\nstatement. If an input data set is specified in the PROC HPDS2 statement, then a run() method should be\nincluded in the DS2 code block. The first statement after the METHOD RUN() statement must be the SET\nDS2GTF.in statement for this case. DS2GTF.out and DS2GTF.in refer to the input and output data sets,\nrespectively."},"StatementOptions":{"StatementOption":{"StatementOptionName":"DS2GTF.OUT","StatementOptionHelp":{"#cdata":"Syntax: DATA DS2GTF.out ; \n          \nA reference to the DS2 Grid Table Function driver (DS2GTF.out) must be included as part of the DATA\nstatement."},"StatementOptionType":"V"}}},{"StatementName":"ENDDATA|ENDTABLE","StatementHelp":{"#cdata":"Syntax: ENDDATA ; \n      \nThe ENDDATA statement terminates the DS2 code block. The statements between the DATA and ENDDATA\nstatement are submitted to the grid for execution. The DS2 run, init, and term methods are specified\nbetween the DATA and ENDDATA statements."},"StatementOptions":null},{"StatementName":"BY","StatementHelp":{"#cdata":"Syntax: [ BY [ DESCENDING ] column [ ... [ DESCENDING ] column ] ; \n      \nBY-group processing is a method of combining rows from one or more tables that are \ngrouped or ordered by values of one or more common columns. When a BY statement is \nspecified immediately after a SET statement, the SET statement interleaves the rows \nof the input tables in sorted order. The sort order or sort key is specified by the \ncolumn names in the BY statement.\n\nThe keyword DESCENDING can be used before the name of the column in the BY statement \nin order to sort that column in descending instead of ascending order.\n\nWhen a BY statement is used, internally DS2 requests the rows in sorted order. If \nthe rows are already sorted or indexed there is a high likelihood that a \"resorting\" \nof the data will not occur."},"StatementOptions":{"StatementOption":{"StatementOptionName":"DESCENDING","StatementOptionHelp":{"#cdata":"Specifies that the tables are sorted in descending order by the column that is specified. \nDESCENDING means largest to smallest for numeric columns, or reverse alphabetical for \ncharacter columns."},"StatementOptionType":"S"}}},{"StatementName":"SET FROM","StatementHelp":{"#cdata":"Syntax: SET FROM thread [ THREADS = threads ]; \n      \nThe SET FROM statement enables a DS2 program to run as a single thread or as multiple \nthreads. The thread name specified in a SET FROM statement references a DS2 program \nthread that has been created by a THREAD statement.\n\nNote: The SET FROM statement is best used in the RUN method to take advantage of the \nRUN method's implicit looping capability."},"StatementOptions":{"StatementOption":{"StatementOptionName":"THREADS=","StatementOptionHelp":{"#cdata":"Syntax: THREADS= threads\n          \nSpecifies the number of threads that are run for thread.\n\nRequirement: threads must be an integer value. \nTip: If threads is not present, the thread will run as a single thread."},"StatementOptionType":"V"}}},{"StatementName":"SET","StatementHelp":{"#cdata":"Syntax: SET < table-reference > [ ... < table-reference > ] ; \n      \nReads rows from one or more tables. \n\nEach time the SET statement executes, one row is read into the program data vector. \nSET reads all columns and all rows from the input tables unless you specify otherwise. \nA SET statement can contain multiple tables; a DS2 program can contain multiple SET \nstatements."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"SELECT","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"S","SubOptionsKeywords":"FROM|WHERE|AS|WHERE|NATURAL JOIN|INNER JOIN|OUTER JOIN|CROSS JOIN|LEFT JOIN|RIGHT JOIN|UNION JOIN|FULL JOIN|UNION|INTO|SELECT|HAVING|ALL|INSERT|CREATE|ORDER BY|GROUP BY"},{"StatementOptionName":"FROM","StatementOptionHelp":{"#cdata":"Syntax: SET FROM thread [ THREADS = threads ]; \n          \nRuns a DS2 program as one or more threads. \n\nThe SET FROM statement enables a DS2 program to run as a single thread or as multiple \nthreads. The thread name specified in a SET FROM statement references a DS2 program \nthread that has been created by a THREAD statement"},"StatementOptionType":"S"},{"StatementOptionName":"DS2GTF.IN","StatementOptionHelp":{"#cdata":"The input data set."},"StatementOptionType":"S"},{"StatementOptionName":"DS2GTF.OUT","StatementOptionHelp":{"#cdata":"The output data set."},"StatementOptionType":"S"},{"StatementOptionName":"ALTER=","StatementOptionHelp":{"#cdata":"Syntax: ALTER=alter-password \n    \nSyntax Description:\nalter-password \n  must be a valid SAS name.\n \nDetails: \nThe ALTER= option applies only to a SAS data set. You can use this option to assign \na password or to access a read-protected, write-protected, or alter-protected file. \nWhen you replace a data set that is protected with an ALTER password, the new data \nset inherits the ALTER password. \n\nThe password is blotted out when the code is written in the SAS log. For example: \n\n  set a(alter=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"},{"StatementOptionName":"BUFNO=","StatementOptionHelp":{"#cdata":"Specifies the number of buffers to be allocated for processing a SAS data set. \n    \nSyntax: BUFNO= n | nK | hexX | MIN | MAX  \n\nSyntax Description:\n\nn | nK \n  specifies the number of buffers in multiples of 1 (bytes); 1,024 (kilobytes). For example, \n  a value of 8 specifies 8 buffers, and a value of 1k specifies 1024 buffers.\n\nhex \n  specifies the number of buffers as a hexadecimal value. You must specify the value beginning \n  with a number (0-9), followed by an X. For example, the value 2dx sets the number of buffers \n  to 45 buffers.\n\nMIN \n  sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value \n  for the operating environment. This is the default.\n\nMAX \n  sets the number of buffers to the maximum possible number in your operating environment, \n  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"hexX","@Value4":"MIN","@Value5":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the number of buffers in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the number of buffers in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the number of buffers as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip4":"Sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value  for the operating environment. This is the default.","@ToolTip5":"Sets the number of buffers to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."}},{"StatementOptionName":"BUFSIZE=","StatementOptionHelp":{"#cdata":"Specifies the size of a permanent buffer page for an output SAS data set. \n    \nSyntax: BUFSIZE= n | nK | nM | nG | hexX | MAX  \n\nSyntax Description:\n\nn | nK | nM | nG \nspecifies the page size in multiples of 1 (bytes); 1,024 (kilobytes); 1,048,576 (megabytes); \nor 1,073,741,824 (gigabytes). For example, a value of 8 specifies a page size of 8 bytes, and \na value of 4k specifies a page size of 4096 bytes. \n\nhexX \nspecifies the page size as a hexadecimal value. You must specify the value beginning with a \nnumber (0-9), followed by an X. For example, the value 2dx sets the page size to 45 bytes.\n\nMAX \nsets the page size to the maximum possible number in your operating environment, up to the \nlargest four-byte, signed integer, which is 231-1, or approximately 2 billion bytes."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"nM","@Value4":"nG","@Value5":"hexX","@Value6":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the page size in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the page size in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the page size in multiples of 1,048,576 (megabytes).  Replace n with an integer value.","@ToolTip4":"Specifies the page size in multiples of 1,073,741,824 (gigabytes).  Replace n with an integer value.","@ToolTip5":"Specifies the page size as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip6":"Sets the page size to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion bytes."}},{"StatementOptionName":"BULKLOAD=","StatementOptionHelp":{"#cdata":"Loads rows of data as one unit. Default value: NO  \n    \nSyntax: BULKLOAD=YES | NO  \n\nSyntax Description:\n\nYES \ncalls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.\n\nNO \nuses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Calls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.","@ToolTip2":"Uses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."}},{"StatementOptionName":"COMPRESS=","StatementOptionHelp":{"#cdata":"Specifies how observations are compressed in a new output SAS data set. \n    \nSyntax: COMPRESS=NO | YES | CHAR | BINARY  \n\nSyntax Description:\nNO \nspecifies that the observations in a newly created SAS data set are uncompressed (fixed-length records).\n\nYES | CHAR \nspecifies that the observations in a newly created SAS data set are compressed (variable-length records) \nby SAS using RLE (Run Length Encoding). RLE compresses observations by reducing repeated consecutive \ncharacters (including blanks) to two-byte or three-byte representations. \n\n  Alias: ON \n  Tip: Use this compression algorithm for character data. \n  Note:   COMPRESS=CHAR is accepted by Version 7 and later versions.  \n\nBINARY \n  specifies that the observations in a newly created SAS data set are compressed (variable-length records) \n  by SAS using RDC (Ross Data Compression). RDC combines run-length encoding and sliding-window compression \n  to compress the file.\n\n  Tip: This method is highly effective for compressing medium to large (several hundred bytes or larger) \n  blocks of binary data (numeric variables). Because the compression function operates on a single record \n  at a time, the record length needs to be several hundred bytes or larger for effective compression."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"NO","@Value2":"YES|ON","@Value3":"CHAR","@Value4":"BINARY"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the observations in a newly created SAS data set are uncompressed  (fixed-length records).","@ToolTip2":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.","@ToolTip3":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.   COMPRESS=CHAR is accepted by Version 7 and later versions.","@ToolTip4":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RDC (Ross Data Compression). RDC combines  run-length encoding and sliding-window compression to compress the file."}},{"StatementOptionName":"DBKEY=","StatementOptionHelp":{"#cdata":"Specifies a key column to optimize DBMS retrieval. Can improve performance when you \nare processing a join that involves a large DBMS table and a small SAS data set \nor DBMS table.\n    \nSyntax: DBKEY=([ ' ] column [ ' ] [... [ ' ] column [ ' ] ])  \n\nSyntax Description: \n\ncolumn \n  used by SAS to build an internal WHERE clause to search for matches in the DBMS table \n  based on the key column. For example:\n\n    select * from sas.a, dbms.b(dbkey=x) where a.x=b.x;\n    \nIn this example, DBKEY= specifies column x , which matches the key column designated in \nthe WHERE clause. However, if the DBKEY= column does NOT match the key column in the \nWHERE clause, then DBKEY= is not used."},"StatementOptionType":"TV"},{"StatementOptionName":"DBNULL=","StatementOptionHelp":{"#cdata":"Indicates whether NULL is a valid value for the specified columns when a table is created. \n    \nSyntax: DBNULL={ _ALL=YES | NO } | ( [column=YES | NO [ ... column=YES | NO ] ] )  \n\nSyntax Description: \n_ALL_ \n  specifies that the YES or NO applies to all columns in the table. (This is valid in \n  the interfaces to Informix, Oracle, Sybase, and Teradata only.)\n\nYES \n  specifies that the NULL value is valid for the specified columns in the DBMS table.\n\nNO \n  specifies that the NULL value is not valid for the specified columns in the DBMS table.\n\ncolumn \n  specifies the name of a column. \n\nDetails: \nThis option is valid only for creating DBMS tables. If you specify more than one column name, \nthe names must be separated with spaces.\n\nThe DBNULL= option processes values from left to right, so if you specify a column name twice, \nor if you use the _ALL_ value, the last value overrides the first value that is specified for \nthe column."},"StatementOptionType":"TV","SubOptionsKeywords":"_ALL_"},{"StatementOptionName":"DROP=","StatementOptionHelp":{"#cdata":"For an input table, excludes the specified columns from processing; for an output table, excludes the specified columns from being written to the table.\n    \nSyntax: DROP= ( column-list );  \n\nArguments: \ncolumn-list \n  specifies the names of the columns to omit from the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the format \n  col: are not supported. \n \nDetails: \nThe DROP= table option specifies that all columns in the column-list should not be included \nin the creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the drop attribute is specified, all columns not included in the drop \nstatement will be used to create columns in the output rows.\n\nIf the DROP= table option is associated with an input table, the columns are not available \nfor processing during program execution."},"StatementOptionType":"TV"},{"StatementOptionName":"ENCRYPT=","StatementOptionHelp":{"#cdata":"Specifies whether to encrypt an output SAS data set. \n    \nSyntax: ENCRYPT=YES | NO  \n\nSyntax Description:\nYES \n  encrypts the file. The encryption method uses passwords. At a minimum, you must specify \n  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because \n  the encryption method uses passwords, you cannot change any password on an encrypted data \n  set without re-creating the data set.\n\nNO \n  does not encrypt the file.\n\nCAUTION:\nRecord all passwords. \nIf you forget the password, you cannot reset it without assistance from SAS. The process \nis time-consuming and resource-intensive."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Encrypts the file. The encryption method uses passwords. At a minimum, you must specify  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because  the encryption method uses passwords, you cannot change any password on an encrypted data  set without re-creating the data set.","@ToolTip2":"Does not encrypt the file."}},{"StatementOptionName":"KEEP=","StatementOptionHelp":{"#cdata":"For an input table, specifies the columns to process; for an output table, specifies \nthe columns to write to the table. \n    \nSyntax: KEEP=( column-list );  \n\nArguments:\n\ncolumn-list \n  specifies the names of the columns to keep in the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the \n  format col: are not supported. \n  \nDetails: \nThe KEEP= table option specifies that all columns in the column-list should be included in \nthe creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the keep attribute is specified, all columns not included in the KEEP \nstatement will be dropped from the output rows.\n\nIf the KEEP= table option is associated with an input table, only the columns that are \nspecified by the KEEP= table option are available for processing during program execution."},"StatementOptionType":"TV"},{"StatementOptionName":"LABEL=","StatementOptionHelp":{"#cdata":"Specifies a label for a table.\n    \nSyntax: LABEL='label'  \n\nSyntax Description: \n\n'label' \n  specifies a text string of up to 256 characters. If the label text contains single \n  quotation marks, use double quotation marks around the label, or use two single \n  quotation marks in the label text and surround the string with single quotation \n  marks. To remove a label from a table, assign a label that is equal to a blank \n  that is enclosed in quotation marks.\n \nDetails: \nYou can use the LABEL= option on both input and output tables. When you use LABEL= \non input tables, it assigns a label for the table for the duration of the DS2 program. \nWhen it is specified for an output table, the label becomes a permanent part of that \ntable."},"StatementOptionType":"TV"},{"StatementOptionName":"LOCKTABLE=","StatementOptionHelp":{"#cdata":"Places shared or exclusive locks on tables. \n    \nSyntax: LOCKTABLE=SHARE | EXCLUSIVE  \n\nSyntax Description:\n\nSHARE \n  locks a table in shared mode, allowing other users or processes to read data from the \n  tables, but preventing users from updating data.\n\nEXCLUSIVE \n  locks a table exclusively, preventing other users from accessing any table that you open. \n\nDetails: \nYou can lock tables only if you are the owner or have been granted the necessary privilege. \n\nIf you access the BASE table driver through PROC DS2, the default value for the LOCKTABLE \noption is EXCLUSIVE. However, if you access the BASE table driver through a table server, \nor if you run your program locally with the SAS Table Server LIBNAME engine, the default \nvalue for the LOCKTABLE option is SHARE."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"SHARE","@Value2":"EXCLUSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Locks a table in shared mode, allowing other users or processes to read data from  the tables, but preventing users from updating data.","@ToolTip2":"Locks a table exclusively, preventing other users from accessing any table that you open."}},{"StatementOptionName":"OVERWRITE=","StatementOptionHelp":{"#cdata":"For a table, drops the output table before the replacement output table is populated \nwith rows; for packages and threads, drops the existing package or thread if a package \nor thread by the same name exists. \n    \nSyntax: OVERWRITE= YES | NO;  \n\nArguments: \n\nYES | NO \n  specifies whether the output table is deleted before a replacement output table \n  is created or whether a package or thread is dropped.\n\n  Default: NO \n\nCAUTION:\nFor tables, use the OVERWRITE=YES statement only with data that is backed up or \nwith data that you can reconstruct. Because the output table is deleted first, \ndata will be lost if a failure occurs while the output table is being written."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the output table is deleted before a replacement output table    is created or a package or thread is dropped.","@ToolTip2":"Specifies that the output table is not deleted before a replacement output table    is created or a package or thread is dropped."}},{"StatementOptionName":"PW=","StatementOptionHelp":{"#cdata":"Assigns a READ, WRITE, and ALTER password to a SAS file, and enables access to a password-protected SAS file. \n    \nSyntax: PW=password  \n\nSyntax Description:\npassword \n  must be a valid SAS name.\n\nDetails:\nThe PW= option applies to all types of SAS files. You can use this option to assign \na password to a SAS file or to access a password-protected SAS file.\n\nWhen replacing a SAS data set that is protected by an ALTER password, the new data \nset inherits the ALTER password. When the code is written to the SAS log the password \nis blotted out, for example: \n\n  drop thread job2 (pw=xxxxxxx);\n\nNote:   A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"},{"StatementOptionName":"READ=","StatementOptionHelp":{"#cdata":"Assigns a READ password to a SAS file that prevents users from reading the file, \nunless they enter the password. \n    \nSyntax: READ=read-password  \n\nSyntax Description: \nread-password \n  must be a valid SAS name. \n \nDetails: \nThe READ= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a read-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  declare package sales (read=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You  \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"},{"StatementOptionName":"RENAME=","StatementOptionHelp":{"#cdata":"Changes the name of a column.\n    \nSyntax: RENAME= (old-name { = | AS } new-name [... old-name { = | AS } new-name ] ) ;  \n\nArguments: \nold-name \n  the column you want to rename.\n\nnew-name \n  the new name of the column. It must be a valid name for the data source.\n \nDetails: \nThe RENAME= table option allows you to change the names of one or more columns.\n\nIf you use RENAME= when you create a table, the new column name is included in the output \ntable. If you use RENAME= on an input table, the new name is used in DS2 programming statements.\n\nIf you use RENAME= in the same DS2 program with either the DROP= or the KEEP= table option, \nthe DROP= and the KEEP= table options are applied before RENAME=. You must use the old name in \nthe DROP= and KEEP= table options. You cannot drop and rename the same column in the same statement.\n\nIn addition to changing the name of a column, RENAME= also changes the label for the column."},"StatementOptionType":"TV","SubOptionsKeywords":"AS"},{"StatementOptionName":"AS","StatementOptionHelp":{"#cdata":"Syntax: RENAME= (old-name AS new-name [... old-name AS new-name ] ) ;\n          \nSeparates the new-name from the old-name."},"StatementOptionType":"S"},{"StatementOptionName":"TYPE=","StatementOptionHelp":{"#cdata":"Specifies the data set type for a specially structured SAS data set. \n    \nSyntax: TYPE=data-set-type  \n\nSyntax Description: \ndata-set-type \n  specifies the special type of the data set.\n\nDetails: \nUse the TYPE= table option to create a special SAS data set in the proper format, \nor to identify the special type of the SAS data set in a procedure statement. \n\nYou can use the CONTENTS procedure to determine the type of a data set."},"StatementOptionType":"TV"},{"StatementOptionName":"WRITE=","StatementOptionHelp":{"#cdata":"Assigns a WRITE password to a SAS file that prevents users from writing to a file, \nunless they enter the password. \n    \nSyntax: WRITE=write-password  \n\nSyntax Description: \nwrite-password \n  must be a valid SAS name. \n \nDetails: \nThe WRITE= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a write-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  drop thread job2a (write=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"}],"#comment":{}}},{"StatementName":"DECLARE PACKAGE","StatementHelp":{"#cdata":"Syntax: DECLARE PACKAGE package [(table-options)] instance [ ( )] [... instance [ ( )]]; \n      \nCreates an instance of a package. \n\ntable-options \n  specifies optional arguments that the DS2 program applies when it creates a package.\n\ninstance \n  specifies a name that identifies an instance of the package."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"HASH","StatementOptionHelp":{"#cdata":"[Syntax: DECLARE PACKAGE HASH instance [ ( hashexp, 'datasource', 'ordered', 'duplicate' ) ];  \n      \nCreates an instance of a hash package. \n\ninstance \nspecifies a name that identifies an instance of the package. \n\nhashexp \n  is the hash package's internal table size, where the size of the hash table is 2^n. \n  The value of hashexp is used as a power-of-two exponent to create the hash table size.   \n'datasource' \n  is the name of a table or TSSQL query to load into the hash package. \n  The name of the table can be a literal or a character variable. The table name must \n  be enclosed in single quotation marks. \n'ordered' \n  specifies whether or how the data is returned in key-value order if you use the hash package \n  with a hash iterator package or if you use the hash package OUTPUT method.\n\nordered can be one of the following values: \n  'ascending' | 'a' \n  Data is returned in ascending key-value order. Specifying `ascending' is the same as specifying `yes'. \n  'descending' | 'd' \n  Data is returned in descending key-value order.\n  'YES' \n  Data is returned in ascending key-value order. Specifying `yes' is the same as specifying `ascending'.\n  'NO' \n  Data is returned in an undefined order.\n\n'duplicate' \n  determines whether to ignore duplicate keys when loading a table into the hash object. The \n  default is to store the first key and ignore all subsequent duplicates. \n  duplicate can be one of the following values: \n    'replace' \n    stores the last duplicate key record. \n    'error' \n    reports an error to the log if a duplicate key is found. \n    'add' \n    stores the first key record found and not any of the duplicates."},"StatementOptionType":"S"},{"StatementOptionName":"ITER","StatementOptionHelp":{"#cdata":"Syntax: DECLARE PACKAGE HITER instance [ ( 'hashname')];  \n      \nCreates an instance of a hash iterator package.\n\ninstance \n  specifies a name that identifies an instance of the package. \n  \n'hashname' \n  specifies the name of the hash package with which the hash iterator is associated."},"StatementOptionType":"S"},{"StatementOptionName":"ALTER=","StatementOptionHelp":{"#cdata":"Syntax: ALTER=alter-password \n    \nSyntax Description:\nalter-password \n  must be a valid SAS name.\n \nDetails: \nThe ALTER= option applies only to a SAS data set. You can use this option to assign \na password or to access a read-protected, write-protected, or alter-protected file. \nWhen you replace a data set that is protected with an ALTER password, the new data \nset inherits the ALTER password. \n\nThe password is blotted out when the code is written in the SAS log. For example: \n\n  set a(alter=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"},{"StatementOptionName":"BUFNO=","StatementOptionHelp":{"#cdata":"Specifies the number of buffers to be allocated for processing a SAS data set. \n    \nSyntax: BUFNO= n | nK | hexX | MIN | MAX  \n\nSyntax Description:\n\nn | nK \n  specifies the number of buffers in multiples of 1 (bytes); 1,024 (kilobytes). For example, \n  a value of 8 specifies 8 buffers, and a value of 1k specifies 1024 buffers.\n\nhex \n  specifies the number of buffers as a hexadecimal value. You must specify the value beginning \n  with a number (0-9), followed by an X. For example, the value 2dx sets the number of buffers \n  to 45 buffers.\n\nMIN \n  sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value \n  for the operating environment. This is the default.\n\nMAX \n  sets the number of buffers to the maximum possible number in your operating environment, \n  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"hexX","@Value4":"MIN","@Value5":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the number of buffers in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the number of buffers in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the number of buffers as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip4":"Sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value  for the operating environment. This is the default.","@ToolTip5":"Sets the number of buffers to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."}},{"StatementOptionName":"BUFSIZE=","StatementOptionHelp":{"#cdata":"Specifies the size of a permanent buffer page for an output SAS data set. \n    \nSyntax: BUFSIZE= n | nK | nM | nG | hexX | MAX  \n\nSyntax Description:\n\nn | nK | nM | nG \nspecifies the page size in multiples of 1 (bytes); 1,024 (kilobytes); 1,048,576 (megabytes); \nor 1,073,741,824 (gigabytes). For example, a value of 8 specifies a page size of 8 bytes, and \na value of 4k specifies a page size of 4096 bytes. \n\nhexX \nspecifies the page size as a hexadecimal value. You must specify the value beginning with a \nnumber (0-9), followed by an X. For example, the value 2dx sets the page size to 45 bytes.\n\nMAX \nsets the page size to the maximum possible number in your operating environment, up to the \nlargest four-byte, signed integer, which is 231-1, or approximately 2 billion bytes."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"nM","@Value4":"nG","@Value5":"hexX","@Value6":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the page size in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the page size in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the page size in multiples of 1,048,576 (megabytes).  Replace n with an integer value.","@ToolTip4":"Specifies the page size in multiples of 1,073,741,824 (gigabytes).  Replace n with an integer value.","@ToolTip5":"Specifies the page size as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip6":"Sets the page size to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion bytes."}},{"StatementOptionName":"BULKLOAD=","StatementOptionHelp":{"#cdata":"Loads rows of data as one unit. Default value: NO  \n    \nSyntax: BULKLOAD=YES | NO  \n\nSyntax Description:\n\nYES \ncalls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.\n\nNO \nuses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Calls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.","@ToolTip2":"Uses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."}},{"StatementOptionName":"COMPRESS=","StatementOptionHelp":{"#cdata":"Specifies how observations are compressed in a new output SAS data set. \n    \nSyntax: COMPRESS=NO | YES | CHAR | BINARY  \n\nSyntax Description:\nNO \nspecifies that the observations in a newly created SAS data set are uncompressed (fixed-length records).\n\nYES | CHAR \nspecifies that the observations in a newly created SAS data set are compressed (variable-length records) \nby SAS using RLE (Run Length Encoding). RLE compresses observations by reducing repeated consecutive \ncharacters (including blanks) to two-byte or three-byte representations. \n\n  Alias: ON \n  Tip: Use this compression algorithm for character data. \n  Note:   COMPRESS=CHAR is accepted by Version 7 and later versions.  \n\nBINARY \n  specifies that the observations in a newly created SAS data set are compressed (variable-length records) \n  by SAS using RDC (Ross Data Compression). RDC combines run-length encoding and sliding-window compression \n  to compress the file.\n\n  Tip: This method is highly effective for compressing medium to large (several hundred bytes or larger) \n  blocks of binary data (numeric variables). Because the compression function operates on a single record \n  at a time, the record length needs to be several hundred bytes or larger for effective compression."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"NO","@Value2":"YES|ON","@Value3":"CHAR","@Value4":"BINARY"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the observations in a newly created SAS data set are uncompressed  (fixed-length records).","@ToolTip2":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.","@ToolTip3":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.   COMPRESS=CHAR is accepted by Version 7 and later versions.","@ToolTip4":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RDC (Ross Data Compression). RDC combines  run-length encoding and sliding-window compression to compress the file."}},{"StatementOptionName":"DBKEY=","StatementOptionHelp":{"#cdata":"Specifies a key column to optimize DBMS retrieval. Can improve performance when you \nare processing a join that involves a large DBMS table and a small SAS data set \nor DBMS table.\n    \nSyntax: DBKEY=([ ' ] column [ ' ] [... [ ' ] column [ ' ] ])  \n\nSyntax Description: \n\ncolumn \n  used by SAS to build an internal WHERE clause to search for matches in the DBMS table \n  based on the key column. For example:\n\n    select * from sas.a, dbms.b(dbkey=x) where a.x=b.x;\n    \nIn this example, DBKEY= specifies column x , which matches the key column designated in \nthe WHERE clause. However, if the DBKEY= column does NOT match the key column in the \nWHERE clause, then DBKEY= is not used."},"StatementOptionType":"TV"},{"StatementOptionName":"DBNULL=","StatementOptionHelp":{"#cdata":"Indicates whether NULL is a valid value for the specified columns when a table is created. \n    \nSyntax: DBNULL={ _ALL=YES | NO } | ( [column=YES | NO [ ... column=YES | NO ] ] )  \n\nSyntax Description: \n_ALL_ \n  specifies that the YES or NO applies to all columns in the table. (This is valid in \n  the interfaces to Informix, Oracle, Sybase, and Teradata only.)\n\nYES \n  specifies that the NULL value is valid for the specified columns in the DBMS table.\n\nNO \n  specifies that the NULL value is not valid for the specified columns in the DBMS table.\n\ncolumn \n  specifies the name of a column. \n\nDetails: \nThis option is valid only for creating DBMS tables. If you specify more than one column name, \nthe names must be separated with spaces.\n\nThe DBNULL= option processes values from left to right, so if you specify a column name twice, \nor if you use the _ALL_ value, the last value overrides the first value that is specified for \nthe column."},"StatementOptionType":"TV","SubOptionsKeywords":"_ALL_"},{"StatementOptionName":"DROP=","StatementOptionHelp":{"#cdata":"For an input table, excludes the specified columns from processing; for an output table, excludes the specified columns from being written to the table.\n    \nSyntax: DROP= ( column-list );  \n\nArguments: \ncolumn-list \n  specifies the names of the columns to omit from the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the format \n  col: are not supported. \n \nDetails: \nThe DROP= table option specifies that all columns in the column-list should not be included \nin the creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the drop attribute is specified, all columns not included in the drop \nstatement will be used to create columns in the output rows.\n\nIf the DROP= table option is associated with an input table, the columns are not available \nfor processing during program execution."},"StatementOptionType":"TV"},{"StatementOptionName":"ENCRYPT=","StatementOptionHelp":{"#cdata":"Specifies whether to encrypt an output SAS data set. \n    \nSyntax: ENCRYPT=YES | NO  \n\nSyntax Description:\nYES \n  encrypts the file. The encryption method uses passwords. At a minimum, you must specify \n  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because \n  the encryption method uses passwords, you cannot change any password on an encrypted data \n  set without re-creating the data set.\n\nNO \n  does not encrypt the file.\n\nCAUTION:\nRecord all passwords. \nIf you forget the password, you cannot reset it without assistance from SAS. The process \nis time-consuming and resource-intensive."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Encrypts the file. The encryption method uses passwords. At a minimum, you must specify  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because  the encryption method uses passwords, you cannot change any password on an encrypted data  set without re-creating the data set.","@ToolTip2":"Does not encrypt the file."}},{"StatementOptionName":"KEEP=","StatementOptionHelp":{"#cdata":"For an input table, specifies the columns to process; for an output table, specifies \nthe columns to write to the table. \n    \nSyntax: KEEP=( column-list );  \n\nArguments:\n\ncolumn-list \n  specifies the names of the columns to keep in the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the \n  format col: are not supported. \n  \nDetails: \nThe KEEP= table option specifies that all columns in the column-list should be included in \nthe creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the keep attribute is specified, all columns not included in the KEEP \nstatement will be dropped from the output rows.\n\nIf the KEEP= table option is associated with an input table, only the columns that are \nspecified by the KEEP= table option are available for processing during program execution."},"StatementOptionType":"TV"},{"StatementOptionName":"LABEL=","StatementOptionHelp":{"#cdata":"Specifies a label for a table.\n    \nSyntax: LABEL='label'  \n\nSyntax Description: \n\n'label' \n  specifies a text string of up to 256 characters. If the label text contains single \n  quotation marks, use double quotation marks around the label, or use two single \n  quotation marks in the label text and surround the string with single quotation \n  marks. To remove a label from a table, assign a label that is equal to a blank \n  that is enclosed in quotation marks.\n \nDetails: \nYou can use the LABEL= option on both input and output tables. When you use LABEL= \non input tables, it assigns a label for the table for the duration of the DS2 program. \nWhen it is specified for an output table, the label becomes a permanent part of that \ntable."},"StatementOptionType":"TV"},{"StatementOptionName":"LOCKTABLE=","StatementOptionHelp":{"#cdata":"Places shared or exclusive locks on tables. \n    \nSyntax: LOCKTABLE=SHARE | EXCLUSIVE  \n\nSyntax Description:\n\nSHARE \n  locks a table in shared mode, allowing other users or processes to read data from the \n  tables, but preventing users from updating data.\n\nEXCLUSIVE \n  locks a table exclusively, preventing other users from accessing any table that you open. \n\nDetails: \nYou can lock tables only if you are the owner or have been granted the necessary privilege. \n\nIf you access the BASE table driver through PROC DS2, the default value for the LOCKTABLE \noption is EXCLUSIVE. However, if you access the BASE table driver through a table server, \nor if you run your program locally with the SAS Table Server LIBNAME engine, the default \nvalue for the LOCKTABLE option is SHARE."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"SHARE","@Value2":"EXCLUSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Locks a table in shared mode, allowing other users or processes to read data from  the tables, but preventing users from updating data.","@ToolTip2":"Locks a table exclusively, preventing other users from accessing any table that you open."}},{"StatementOptionName":"OVERWRITE=","StatementOptionHelp":{"#cdata":"For a table, drops the output table before the replacement output table is populated \nwith rows; for packages and threads, drops the existing package or thread if a package \nor thread by the same name exists. \n    \nSyntax: OVERWRITE= YES | NO;  \n\nArguments: \n\nYES | NO \n  specifies whether the output table is deleted before a replacement output table \n  is created or whether a package or thread is dropped.\n\n  Default: NO \n\nCAUTION:\nFor tables, use the OVERWRITE=YES statement only with data that is backed up or \nwith data that you can reconstruct. Because the output table is deleted first, \ndata will be lost if a failure occurs while the output table is being written."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the output table is deleted before a replacement output table    is created or a package or thread is dropped.","@ToolTip2":"Specifies that the output table is not deleted before a replacement output table    is created or a package or thread is dropped."}},{"StatementOptionName":"PW=","StatementOptionHelp":{"#cdata":"Assigns a READ, WRITE, and ALTER password to a SAS file, and enables access to a password-protected SAS file. \n    \nSyntax: PW=password  \n\nSyntax Description:\npassword \n  must be a valid SAS name.\n\nDetails:\nThe PW= option applies to all types of SAS files. You can use this option to assign \na password to a SAS file or to access a password-protected SAS file.\n\nWhen replacing a SAS data set that is protected by an ALTER password, the new data \nset inherits the ALTER password. When the code is written to the SAS log the password \nis blotted out, for example: \n\n  drop thread job2 (pw=xxxxxxx);\n\nNote:   A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"},{"StatementOptionName":"READ=","StatementOptionHelp":{"#cdata":"Assigns a READ password to a SAS file that prevents users from reading the file, \nunless they enter the password. \n    \nSyntax: READ=read-password  \n\nSyntax Description: \nread-password \n  must be a valid SAS name. \n \nDetails: \nThe READ= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a read-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  declare package sales (read=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You  \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"},{"StatementOptionName":"RENAME=","StatementOptionHelp":{"#cdata":"Changes the name of a column.\n    \nSyntax: RENAME= (old-name { = | AS } new-name [... old-name { = | AS } new-name ] ) ;  \n\nArguments: \nold-name \n  the column you want to rename.\n\nnew-name \n  the new name of the column. It must be a valid name for the data source.\n \nDetails: \nThe RENAME= table option allows you to change the names of one or more columns.\n\nIf you use RENAME= when you create a table, the new column name is included in the output \ntable. If you use RENAME= on an input table, the new name is used in DS2 programming statements.\n\nIf you use RENAME= in the same DS2 program with either the DROP= or the KEEP= table option, \nthe DROP= and the KEEP= table options are applied before RENAME=. You must use the old name in \nthe DROP= and KEEP= table options. You cannot drop and rename the same column in the same statement.\n\nIn addition to changing the name of a column, RENAME= also changes the label for the column."},"StatementOptionType":"TV","SubOptionsKeywords":"AS"},{"StatementOptionName":"AS","StatementOptionHelp":{"#cdata":"Syntax: RENAME= (old-name AS new-name [... old-name AS new-name ] ) ;\n          \nSeparates the new-name from the old-name."},"StatementOptionType":"S"},{"StatementOptionName":"TYPE=","StatementOptionHelp":{"#cdata":"Specifies the data set type for a specially structured SAS data set. \n    \nSyntax: TYPE=data-set-type  \n\nSyntax Description: \ndata-set-type \n  specifies the special type of the data set.\n\nDetails: \nUse the TYPE= table option to create a special SAS data set in the proper format, \nor to identify the special type of the SAS data set in a procedure statement. \n\nYou can use the CONTENTS procedure to determine the type of a data set."},"StatementOptionType":"TV"},{"StatementOptionName":"WRITE=","StatementOptionHelp":{"#cdata":"Assigns a WRITE password to a SAS file that prevents users from writing to a file, \nunless they enter the password. \n    \nSyntax: WRITE=write-password  \n\nSyntax Description: \nwrite-password \n  must be a valid SAS name. \n \nDetails: \nThe WRITE= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a write-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  drop thread job2a (write=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"}],"#comment":{}}},{"StatementName":"DECLARE PACKAGE HASH","StatementHelp":{"#cdata":"Syntax: DECLARE PACKAGE HASH instance [ ( hashexp, 'datasource', 'ordered', 'duplicate' ) ];  \n      \nCreates an instance of a hash package. \n\ninstance \nspecifies a name that identifies an instance of the package. \n\nhashexp \n  is the hash package's internal table size, where the size of the hash table is 2^n. \n  The value of hashexp is used as a power-of-two exponent to create the hash table size.   \n'datasource' \n  is the name of a table or TSSQL query to load into the hash package. \n  The name of the table can be a literal or a character variable. The table name must \n  be enclosed in single quotation marks. \n'ordered' \n  specifies whether or how the data is returned in key-value order if you use the hash package \n  with a hash iterator package or if you use the hash package OUTPUT method.\n\nordered can be one of the following values: \n  'ascending' | 'a' \n  Data is returned in ascending key-value order. Specifying `ascending' is the same as specifying `yes'. \n  'descending' | 'd' \n  Data is returned in descending key-value order.\n  'YES' \n  Data is returned in ascending key-value order. Specifying `yes' is the same as specifying `ascending'.\n  'NO' \n  Data is returned in an undefined order.\n\n'duplicate' \n  determines whether to ignore duplicate keys when loading a table into the hash object. The \n  default is to store the first key and ignore all subsequent duplicates. \n  duplicate can be one of the following values: \n    'replace' \n    stores the last duplicate key record. \n    'error' \n    reports an error to the log if a duplicate key is found. \n    'add' \n    stores the first key record found and not any of the duplicates."},"StatementOptions":null},{"StatementName":"DECLARE PACKAGE HITER","StatementHelp":{"#cdata":"Syntax: DECLARE PACKAGE HITER instance [ ( 'hashname')];  \n      \nCreates an instance of a hash iterator package. \n\ninstance \n  specifies a name that identifies an instance of the package. \n  \n'hashname' \n  specifies the name of the hash package with which the hash iterator is associated."},"StatementOptions":null},{"StatementName":"DECLARE THREAD","StatementHelp":{"#cdata":"Syntax: DECLARE THREAD thread [(table-options)] instance( argument ) [... instance ( argument )]; \n      \nCreates an instance of a thread. \n\nthread \nspecifies the thread name. thread can be one of these forms: \n\n   catalog.schema.thread  \n   schema.thread  \n   catalog.thread  \n   thread \n\n  catalog \n  is an implementation of the ANSI SQL standard for an SQL catalog, which is a data \n  container object that groups logically related schemas. The catalog is the first-level \n  (top) grouping mechanism in a data organization hierarchy that is used along with a \n  schema to provide a means of qualifying names. A catalog is a metadata object in a \n  SAS Metadata Repository.\n\n  schema \n  is an implementation of the ANSI SQL standard for an SQL schema, which is a data \n  container object that groups files such as tables and views and other objects \n  supported by a data source such as stored procedures. The schema provides a grouping \n  object that is used along with a catalog to provide a means of qualifying names.\n\n  thread \n  is the name of the thread.\n\n  Requirement: The thread name must match the name of a thread created in a THREAD \n  statement, or an error will occur.\n  Requirement: Thread naming conventions are based on the data source. \n\ntable-options \nspecifies optional arguments that the DS2 program applies when it creates a thread. \n\ninstance \nspecifies a name that identifies an instance of the thread.\n\nargument \nspecifies arguments used with instance-name."},"StatementOptions":{"#comment":{},"StatementOption":[{"StatementOptionName":"ALTER=","StatementOptionHelp":{"#cdata":"Syntax: ALTER=alter-password \n    \nSyntax Description:\nalter-password \n  must be a valid SAS name.\n \nDetails: \nThe ALTER= option applies only to a SAS data set. You can use this option to assign \na password or to access a read-protected, write-protected, or alter-protected file. \nWhen you replace a data set that is protected with an ALTER password, the new data \nset inherits the ALTER password. \n\nThe password is blotted out when the code is written in the SAS log. For example: \n\n  set a(alter=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"V"},{"StatementOptionName":"BUFNO=","StatementOptionHelp":{"#cdata":"Specifies the number of buffers to be allocated for processing a SAS data set. \n    \nSyntax: BUFNO= n | nK | hexX | MIN | MAX  \n\nSyntax Description:\n\nn | nK \n  specifies the number of buffers in multiples of 1 (bytes); 1,024 (kilobytes). For example, \n  a value of 8 specifies 8 buffers, and a value of 1k specifies 1024 buffers.\n\nhex \n  specifies the number of buffers as a hexadecimal value. You must specify the value beginning \n  with a number (0-9), followed by an X. For example, the value 2dx sets the number of buffers \n  to 45 buffers.\n\nMIN \n  sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value \n  for the operating environment. This is the default.\n\nMAX \n  sets the number of buffers to the maximum possible number in your operating environment, \n  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"hexX","@Value4":"MIN","@Value5":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the number of buffers in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the number of buffers in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the number of buffers as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip4":"Sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value  for the operating environment. This is the default.","@ToolTip5":"Sets the number of buffers to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."}},{"StatementOptionName":"BUFSIZE=","StatementOptionHelp":{"#cdata":"Specifies the size of a permanent buffer page for an output SAS data set. \n    \nSyntax: BUFSIZE= n | nK | nM | nG | hexX | MAX  \n\nSyntax Description:\n\nn | nK | nM | nG \nspecifies the page size in multiples of 1 (bytes); 1,024 (kilobytes); 1,048,576 (megabytes); \nor 1,073,741,824 (gigabytes). For example, a value of 8 specifies a page size of 8 bytes, and \na value of 4k specifies a page size of 4096 bytes. \n\nhexX \nspecifies the page size as a hexadecimal value. You must specify the value beginning with a \nnumber (0-9), followed by an X. For example, the value 2dx sets the page size to 45 bytes.\n\nMAX \nsets the page size to the maximum possible number in your operating environment, up to the \nlargest four-byte, signed integer, which is 231-1, or approximately 2 billion bytes."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"nM","@Value4":"nG","@Value5":"hexX","@Value6":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the page size in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the page size in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the page size in multiples of 1,048,576 (megabytes).  Replace n with an integer value.","@ToolTip4":"Specifies the page size in multiples of 1,073,741,824 (gigabytes).  Replace n with an integer value.","@ToolTip5":"Specifies the page size as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip6":"Sets the page size to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion bytes."}},{"StatementOptionName":"BULKLOAD=","StatementOptionHelp":{"#cdata":"Loads rows of data as one unit. Default value: NO  \n    \nSyntax: BULKLOAD=YES | NO  \n\nSyntax Description:\n\nYES \ncalls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.\n\nNO \nuses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Calls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.","@ToolTip2":"Uses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."}},{"StatementOptionName":"COMPRESS=","StatementOptionHelp":{"#cdata":"Specifies how observations are compressed in a new output SAS data set. \n    \nSyntax: COMPRESS=NO | YES | CHAR | BINARY  \n\nSyntax Description:\nNO \nspecifies that the observations in a newly created SAS data set are uncompressed (fixed-length records).\n\nYES | CHAR \nspecifies that the observations in a newly created SAS data set are compressed (variable-length records) \nby SAS using RLE (Run Length Encoding). RLE compresses observations by reducing repeated consecutive \ncharacters (including blanks) to two-byte or three-byte representations. \n\n  Alias: ON \n  Tip: Use this compression algorithm for character data. \n  Note:   COMPRESS=CHAR is accepted by Version 7 and later versions.  \n\nBINARY \n  specifies that the observations in a newly created SAS data set are compressed (variable-length records) \n  by SAS using RDC (Ross Data Compression). RDC combines run-length encoding and sliding-window compression \n  to compress the file.\n\n  Tip: This method is highly effective for compressing medium to large (several hundred bytes or larger) \n  blocks of binary data (numeric variables). Because the compression function operates on a single record \n  at a time, the record length needs to be several hundred bytes or larger for effective compression."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NO","@Value2":"YES|ON","@Value3":"CHAR","@Value4":"BINARY"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the observations in a newly created SAS data set are uncompressed  (fixed-length records).","@ToolTip2":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.","@ToolTip3":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.   COMPRESS=CHAR is accepted by Version 7 and later versions.","@ToolTip4":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RDC (Ross Data Compression). RDC combines  run-length encoding and sliding-window compression to compress the file."}},{"StatementOptionName":"DBKEY=","StatementOptionHelp":{"#cdata":"Specifies a key column to optimize DBMS retrieval. Can improve performance when you \nare processing a join that involves a large DBMS table and a small SAS data set \nor DBMS table.\n    \nSyntax: DBKEY=([ ' ] column [ ' ] [... [ ' ] column [ ' ] ])  \n\nSyntax Description: \n\ncolumn \n  used by SAS to build an internal WHERE clause to search for matches in the DBMS table \n  based on the key column. For example:\n\n    select * from sas.a, dbms.b(dbkey=x) where a.x=b.x;\n    \nIn this example, DBKEY= specifies column x , which matches the key column designated in \nthe WHERE clause. However, if the DBKEY= column does NOT match the key column in the \nWHERE clause, then DBKEY= is not used."},"StatementOptionType":"V"},{"StatementOptionName":"DBNULL=","StatementOptionHelp":{"#cdata":"Indicates whether NULL is a valid value for the specified columns when a table is created. \n    \nSyntax: DBNULL={ _ALL=YES | NO } | ( [column=YES | NO [ ... column=YES | NO ] ] )  \n\nSyntax Description: \n_ALL_ \n  specifies that the YES or NO applies to all columns in the table. (This is valid in \n  the interfaces to Informix, Oracle, Sybase, and Teradata only.)\n\nYES \n  specifies that the NULL value is valid for the specified columns in the DBMS table.\n\nNO \n  specifies that the NULL value is not valid for the specified columns in the DBMS table.\n\ncolumn \n  specifies the name of a column. \n\nDetails: \nThis option is valid only for creating DBMS tables. If you specify more than one column name, \nthe names must be separated with spaces.\n\nThe DBNULL= option processes values from left to right, so if you specify a column name twice, \nor if you use the _ALL_ value, the last value overrides the first value that is specified for \nthe column."},"StatementOptionType":"V","SubOptionsKeywords":"_ALL_"},{"StatementOptionName":"DROP=","StatementOptionHelp":{"#cdata":"For an input table, excludes the specified columns from processing; for an output table, excludes the specified columns from being written to the table.\n    \nSyntax: DROP= ( column-list );  \n\nArguments: \ncolumn-list \n  specifies the names of the columns to omit from the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the format \n  col: are not supported. \n \nDetails: \nThe DROP= table option specifies that all columns in the column-list should not be included \nin the creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the drop attribute is specified, all columns not included in the drop \nstatement will be used to create columns in the output rows.\n\nIf the DROP= table option is associated with an input table, the columns are not available \nfor processing during program execution."},"StatementOptionType":"V"},{"StatementOptionName":"ENCRYPT=","StatementOptionHelp":{"#cdata":"Specifies whether to encrypt an output SAS data set. \n    \nSyntax: ENCRYPT=YES | NO  \n\nSyntax Description:\nYES \n  encrypts the file. The encryption method uses passwords. At a minimum, you must specify \n  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because \n  the encryption method uses passwords, you cannot change any password on an encrypted data \n  set without re-creating the data set.\n\nNO \n  does not encrypt the file.\n\nCAUTION:\nRecord all passwords. \nIf you forget the password, you cannot reset it without assistance from SAS. The process \nis time-consuming and resource-intensive."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Encrypts the file. The encryption method uses passwords. At a minimum, you must specify  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because  the encryption method uses passwords, you cannot change any password on an encrypted data  set without re-creating the data set.","@ToolTip2":"Does not encrypt the file."}},{"StatementOptionName":"KEEP=","StatementOptionHelp":{"#cdata":"For an input table, specifies the columns to process; for an output table, specifies \nthe columns to write to the table. \n    \nSyntax: KEEP=( column-list );  \n\nArguments:\n\ncolumn-list \n  specifies the names of the columns to keep in the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the \n  format col: are not supported. \n  \nDetails: \nThe KEEP= table option specifies that all columns in the column-list should be included in \nthe creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the keep attribute is specified, all columns not included in the KEEP \nstatement will be dropped from the output rows.\n\nIf the KEEP= table option is associated with an input table, only the columns that are \nspecified by the KEEP= table option are available for processing during program execution."},"StatementOptionType":"V"},{"StatementOptionName":"LABEL=","StatementOptionHelp":{"#cdata":"Specifies a label for a table.\n    \nSyntax: LABEL='label'  \n\nSyntax Description: \n\n'label' \n  specifies a text string of up to 256 characters. If the label text contains single \n  quotation marks, use double quotation marks around the label, or use two single \n  quotation marks in the label text and surround the string with single quotation \n  marks. To remove a label from a table, assign a label that is equal to a blank \n  that is enclosed in quotation marks.\n \nDetails: \nYou can use the LABEL= option on both input and output tables. When you use LABEL= \non input tables, it assigns a label for the table for the duration of the DS2 program. \nWhen it is specified for an output table, the label becomes a permanent part of that \ntable."},"StatementOptionType":"V"},{"StatementOptionName":"LOCKTABLE=","StatementOptionHelp":{"#cdata":"Places shared or exclusive locks on tables. \n    \nSyntax: LOCKTABLE=SHARE | EXCLUSIVE  \n\nSyntax Description:\n\nSHARE \n  locks a table in shared mode, allowing other users or processes to read data from the \n  tables, but preventing users from updating data.\n\nEXCLUSIVE \n  locks a table exclusively, preventing other users from accessing any table that you open. \n\nDetails: \nYou can lock tables only if you are the owner or have been granted the necessary privilege. \n\nIf you access the BASE table driver through PROC DS2, the default value for the LOCKTABLE \noption is EXCLUSIVE. However, if you access the BASE table driver through a table server, \nor if you run your program locally with the SAS Table Server LIBNAME engine, the default \nvalue for the LOCKTABLE option is SHARE."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"SHARE","@Value2":"EXCLUSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Locks a table in shared mode, allowing other users or processes to read data from  the tables, but preventing users from updating data.","@ToolTip2":"Locks a table exclusively, preventing other users from accessing any table that you open."}},{"StatementOptionName":"OVERWRITE=","StatementOptionHelp":{"#cdata":"For a table, drops the output table before the replacement output table is populated \nwith rows; for packages and threads, drops the existing package or thread if a package \nor thread by the same name exists. \n    \nSyntax: OVERWRITE= YES | NO;  \n\nArguments: \n\nYES | NO \n  specifies whether the output table is deleted before a replacement output table \n  is created or whether a package or thread is dropped.\n\n  Default: NO \n\nCAUTION:\nFor tables, use the OVERWRITE=YES statement only with data that is backed up or \nwith data that you can reconstruct. Because the output table is deleted first, \ndata will be lost if a failure occurs while the output table is being written."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the output table is deleted before a replacement output table    is created or a package or thread is dropped.","@ToolTip2":"Specifies that the output table is not deleted before a replacement output table    is created or a package or thread is dropped."}},{"StatementOptionName":"PW=","StatementOptionHelp":{"#cdata":"Assigns a READ, WRITE, and ALTER password to a SAS file, and enables access to a password-protected SAS file. \n    \nSyntax: PW=password  \n\nSyntax Description:\npassword \n  must be a valid SAS name.\n\nDetails:\nThe PW= option applies to all types of SAS files. You can use this option to assign \na password to a SAS file or to access a password-protected SAS file.\n\nWhen replacing a SAS data set that is protected by an ALTER password, the new data \nset inherits the ALTER password. When the code is written to the SAS log the password \nis blotted out, for example: \n\n  drop thread job2 (pw=xxxxxxx);\n\nNote:   A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"V"},{"StatementOptionName":"READ=","StatementOptionHelp":{"#cdata":"Assigns a READ password to a SAS file that prevents users from reading the file, \nunless they enter the password. \n    \nSyntax: READ=read-password  \n\nSyntax Description: \nread-password \n  must be a valid SAS name. \n \nDetails: \nThe READ= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a read-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  declare package sales (read=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You  \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"V"},{"StatementOptionName":"RENAME=","StatementOptionHelp":{"#cdata":"Changes the name of a column.\n    \nSyntax: RENAME= (old-name { = | AS } new-name [... old-name { = | AS } new-name ] ) ;  \n\nArguments: \nold-name \n  the column you want to rename.\n\nnew-name \n  the new name of the column. It must be a valid name for the data source.\n \nDetails: \nThe RENAME= table option allows you to change the names of one or more columns.\n\nIf you use RENAME= when you create a table, the new column name is included in the output \ntable. If you use RENAME= on an input table, the new name is used in DS2 programming statements.\n\nIf you use RENAME= in the same DS2 program with either the DROP= or the KEEP= table option, \nthe DROP= and the KEEP= table options are applied before RENAME=. You must use the old name in \nthe DROP= and KEEP= table options. You cannot drop and rename the same column in the same statement.\n\nIn addition to changing the name of a column, RENAME= also changes the label for the column."},"StatementOptionType":"V","SubOptionsKeywords":"AS"},{"StatementOptionName":"AS","StatementOptionHelp":{"#cdata":"Syntax: RENAME= (old-name AS new-name [... old-name AS new-name ] ) ;\n          \nSeparates the new-name from the old-name."},"StatementOptionType":"S"},{"StatementOptionName":"TYPE=","StatementOptionHelp":{"#cdata":"Specifies the data set type for a specially structured SAS data set. \n    \nSyntax: TYPE=data-set-type  \n\nSyntax Description: \ndata-set-type \n  specifies the special type of the data set.\n\nDetails: \nUse the TYPE= table option to create a special SAS data set in the proper format, \nor to identify the special type of the SAS data set in a procedure statement. \n\nYou can use the CONTENTS procedure to determine the type of a data set."},"StatementOptionType":"V"},{"StatementOptionName":"WRITE=","StatementOptionHelp":{"#cdata":"Assigns a WRITE password to a SAS file that prevents users from writing to a file, \nunless they enter the password. \n    \nSyntax: WRITE=write-password  \n\nSyntax Description: \nwrite-password \n  must be a valid SAS name. \n \nDetails: \nThe WRITE= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a write-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  drop thread job2a (write=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"V"}]}},{"StatementName":"DO","StatementHelp":{"#cdata":"Syntax: DO [ < index-variable-clause > ] [ < conditional-clause > ] ;  \n  ...statement-list...\n  END [end-label ] ;  \n\nSpecifies a group of statements to be executed as a unit."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"WHILE","StatementOptionHelp":{"#cdata":"Executes statements in a DO-loop repetitively while a condition is true. \n          \nSyntax: \nDO WHILE (expression); \n...more SAS statements...  \nEND;"},"StatementOptionType":"S"},{"StatementOptionName":"UNTIL","StatementOptionHelp":{"#cdata":"Executes statements in a DO loop repetitively until a condition is true.\n          \nSyntax: \nDO UNTIL (expression); \n...more SAS statements...  \nEND;"},"StatementOptionType":"S"},{"StatementOptionName":"TO","StatementOptionHelp":{"#cdata":"Separates the start and stop integers or expressions that control the number of times the \nportion of the step between the iterative DO and END statements is processed."},"StatementOptionType":"S"},{"StatementOptionName":"BY","StatementOptionHelp":{"#cdata":"Precedes an increment integer (other than 0) or an expression that generates an integer to be \nadded to the value of the index variable in each iteration of the DO loop."},"StatementOptionType":"S"}]}},{"StatementName":"DO WHILE","StatementHelp":{"#cdata":"Executes statements in a DO-loop repetitively while a condition is true. \n          \nSyntax: \nDO WHILE (expression); \n...more SAS statements...  \nEND;"},"StatementOptions":null},{"StatementName":"DO UNTIL","StatementHelp":{"#cdata":"Executes statements in a DO loop repetitively until a condition is true.\n          \nSyntax: \nDO UNTIL (expression); \n...more SAS statements...  \nEND;"},"StatementOptions":null},{"StatementName":"DROP","StatementHelp":{"#cdata":"Syntax: DROP column-list;  \n      \nExcludes columns from output tables. \n\nThe DROP statement applies to all the tables that are created within the same DS2 program \nand can appear anywhere in the program. The columns in the DROP statement are available for \nprocessing in the DS2 program. If no DROP or KEEP statement appears, all tables that are \ncreated in the DS2 program contain all columns. Do not use both DROP and KEEP statements \nwithin the same DS2 program."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"PACKAGE","StatementOptionHelp":{"#cdata":"Removes a DS2 package. \n          \nSyntax: DROP PACKAGE package [(table-options)];  \n\nArguments: \npackage \n  specifies the name of the package to be removed.\n\ntable-options \n  specifies optional arguments that the DS2 program applies when it removes a package."},"StatementOptionType":"S"},{"StatementOptionName":"THREAD","StatementOptionHelp":{"#cdata":"Removes a DS2 program thread. \n          \nSyntax \nDROP THREAD thread [(table-options)];  \n\nArguments:\nthread \n  specifies the name of the thread to be removed.\n\ntable-options \n  specifies optional arguments that the DS2 program applies when it removes a thread."},"StatementOptionType":"S"}]}},{"StatementName":"KEEP","StatementHelp":{"#cdata":"Syntax: KEEP column-list; \n      \nIncludes columns in output tables. \n\nThe KEEP statement specifies that all columns in the column list should be included \nin the creation of output rows. If the KEEP attribute is specified, all columns not \nincluded in the KEEP statement will be dropped from the output rows. If no DROP or \nKEEP statement appears, all tables that are created in the DS2 program contain all \ncolumns. Do not use both DROP and KEEP statements within the same DS2 program."},"StatementOptions":null},{"StatementName":"DROP PACKAGE","StatementHelp":{"#cdata":"Syntax: DROP PACKAGE package [(table-options)]; \n      \nRemoves a DS2 package. \n\npackage \nspecifies the name of the package to be removed.\n\ntable-options \nspecifies optional arguments that the DS2 program applies when it removes a package."},"StatementOptions":{"#comment":{},"StatementOption":[{"StatementOptionName":"ALTER=","StatementOptionHelp":{"#cdata":"Syntax: ALTER=alter-password \n    \nSyntax Description:\nalter-password \n  must be a valid SAS name.\n \nDetails: \nThe ALTER= option applies only to a SAS data set. You can use this option to assign \na password or to access a read-protected, write-protected, or alter-protected file. \nWhen you replace a data set that is protected with an ALTER password, the new data \nset inherits the ALTER password. \n\nThe password is blotted out when the code is written in the SAS log. For example: \n\n  set a(alter=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"V"},{"StatementOptionName":"BUFNO=","StatementOptionHelp":{"#cdata":"Specifies the number of buffers to be allocated for processing a SAS data set. \n    \nSyntax: BUFNO= n | nK | hexX | MIN | MAX  \n\nSyntax Description:\n\nn | nK \n  specifies the number of buffers in multiples of 1 (bytes); 1,024 (kilobytes). For example, \n  a value of 8 specifies 8 buffers, and a value of 1k specifies 1024 buffers.\n\nhex \n  specifies the number of buffers as a hexadecimal value. You must specify the value beginning \n  with a number (0-9), followed by an X. For example, the value 2dx sets the number of buffers \n  to 45 buffers.\n\nMIN \n  sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value \n  for the operating environment. This is the default.\n\nMAX \n  sets the number of buffers to the maximum possible number in your operating environment, \n  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"hexX","@Value4":"MIN","@Value5":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the number of buffers in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the number of buffers in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the number of buffers as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip4":"Sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value  for the operating environment. This is the default.","@ToolTip5":"Sets the number of buffers to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."}},{"StatementOptionName":"BUFSIZE=","StatementOptionHelp":{"#cdata":"Specifies the size of a permanent buffer page for an output SAS data set. \n    \nSyntax: BUFSIZE= n | nK | nM | nG | hexX | MAX  \n\nSyntax Description:\n\nn | nK | nM | nG \nspecifies the page size in multiples of 1 (bytes); 1,024 (kilobytes); 1,048,576 (megabytes); \nor 1,073,741,824 (gigabytes). For example, a value of 8 specifies a page size of 8 bytes, and \na value of 4k specifies a page size of 4096 bytes. \n\nhexX \nspecifies the page size as a hexadecimal value. You must specify the value beginning with a \nnumber (0-9), followed by an X. For example, the value 2dx sets the page size to 45 bytes.\n\nMAX \nsets the page size to the maximum possible number in your operating environment, up to the \nlargest four-byte, signed integer, which is 231-1, or approximately 2 billion bytes."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"nM","@Value4":"nG","@Value5":"hexX","@Value6":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the page size in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the page size in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the page size in multiples of 1,048,576 (megabytes).  Replace n with an integer value.","@ToolTip4":"Specifies the page size in multiples of 1,073,741,824 (gigabytes).  Replace n with an integer value.","@ToolTip5":"Specifies the page size as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip6":"Sets the page size to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion bytes."}},{"StatementOptionName":"BULKLOAD=","StatementOptionHelp":{"#cdata":"Loads rows of data as one unit. Default value: NO  \n    \nSyntax: BULKLOAD=YES | NO  \n\nSyntax Description:\n\nYES \ncalls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.\n\nNO \nuses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Calls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.","@ToolTip2":"Uses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."}},{"StatementOptionName":"COMPRESS=","StatementOptionHelp":{"#cdata":"Specifies how observations are compressed in a new output SAS data set. \n    \nSyntax: COMPRESS=NO | YES | CHAR | BINARY  \n\nSyntax Description:\nNO \nspecifies that the observations in a newly created SAS data set are uncompressed (fixed-length records).\n\nYES | CHAR \nspecifies that the observations in a newly created SAS data set are compressed (variable-length records) \nby SAS using RLE (Run Length Encoding). RLE compresses observations by reducing repeated consecutive \ncharacters (including blanks) to two-byte or three-byte representations. \n\n  Alias: ON \n  Tip: Use this compression algorithm for character data. \n  Note:   COMPRESS=CHAR is accepted by Version 7 and later versions.  \n\nBINARY \n  specifies that the observations in a newly created SAS data set are compressed (variable-length records) \n  by SAS using RDC (Ross Data Compression). RDC combines run-length encoding and sliding-window compression \n  to compress the file.\n\n  Tip: This method is highly effective for compressing medium to large (several hundred bytes or larger) \n  blocks of binary data (numeric variables). Because the compression function operates on a single record \n  at a time, the record length needs to be several hundred bytes or larger for effective compression."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NO","@Value2":"YES|ON","@Value3":"CHAR","@Value4":"BINARY"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the observations in a newly created SAS data set are uncompressed  (fixed-length records).","@ToolTip2":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.","@ToolTip3":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.   COMPRESS=CHAR is accepted by Version 7 and later versions.","@ToolTip4":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RDC (Ross Data Compression). RDC combines  run-length encoding and sliding-window compression to compress the file."}},{"StatementOptionName":"DBKEY=","StatementOptionHelp":{"#cdata":"Specifies a key column to optimize DBMS retrieval. Can improve performance when you \nare processing a join that involves a large DBMS table and a small SAS data set \nor DBMS table.\n    \nSyntax: DBKEY=([ ' ] column [ ' ] [... [ ' ] column [ ' ] ])  \n\nSyntax Description: \n\ncolumn \n  used by SAS to build an internal WHERE clause to search for matches in the DBMS table \n  based on the key column. For example:\n\n    select * from sas.a, dbms.b(dbkey=x) where a.x=b.x;\n    \nIn this example, DBKEY= specifies column x , which matches the key column designated in \nthe WHERE clause. However, if the DBKEY= column does NOT match the key column in the \nWHERE clause, then DBKEY= is not used."},"StatementOptionType":"V"},{"StatementOptionName":"DBNULL=","StatementOptionHelp":{"#cdata":"Indicates whether NULL is a valid value for the specified columns when a table is created. \n    \nSyntax: DBNULL={ _ALL=YES | NO } | ( [column=YES | NO [ ... column=YES | NO ] ] )  \n\nSyntax Description: \n_ALL_ \n  specifies that the YES or NO applies to all columns in the table. (This is valid in \n  the interfaces to Informix, Oracle, Sybase, and Teradata only.)\n\nYES \n  specifies that the NULL value is valid for the specified columns in the DBMS table.\n\nNO \n  specifies that the NULL value is not valid for the specified columns in the DBMS table.\n\ncolumn \n  specifies the name of a column. \n\nDetails: \nThis option is valid only for creating DBMS tables. If you specify more than one column name, \nthe names must be separated with spaces.\n\nThe DBNULL= option processes values from left to right, so if you specify a column name twice, \nor if you use the _ALL_ value, the last value overrides the first value that is specified for \nthe column."},"StatementOptionType":"V","SubOptionsKeywords":"_ALL_"},{"StatementOptionName":"DROP=","StatementOptionHelp":{"#cdata":"For an input table, excludes the specified columns from processing; for an output table, excludes the specified columns from being written to the table.\n    \nSyntax: DROP= ( column-list );  \n\nArguments: \ncolumn-list \n  specifies the names of the columns to omit from the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the format \n  col: are not supported. \n \nDetails: \nThe DROP= table option specifies that all columns in the column-list should not be included \nin the creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the drop attribute is specified, all columns not included in the drop \nstatement will be used to create columns in the output rows.\n\nIf the DROP= table option is associated with an input table, the columns are not available \nfor processing during program execution."},"StatementOptionType":"V"},{"StatementOptionName":"ENCRYPT=","StatementOptionHelp":{"#cdata":"Specifies whether to encrypt an output SAS data set. \n    \nSyntax: ENCRYPT=YES | NO  \n\nSyntax Description:\nYES \n  encrypts the file. The encryption method uses passwords. At a minimum, you must specify \n  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because \n  the encryption method uses passwords, you cannot change any password on an encrypted data \n  set without re-creating the data set.\n\nNO \n  does not encrypt the file.\n\nCAUTION:\nRecord all passwords. \nIf you forget the password, you cannot reset it without assistance from SAS. The process \nis time-consuming and resource-intensive."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Encrypts the file. The encryption method uses passwords. At a minimum, you must specify  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because  the encryption method uses passwords, you cannot change any password on an encrypted data  set without re-creating the data set.","@ToolTip2":"Does not encrypt the file."}},{"StatementOptionName":"KEEP=","StatementOptionHelp":{"#cdata":"For an input table, specifies the columns to process; for an output table, specifies \nthe columns to write to the table. \n    \nSyntax: KEEP=( column-list );  \n\nArguments:\n\ncolumn-list \n  specifies the names of the columns to keep in the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the \n  format col: are not supported. \n  \nDetails: \nThe KEEP= table option specifies that all columns in the column-list should be included in \nthe creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the keep attribute is specified, all columns not included in the KEEP \nstatement will be dropped from the output rows.\n\nIf the KEEP= table option is associated with an input table, only the columns that are \nspecified by the KEEP= table option are available for processing during program execution."},"StatementOptionType":"V"},{"StatementOptionName":"LABEL=","StatementOptionHelp":{"#cdata":"Specifies a label for a table.\n    \nSyntax: LABEL='label'  \n\nSyntax Description: \n\n'label' \n  specifies a text string of up to 256 characters. If the label text contains single \n  quotation marks, use double quotation marks around the label, or use two single \n  quotation marks in the label text and surround the string with single quotation \n  marks. To remove a label from a table, assign a label that is equal to a blank \n  that is enclosed in quotation marks.\n \nDetails: \nYou can use the LABEL= option on both input and output tables. When you use LABEL= \non input tables, it assigns a label for the table for the duration of the DS2 program. \nWhen it is specified for an output table, the label becomes a permanent part of that \ntable."},"StatementOptionType":"V"},{"StatementOptionName":"LOCKTABLE=","StatementOptionHelp":{"#cdata":"Places shared or exclusive locks on tables. \n    \nSyntax: LOCKTABLE=SHARE | EXCLUSIVE  \n\nSyntax Description:\n\nSHARE \n  locks a table in shared mode, allowing other users or processes to read data from the \n  tables, but preventing users from updating data.\n\nEXCLUSIVE \n  locks a table exclusively, preventing other users from accessing any table that you open. \n\nDetails: \nYou can lock tables only if you are the owner or have been granted the necessary privilege. \n\nIf you access the BASE table driver through PROC DS2, the default value for the LOCKTABLE \noption is EXCLUSIVE. However, if you access the BASE table driver through a table server, \nor if you run your program locally with the SAS Table Server LIBNAME engine, the default \nvalue for the LOCKTABLE option is SHARE."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"SHARE","@Value2":"EXCLUSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Locks a table in shared mode, allowing other users or processes to read data from  the tables, but preventing users from updating data.","@ToolTip2":"Locks a table exclusively, preventing other users from accessing any table that you open."}},{"StatementOptionName":"OVERWRITE=","StatementOptionHelp":{"#cdata":"For a table, drops the output table before the replacement output table is populated \nwith rows; for packages and threads, drops the existing package or thread if a package \nor thread by the same name exists. \n    \nSyntax: OVERWRITE= YES | NO;  \n\nArguments: \n\nYES | NO \n  specifies whether the output table is deleted before a replacement output table \n  is created or whether a package or thread is dropped.\n\n  Default: NO \n\nCAUTION:\nFor tables, use the OVERWRITE=YES statement only with data that is backed up or \nwith data that you can reconstruct. Because the output table is deleted first, \ndata will be lost if a failure occurs while the output table is being written."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the output table is deleted before a replacement output table    is created or a package or thread is dropped.","@ToolTip2":"Specifies that the output table is not deleted before a replacement output table    is created or a package or thread is dropped."}},{"StatementOptionName":"PW=","StatementOptionHelp":{"#cdata":"Assigns a READ, WRITE, and ALTER password to a SAS file, and enables access to a password-protected SAS file. \n    \nSyntax: PW=password  \n\nSyntax Description:\npassword \n  must be a valid SAS name.\n\nDetails:\nThe PW= option applies to all types of SAS files. You can use this option to assign \na password to a SAS file or to access a password-protected SAS file.\n\nWhen replacing a SAS data set that is protected by an ALTER password, the new data \nset inherits the ALTER password. When the code is written to the SAS log the password \nis blotted out, for example: \n\n  drop thread job2 (pw=xxxxxxx);\n\nNote:   A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"V"},{"StatementOptionName":"READ=","StatementOptionHelp":{"#cdata":"Assigns a READ password to a SAS file that prevents users from reading the file, \nunless they enter the password. \n    \nSyntax: READ=read-password  \n\nSyntax Description: \nread-password \n  must be a valid SAS name. \n \nDetails: \nThe READ= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a read-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  declare package sales (read=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You  \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"V"},{"StatementOptionName":"RENAME=","StatementOptionHelp":{"#cdata":"Changes the name of a column.\n    \nSyntax: RENAME= (old-name { = | AS } new-name [... old-name { = | AS } new-name ] ) ;  \n\nArguments: \nold-name \n  the column you want to rename.\n\nnew-name \n  the new name of the column. It must be a valid name for the data source.\n \nDetails: \nThe RENAME= table option allows you to change the names of one or more columns.\n\nIf you use RENAME= when you create a table, the new column name is included in the output \ntable. If you use RENAME= on an input table, the new name is used in DS2 programming statements.\n\nIf you use RENAME= in the same DS2 program with either the DROP= or the KEEP= table option, \nthe DROP= and the KEEP= table options are applied before RENAME=. You must use the old name in \nthe DROP= and KEEP= table options. You cannot drop and rename the same column in the same statement.\n\nIn addition to changing the name of a column, RENAME= also changes the label for the column."},"StatementOptionType":"V","SubOptionsKeywords":"AS"},{"StatementOptionName":"AS","StatementOptionHelp":{"#cdata":"Syntax: RENAME= (old-name AS new-name [... old-name AS new-name ] ) ;\n          \nSeparates the new-name from the old-name."},"StatementOptionType":"S"},{"StatementOptionName":"TYPE=","StatementOptionHelp":{"#cdata":"Specifies the data set type for a specially structured SAS data set. \n    \nSyntax: TYPE=data-set-type  \n\nSyntax Description: \ndata-set-type \n  specifies the special type of the data set.\n\nDetails: \nUse the TYPE= table option to create a special SAS data set in the proper format, \nor to identify the special type of the SAS data set in a procedure statement. \n\nYou can use the CONTENTS procedure to determine the type of a data set."},"StatementOptionType":"V"},{"StatementOptionName":"WRITE=","StatementOptionHelp":{"#cdata":"Assigns a WRITE password to a SAS file that prevents users from writing to a file, \nunless they enter the password. \n    \nSyntax: WRITE=write-password  \n\nSyntax Description: \nwrite-password \n  must be a valid SAS name. \n \nDetails: \nThe WRITE= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a write-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  drop thread job2a (write=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"V"}]}},{"StatementName":"CONTINUE","StatementHelp":{"#cdata":"Syntax: CONTINUE; \n      \nStops processing the current DO loop iteration and resumes with the next iteration."},"StatementOptions":null},{"StatementName":"IF","StatementHelp":{"#cdata":"Syntax: IF expression THEN statement; \n  [ ELSE statement ;] \n  \nExecutes a statement for observations that meet specific conditions."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"THEN","StatementOptionHelp":{"#cdata":"If the conditions that are specified in the IF clause are met, the IF-THEN statement \nexecutes a SAS statement."},"StatementOptionType":"S"},{"StatementOptionName":"DO","StatementOptionHelp":{"#cdata":"Syntax: DO [ < index-variable-clause > ] [ < conditional-clause > ] ;  \n  ...statement-list...\n  END [end-label ] ;  \n\nSpecifies a group of statements to be executed as a unit."},"StatementOptionType":"S"},{"StatementOptionName":"TO","StatementOptionHelp":{"#cdata":"Separates the start and stop integers or expressions that control the number of times the \nportion of the step between the iterative DO and END statements is processed."},"StatementOptionType":"S"},{"StatementOptionName":"BY","StatementOptionHelp":{"#cdata":"Precedes an increment integer (other than 0) or an expression that generates an integer to be \nadded to the value of the index variable in each iteration of the DO loop."},"StatementOptionType":"S"},{"StatementOptionName":"CONTINUE","StatementOptionHelp":{"#cdata":"Stops processing the current DO loop iteration and resumes with the next iteration."},"StatementOptionType":"S"},{"StatementOptionName":"LEAVE","StatementOptionHelp":{"#cdata":"Syntax: LEAVE [ identifier ] ; \n      \nStops processing the current DO loop and transfers execution to either the statement \nfollowing the current DO statement, or a labeled DO statement that encloses the current \nDO statement."},"StatementOptionType":"S"}]}},{"StatementName":"ELSE","StatementHelp":{"#cdata":"If the condition in an IF-THEN statement is false and an ELSE statement is present, \nthen the ELSE action is carried out."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"IF","StatementOptionHelp":{"#cdata":"Syntax: ELSE IF expression THEN statement; \n\nExecutes a statement for observations that meet specific conditions."},"StatementOptionType":"S"},{"StatementOptionName":"THEN","StatementOptionHelp":{"#cdata":"If the conditions that are specified in the IF clause are met, the IF-THEN statement \nexecutes a SAS statement."},"StatementOptionType":"S"},{"StatementOptionName":"DO","StatementOptionHelp":{"#cdata":"Syntax: DO [ < index-variable-clause > ] [ < conditional-clause > ] ;  \n  ...statement-list...\n  END [end-label ] ;  \n\nSpecifies a group of statements to be executed as a unit."},"StatementOptionType":"S"},{"StatementOptionName":"TO","StatementOptionHelp":{"#cdata":"Separates the start and stop integers or expressions that control the number of times the \nportion of the step between the iterative DO and END statements is processed."},"StatementOptionType":"S"},{"StatementOptionName":"BY","StatementOptionHelp":{"#cdata":"Precedes an increment integer (other than 0) or an expression that generates an integer to be \nadded to the value of the index variable in each iteration of the DO loop."},"StatementOptionType":"S"},{"StatementOptionName":"CONTINUE","StatementOptionHelp":{"#cdata":"Stops processing the current DO loop iteration and resumes with the next iteration."},"StatementOptionType":"S"},{"StatementOptionName":"PUT","StatementOptionHelp":{"#cdata":"Syntax: PUT < put-list > [ ... <put-list> ] ; \n  <put-list>::=  'character-string' | <eq-expression> [ = ] [ [ : ] format [-L | -C | -R ] ]   \n  <eq-expression>::=  identifier | array-reference | this-expression \n      \nPrints values of program variables and constants to the log. \n\nArguments:\n'character-string' \nspecifies a string of text, enclosed in quotation marks, that is written to the SAS log.\n\nidentifier \nnames a variable whose value is written to the SAS log.\n\narray-reference \nspecifies an array element. The subscript can be any SAS expression that resolves to an \ninteger value when the PUT statement executes. Use the array subscript asterisk (*) to \nwrite all elements of the array.\n\nthis-expression \nspecifies a THIS expression.\n\n= \nIf an equal sign is added after a variable or array element, then the output is preceded \nby the variable or array element name and an equal sign.\n\n: \nenables you to specify a format that the PUT statement uses to write the variable value. \nAll leading and trailing blanks are deleted, and each value is followed by a single blank.\nRestriction: You must specify a format. \n\nformat \nspecifies a format to use when the data value is written to the SAS log. If you use a colon \nmodifier (:) with the format name, all leading and trailing blanks are deleted and each value \nis followed by a single blank. To override the default alignment, you can add an alignment \nspecification to a format:\n  -L left aligns the value.  \n  -C centers the value.  \n  -R right aligns the value.\n \nTip: Ensure that the format width provides enough space to write the value and any commas, \ndollar signs, decimal points, or other special characters that the format includes."},"StatementOptionType":"S"},{"StatementOptionName":"LEAVE","StatementOptionHelp":{"#cdata":"Syntax: LEAVE [ identifier ] ; \n      \nStops processing the current DO loop and transfers execution to either the statement \nfollowing the current DO statement, or a labeled DO statement that encloses the current \nDO statement."},"StatementOptionType":"S"}]}},{"StatementName":"DECLARE|DCL","StatementHelp":{"#cdata":"Syntax: DECLARE { <data-type> <variable-list> [ <having-clause> ] } ; \n      \nDeclares one or more DS2 variables or arrays."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"INTEGER|INT","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"BIGINT","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"IDENTITY","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"SMALLINT","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"TINYINT","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"DOUBLE","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"DOUBLE PRECISION","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"FLOAT","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"REAL","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"VARBINARY|BINARY VARYING","StatementOptionHelp":{"#cdata":"Specifies a varying-length binary variable.\n\nAlias: BINARY VARYING \n\nRequirement: If you specify VARBINARY, you must also specify the length of the binary \nvariable in bytes."},"StatementOptionType":"S"},{"StatementOptionName":"NCHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"NVARCHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"CHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"VARCHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"CHARACTER SET","StatementOptionHelp":{"#cdata":"[For use with CHAR and VARCHAR data types only]\n          \nSyntax: \nCHAR [ ( character-length ) ] [CHARACTER SET (character-set-identifier) ] \nVARCHAR [ ( character-length ) ] [CHARACTER SET (character-set-identifier) ]\n\nSpecifies character set encoding information for CHAR and VARCHAR data types."},"StatementOptionType":"S"},{"StatementOptionName":"TIME","StatementOptionHelp":{"#cdata":"Syntax: TIME (precision)\n          \nSpecifies a time variable. \n\nprecision \nspecifies the precision for a TIME data type.\n\nDefault: 0"},"StatementOptionType":"S"},{"StatementOptionName":"TIMESTAMP","StatementOptionHelp":{"#cdata":"Syntax: TIMESTAMP (precision) \n          \nSpecifies both a date and time variable. \n\nprecision \nspecifies the precision for a TIMESTAMP data type.\n\nDefault: 6"},"StatementOptionType":"S"},{"StatementOptionName":"DATE","StatementOptionHelp":{"#cdata":"Specifies a date variable."},"StatementOptionType":"S"},{"StatementOptionName":"HAVING","StatementOptionHelp":{"#cdata":"Syntax: HAVING <having-option> [... <having-option> ]  \n \nThe HAVING clause functions the same as the FORMAT, INFORMAT, and LABEL statements \nin Base SAS. However, in DS2, the attributes must be specified in the declaration \nstatement of the variable."},"StatementOptionType":"S"},{"StatementOptionName":"LABEL","StatementOptionHelp":{"#cdata":"[For HAVING clause only]\n          \nSyntax: LABEL 'string' | n'string' \n\nAssigns a descriptive label to the variable. The label can be a CHAR literal (string) \nor NCHAR literal (nstring)."},"StatementOptionType":"S"},{"StatementOptionName":"FORMAT","StatementOptionHelp":{"#cdata":"[For HAVING clause only] \n          \nSyntax: FORMAT format \n\nAssociates any valid DS2 format with the variable."},"StatementOptionType":"S"},{"StatementOptionName":"INFORMAT","StatementOptionHelp":{"#cdata":"[For HAVING clause only] \n          \nSyntax: INFORMAT informat \n\nAssociates any valid SAS informat with the variable."},"StatementOptionType":"S"},{"StatementOptionName":"PACKAGE","StatementOptionHelp":{"#cdata":"Creates an instance of a package. \n          \nSyntax:\n(1) DECLARE PACKAGE package [(table-options)] instance [ ( )] [... instance [ ( )]];  \n(2) DECLARE PACKAGE HASH instance [ ( hashexp, 'datasource', 'ordered', 'duplicate' ) ];  \n(3) DECLARE PACKAGE HITER instance [ ( 'hashname')];"},"StatementOptionType":"S"},{"StatementOptionName":"HASH","StatementOptionHelp":{"#cdata":"Specifies the name of the package as HASH to register the hash package \nfor use in a DS2 program."},"StatementOptionType":"RS"},{"StatementOptionName":"HITER","StatementOptionHelp":{"#cdata":"Specifies the name of the package as HITER to register the hash iterator package \nfor use in a DS2 program."},"StatementOptionType":"RS"}]}},{"StatementName":"GLOBAL","StatementHelp":{"#cdata":"Syntax: GLOBAL { <data-type> <variable-list> [ <having-clause> ] } ; \n      \nDeclares one or more global variables or arrays."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"INT|INTEGER","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"BIGINT","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"IDENTITY","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"SMALLINT","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"TINYINT","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"DOUBLE","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"DOUBLE PRECISION","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"FLOAT","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"REAL","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"VARBINARY","StatementOptionHelp":{"#cdata":"Specifies a varying-length binary variable.\n\nAlias: BINARY VARYING \n\nRequirement: If you specify VARBINARY, you must also specify the length of the binary \nvariable in bytes."},"StatementOptionType":"S"},{"StatementOptionName":"NCHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"NVARCHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"CHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"VARCHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"CHARACTER SET","StatementOptionHelp":{"#cdata":"[For use with CHAR and VARCHAR data types only]\n          \nSyntax: \nCHAR [ ( character-length ) ] [CHARACTER SET (character-set-identifier) ] \nVARCHAR [ ( character-length ) ] [CHARACTER SET (character-set-identifier) ]\n\nSpecifies character set encoding information for CHAR and VARCHAR data types."},"StatementOptionType":"S"},{"StatementOptionName":"TIME","StatementOptionHelp":{"#cdata":"Syntax: TIME (precision)\n          \nSpecifies a time variable. \n\nprecision \nspecifies the precision for a TIME data type.\n\nDefault: 0"},"StatementOptionType":"S"},{"StatementOptionName":"TIMESTAMP","StatementOptionHelp":{"#cdata":"Syntax: TIMESTAMP (precision) \n          \nSpecifies both a date and time variable. \n\nprecision \nspecifies the precision for a TIMESTAMP data type.\n\nDefault: 6"},"StatementOptionType":"S"},{"StatementOptionName":"DATE","StatementOptionHelp":{"#cdata":"Specifies a date variable."},"StatementOptionType":"S"},{"StatementOptionName":"HAVING","StatementOptionHelp":{"#cdata":"Syntax: HAVING <having-option> [... <having-option> ]  \n \nThe HAVING clause functions the same as the FORMAT, INFORMAT, and LABEL statements \nin Base SAS. However, in DS2, the attributes must be specified in the declaration \nstatement of the variable."},"StatementOptionType":"S"},{"StatementOptionName":"LABEL","StatementOptionHelp":{"#cdata":"[For HAVING clause only]\n          \nSyntax: LABEL 'string' | n'string' \n\nAssigns a descriptive label to the variable. The label can be a CHAR literal (string) \nor NCHAR literal (nstring)."},"StatementOptionType":"S"},{"StatementOptionName":"FORMAT","StatementOptionHelp":{"#cdata":"[For HAVING clause only] \n          \nSyntax: FORMAT format \n\nAssociates any valid DS2 format with the variable."},"StatementOptionType":"S"},{"StatementOptionName":"INFORMAT","StatementOptionHelp":{"#cdata":"[For HAVING clause only] \n          \nSyntax: INFORMAT informat \n\nAssociates any valid SAS informat with the variable."},"StatementOptionType":"S"}]}},{"StatementName":"DROP THREAD","StatementHelp":{"#cdata":"Syntax: DROP THREAD thread [(table-options)]; \n      \nRemoves a DS2 program thread. \n\nthread \nspecifies the name of the thread to be removed.\n\ntable-options \nspecifies optional arguments that the DS2 program applies when it removes a thread."},"StatementOptions":{"#comment":{},"StatementOption":[{"StatementOptionName":"ALTER=","StatementOptionHelp":{"#cdata":"Syntax: ALTER=alter-password \n    \nSyntax Description:\nalter-password \n  must be a valid SAS name.\n \nDetails:\nThe ALTER= option applies only to a SAS data set. You can use this option to assign \na password or to access a read-protected, write-protected, or alter-protected file. \nWhen you replace a data set that is protected with an ALTER password, the new data \nset inherits the ALTER password. \n\nThe password is blotted out when the code is written in the SAS log. For example: \n\n  set a(alter=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"},{"StatementOptionName":"BUFNO=","StatementOptionHelp":{"#cdata":"Specifies the number of buffers to be allocated for processing a SAS data set. \n    \nSyntax: BUFNO= n | nK | hexX | MIN | MAX  \n\nSyntax Description:\n\nn | nK \n  specifies the number of buffers in multiples of 1 (bytes); 1,024 (kilobytes). For example, \n  a value of 8 specifies 8 buffers, and a value of 1k specifies 1024 buffers.\n\nhex \n  specifies the number of buffers as a hexadecimal value. You must specify the value beginning \n  with a number (0-9), followed by an X. For example, the value 2dx sets the number of buffers \n  to 45 buffers.\n\nMIN \n  sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value \n  for the operating environment. This is the default.\n\nMAX \n  sets the number of buffers to the maximum possible number in your operating environment, \n  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"hexX","@Value4":"MIN","@Value5":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the number of buffers in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the number of buffers in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the number of buffers as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip4":"Sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value  for the operating environment. This is the default.","@ToolTip5":"Sets the number of buffers to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."}},{"StatementOptionName":"BUFSIZE=","StatementOptionHelp":{"#cdata":"Specifies the size of a permanent buffer page for an output SAS data set. \n    \nSyntax: BUFSIZE= n | nK | nM | nG | hexX | MAX  \n\nSyntax Description:\n\nn | nK | nM | nG \nspecifies the page size in multiples of 1 (bytes); 1,024 (kilobytes); 1,048,576 (megabytes); \nor 1,073,741,824 (gigabytes). For example, a value of 8 specifies a page size of 8 bytes, and \na value of 4k specifies a page size of 4096 bytes. \n\nhexX \nspecifies the page size as a hexadecimal value. You must specify the value beginning with a \nnumber (0-9), followed by an X. For example, the value 2dx sets the page size to 45 bytes.\n\nMAX \nsets the page size to the maximum possible number in your operating environment, up to the \nlargest four-byte, signed integer, which is 231-1, or approximately 2 billion bytes."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"nM","@Value4":"nG","@Value5":"hexX","@Value6":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the page size in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the page size in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the page size in multiples of 1,048,576 (megabytes).  Replace n with an integer value.","@ToolTip4":"Specifies the page size in multiples of 1,073,741,824 (gigabytes).  Replace n with an integer value.","@ToolTip5":"Specifies the page size as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip6":"Sets the page size to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion bytes."}},{"StatementOptionName":"BULKLOAD=","StatementOptionHelp":{"#cdata":"Loads rows of data as one unit. Default value: NO  \n    \nSyntax: BULKLOAD=YES | NO  \n\nSyntax Description:\n\nYES \ncalls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.\n\nNO \nuses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Calls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.","@ToolTip2":"Uses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."}},{"StatementOptionName":"COMPRESS=","StatementOptionHelp":{"#cdata":"Specifies how observations are compressed in a new output SAS data set. \n    \nSyntax: COMPRESS=NO | YES | CHAR | BINARY  \n\nSyntax Description:\nNO \nspecifies that the observations in a newly created SAS data set are uncompressed (fixed-length records).\n\nYES | CHAR \nspecifies that the observations in a newly created SAS data set are compressed (variable-length records) \nby SAS using RLE (Run Length Encoding). RLE compresses observations by reducing repeated consecutive \ncharacters (including blanks) to two-byte or three-byte representations. \n\n  Alias: ON \n  Tip: Use this compression algorithm for character data. \n  Note:   COMPRESS=CHAR is accepted by Version 7 and later versions.  \n\nBINARY \n  specifies that the observations in a newly created SAS data set are compressed (variable-length records) \n  by SAS using RDC (Ross Data Compression). RDC combines run-length encoding and sliding-window compression \n  to compress the file.\n\n  Tip: This method is highly effective for compressing medium to large (several hundred bytes or larger) \n  blocks of binary data (numeric variables). Because the compression function operates on a single record \n  at a time, the record length needs to be several hundred bytes or larger for effective compression."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"NO","@Value2":"YES|ON","@Value3":"CHAR","@Value4":"BINARY"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the observations in a newly created SAS data set are uncompressed  (fixed-length records).","@ToolTip2":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.","@ToolTip3":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.   COMPRESS=CHAR is accepted by Version 7 and later versions.","@ToolTip4":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RDC (Ross Data Compression). RDC combines  run-length encoding and sliding-window compression to compress the file."}},{"StatementOptionName":"DBKEY=","StatementOptionHelp":{"#cdata":"Specifies a key column to optimize DBMS retrieval. Can improve performance when you \nare processing a join that involves a large DBMS table and a small SAS data set \nor DBMS table.\n    \nSyntax: DBKEY=([ ' ] column [ ' ] [... [ ' ] column [ ' ] ])  \n\nSyntax Description: \n\ncolumn \n  used by SAS to build an internal WHERE clause to search for matches in the DBMS table \n  based on the key column. For example:\n\n    select * from sas.a, dbms.b(dbkey=x) where a.x=b.x;\n    \nIn this example, DBKEY= specifies column x , which matches the key column designated in \nthe WHERE clause. However, if the DBKEY= column does NOT match the key column in the \nWHERE clause, then DBKEY= is not used."},"StatementOptionType":"TV"},{"StatementOptionName":"DBNULL=","StatementOptionHelp":{"#cdata":"Indicates whether NULL is a valid value for the specified columns when a table is created. \n    \nSyntax: DBNULL={ _ALL=YES | NO } | ( [column=YES | NO [ ... column=YES | NO ] ] )  \n\nSyntax Description: \n_ALL_ \n  specifies that the YES or NO applies to all columns in the table. (This is valid in \n  the interfaces to Informix, Oracle, Sybase, and Teradata only.)\n\nYES \n  specifies that the NULL value is valid for the specified columns in the DBMS table.\n\nNO \n  specifies that the NULL value is not valid for the specified columns in the DBMS table.\n\ncolumn \n  specifies the name of a column. \n\nDetails: \nThis option is valid only for creating DBMS tables. If you specify more than one column name, \nthe names must be separated with spaces.\n\nThe DBNULL= option processes values from left to right, so if you specify a column name twice, \nor if you use the _ALL_ value, the last value overrides the first value that is specified for \nthe column."},"StatementOptionType":"TV","SubOptionsKeywords":"_ALL_"},{"StatementOptionName":"DROP=","StatementOptionHelp":{"#cdata":"For an input table, excludes the specified columns from processing; for an output table, excludes the specified columns from being written to the table.\n    \nSyntax: DROP= ( column-list );  \n\nArguments: \ncolumn-list \n  specifies the names of the columns to omit from the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the format \n  col: are not supported. \n \nDetails: \nThe DROP= table option specifies that all columns in the column-list should not be included \nin the creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the drop attribute is specified, all columns not included in the drop \nstatement will be used to create columns in the output rows.\n\nIf the DROP= table option is associated with an input table, the columns are not available \nfor processing during program execution."},"StatementOptionType":"TV"},{"StatementOptionName":"ENCRYPT=","StatementOptionHelp":{"#cdata":"Specifies whether to encrypt an output SAS data set. \n    \nSyntax: ENCRYPT=YES | NO  \n\nSyntax Description:\nYES \n  encrypts the file. The encryption method uses passwords. At a minimum, you must specify \n  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because \n  the encryption method uses passwords, you cannot change any password on an encrypted data \n  set without re-creating the data set.\n\nNO \n  does not encrypt the file.\n\nCAUTION:\nRecord all passwords. \nIf you forget the password, you cannot reset it without assistance from SAS. The process \nis time-consuming and resource-intensive."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Encrypts the file. The encryption method uses passwords. At a minimum, you must specify  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because  the encryption method uses passwords, you cannot change any password on an encrypted data  set without re-creating the data set.","@ToolTip2":"Does not encrypt the file."}},{"StatementOptionName":"KEEP=","StatementOptionHelp":{"#cdata":"For an input table, specifies the columns to process; for an output table, specifies \nthe columns to write to the table. \n    \nSyntax: KEEP=( column-list );  \n\nArguments:\n\ncolumn-list \n  specifies the names of the columns to keep in the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the \n  format col: are not supported. \n  \nDetails: \nThe KEEP= table option specifies that all columns in the column-list should be included in \nthe creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the keep attribute is specified, all columns not included in the KEEP \nstatement will be dropped from the output rows.\n\nIf the KEEP= table option is associated with an input table, only the columns that are \nspecified by the KEEP= table option are available for processing during program execution."},"StatementOptionType":"TV"},{"StatementOptionName":"LABEL=","StatementOptionHelp":{"#cdata":"Specifies a label for a table.\n    \nSyntax: LABEL='label'  \n\nSyntax Description: \n\n'label' \n  specifies a text string of up to 256 characters. If the label text contains single \n  quotation marks, use double quotation marks around the label, or use two single \n  quotation marks in the label text and surround the string with single quotation \n  marks. To remove a label from a table, assign a label that is equal to a blank \n  that is enclosed in quotation marks.\n \nDetails: \nYou can use the LABEL= option on both input and output tables. When you use LABEL= \non input tables, it assigns a label for the table for the duration of the DS2 program. \nWhen it is specified for an output table, the label becomes a permanent part of that \ntable."},"StatementOptionType":"TV"},{"StatementOptionName":"LOCKTABLE=","StatementOptionHelp":{"#cdata":"Places shared or exclusive locks on tables. \n    \nSyntax: LOCKTABLE=SHARE | EXCLUSIVE  \n\nSyntax Description:\n\nSHARE \n  locks a table in shared mode, allowing other users or processes to read data from the \n  tables, but preventing users from updating data.\n\nEXCLUSIVE \n  locks a table exclusively, preventing other users from accessing any table that you open. \n\nDetails: \nYou can lock tables only if you are the owner or have been granted the necessary privilege. \n\nIf you access the BASE table driver through PROC DS2, the default value for the LOCKTABLE \noption is EXCLUSIVE. However, if you access the BASE table driver through a table server, \nor if you run your program locally with the SAS Table Server LIBNAME engine, the default \nvalue for the LOCKTABLE option is SHARE."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"SHARE","@Value2":"EXCLUSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Locks a table in shared mode, allowing other users or processes to read data from  the tables, but preventing users from updating data.","@ToolTip2":"Locks a table exclusively, preventing other users from accessing any table that you open."}},{"StatementOptionName":"OVERWRITE=","StatementOptionHelp":{"#cdata":"For a table, drops the output table before the replacement output table is populated \nwith rows; for packages and threads, drops the existing package or thread if a package \nor thread by the same name exists. \n    \nSyntax: OVERWRITE= YES | NO;  \n\nArguments: \n\nYES | NO \n  specifies whether the output table is deleted before a replacement output table \n  is created or whether a package or thread is dropped.\n\n  Default: NO \n\nCAUTION:\nFor tables, use the OVERWRITE=YES statement only with data that is backed up or \nwith data that you can reconstruct. Because the output table is deleted first, \ndata will be lost if a failure occurs while the output table is being written."},"StatementOptionType":"TV","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the output table is deleted before a replacement output table    is created or a package or thread is dropped.","@ToolTip2":"Specifies that the output table is not deleted before a replacement output table    is created or a package or thread is dropped."}},{"StatementOptionName":"PW=","StatementOptionHelp":{"#cdata":"Assigns a READ, WRITE, and ALTER password to a SAS file, and enables access to a password-protected SAS file. \n    \nSyntax: PW=password  \n\nSyntax Description:\npassword \n  must be a valid SAS name.\n\nDetails:\nThe PW= option applies to all types of SAS files. You can use this option to assign \na password to a SAS file or to access a password-protected SAS file.\n\nWhen replacing a SAS data set that is protected by an ALTER password, the new data \nset inherits the ALTER password. When the code is written to the SAS log the password \nis blotted out, for example: \n\n  drop thread job2 (pw=xxxxxxx);\n\nNote:   A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"},{"StatementOptionName":"READ=","StatementOptionHelp":{"#cdata":"Assigns a READ password to a SAS file that prevents users from reading the file, \nunless they enter the password. \n    \nSyntax: READ=read-password  \n\nSyntax Description: \nread-password \n  must be a valid SAS name. \n \nDetails: \nThe READ= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a read-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  declare package sales (read=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You  \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"},{"StatementOptionName":"RENAME=","StatementOptionHelp":{"#cdata":"Changes the name of a column.\n    \nSyntax: RENAME= (old-name { = | AS } new-name [... old-name { = | AS } new-name ] ) ;  \n\nArguments: \nold-name \n  the column you want to rename.\n\nnew-name \n  the new name of the column. It must be a valid name for the data source.\n \nDetails: \nThe RENAME= table option allows you to change the names of one or more columns.\n\nIf you use RENAME= when you create a table, the new column name is included in the output \ntable. If you use RENAME= on an input table, the new name is used in DS2 programming statements.\n\nIf you use RENAME= in the same DS2 program with either the DROP= or the KEEP= table option, \nthe DROP= and the KEEP= table options are applied before RENAME=. You must use the old name in \nthe DROP= and KEEP= table options. You cannot drop and rename the same column in the same statement.\n\nIn addition to changing the name of a column, RENAME= also changes the label for the column."},"StatementOptionType":"TV","SubOptionsKeywords":"AS"},{"StatementOptionName":"AS","StatementOptionHelp":{"#cdata":"Syntax: RENAME= (old-name AS new-name [... old-name AS new-name ] ) ;\n          \nSeparates the new-name from the old-name."},"StatementOptionType":"S"},{"StatementOptionName":"TYPE=","StatementOptionHelp":{"#cdata":"Specifies the data set type for a specially structured SAS data set. \n    \nSyntax: TYPE=data-set-type  \n\nSyntax Description: \ndata-set-type \n  specifies the special type of the data set.\n\nDetails: \nUse the TYPE= table option to create a special SAS data set in the proper format, \nor to identify the special type of the SAS data set in a procedure statement. \n\nYou can use the CONTENTS procedure to determine the type of a data set."},"StatementOptionType":"TV"},{"StatementOptionName":"WRITE=","StatementOptionHelp":{"#cdata":"Assigns a WRITE password to a SAS file that prevents users from writing to a file, \nunless they enter the password. \n    \nSyntax: WRITE=write-password  \n\nSyntax Description: \nwrite-password \n  must be a valid SAS name. \n \nDetails: \nThe WRITE= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a write-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  drop thread job2a (write=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"TV"}]}},{"StatementName":"ENDPACKAGE","StatementHelp":{"#cdata":"Syntax: ENDPACKAGE; \n      \nMarks the end of a PACKAGE statement. \n\nAlthough the ENDPACKAGE statement is not required, it can make the code easier to read."},"StatementOptions":null},{"StatementName":"ENDTHREAD","StatementHelp":{"#cdata":"Syntax: ENDTHREAD; \n      \nMarks the end of a THREAD statement. \n\nAlthough the ENDTHREAD statement is not required, it can make the code easier to read."},"StatementOptions":null},{"StatementName":"FORWARD","StatementHelp":{"#cdata":"Syntax: FORWARD method [ ...method ]; \n      \nIndicates that the method definition follows the method expression. \n\nmethod \nspecifies the name of the method to be defined."},"StatementOptions":null},{"StatementName":"GOTO","StatementHelp":{"#cdata":"Syntax: GOTO label; \n      \nTransfers execution immediately to a labeled statement. \n\nThe destination label for the GOTO statement must be within the same DS2 method. \nYou must specify the label argument or an error will occur. Statement labels are \ndefined by using the Labels statement."},"StatementOptions":null},{"StatementName":"LEAVE","StatementHelp":{"#cdata":"Syntax: LEAVE [ identifier ] ; \n      \nStops processing the current DO loop and transfers execution to either the statement \nfollowing the current DO statement, or a labeled DO statement that encloses the current \nDO statement."},"StatementOptions":null},{"StatementName":"METHOD","StatementHelp":{"#cdata":"Syntax: METHOD method ( [ <parameter > [ ,... < parameter > ] ] )  \n    [ RETURNS data-type ]>; \n    ... method-body ...  \n  END; \n\nDefines a block of code that can be called and executed multiple times."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"RETURNS","StatementOptionHelp":{"#cdata":"Syntax: RETURNS data-type \n          \nSpecifies the data type of the value that the method returns. The type \ncan be any valid character, numeric, or date type."},"StatementOptionType":"S"},{"StatementOptionName":"INIT","StatementOptionHelp":{"#cdata":"Calls a DS2 system method where program initializations can take place.\n          \n Syntax: \n METHOD INIT();  \n END;  \n\nWithout Arguments\nThe METHOD INIT statement has no arguments. If you try to pass arguments, an error will occur.\n\nDetails: \nTypically, the INIT method will contain any initialization code such as variable initialization \nor opening of tables. Code in the INIT method will run once at the beginning of the DS2 program. \nBefore the INIT method has run, variables in the program data vector which have not been retained \n'(by using the RETAIN statement) will be set to either SAS missing values or null values depending \non whether you are in SAS mode or ANSI mode. \n\nEvery DS2 program will contain, either implicitly or explicitly, the INIT, RUN, and TERM methods. \nIf you do not specify a METHOD INIT statement, DS2 will automatically provide one."},"StatementOptionType":"S"},{"StatementOptionName":"RUN","StatementOptionHelp":{"#cdata":"\n          \nSyntax:\n  METHOD RUN();  \n  END;  \n\nWithout Arguments:\nThe METHOD RUN statement has no arguments. If you try to pass arguments, an error \nwill occur.\n\nDetails: \nTypically, the RUN method will contain the main DS2 program code. The RUN method \nhas the same feature of automatic, implicit looping as the Base SAS DATA step. After \nthe RUN method has been executed one time, the RUN method either runs again or \ncontrol is passed to the TERM method.\n\nEvery DS2 program will contain, either implicity or explicitly, the INIT, RUN, \nand TERM methods. If you do not specify a METHOD RUN statement, DS2 will \nautomatically provide one."},"StatementOptionType":"S"},{"StatementOptionName":"TERM","StatementOptionHelp":{"#cdata":"\n          \nSyntax:\n  METHOD TERM();  \n  END;  \n \nWithout Arguments:\nThe METHOD TERM statement has no arguments. If you try to pass arguments, an error \nwill occur.\n\nDetails:\nTypically, the TERM method will contain any finalization code such as writing data \nto the SAS log. Code in the TERM method will run once at the end of the DS2 program.\n\nEvery DS2 program will contain, either implicitly or explicitly, the INIT, RUN, and \nTERM methods. If you do not specify a METHOD TERM statement, DS2 will automatically\nprovide one."},"StatementOptionType":"S"},{"StatementOptionName":"INT|INTEGER","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"BIGINT","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"IDENTITY","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"SMALLINT","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"TINYINT","StatementOptionHelp":{"#cdata":"Specifies an integer variable."},"StatementOptionType":"S"},{"StatementOptionName":"DOUBLE","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"DOUBLE PRECISION","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"FLOAT","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"REAL","StatementOptionHelp":{"#cdata":"Specifies a floating-point variable."},"StatementOptionType":"S"},{"StatementOptionName":"VARBINARY|BINARY VARYING","StatementOptionHelp":{"#cdata":"Specifies a varying-length binary variable.\n\nAlias: BINARY VARYING \n\nRequirement: If you specify VARBINARY, you must also specify the length of the binary \nvariable in bytes."},"StatementOptionType":"S"},{"StatementOptionName":"NCHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"NVARCHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"CHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"VARCHAR","StatementOptionHelp":{"#cdata":"Specifies a character variable."},"StatementOptionType":"S"},{"StatementOptionName":"TIME","StatementOptionHelp":{"#cdata":"Syntax: TIME (precision)\n          \nSpecifies a time variable. \n\nprecision \nspecifies the precision for a TIME data type.\n\nDefault: 0"},"StatementOptionType":"S"},{"StatementOptionName":"TIMESTAMP","StatementOptionHelp":{"#cdata":"Syntax: TIMESTAMP (precision) \n          \nSpecifies both a date and time variable. \n\nprecision \nspecifies the precision for a TIMESTAMP data type.\n\nDefault: 6"},"StatementOptionType":"S"},{"StatementOptionName":"DATE","StatementOptionHelp":{"#cdata":"Specifies a date variable."},"StatementOptionType":"S"}],"#comment":{}}},{"StatementName":"OUTPUT","StatementHelp":{"#cdata":"Syntax: OUTPUT [ { table [ ... table ] } | _ROWSET_ | _NULL_ ]; \n      \nWrites the current row to a table. \n\ntable \nspecifies the name of the table to which to write rows. table can be one of these forms. \n\n   catalog.schema.table-name  \n   schema.table-name  \n   catalog.table-name                \n   table-name  \n                                               \n  catalog \n  is an implementation of the ANSI SQL standard for an SQL catalog, which is a data \n  container object that groups logically related schemas. \n  \n  schema \n  is an implementation of the ANSI SQL standard for an SQL schema, which is a data \n  container object that groups files such as tables and views and other objects supported \n  by a data source such as stored procedures. \n  table-name \n  is the name of the table.\n\n  Restriction: All names specified in the OUTPUT statement must also appear in the TABLE statement. \n  Requirements: Table naming conventions are based on the datasource. \n  Tip: You can specify up to as many tables in the OUTPUT statement as you specified in the TABLE \n  statement for that DS2 program. \n  \n_ROWSET_ \nspecifies that the OUTPUT statement should not write rows to a table, but it should instead \nreturn table rows to the client application.\n\n_NULL_ \nspecifies that the OUTPUT statement should not write rows to either a table or the client application."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"_ROWSET_","StatementOptionHelp":{"#cdata":"Specifies that the OUTPUT statement should not write rows to a table, but it should \ninstead return table rows to the client application."},"StatementOptionType":"S"},{"StatementOptionName":"_NULL_","StatementOptionHelp":{"#cdata":"Specifies that the OUTPUT statement should not write rows to either a table or the \nclient application."},"StatementOptionType":"S"}]}},{"StatementName":"PACKAGE","StatementHelp":{"#cdata":"Syntax: (1) PACKAGE package [ / [SAS_ENCRYPT=YES|NO] [table-options]];  \n    ... package-body ...  \n \n  [ ENDPACKAGE ] ;  \n  \n(2) PACKAGE { HASH | HITER } / EXTENSION= 'HASH' | 'HITER';  \n    ... package-body ...  \n \n  [ ENDPACKAGE ] ;  \n\nCreates a DS2 package. \n\npackage \nspecifies the package name. package can be one of these forms. \n\n   catalog.schema.package  \n   schema.package  \n   catalog.package  \n   package \n\n  catalog \n  is an implementation of the ANSI SQL standard for an SQL catalog, which is a data container \n  object that groups logically related schemas. \n\n  schema \n  is an implementation of the ANSI SQL standard for an SQL schema, which is a data container \n  object that groups files such as tables and views and other objects supported by a data source \n  such as stored procedures. \n\n  package \n  is the name of the package.\n  Requirement: Package naming conventions are based on the data source."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"SAS_ENCRYPT=","StatementOptionHelp":{"#cdata":"Specifies the encryption algorithm. \n\nDefault: NO"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the SAS Proprietary algorithm.","@ToolTip2":"Specifies the Advanced Encryption Standard (AES) algorithm."}},{"StatementOptionName":"HASH","StatementOptionHelp":{"#cdata":"Specifies the name of the package as HASH to register the hash package \nfor use in a DS2 program."},"StatementOptionType":"RS"},{"StatementOptionName":"HITER","StatementOptionHelp":{"#cdata":"Specifies the name of the package as HITER to register the hash iterator package \nfor use in a DS2 program."},"StatementOptionType":"RS"},{"StatementOptionName":"EXTENSION=|EXT=","StatementOptionHelp":{"#cdata":"Specifies that the package is of type hash or hash iterator."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"'HASH'","@Value2":"'HITER'"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the package is of type hash.","@ToolTip2":"Specifies that the package is of type hash iterator."}},{"StatementOptionName":"ALTER=","StatementOptionHelp":{"#cdata":"Syntax: ALTER=alter-password \n    \nSyntax Description:\nalter-password \n  must be a valid SAS name.\n \nDetails: \nThe ALTER= option applies only to a SAS data set. You can use this option to assign \na password or to access a read-protected, write-protected, or alter-protected file. \nWhen you replace a data set that is protected with an ALTER password, the new data \nset inherits the ALTER password. \n\nThe password is blotted out when the code is written in the SAS log. For example: \n\n  set a(alter=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"V"},{"StatementOptionName":"BUFNO=","StatementOptionHelp":{"#cdata":"Specifies the number of buffers to be allocated for processing a SAS data set. \n    \nSyntax: BUFNO= n | nK | hexX | MIN | MAX  \n\nSyntax Description:\n\nn | nK \n  specifies the number of buffers in multiples of 1 (bytes); 1,024 (kilobytes). For example, \n  a value of 8 specifies 8 buffers, and a value of 1k specifies 1024 buffers.\n\nhex \n  specifies the number of buffers as a hexadecimal value. You must specify the value beginning \n  with a number (0-9), followed by an X. For example, the value 2dx sets the number of buffers \n  to 45 buffers.\n\nMIN \n  sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value \n  for the operating environment. This is the default.\n\nMAX \n  sets the number of buffers to the maximum possible number in your operating environment, \n  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"hexX","@Value4":"MIN","@Value5":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the number of buffers in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the number of buffers in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the number of buffers as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip4":"Sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value  for the operating environment. This is the default.","@ToolTip5":"Sets the number of buffers to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."}},{"StatementOptionName":"BUFSIZE=","StatementOptionHelp":{"#cdata":"Specifies the size of a permanent buffer page for an output SAS data set. \n    \nSyntax: BUFSIZE= n | nK | nM | nG | hexX | MAX  \n\nSyntax Description:\n\nn | nK | nM | nG \nspecifies the page size in multiples of 1 (bytes); 1,024 (kilobytes); 1,048,576 (megabytes); \nor 1,073,741,824 (gigabytes). For example, a value of 8 specifies a page size of 8 bytes, and \na value of 4k specifies a page size of 4096 bytes. \n\nhexX \nspecifies the page size as a hexadecimal value. You must specify the value beginning with a \nnumber (0-9), followed by an X. For example, the value 2dx sets the page size to 45 bytes.\n\nMAX \nsets the page size to the maximum possible number in your operating environment, up to the \nlargest four-byte, signed integer, which is 231-1, or approximately 2 billion bytes."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"nM","@Value4":"nG","@Value5":"hexX","@Value6":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the page size in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the page size in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the page size in multiples of 1,048,576 (megabytes).  Replace n with an integer value.","@ToolTip4":"Specifies the page size in multiples of 1,073,741,824 (gigabytes).  Replace n with an integer value.","@ToolTip5":"Specifies the page size as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip6":"Sets the page size to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion bytes."}},{"StatementOptionName":"BULKLOAD=","StatementOptionHelp":{"#cdata":"Loads rows of data as one unit. Default value: NO  \n    \nSyntax: BULKLOAD=YES | NO  \n\nSyntax Description:\n\nYES \ncalls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.\n\nNO \nuses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Calls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.","@ToolTip2":"Uses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."}},{"StatementOptionName":"COMPRESS=","StatementOptionHelp":{"#cdata":"Specifies how observations are compressed in a new output SAS data set. \n    \nSyntax: COMPRESS=NO | YES | CHAR | BINARY  \n\nSyntax Description:\nNO \nspecifies that the observations in a newly created SAS data set are uncompressed (fixed-length records).\n\nYES | CHAR \nspecifies that the observations in a newly created SAS data set are compressed (variable-length records) \nby SAS using RLE (Run Length Encoding). RLE compresses observations by reducing repeated consecutive \ncharacters (including blanks) to two-byte or three-byte representations. \n\n  Alias: ON \n  Tip: Use this compression algorithm for character data. \n  Note:   COMPRESS=CHAR is accepted by Version 7 and later versions.  \n\nBINARY \n  specifies that the observations in a newly created SAS data set are compressed (variable-length records) \n  by SAS using RDC (Ross Data Compression). RDC combines run-length encoding and sliding-window compression \n  to compress the file.\n\n  Tip: This method is highly effective for compressing medium to large (several hundred bytes or larger) \n  blocks of binary data (numeric variables). Because the compression function operates on a single record \n  at a time, the record length needs to be several hundred bytes or larger for effective compression."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NO","@Value2":"YES|ON","@Value3":"CHAR","@Value4":"BINARY"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the observations in a newly created SAS data set are uncompressed  (fixed-length records).","@ToolTip2":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.","@ToolTip3":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.   COMPRESS=CHAR is accepted by Version 7 and later versions.","@ToolTip4":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RDC (Ross Data Compression). RDC combines  run-length encoding and sliding-window compression to compress the file."}},{"StatementOptionName":"DBKEY=","StatementOptionHelp":{"#cdata":"Specifies a key column to optimize DBMS retrieval. Can improve performance when you \nare processing a join that involves a large DBMS table and a small SAS data set \nor DBMS table.\n    \nSyntax: DBKEY=([ ' ] column [ ' ] [... [ ' ] column [ ' ] ])  \n\nSyntax Description: \n\ncolumn \n  used by SAS to build an internal WHERE clause to search for matches in the DBMS table \n  based on the key column. For example:\n\n    select * from sas.a, dbms.b(dbkey=x) where a.x=b.x;\n    \nIn this example, DBKEY= specifies column x , which matches the key column designated in \nthe WHERE clause. However, if the DBKEY= column does NOT match the key column in the \nWHERE clause, then DBKEY= is not used."},"StatementOptionType":"V"},{"StatementOptionName":"DBNULL=","StatementOptionHelp":{"#cdata":"Indicates whether NULL is a valid value for the specified columns when a table is created. \n    \nSyntax: DBNULL={ _ALL=YES | NO } | ( [column=YES | NO [ ... column=YES | NO ] ] )  \n\nSyntax Description: \n_ALL_ \n  specifies that the YES or NO applies to all columns in the table. (This is valid in \n  the interfaces to Informix, Oracle, Sybase, and Teradata only.)\n\nYES \n  specifies that the NULL value is valid for the specified columns in the DBMS table.\n\nNO \n  specifies that the NULL value is not valid for the specified columns in the DBMS table.\n\ncolumn \n  specifies the name of a column. \n\nDetails: \nThis option is valid only for creating DBMS tables. If you specify more than one column name, \nthe names must be separated with spaces.\n\nThe DBNULL= option processes values from left to right, so if you specify a column name twice, \nor if you use the _ALL_ value, the last value overrides the first value that is specified for \nthe column."},"StatementOptionType":"V","SubOptionsKeywords":"_ALL_"},{"StatementOptionName":"DROP=","StatementOptionHelp":{"#cdata":"For an input table, excludes the specified columns from processing; for an output table, excludes the specified columns from being written to the table.\n    \nSyntax: DROP= ( column-list );  \n\nArguments: \ncolumn-list \n  specifies the names of the columns to omit from the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the format \n  col: are not supported. \n \nDetails: \nThe DROP= table option specifies that all columns in the column-list should not be included \nin the creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the drop attribute is specified, all columns not included in the drop \nstatement will be used to create columns in the output rows.\n\nIf the DROP= table option is associated with an input table, the columns are not available \nfor processing during program execution."},"StatementOptionType":"V"},{"StatementOptionName":"ENCRYPT=","StatementOptionHelp":{"#cdata":"Specifies whether to encrypt an output SAS data set. \n    \nSyntax: ENCRYPT=YES | NO  \n\nSyntax Description:\nYES \n  encrypts the file. The encryption method uses passwords. At a minimum, you must specify \n  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because \n  the encryption method uses passwords, you cannot change any password on an encrypted data \n  set without re-creating the data set.\n\nNO \n  does not encrypt the file.\n\nCAUTION:\nRecord all passwords. \nIf you forget the password, you cannot reset it without assistance from SAS. The process \nis time-consuming and resource-intensive."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Encrypts the file. The encryption method uses passwords. At a minimum, you must specify  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because  the encryption method uses passwords, you cannot change any password on an encrypted data  set without re-creating the data set.","@ToolTip2":"Does not encrypt the file."}},{"StatementOptionName":"KEEP=","StatementOptionHelp":{"#cdata":"For an input table, specifies the columns to process; for an output table, specifies \nthe columns to write to the table. \n    \nSyntax: KEEP=( column-list );  \n\nArguments:\n\ncolumn-list \n  specifies the names of the columns to keep in the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the \n  format col: are not supported. \n  \nDetails: \nThe KEEP= table option specifies that all columns in the column-list should be included in \nthe creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the keep attribute is specified, all columns not included in the KEEP \nstatement will be dropped from the output rows.\n\nIf the KEEP= table option is associated with an input table, only the columns that are \nspecified by the KEEP= table option are available for processing during program execution."},"StatementOptionType":"V"},{"StatementOptionName":"LABEL=","StatementOptionHelp":{"#cdata":"Specifies a label for a table.\n    \nSyntax: LABEL='label'  \n\nSyntax Description: \n\n'label' \n  specifies a text string of up to 256 characters. If the label text contains single \n  quotation marks, use double quotation marks around the label, or use two single \n  quotation marks in the label text and surround the string with single quotation \n  marks. To remove a label from a table, assign a label that is equal to a blank \n  that is enclosed in quotation marks.\n \nDetails: \nYou can use the LABEL= option on both input and output tables. When you use LABEL= \non input tables, it assigns a label for the table for the duration of the DS2 program. \nWhen it is specified for an output table, the label becomes a permanent part of that \ntable."},"StatementOptionType":"V"},{"StatementOptionName":"LOCKTABLE=","StatementOptionHelp":{"#cdata":"Places shared or exclusive locks on tables. \n    \nSyntax: LOCKTABLE=SHARE | EXCLUSIVE  \n\nSyntax Description:\n\nSHARE \n  locks a table in shared mode, allowing other users or processes to read data from the \n  tables, but preventing users from updating data.\n\nEXCLUSIVE \n  locks a table exclusively, preventing other users from accessing any table that you open. \n\nDetails: \nYou can lock tables only if you are the owner or have been granted the necessary privilege. \n\nIf you access the BASE table driver through PROC DS2, the default value for the LOCKTABLE \noption is EXCLUSIVE. However, if you access the BASE table driver through a table server, \nor if you run your program locally with the SAS Table Server LIBNAME engine, the default \nvalue for the LOCKTABLE option is SHARE."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"SHARE","@Value2":"EXCLUSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Locks a table in shared mode, allowing other users or processes to read data from  the tables, but preventing users from updating data.","@ToolTip2":"Locks a table exclusively, preventing other users from accessing any table that you open."}},{"StatementOptionName":"OVERWRITE=","StatementOptionHelp":{"#cdata":"For a table, drops the output table before the replacement output table is populated \nwith rows; for packages and threads, drops the existing package or thread if a package \nor thread by the same name exists. \n    \nSyntax: OVERWRITE= YES | NO;  \n\nArguments: \n\nYES | NO \n  specifies whether the output table is deleted before a replacement output table \n  is created or whether a package or thread is dropped.\n\n  Default: NO \n\nCAUTION:\nFor tables, use the OVERWRITE=YES statement only with data that is backed up or \nwith data that you can reconstruct. Because the output table is deleted first, \ndata will be lost if a failure occurs while the output table is being written."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the output table is deleted before a replacement output table    is created or a package or thread is dropped.","@ToolTip2":"Specifies that the output table is not deleted before a replacement output table    is created or a package or thread is dropped."}},{"StatementOptionName":"PW=","StatementOptionHelp":{"#cdata":"Assigns a READ, WRITE, and ALTER password to a SAS file, and enables access to a password-protected SAS file. \n    \nSyntax: PW=password  \n\nSyntax Description:\npassword \n  must be a valid SAS name.\n\nDetails:\nThe PW= option applies to all types of SAS files. You can use this option to assign \na password to a SAS file or to access a password-protected SAS file.\n\nWhen replacing a SAS data set that is protected by an ALTER password, the new data \nset inherits the ALTER password. When the code is written to the SAS log the password \nis blotted out, for example: \n\n  drop thread job2 (pw=xxxxxxx);\n\nNote:   A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"V"},{"StatementOptionName":"READ=","StatementOptionHelp":{"#cdata":"Assigns a READ password to a SAS file that prevents users from reading the file, \nunless they enter the password. \n    \nSyntax: READ=read-password  \n\nSyntax Description: \nread-password \n  must be a valid SAS name. \n \nDetails: \nThe READ= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a read-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  declare package sales (read=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You  \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"V"},{"StatementOptionName":"RENAME=","StatementOptionHelp":{"#cdata":"Changes the name of a column.\n    \nSyntax: RENAME= (old-name { = | AS } new-name [... old-name { = | AS } new-name ] ) ;  \n\nArguments: \nold-name \n  the column you want to rename.\n\nnew-name \n  the new name of the column. It must be a valid name for the data source.\n \nDetails: \nThe RENAME= table option allows you to change the names of one or more columns.\n\nIf you use RENAME= when you create a table, the new column name is included in the output \ntable. If you use RENAME= on an input table, the new name is used in DS2 programming statements.\n\nIf you use RENAME= in the same DS2 program with either the DROP= or the KEEP= table option, \nthe DROP= and the KEEP= table options are applied before RENAME=. You must use the old name in \nthe DROP= and KEEP= table options. You cannot drop and rename the same column in the same statement.\n\nIn addition to changing the name of a column, RENAME= also changes the label for the column."},"StatementOptionType":"V","SubOptionsKeywords":"AS"},{"StatementOptionName":"AS","StatementOptionHelp":{"#cdata":"Syntax: RENAME= (old-name AS new-name [... old-name AS new-name ] ) ;\n          \nSeparates the new-name from the old-name."},"StatementOptionType":"S"},{"StatementOptionName":"TYPE=","StatementOptionHelp":{"#cdata":"Specifies the data set type for a specially structured SAS data set. \n    \nSyntax: TYPE=data-set-type  \n\nSyntax Description: \ndata-set-type \n  specifies the special type of the data set.\n\nDetails: \nUse the TYPE= table option to create a special SAS data set in the proper format, \nor to identify the special type of the SAS data set in a procedure statement. \n\nYou can use the CONTENTS procedure to determine the type of a data set."},"StatementOptionType":"V"},{"StatementOptionName":"WRITE=","StatementOptionHelp":{"#cdata":"Assigns a WRITE password to a SAS file that prevents users from writing to a file, \nunless they enter the password. \n    \nSyntax: WRITE=write-password  \n\nSyntax Description: \nwrite-password \n  must be a valid SAS name. \n \nDetails: \nThe WRITE= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a write-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  drop thread job2a (write=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"V"}],"#comment":{}}},{"StatementName":"PUT","StatementHelp":{"#cdata":"Syntax: PUT < put-list > [ ... <put-list> ] ; \n  <put-list>::=  'character-string' | <eq-expression> [ = ] [ [ : ] format [-L | -C | -R ] ]   \n  <eq-expression>::=  identifier | array-reference | this-expression \n      \nPrints values of program variables and constants to the log. \n\nArguments:\n'character-string' \nspecifies a string of text, enclosed in quotation marks, that is written to the SAS log.\n\nidentifier \nnames a variable whose value is written to the SAS log.\n\narray-reference \nspecifies an array element. The subscript can be any SAS expression that resolves to an \ninteger value when the PUT statement executes. Use the array subscript asterisk (*) to \nwrite all elements of the array.\n\nthis-expression \nspecifies a THIS expression.\n\n= \nIf an equal sign is added after a variable or array element, then the output is preceded \nby the variable or array element name and an equal sign.\n\n: \nenables you to specify a format that the PUT statement uses to write the variable value. \nAll leading and trailing blanks are deleted, and each value is followed by a single blank.\nRestriction: You must specify a format. \n\nformat \nspecifies a format to use when the data value is written to the SAS log. If you use a colon \nmodifier (:) with the format name, all leading and trailing blanks are deleted and each value \nis followed by a single blank. To override the default alignment, you can add an alignment \nspecification to a format:\n  -L left aligns the value.  \n  -C centers the value.  \n  -R right aligns the value.\n \nTip: Ensure that the format width provides enough space to write the value and any commas, \ndollar signs, decimal points, or other special characters that the format includes."},"StatementOptions":null},{"StatementName":"RENAME","StatementHelp":{"#cdata":"Syntax: RENAME old-name = new-name [ ... old-name = new-name ];  \nRENAME old-name AS new-name [ ... old-name AS new-name ];  \n\nSpecifies new names for columns in output tables."},"StatementOptions":{"StatementOption":{"StatementOptionName":"AS","StatementOptionHelp":{"#cdata":"RENAME old-name AS new-name [ ... old-name AS new-name ];\n          \nSeparates the new-name from the old-name."},"StatementOptionType":"S"}}},{"StatementName":"RETAIN","StatementHelp":{"#cdata":"Syntax: (1) RETAIN;  \n (2) RETAIN column-list;  \n (3)RETAIN column-list < constant-value >;  \n (4) RETAIN column-list ( < constant-value > ... < constant-value > );  \n\nSpecifies that all columns in the column list should have their values retained during \neach execution of the RUN method. \n\nIf you do not specify any arguments, the RETAIN statement causes the values of all \ncolumns to be retained from one iteration of the DS2 program to the next."},"StatementOptions":null},{"StatementName":"RETURN","StatementHelp":{"#cdata":"Syntax: RETURN [ expression ]; \n      \nReturns execution from a method to the method caller. \n\nexpression \nspecifies any valid expression that returns a single value. The expression's type \nis evaluated, and if necessary, converted to the type specified in the METHOD statement's \nRETURNS clause. The value of expression is then passed back to the caller of the method."},"StatementOptions":null},{"StatementName":"SELECT","StatementHelp":{"#cdata":"Syntax: SELECT [ ( select-expression ) ];  \n    [ < when-list > [ ...< when-list> ] ] ;  \n    [ OTHERWISE statement-list ] ;  \n \n  END [ end-label ];  \n\nExecutes one of several statements or groups of statements. \n\nArguments:\n\n  select-expression \n  specifies an expression that evaluates to a single value of any type other than VARBINARY.\n\n  end-label \n  The END statement closes the SELECT statement. The optional end-label argument specifies \n  an identifier. This label, created by using the Labels statement, must match the label \n  immediately preceding the SELECT statement, or an error will occur.\n\n  when-expression \n  specifies any expression, including a compound expression.\n\n    Requirement: You must specify at least one when-expression. \n\n  statement-list \n  can be any executable statement or statements."},"StatementOptions":null},{"StatementName":"OTHERWISE","StatementHelp":{"#cdata":"Syntax: [OTHERWISE statement-list]; \n      \nAn optional OTHERWISE statement specifies a statement to be executed if no WHEN condition is met."},"StatementOptions":null},{"StatementName":"WHEN","StatementHelp":{"#cdata":"Syntax: WHEN ( when-expression ) [ statement-list ]  \n\nSELECT groups contain WHEN statements that identify DS2 statements that are executed \nwhen a particular condition is true. Use at least one WHEN statement in a SELECT group."},"StatementOptions":null},{"StatementName":"STOP","StatementHelp":{"#cdata":"Syntax: STOP; \n      \nStops execution of the current DS2 program. \n\nThe STOP statement causes processing of the current DS2 program to stop immediately \nand resume processing statements after the end of the current DS2 program."},"StatementOptions":null},{"StatementName":"THREAD","StatementHelp":{"#cdata":"Syntax: THREAD thread [ ( data-type variable [ , ... data-type variable ] ) ] [ / [SAS_ENCRYPT=YES|NO] [table-options]];  \n    ... thread-body ...  \n \n  [ ENDTHREAD ; ]  \n\nCreates a DS2 program thread. \n\nthread \nspecifies the thread name. thread can be one of these forms. \n\n   catalog.schema.thread  \n   schema.thread  \n   catalog.thread  \n   thread \n\n  catalog \n  is an implementation of the ANSI SQL standard for an SQL catalog, which is a data container \n  object that groups logically related schemas. \n\n  schema \n  is an implementation of the ANSI SQL standard for an SQL schema, which is a data container \n  object that groups files such as tables and views and other objects supported by a data source \n  such as stored procedures. \n\n  thread \n  is the name of the thread.\n  Requirement: Thread naming conventions are based on the data source."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"SAS_ENCRYPT=","StatementOptionHelp":{"#cdata":"Specifies the encryption algorithm. \n\nDefault: NO"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the SAS Proprietary algorithm.","@ToolTip2":"Specifies the Advanced Encryption Standard (AES) algorithm."}},{"StatementOptionName":"ALTER=","StatementOptionHelp":{"#cdata":"Syntax: ALTER=alter-password \n    \nSyntax Description:\nalter-password \n  must be a valid SAS name.\n \nDetails: \nThe ALTER= option applies only to a SAS data set. You can use this option to assign \na password or to access a read-protected, write-protected, or alter-protected file. \nWhen you replace a data set that is protected with an ALTER password, the new data \nset inherits the ALTER password. \n\nThe password is blotted out when the code is written in the SAS log. For example: \n\n  set a(alter=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"V"},{"StatementOptionName":"BUFNO=","StatementOptionHelp":{"#cdata":"Specifies the number of buffers to be allocated for processing a SAS data set. \n    \nSyntax: BUFNO= n | nK | hexX | MIN | MAX  \n\nSyntax Description:\n\nn | nK \n  specifies the number of buffers in multiples of 1 (bytes); 1,024 (kilobytes). For example, \n  a value of 8 specifies 8 buffers, and a value of 1k specifies 1024 buffers.\n\nhex \n  specifies the number of buffers as a hexadecimal value. You must specify the value beginning \n  with a number (0-9), followed by an X. For example, the value 2dx sets the number of buffers \n  to 45 buffers.\n\nMIN \n  sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value \n  for the operating environment. This is the default.\n\nMAX \n  sets the number of buffers to the maximum possible number in your operating environment, \n  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"hexX","@Value4":"MIN","@Value5":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the number of buffers in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the number of buffers in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the number of buffers as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip4":"Sets the minimum number of buffers to 0, which causes SAS to use the minimum optimal value  for the operating environment. This is the default.","@ToolTip5":"Sets the number of buffers to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion."}},{"StatementOptionName":"BUFSIZE=","StatementOptionHelp":{"#cdata":"Specifies the size of a permanent buffer page for an output SAS data set. \n    \nSyntax: BUFSIZE= n | nK | nM | nG | hexX | MAX  \n\nSyntax Description:\n\nn | nK | nM | nG \nspecifies the page size in multiples of 1 (bytes); 1,024 (kilobytes); 1,048,576 (megabytes); \nor 1,073,741,824 (gigabytes). For example, a value of 8 specifies a page size of 8 bytes, and \na value of 4k specifies a page size of 4096 bytes. \n\nhexX \nspecifies the page size as a hexadecimal value. You must specify the value beginning with a \nnumber (0-9), followed by an X. For example, the value 2dx sets the page size to 45 bytes.\n\nMAX \nsets the page size to the maximum possible number in your operating environment, up to the \nlargest four-byte, signed integer, which is 231-1, or approximately 2 billion bytes."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"n","@Value2":"nK","@Value3":"nM","@Value4":"nG","@Value5":"hexX","@Value6":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the page size in multiples of 1 (bytes).  Replace n with an integer value.","@ToolTip2":"Specifies the page size in multiples of 1,024 (kilobytes).  Replace n with an integer value.","@ToolTip3":"Specifies the page size in multiples of 1,048,576 (megabytes).  Replace n with an integer value.","@ToolTip4":"Specifies the page size in multiples of 1,073,741,824 (gigabytes).  Replace n with an integer value.","@ToolTip5":"Specifies the page size as a hexadecimal value.  Replace hex with an actual hexadecimal value.","@ToolTip6":"Sets the page size to the maximum possible number in your operating environment,  up to the largest four-byte, signed integer, which is 2\u00b3\u00b9-1, or approximately 2 billion bytes."}},{"StatementOptionName":"BULKLOAD=","StatementOptionHelp":{"#cdata":"Loads rows of data as one unit. Default value: NO  \n    \nSyntax: BULKLOAD=YES | NO  \n\nSyntax Description:\n\nYES \ncalls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.\n\nNO \nuses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Calls a DBMS-specific bulk load facility in order to insert or append rows to a DBMS table.","@ToolTip2":"Uses the dynamic SAS/ACCESS engine to insert or append data to a DBMS table."}},{"StatementOptionName":"COMPRESS=","StatementOptionHelp":{"#cdata":"Specifies how observations are compressed in a new output SAS data set. \n    \nSyntax: COMPRESS=NO | YES | CHAR | BINARY  \n\nSyntax Description:\nNO \nspecifies that the observations in a newly created SAS data set are uncompressed (fixed-length records).\n\nYES | CHAR \nspecifies that the observations in a newly created SAS data set are compressed (variable-length records) \nby SAS using RLE (Run Length Encoding). RLE compresses observations by reducing repeated consecutive \ncharacters (including blanks) to two-byte or three-byte representations. \n\n  Alias: ON \n  Tip: Use this compression algorithm for character data. \n  Note:   COMPRESS=CHAR is accepted by Version 7 and later versions.  \n\nBINARY \n  specifies that the observations in a newly created SAS data set are compressed (variable-length records) \n  by SAS using RDC (Ross Data Compression). RDC combines run-length encoding and sliding-window compression \n  to compress the file.\n\n  Tip: This method is highly effective for compressing medium to large (several hundred bytes or larger) \n  blocks of binary data (numeric variables). Because the compression function operates on a single record \n  at a time, the record length needs to be several hundred bytes or larger for effective compression."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NO","@Value2":"YES|ON","@Value3":"CHAR","@Value4":"BINARY"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the observations in a newly created SAS data set are uncompressed  (fixed-length records).","@ToolTip2":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.","@ToolTip3":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RLE (Run Length Encoding). RLE compresses  observations by reducing repeated consecutive characters (including blanks) to  two-byte or three-byte representations.   COMPRESS=CHAR is accepted by Version 7 and later versions.","@ToolTip4":"Specifies that the observations in a newly created SAS data set are compressed  (variable-length records) by SAS using RDC (Ross Data Compression). RDC combines  run-length encoding and sliding-window compression to compress the file."}},{"StatementOptionName":"DBKEY=","StatementOptionHelp":{"#cdata":"Specifies a key column to optimize DBMS retrieval. Can improve performance when you \nare processing a join that involves a large DBMS table and a small SAS data set \nor DBMS table.\n    \nSyntax: DBKEY=([ ' ] column [ ' ] [... [ ' ] column [ ' ] ])  \n\nSyntax Description: \n\ncolumn \n  used by SAS to build an internal WHERE clause to search for matches in the DBMS table \n  based on the key column. For example:\n\n    select * from sas.a, dbms.b(dbkey=x) where a.x=b.x;\n    \nIn this example, DBKEY= specifies column x , which matches the key column designated in \nthe WHERE clause. However, if the DBKEY= column does NOT match the key column in the \nWHERE clause, then DBKEY= is not used."},"StatementOptionType":"V"},{"StatementOptionName":"DBNULL=","StatementOptionHelp":{"#cdata":"Indicates whether NULL is a valid value for the specified columns when a table is created. \n    \nSyntax: DBNULL={ _ALL=YES | NO } | ( [column=YES | NO [ ... column=YES | NO ] ] )  \n\nSyntax Description: \n_ALL_ \n  specifies that the YES or NO applies to all columns in the table. (This is valid in \n  the interfaces to Informix, Oracle, Sybase, and Teradata only.)\n\nYES \n  specifies that the NULL value is valid for the specified columns in the DBMS table.\n\nNO \n  specifies that the NULL value is not valid for the specified columns in the DBMS table.\n\ncolumn \n  specifies the name of a column. \n\nDetails: \nThis option is valid only for creating DBMS tables. If you specify more than one column name, \nthe names must be separated with spaces.\n\nThe DBNULL= option processes values from left to right, so if you specify a column name twice, \nor if you use the _ALL_ value, the last value overrides the first value that is specified for \nthe column."},"StatementOptionType":"V","SubOptionsKeywords":"_ALL_"},{"StatementOptionName":"DROP=","StatementOptionHelp":{"#cdata":"For an input table, excludes the specified columns from processing; for an output table, excludes the specified columns from being written to the table.\n    \nSyntax: DROP= ( column-list );  \n\nArguments: \ncolumn-list \n  specifies the names of the columns to omit from the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the format \n  col: are not supported. \n \nDetails: \nThe DROP= table option specifies that all columns in the column-list should not be included \nin the creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the drop attribute is specified, all columns not included in the drop \nstatement will be used to create columns in the output rows.\n\nIf the DROP= table option is associated with an input table, the columns are not available \nfor processing during program execution."},"StatementOptionType":"V"},{"StatementOptionName":"ENCRYPT=","StatementOptionHelp":{"#cdata":"Specifies whether to encrypt an output SAS data set. \n    \nSyntax: ENCRYPT=YES | NO  \n\nSyntax Description:\nYES \n  encrypts the file. The encryption method uses passwords. At a minimum, you must specify \n  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because \n  the encryption method uses passwords, you cannot change any password on an encrypted data \n  set without re-creating the data set.\n\nNO \n  does not encrypt the file.\n\nCAUTION:\nRecord all passwords. \nIf you forget the password, you cannot reset it without assistance from SAS. The process \nis time-consuming and resource-intensive."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Encrypts the file. The encryption method uses passwords. At a minimum, you must specify  the READ= or the PW= table option at the same time that you specify ENCRYPT=YES. Because  the encryption method uses passwords, you cannot change any password on an encrypted data  set without re-creating the data set.","@ToolTip2":"Does not encrypt the file."}},{"StatementOptionName":"KEEP=","StatementOptionHelp":{"#cdata":"For an input table, specifies the columns to process; for an output table, specifies \nthe columns to write to the table. \n    \nSyntax: KEEP=( column-list );  \n\nArguments:\n\ncolumn-list \n  specifies the names of the columns to keep in the output table.\n\n  Restriction: Numbered range lists in the format col1-col5 and name prefix lists in the \n  format col: are not supported. \n  \nDetails: \nThe KEEP= table option specifies that all columns in the column-list should be included in \nthe creation of output rows. Normally, all columns in the program data vector are included \nin the output rows. If the keep attribute is specified, all columns not included in the KEEP \nstatement will be dropped from the output rows.\n\nIf the KEEP= table option is associated with an input table, only the columns that are \nspecified by the KEEP= table option are available for processing during program execution."},"StatementOptionType":"V"},{"StatementOptionName":"LABEL=","StatementOptionHelp":{"#cdata":"Specifies a label for a table.\n    \nSyntax: LABEL='label'  \n\nSyntax Description: \n\n'label' \n  specifies a text string of up to 256 characters. If the label text contains single \n  quotation marks, use double quotation marks around the label, or use two single \n  quotation marks in the label text and surround the string with single quotation \n  marks. To remove a label from a table, assign a label that is equal to a blank \n  that is enclosed in quotation marks.\n \nDetails: \nYou can use the LABEL= option on both input and output tables. When you use LABEL= \non input tables, it assigns a label for the table for the duration of the DS2 program. \nWhen it is specified for an output table, the label becomes a permanent part of that \ntable."},"StatementOptionType":"V"},{"StatementOptionName":"LOCKTABLE=","StatementOptionHelp":{"#cdata":"Places shared or exclusive locks on tables. \n    \nSyntax: LOCKTABLE=SHARE | EXCLUSIVE  \n\nSyntax Description:\n\nSHARE \n  locks a table in shared mode, allowing other users or processes to read data from the \n  tables, but preventing users from updating data.\n\nEXCLUSIVE \n  locks a table exclusively, preventing other users from accessing any table that you open. \n\nDetails: \nYou can lock tables only if you are the owner or have been granted the necessary privilege. \n\nIf you access the BASE table driver through PROC DS2, the default value for the LOCKTABLE \noption is EXCLUSIVE. However, if you access the BASE table driver through a table server, \nor if you run your program locally with the SAS Table Server LIBNAME engine, the default \nvalue for the LOCKTABLE option is SHARE."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"SHARE","@Value2":"EXCLUSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Locks a table in shared mode, allowing other users or processes to read data from  the tables, but preventing users from updating data.","@ToolTip2":"Locks a table exclusively, preventing other users from accessing any table that you open."}},{"StatementOptionName":"OVERWRITE=","StatementOptionHelp":{"#cdata":"For a table, drops the output table before the replacement output table is populated \nwith rows; for packages and threads, drops the existing package or thread if a package \nor thread by the same name exists. \n    \nSyntax: OVERWRITE= YES | NO;  \n\nArguments: \n\nYES | NO \n  specifies whether the output table is deleted before a replacement output table \n  is created or whether a package or thread is dropped.\n\n  Default: NO \n\nCAUTION:\nFor tables, use the OVERWRITE=YES statement only with data that is backed up or \nwith data that you can reconstruct. Because the output table is deleted first, \ndata will be lost if a failure occurs while the output table is being written."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the output table is deleted before a replacement output table    is created or a package or thread is dropped.","@ToolTip2":"Specifies that the output table is not deleted before a replacement output table    is created or a package or thread is dropped."}},{"StatementOptionName":"PW=","StatementOptionHelp":{"#cdata":"Assigns a READ, WRITE, and ALTER password to a SAS file, and enables access to a password-protected SAS file. \n    \nSyntax: PW=password  \n\nSyntax Description:\npassword \n  must be a valid SAS name.\n\nDetails:\nThe PW= option applies to all types of SAS files. You can use this option to assign \na password to a SAS file or to access a password-protected SAS file.\n\nWhen replacing a SAS data set that is protected by an ALTER password, the new data \nset inherits the ALTER password. When the code is written to the SAS log the password \nis blotted out, for example: \n\n  drop thread job2 (pw=xxxxxxx);\n\nNote:   A SAS password does not control access to a SAS file beyond the SAS system. \nYou should use the operating system-supplied utilities and file-system security \ncontrols in order to control access to SAS files outside of SAS."},"StatementOptionType":"V"},{"StatementOptionName":"READ=","StatementOptionHelp":{"#cdata":"Assigns a READ password to a SAS file that prevents users from reading the file, \nunless they enter the password. \n    \nSyntax: READ=read-password  \n\nSyntax Description: \nread-password \n  must be a valid SAS name. \n \nDetails: \nThe READ= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a read-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  declare package sales (read=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You  \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"V"},{"StatementOptionName":"RENAME=","StatementOptionHelp":{"#cdata":"Changes the name of a column.\n    \nSyntax: RENAME= (old-name { = | AS } new-name [... old-name { = | AS } new-name ] ) ;  \n\nArguments: \nold-name \n  the column you want to rename.\n\nnew-name \n  the new name of the column. It must be a valid name for the data source.\n \nDetails: \nThe RENAME= table option allows you to change the names of one or more columns.\n\nIf you use RENAME= when you create a table, the new column name is included in the output \ntable. If you use RENAME= on an input table, the new name is used in DS2 programming statements.\n\nIf you use RENAME= in the same DS2 program with either the DROP= or the KEEP= table option, \nthe DROP= and the KEEP= table options are applied before RENAME=. You must use the old name in \nthe DROP= and KEEP= table options. You cannot drop and rename the same column in the same statement.\n\nIn addition to changing the name of a column, RENAME= also changes the label for the column."},"StatementOptionType":"V","SubOptionsKeywords":"AS"},{"StatementOptionName":"AS","StatementOptionHelp":{"#cdata":"Syntax: RENAME= (old-name AS new-name [... old-name AS new-name ] ) ;\n          \nSeparates the new-name from the old-name."},"StatementOptionType":"S"},{"StatementOptionName":"TYPE=","StatementOptionHelp":{"#cdata":"Specifies the data set type for a specially structured SAS data set. \n    \nSyntax: TYPE=data-set-type  \n\nSyntax Description: \ndata-set-type \n  specifies the special type of the data set.\n\nDetails: \nUse the TYPE= table option to create a special SAS data set in the proper format, \nor to identify the special type of the SAS data set in a procedure statement. \n\nYou can use the CONTENTS procedure to determine the type of a data set."},"StatementOptionType":"V"},{"StatementOptionName":"WRITE=","StatementOptionHelp":{"#cdata":"Assigns a WRITE password to a SAS file that prevents users from writing to a file, \nunless they enter the password. \n    \nSyntax: WRITE=write-password  \n\nSyntax Description: \nwrite-password \n  must be a valid SAS name. \n \nDetails: \nThe WRITE= option applies to all types of SAS files except catalogs. You can use this \noption to assign a password to a SAS file or to access a write-protected SAS file. When \nthe code is written to the SAS log, the password is blotted out, for example: \n\n  drop thread job2a (write=XXXXXXX);\n\nNote: A SAS password does not control access to a SAS file beyond the SAS system. You \nshould use the operating system-supplied utilities and file-system security controls \nin order to control access to SAS files outside of SAS."},"StatementOptionType":"V"}],"#comment":{}}},{"StatementName":"END","StatementHelp":{"#cdata":"Syntax: END; \n      \nMarks the end of a block of code."},"StatementOptions":null},{"StatementName":"PERFORMANCE","StatementHelp":{"#cdata":"Syntax: PERFORMANCE < performance-options > ;\n      \nThe PERFORMANCE statement defines performance parameters for multithreaded and distributed \ncomputing, passes variables about the distributed computing environment, and requests detailed \nresults about the performance characteristics of a High-Performance Analytics procedure.\n\nWith the PERFORMANCE statement, you can also control whether a High-Performance Analytics \nprocedure executes in SMP or MPP mode."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"COMMIT=","StatementOptionHelp":{"#cdata":"Syntax: COMMIT=n\n          \nRequests that the High-Performance Analytics procedure write periodic updates to the \nSAS Log when observations are sent from the client to the appliance for distributed \nprocessing.\n\nHigh-Performance Analytics procedures do not have to use input data that are stored \nin the appliance. You can perform distributed computations regardless of the origin \nor format of the input data, provided the data are in a format that can be read by \nthe SAS System (for example, because a SAS/ACCESS engine is available)."},"StatementOptionType":"V"},{"StatementOptionName":"CPUCOUNT=","StatementOptionHelp":{"#cdata":"Syntax: CPUCOUNT=ACTUAL | num\n          \nSpecifies how many processors the procedure assumes are available on each host in the \ncomputing environment. num can be any integer from 1 to 256.\n\nCPUCOUNT=ACTUAL sets CPUCOUNT to the number of physical processors available. This number\ncan be less than the physical number of CPUs if the SAS process has been restricted by system\nadministration tools. Setting CPUCOUNT= to a number greater than the actual number of available\nCPUs might result in reduced performance. This option overrides the CPUCOUNT= SAS system\noption.\n\nIf a High-Performance Analytics procedure executes in SMP mode, this option refers to the client\nmachine of the SAS session. In MPP mode, this option applies to the nodes on the appliance."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"ACTUAL","@Value2":"<num>"},"StatementOptionToolTips":{"@ToolTip1":"Sets CPUCOUNT to the number of physical processors available. This number can be less than the physical number of CPUs if the SAS process has been restricted by system administration tools.","@ToolTip2":"Replace <num> with an actual number. Setting CPUCOUNT= to a number  greater than the actual number of available CPUs might result in reduced performance. This  option overrides the CPUCOUNT= SAS system option."}},{"StatementOptionName":"DATASERVER=","StatementOptionHelp":{"#cdata":"Syntax: DATASERVER=\u201cname\u201d\n          \nSpecifies the name of the server on Teradata systems as defined through the hosts file \nand as used in the LIBNAME statement for Teradata. For example, if the hosts file defines\n\n    myservercop1 33.44.55.66\n    \nas the server for Teradata, then a LIBNAME specification would be as follows:\n\n    libname TDLib teradata server=myserver user= password= database= ;\n    \nA PERFORMANCE statement to induce running alongside the Teradata server would specify the\nfollowing:\n\n    performance dataserver=\"myserver\";\n    \nIf the DATASERVER= option is specified, it overrides the GRIDDATASERVER environment \nvariable."},"StatementOptionType":"V"},{"StatementOptionName":"DETAILS","StatementOptionHelp":{"#cdata":"Requests a table that shows a timing breakdown of the procedure steps."},"StatementOptionType":"V"},{"StatementOptionName":"TIMEOUT=","StatementOptionHelp":{"#cdata":"Syntax: TIMEOUT=s\n          \nSpecifies the timeout in seconds for a High-Performance Analytics procedure to wait for a connection\nto the appliance and establish a connection back to the client. The default is s=120 seconds. If jobs\nare submitted to the appliance through workload management tools that might suspend access to the\nappliance for a longer period, you might want to increase the timeout value."},"StatementOptionType":"V"},{"StatementOptionName":"HOST=|GRIDHOST=","StatementOptionHelp":{"#cdata":"Syntax: HOST=\u201cname\u201d | GRIDHOST=\u201cname\u201d \n          \nSpecifies the name of the appliance host in single or double quotes. If the HOST= option \nis specified, it overrides the value of the GRIDHOST environment variable."},"StatementOptionType":"V"},{"StatementOptionName":"INSTALL=|INSTALLLOC=","StatementOptionHelp":{"#cdata":"Syntax: INSTALL=\u201cname\u201d | INSTALLLOC=\u201cname\u201d \n          \nSpecifies the directory in which the High-Performance Analytics shared libraries are \ninstalled on the appliance. Specifying the INSTALL= option overrides the GRIDINSTALLLOC \nenvironment variable."},"StatementOptionType":"V"},{"StatementOptionName":"NODES=|NNODES=","StatementOptionHelp":{"#cdata":"Syntax: NODES=n | NNODES=n\n          \nSpecifies the number of nodes in the distributed computing environment, provided that \nthe data are not processed alongside the database.\n\nIf you specify NODES=0, you indicate that you want to process the data in SMP mode on \nthe client machine. If the input data are not alongside the database, this is the default. \nThe High-Performance Analytics procedures then perform the analysis mutlithreaded on the client."},"StatementOptionType":"V"},{"StatementOptionName":"NTHREADS=","StatementOptionHelp":{"#cdata":"Syntax: NTHREADS=n \n          \nSpecifies the number of threads for analytic computations and overrides the SAS system option\nTHREADS | NOTHREADS. If you do not specify the NTHREADS= option, the number of threads\nare determined based on the number of CPUs on the host on which the analytic computations execute.\nThe algorithm by which a CPU count is converted to a thread count is specific to the High-\nPerformance Analytics procedure. Most procedures create one thread per CPU for the analytic computations.\nBy default, High-Performance Analytics procedures execute in multiple concurrent threads unless\nturned off by the NOTHREADS system option or you force single-threaded execution with\nNTHREADS=1. The largest number that can be specified for n is 256. Individual High-Performance\nAnalytics procedures can impose more stringent limits if called for by algorithmic considerations.\nYou can affect the determination of the CPU count with the CPUCOUNT= option in the PERFORMANCE\nstatement.\n\nNOTE: The SAS system options THREADS | NOTHREADS apply to the client machine on which\nthe SAS High-Performance Analytics procedures execute. They do not apply to the compute nodes\nin a distributed environment."},"StatementOptionType":"V"}]}},{"StatementName":"RUN CANCEL","StatementHelp":{"#cdata":"Syntax: RUN CANCEL ; \n      \nThe RUN CANCEL statement cancels the preceding PROC HPDS2 statements. RUN CANCEL is useful if\nyou enter a typographical error."},"StatementOptions":null}]}}}