{"Procedure":{"Name":"IML","ProductGroup":"SAS/IML","ProcedureHelp":{"#cdata":"Syntax: PROC IML <SYMSIZE=n1 > <WORKSIZE=n2 >; \n  ...statements/functions/call-routines \n  RUN;\n\nwhere n1 and n2 are specified in kilobytes. \n\nThe SYMSIZE= and WORKSIZE= options in the PROC IML statement give you control over \nthe size of memory allocated to the symbol space and the size of each extent of \nworkspace. If you do not specify these options, PROC IML uses host dependent defaults. \n \nSAS/IML software gives you access to a powerful and flexible programming language \n(Interactive Matrix Language) in a dynamic, interactive environment. The fundamental \nobject of the language is a data matrix. You can use SAS/IML software interactively \n(at the statement level) to see results immediately, or you can store statements in \na module and execute them later. The programming is dynamic because necessary \nactivities such as memory allocation and dimensioning of matrices are performed \nautomatically. \n\nSAS/IML software is powerful. You can access built-in operators and call routines \nto perform complex tasks such as matrix inversion or eigenvector generation. You \ncan define your own functions and subroutines by using SAS/IML modules. You can \nperform operations on a single value or take advantage of matrix operators to perform \noperations on an entire data matrix."},"ProcedureOptions":{"ProcedureOption":[{"ProcedureOptionName":"SYMSIZE=","ProcedureOptionHelp":{"#cdata":"[Syntax: SYMSIZE=n1] \n      \nGives you control over the size of memory allocated to the symbol space."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"WORKSIZE=","ProcedureOptionHelp":{"#cdata":"[Syntax: WORKSIZE=n2] \n      \nGives you control over the size of each extent of workspace."},"ProcedureOptionType":"V"}]},"ProcedureStatements":{"ProcedureStatement":[{"StatementName":"DO","StatementHelp":{"#cdata":"Specifies a group of statements to be executed as a unit.\n      \nSyntax: \n(1) DO; \n...more SAS statements...  \nEND;  \n\n(2) DO index-variable=specification-1 <, ... specification-n>; \n... more SAS statements ...  \nEND;  \n\n(3) DO UNTIL (expression); \n...more SAS statements...  \nEND \n\n(4) DO WHILE (expression); \n...more SAS statements...  \nEND;"},"StatementOptions":{"StatementOption":[{"StatementOptionName":"UNTIL","StatementOptionHelp":{"#cdata":"Executes statements in a DO loop repetitively until a condition is true.\n          \nSyntax: \nDO UNTIL (expression); \n...more SAS statements...  \nEND"},"StatementOptionType":"S"},{"StatementOptionName":"WHILE","StatementOptionHelp":{"#cdata":"Executes statements in a DO-loop repetitively while a condition is true. \n          \nSyntax: \nDO WHILE (expression); \n...more SAS statements...  \nEND;"},"StatementOptionType":"S"},{"StatementOptionName":"OVER","StatementOptionType":"S"},{"StatementOptionName":"TO","StatementOptionHelp":{"#cdata":"Separates the start and stop integers or expressions that control the number of times the \nportion of the DATA step between the iterative DO and END statements is processed."},"StatementOptionType":"S"},{"StatementOptionName":"BY","StatementOptionHelp":{"#cdata":"Precedes an increment integer (other than 0) or an expression that generates an integer to be \nadded to the value of the index variable in each iteration of the DO loop."},"StatementOptionType":"S"}]}},{"StatementName":"DO WHILE","StatementHelp":{"#cdata":"Executes statements in a DO-loop repetitively while a condition is true. \n          \nSyntax: \nDO WHILE (expression); \n...more SAS statements...  \nEND;"},"StatementOptions":null},{"StatementName":"DO UNTIL","StatementHelp":{"#cdata":"Executes statements in a DO loop repetitively until a condition is true.\n          \nSyntax: \nDO UNTIL (expression); \n...more SAS statements...  \nEND"},"StatementOptions":null},{"StatementName":"END","StatementHelp":{"#cdata":"Syntax: END; \n      \nEnds a DO group/loop/statement or SELECT group processing."},"StatementOptions":null},{"StatementName":"GO TO|GOTO","StatementHelp":{"#cdata":"Syntax: GO TO label | GOTO label;\n      \nJumps to a new statement."},"StatementOptions":null},{"StatementName":"IF","StatementHelp":{"#cdata":"Executes a SAS statement for observations that meet specific conditions. \n\nSyntax: \n(1) IF expression THEN statement; \n    <ELSE statement;> \n(2) IF condition;"},"StatementOptions":{"StatementOption":[{"StatementOptionName":"THEN","StatementOptionHelp":{"#cdata":"If the conditions that are specified in the IF clause are met, the IF-THEN statement executes a SAS \nstatement for observations that are read from a SAS data set, for records in an external file, or \nfor computed values."},"StatementOptionType":"S"},{"StatementOptionName":"DO","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct."},"StatementOptionType":"S"},{"StatementOptionName":"WHEN","StatementOptionHelp":{"#cdata":"WHEN statement in an IF-THEN-WHEN construct."},"StatementOptionType":"S"},{"StatementOptionName":"OUTPUT","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct."},"StatementOptionType":"S"},{"StatementOptionName":"GO TO|GOTO","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct. \n          \nSyntax: ... GO TO label; | ... GOTO label;\n      \nJumps to a new statement."},"StatementOptionType":"S"},{"StatementOptionName":"PUT","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct."},"StatementOptionType":"S"},{"StatementOptionName":"STOP","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct. \n          \nStops execution of the current DATA step."},"StatementOptionType":"S"},{"StatementOptionName":"RETURN","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct. \n          \nStops executing statements at the current point in the DATA step and returns to \na predetermined point in the step. "},"StatementOptionType":"S"},{"StatementOptionName":"CALL","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct. \n          \nSyntax: CALL routine(parameter-1<, ...parameter-n>); \n      \nInvokes a SAS CALL routine."},"StatementOptionType":"S"},{"StatementOptionName":"SET","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct.\n          \nSyntax: SET <SAS-data-set(s) <(data-set-options(s) )>>; \n      \nReads an observation from one or more SAS data sets."},"StatementOptionType":"S"},{"StatementOptionName":"NOT","StatementOptionType":"S"},{"StatementOptionName":"OR","StatementOptionType":"S"},{"StatementOptionName":"AND","StatementOptionType":"S"}],"#comment":{}}},{"StatementName":"ELSE","StatementHelp":{"#cdata":"If the condition in an IF-THEN statement is false and an ELSE statement is present, \nthen the ELSE action is carried out."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"THEN","StatementOptionHelp":{"#cdata":"If the conditions that are specified in the IF clause are met, the IF-THEN statement executes a SAS \nstatement for observations that are read from a SAS data set, for records in an external file, or \nfor computed values."},"StatementOptionType":"S"},{"StatementOptionName":"IF","StatementOptionHelp":{"#cdata":"Executes a SAS statement for observations that meet specific conditions."},"StatementOptionType":"S"},{"StatementOptionName":"DO","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN-ELSE construct."},"StatementOptionType":"S"},{"StatementOptionName":"OUTPUT","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN-ELSE construct."},"StatementOptionType":"S"},{"StatementOptionName":"NOT","StatementOptionType":"S"},{"StatementOptionName":"OR","StatementOptionType":"S"},{"StatementOptionName":"AND","StatementOptionType":"S"}],"#comment":{}}},{"StatementName":"LINK","StatementHelp":{"#cdata":"Syntax: LINK label; \n      \nDirects program execution immediately to the statement label that is specified and, if followed \nby a RETURN statement, returns execution to the statement that follows the LINK statement."},"StatementOptions":null},{"StatementName":"QUIT","StatementHelp":{"#cdata":"Syntax: QUIT ; \n      \nUse the QUIT statement to exit IML. If a DATA or PROC statement is encountered, QUIT \nis implied. The QUIT statement is executed immediately; therefore, you cannot use QUIT \nas an executable statement, that is, as part of a module or conditional clause. \n\nPROC IML closes all open data sets and files when a QUIT statement is encountered. \nWorkspace and symbol spaces are freed up. If you need to use any matrix values or any \nmodule definitions in a later session, you must store them in a storage library before \nyou quit."},"StatementOptions":null},{"StatementName":"PAUSE","StatementHelp":{"#cdata":"Syntax: PAUSE <expression> <*>;\n\nThe inputs to the PAUSE statement are as follows: \n\nexpression \nis a character matrix or quoted literal giving a message to print. \n\n* \nsuppresses any messages. \n\nThe PAUSE statement stops execution of a module, saves the calling chain so that \nexecution can resume later (by a RESUME statement), prints a pause message that \nyou can specify, and puts you in immediate mode so you can enter more statements."},"StatementOptions":null},{"StatementName":"RESUME","StatementHelp":{"#cdata":"Syntax: RESUME; \n      \nThe RESUME statement enables you to continue execution from the line in the module \nwhere the most recent PAUSE statement was executed. PROC IML issues an automatic pause \nwhen an error occurs inside a module. If a module was paused due to an error, the RESUME \nstatement resumes execution immediately after the statement that caused the error. The \nSHOW pause statement displays the current state of all paused modules."},"StatementOptions":null},{"StatementName":"RETURN","StatementHelp":{"#cdata":"Syntax: RETURN <(operand)>; \n      \nwhere operand is the value of the function returned. Use operand only in function modules. \n\nThe RETURN statement causes IML to return to the calling point in a program. If a LINK \nstatement has been issued, IML returns to the statement following the LINK. If no LINK \nstatement was issued, the RETURN statement exits a module. If not in a module, execution \nis stopped (as with a STOP statement), and IML looks for more statements to parse. \n\nThe RETURN statement with an operand is used in function modules that return a value. The \noperand can be a variable name or an expression. It is evaluated, and the value is returned."},"StatementOptions":null},{"StatementName":"RUN","StatementHelp":{"#cdata":"Syntax: RUN <name> <(arguments)>;\n\nThe inputs to the RUN statement are as follows: \nname \nis the name of a user-defined module or an IML built-in subroutine. \n\narguments \nare arguments to the subroutine. Arguments can be both local and global. \nThe RUN statement executes a user-defined module or invokes PROC IML's built-in \nsubroutines."},"StatementOptions":null},{"StatementName":"START","StatementHelp":{"#cdata":"Syntax: START <name> <(arguments)> <GLOBAL(arguments)>;\n    module statements;\n  FINISH <name>;\n\nThe inputs to the START and FINISH statements are as follows: \n\nname \nis the name of a user-defined module. \n\narguments \nare names of variable arguments to the module. Arguments can be either input variables \nor output (returned) variables. Arguments listed in the GLOBAL clause are treated as \nglobal variables. Otherwise, the arguments are local. \n\n\nmodule statements \nare statements making up the body of the module. \nThe START statement instructs IML to enter a module-collect mode to collect the statements \nof a module rather than execute them immediately."},"StatementOptions":{"StatementOption":{"StatementOptionName":"GLOBAL","StatementOptionHelp":{"#cdata":"[Syntax: GLOBAL(arguments)] \n          \nArguments listed in the GLOBAL clause are treated as global variables. Otherwise, \nthe arguments are local."},"StatementOptionType":"S"}}},{"StatementName":"FINISH","StatementHelp":{"#cdata":"Syntax: START <name> <(arguments)> <GLOBAL(arguments)>;\n    module statements;\n  FINISH <name>; \n  \nThe FINISH statement signals the end of a module. Optionally, the FINISH statement \ncan take the module name as its argument."},"StatementOptions":null},{"StatementName":"STOP","StatementHelp":{"#cdata":"Syntax: STOP ; \n      \nThe STOP statement stops the IML program, and no further matrix statements are executed. \nHowever, IML continues to execute if more statements are entered. See also the descriptions \nof the RETURN and ABORT statements. \n\nIf IML execution was interrupted by a PAUSE statement or by a break, the STOP statement \nclears all the paused states and returns to immediate mode. \n\nIML supports STOP processing of both regular and function modules."},"StatementOptions":null},{"StatementName":"ABORT","StatementHelp":{"#cdata":"Syntax: ABORT ; \n      \nThe ABORT statement instructs IML to stop executing statements. It also stops IML \nfrom parsing any further statements, causing IML to close its files and exit."},"StatementOptions":null},{"StatementName":"APPEND","StatementHelp":{"#cdata":"Syntax: APPEND < VAR operand > ;\n  | APPEND < FROM from-name < [ROWNAME=row-name] > > ;\n\nwhere:\n\noperand \ncan be specified as one of the following: \n  o a literal containing variable names \n  o a character matrix containing variable names \n  o an expression in parentheses yielding variable names \n  o one of the keywords described in the following list: \n  \n    _ALL_ -- for all variables \n    _CHAR_ -- for all character variables \n    _NUM_ -- for all numeric variables \n\nfrom-name -- is the name of a matrix containing data to append. \n\nrow-name -- is a character matrix or quoted literal containing descriptive row names. \n\nUse the APPEND statement to add data to the end of the current output data set. The \nappended observations are from either the variables specified in the VAR clause or \nvariables created from the columns of the FROM matrix. The FROM clause and the VAR \nclause should not be specified together. \n\nYou can specify a set of variables to use with the VAR clause."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"VAR","StatementOptionHelp":{"#cdata":"[Syntax: VAR operand] \n          \nwhere\n\noperand \ncan be specified as one of the following: \n  o a literal containing variable names \n  o a character matrix containing variable names \n  o an expression in parentheses yielding variable names \n  o one of the keywords described in the following list: \n  \n    _ALL_ -- for all variables \n    _CHAR_ -- for all character variables \n    _NUM_ -- for all numeric variables \n          \nThe variables in the new SAS data set are the variables listed in the VAR clause."},"StatementOptionType":"S"},{"StatementOptionName":"FROM","StatementOptionHelp":{"#cdata":"[Syntax: FROM matrix-name] \n          \nThe variables in the new SAS data set are variables created from the columns of the \nFROM matrix."},"StatementOptionType":"S"},{"StatementOptionName":"_ALL_","StatementOptionHelp":{"#cdata":"For all variables"},"StatementOptionType":"S"},{"StatementOptionName":"_CHAR_","StatementOptionHelp":{"#cdata":"For all character variables"},"StatementOptionType":"S"},{"StatementOptionName":"_NUM_","StatementOptionHelp":{"#cdata":"For all numeric variables"},"StatementOptionType":"S"}]}},{"StatementName":"CLOSE","StatementHelp":{"#cdata":"Syntax: CLOSE <SAS-data-set>; \n      \nwhere SAS-data-set can be specified with a one-level name (for example, A) or \na two-level name (for example, SASUSER.A). More than one SAS data set can be \nlisted in a CLOSE statement. \n\nThe CLOSE statement is used to close one or more SAS data sets opened with the \nUSE, EDIT, or CREATE statement. To find out which data sets are open, use the \nSHOW DATASETS statement; see also the section on the SAVE statement later in \nthis chapter. IML automatically closes all open data sets when a QUIT statement \nis executed."},"StatementOptions":null},{"StatementName":"CLOSEFILE","StatementHelp":{"#cdata":"Syntax: CLOSEFILE files; \n      \nwhere files can be names (for defined filenames), literals, or expressions in\nparentheses (for pathnames). \n\nThe CLOSEFILE statement is used to close files opened by the INFILE or FILE\nstatement. The file specification should be the same as when the file was\nopened. File specifications are either a name (for a defined filename), a\nliteral, or an expression in parentheses (for a pathname). To find out what\nfiles are open, use the SHOW FILES statement. For further information, consult\nChapter 7. See also the description of the SAVE statement. IML automatically\ncloses all files when a QUIT statement is executed. "},"StatementOptions":null},{"StatementName":"CREATE","StatementHelp":{"#cdata":"Syntax: CREATE SAS-data-set < VAR operand > ;\n  | CREATE SAS-data-set FROM from-name FROM matrix-name <[COLNAME=column-name ROWNAME=row-name]>;\n\nwhere:\n\n  SAS-data-set -- can be specified with a one-level name (for example, A) or a two-level name \n  (for example, SASUSER.A). \n\n  operand -- gives a set of existing IML variables to become data set variables. \n\n  matrix-name -- names a matrix containing the data. \n\n  column-name \n  is a character matrix or quoted literal containing descriptive names to associate with \n  data set variables. \n\n  row-name \n  is a character matrix or quoted literal containing descriptive names to associate with \n  observations on the data set. \n\nThe CREATE statement creates a new SAS data set and makes it both the current input and \noutput data sets. The variables in the new SAS data set are either the variables listed \nin the VAR clause or variables created from the columns of the FROM matrix. The FROM \nclause and the VAR clause should not be specified together."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"VAR","StatementOptionHelp":{"#cdata":"[Syntax: VAR operand] \n          \nYou can specify a set of variables to use with the VAR clause, where operand can be \nspecified as one of the following: \n\n  o a literal containing variable names \n  o a character matrix containing variable names \n  o an expression in parentheses yielding variable names \n  o one of the keywords described in the following list: \n  \n    _ALL_ -- for all variables \n    _CHAR_ -- for all character variables \n    _NUM_ -- for all numeric variables"},"StatementOptionType":"S","SubOptionsKeywords":"_ALL_|_CHAR_|_NUM_"},{"StatementOptionName":"FROM","StatementOptionHelp":{"#cdata":"[Syntax: FROM matrix-name] \n          \nThe variables in the new SAS data set are variables created from the columns of the \nFROM matrix."},"StatementOptionType":"S"},{"StatementOptionName":"_ALL_","StatementOptionHelp":{"#cdata":"For all variables"},"StatementOptionType":"S"},{"StatementOptionName":"_CHAR_","StatementOptionHelp":{"#cdata":"For all character variables"},"StatementOptionType":"S"},{"StatementOptionName":"_NUM_","StatementOptionHelp":{"#cdata":"For all numeric variables"},"StatementOptionType":"S"},{"StatementOptionName":"COLNAME=","#comment":{},"StatementOptionType":"V"},{"StatementOptionName":"ROWNAME=","#comment":{},"StatementOptionType":"V"}]}},{"StatementName":"DELETE","StatementHelp":{"#cdata":"Syntax: DELETE <range> <WHERE(expression)>;\n\nThe inputs to the DELETE statement are as follows: \nrange \nspecifies a range of observations. \n\nexpression \nis an expression that is evaluated for being true or false. \n\nUse the DELETE statement to mark records for deletion in the current output data set. \nTo delete records and renumber the remaining observations, use the PURGE statement."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"WHERE","StatementOptionHelp":{"#cdata":"[Syntax: WHERE(expression)] \n          \nThe WHERE clause conditionally selects observations that are contained within the range \nspecification. The general form of the WHERE clause is \n\n  WHERE(variable comparison-op operand) \n \nwhere:\n\nvariable -- is a variable in the SAS data set. \ncomparison-op -- is one of the several comparison operators (<, <=, =, >, >=, ^=, ?, etc.)"},"StatementOptionType":"S"},{"StatementOptionName":"ALL","StatementOptionHelp":{"#cdata":"[range] \n          \nSpecifies all observations."},"StatementOptionType":"S"},{"StatementOptionName":"CURRENT","StatementOptionHelp":{"#cdata":"[range] \n          \nSpecifies the current observation."},"StatementOptionType":"S"},{"StatementOptionName":"NEXT","StatementOptionHelp":{"#cdata":"[range][Syntax: NEXT <number>] \n          \nSpecifies the next observation or the next number of observations."},"StatementOptionType":"S"},{"StatementOptionName":"AFTER","StatementOptionHelp":{"#cdata":"[range] \n          \nSpecifies all observations after the current one."},"StatementOptionType":"S"},{"StatementOptionName":"POINT","StatementOptionHelp":{"#cdata":"[range][Syntax: POINT operand] \n          \nspecifies observations by number, where operand is one of the following: \n\nOperand   \n  o a single record number (Example: point 5)\n  o a literal giving several point record numbers (Example: {2 5 10})   \n  o the name of a matrix containing record numbers (Example: point p)   \n  o an expression in parentheses (Example: point (p+1)\n  \nCURRENT is the default value for range. If the current data set has an index in use, \nthe POINT option is invalid."},"StatementOptionType":"S"}]}},{"StatementName":"DISPLAY","StatementHelp":{"#cdata":"Syntax: DISPLAY <group-spec group-options, group-spec group-options>;\n\nThe inputs to the DISPLAY statement are as follows: \n\n  group-spec \n  specifies a group. It can be specified as either a compound name of the form windowname.groupname \n  or a window name followed by a group of the form window-name (field-specs), where field-specs is \n  as defined for the WINDOW statement. \n\n  group-options \n  can be any of the following: \n\n  NOINPUT \n  displays the group with all fields protected so that no data can be entered in the fields. \n\n  REPEAT \n  repeats the group for each element of the matrices specified as field operands. \n\n  BELL \n  rings the bell, sounds the alarm, or causes the speaker in your workstation to beep when the \n  window is displayed. The DISPLAY statement directs IML to gather data into fields defined in \n  the window for purposes of display, data entry, or menu selection. The DISPLAY statement always \n  refers to a window that has been previously opened by a WINDOW statement."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"NOINPUT","StatementOptionHelp":{"#cdata":"Displays the group with all fields protected so that no data can be entered in the fields."},"StatementOptionType":"S"},{"StatementOptionName":"REPEAT","StatementOptionHelp":{"#cdata":"Repeats the group for each element of the matrices specified as field operands."},"StatementOptionType":"S"},{"StatementOptionName":"BELL","StatementOptionHelp":{"#cdata":"Repeats the group for each element of the matrices specified as field operands."},"StatementOptionType":"S"}]}},{"StatementName":"DO DATA","StatementHelp":{"#cdata":"Syntax: DO DATA <variable=start TO stop>; \n\nThe inputs to the DO DATA statement are as follows: \nvariable \nis the name of a variable indexing the loop. \n\n  start \n  is the starting value for the looping variable. \n\n  stop \n  is the stopping value for the looping variable. \n  The DO DATA statement is used for repetitive DO loops that need to be exited upon the \n  occurrence of an end of file for an INPUT, READ, or other I/O statement. This form is \n  common for loops that read data from either a sequential file or a SAS data set. \n\nWhen an end of file is reached inside the DO DATA group, IML immediately jumps from the \ngroup and starts executing the statement following the END statement. DO DATA groups can \nbe nested, where each end of file causes a jump from the most local DO DATA group. The \nDO DATA loop simulates the end-of-file behavior of the SAS DATA step. You should avoid \nusing GOTO and LINK statements to jump out of a DO DATA group."},"StatementOptions":{"StatementOption":{"StatementOptionName":"TO","StatementOptionType":"S"}}},{"StatementName":"FIND","StatementHelp":{"#cdata":"Syntax: FIND <range> <WHERE(expression)> INTO matrix-name;\n\nThe inputs to the FIND statement are as follows: \n\n  range \n  specifies a range of observations. \n\n  expression \n  is an expression that is evaluated for being true or false. \n\n  matrix-name \n  names a matrix to contain the observation numbers. \n\nThe FIND statement finds the observation numbers of records in range that satisfy \nthe conditions of the WHERE clause. The FIND statement places these observation \nnumbers in the numeric matrix whose name follows the INTO keyword."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"WHERE","StatementOptionHelp":{"#cdata":"[Syntax: WHERE(expression)]\n          \nThe WHERE clause conditionally selects observations that are contained within the range \nspecification. The general form of the WHERE clause is \n\n  WHERE(variable comparison-op operand) \n \nwhere:\n\nvariable -- is a variable in the SAS data set. \ncomparison-op -- is one of the several comparison operators (<, <=, =, >, >=, ^=, ?, etc.)"},"StatementOptionType":"S"},{"StatementOptionName":"INTO","StatementOptionHelp":{"#cdata":"The FIND statement finds the observation numbers of records in range that satisfy \nthe conditions of the WHERE clause. The FIND statement places these observation \nnumbers in the numeric matrix whose name follows the INTO keyword."},"StatementOptionType":"S"},{"StatementOptionName":"ALL","StatementOptionHelp":{"#cdata":"[range] \n          \nSpecifies all observations."},"StatementOptionType":"S"},{"StatementOptionName":"CURRENT","StatementOptionHelp":{"#cdata":"[range] \n          \nSpecifies the current observation."},"StatementOptionType":"S"},{"StatementOptionName":"NEXT","StatementOptionHelp":{"#cdata":"[range][Syntax: NEXT <number>] \n          \nSpecifies the next observation or the next number of observations."},"StatementOptionType":"S"},{"StatementOptionName":"AFTER","StatementOptionHelp":{"#cdata":"[range] \n          \nSpecifies all observations after the current one."},"StatementOptionType":"S"},{"StatementOptionName":"POINT","StatementOptionHelp":{"#cdata":"[range][Syntax: POINT operand] \n          \nSpecifies observations by number, where operand is one of the following: \n\nOperand   \n  o a single record number (Example: point 5)\n  o a literal giving several point record numbers (Example: {2 5 10})   \n  o the name of a matrix containing record numbers (Example: point p)   \n  o an expression in parentheses (Example: point (p+1)\n  \nCURRENT is the default value for range. If the current data set has an index in use, \nthe POINT option is invalid."},"StatementOptionType":"S"}]}},{"StatementName":"FILE","StatementHelp":{"#cdata":"Syntax: FILE file-name <RECFM=N> <LRECL=operand>;\n\nThe inputs to the FILE statement are as follows: \n\n  file-name \n  is a name (for defined filenames), a quoted literal, or an expression in parentheses \n  (for pathnames). \n\n  RECFM=N \n  specifies that the file is to be written as a pure binary file without record-separator \n  characters. \n\n  LRECL=operand \n  specifies the record length of the output file. The default record length is 512."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"RECFM=","StatementOptionHelp":{"#cdata":"[Syntax: RECFM=N] \n          \nSpecifies that the file is to be written as a pure binary file without record-separator \ncharacters."},"StatementOptionType":"V"},{"StatementOptionName":"LRECL=","StatementOptionHelp":{"#cdata":"[Syntax: LRECL=operand] \n          \nSpecifies the record length of the output file. The default record length is 512."},"StatementOptionType":"V"}]}},{"StatementName":"SAVE|FORCE","StatementHelp":{"#cdata":"Syntax: SAVE ; \n      \nThe SAVE statement forces out any data residing in output buffers for all active \noutput data sets and files to ensure that the data are written to disk. This is \nequivalent to closing and then reopening the files."},"StatementOptions":null},{"StatementName":"FREE","StatementHelp":{"#cdata":"Syntax: FREE matrices; |  FREE / <matrices>;\n\nwhere matrices are names of matrices. \n\nThe FREE statement causes the specified matrices to lose their values; the memory \nis then freed for other uses. After execution of the FREE statement, the matrix does \nnot have a value, and it returns 0 for the NROW and NCOL functions. Any printing \nattributes (assigned by the MATTRIB statement) are not released. \n\nThe FREE statement is used mostly in large applications or under tight memory constraints \nto make room for more data (matrices) in the workspace."},"StatementOptions":null},{"StatementName":"INDEX","StatementHelp":{"#cdata":"Syntax: INDEX variables|NONE \n      \nwhere variables are the names of variables for which indexes are to be built. \n\nYou can use the INDEX statement to create an index for the named variables in the \ncurrent input SAS data set. An index is created for each variable listed if it does \nnot already have an index. Current retrieval is set to the last variable indexed. \nSubsequent I/O operations such as LIST, READ, FIND, and DELETE can use this index \nto retrieve observations from the data set if IML determines that indexed retrieval \nwill be faster. The indices are automatically updated when a data set is edited with \nthe APPEND, DELETE, or REPLACE statements. Only one index is in effect at any given \ntime. The SHOW contents command indicates which index is in use."},"StatementOptions":{"StatementOption":{"StatementOptionName":"NONE","StatementOptionHelp":{"#cdata":"An INDEX none statement can be used to set retrieval back to physical order."},"StatementOptionType":"S"}}},{"StatementName":"INPUT","StatementHelp":{"#cdata":"Syntax: INPUT <variables> <informats> <record-directives> <positionals>;\n\nwhere the clauses and options are explained in the following list. \n\nYou can use the INPUT statement to input records from the current input file, placing \nthe values into IML variables. The INFILE statement sets up the current input file.  \n\nThe INPUT statement contains a sequence of arguments that include the following: \n\nvariables \nspecify the variable or variables you want to read from the current position in the \nrecord. Each variable can be followed immediately by an input format specification. \n\ninformats \nspecify an input format."},"StatementOptions":null},{"StatementName":"LIST","StatementHelp":{"#cdata":"Syntax: LIST <range> <VAR operand> <WHERE(expression)>;\n\nThe inputs to the LIST statement are as follows: \n\n  range \n  specifies a range of observations \n\n  operand \n  specifies a set of variables \n\n  expression \n  is an expression evaluated to be true or false \n\nThe LIST statement prints selected observations of a data set. If all data values \nfor variables in the VAR clause fit on a single line, values are displayed in columns \nheaded by the variable names. Each record occupies a separate line. If the data values \ndo not fit on a single line, values from each record are grouped into paragraphs. Each \nelement in the paragraph has the form name=value."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"VAR","StatementOptionHelp":{"#cdata":"[Syntax: VAR operand]\n          \nYou can specify a set of variables to use with the VAR clause. The operand in the \nVAR clause can be one of the following: \n\n  o a literal containing variable names \n  o the name of a matrix containing variable names \n  o an expression in parentheses yielding variable names \n  o one of keywords described in the following list: \n  \n    _ALL_ \n    for all variables \n\n    _CHAR_ \n    for all character variables \n\n    _NUM_ \n    for all numeric variables."},"StatementOptionType":"S"},{"StatementOptionName":"WHERE","StatementOptionHelp":{"#cdata":"[Syntax: WHERE(expression)] \n          \nThe WHERE clause conditionally selects observations that are contained within the range \nspecification. The general form of the WHERE clause is \n\n  WHERE(variable comparison-op operand) \n \nwhere:\n\nvariable -- is a variable in the SAS data set. \ncomparison-op -- is one of the several comparison operators (<, <=, =, >, >=, ^=, ?, etc.)"},"StatementOptionType":"S"},{"StatementOptionName":"ALL","StatementOptionHelp":{"#cdata":"[range] \n          \nSpecifies all observations."},"StatementOptionType":"S"},{"StatementOptionName":"CURRENT","StatementOptionHelp":{"#cdata":"[range] \n          \nSpecifies the current observation (this is the default for the LIST statement)."},"StatementOptionType":"S"},{"StatementOptionName":"NEXT","StatementOptionHelp":{"#cdata":"[range][Syntax: NEXT <number>] \n          \nSpecifies the next observation or the next number of observations."},"StatementOptionType":"S"},{"StatementOptionName":"AFTER","StatementOptionHelp":{"#cdata":"[range] \n          \nSpecifies all observations after the current one."},"StatementOptionType":"S"},{"StatementOptionName":"POINT","StatementOptionHelp":{"#cdata":"[range][Syntax: POINT operand] \n          \nspecifies observations by number, where operand is one of the following: \n\nOperand   \n  o a single record number (Example: point 5)\n  o a literal giving several point record numbers (Example: {2 5 10})   \n  o the name of a matrix containing record numbers (Example: point p)   \n  o an expression in parentheses (Example: point (p+1)\n  \nCURRENT is the default value for range. If the current data set has an index in use, \nthe POINT option is invalid."},"StatementOptionType":"S"},{"StatementOptionName":"_ALL_","StatementOptionHelp":{"#cdata":"For all variables"},"StatementOptionType":"S"},{"StatementOptionName":"_CHAR_","StatementOptionHelp":{"#cdata":"For all character variables"},"StatementOptionType":"S"},{"StatementOptionName":"_NUM_","StatementOptionHelp":{"#cdata":"For all numeric variables"},"StatementOptionType":"S"}]}},{"StatementName":"LOAD","StatementHelp":{"#cdata":"Syntax: LOAD <MODULE=(module-list)> <matrix-list>;\n\nThe inputs to the LOAD statement are as follows: \n\nmodule-list \nis a list of modules. \n\nmatrix-list \nis a list of matrices. \n\nThe LOAD statement loads modules or matrix values from the current library storage \ninto the current workspace."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"MODULE=","StatementOptionHelp":{"#cdata":"[Syntax: MODULE=(module-list)] \n          \nLoads modules."},"StatementOptionType":"V"},{"StatementOptionName":"_ALL_","StatementOptionHelp":{"#cdata":"Loads all matrices or all modules."},"StatementOptionType":"S"}]}},{"StatementName":"MATTRIB","StatementHelp":{"#cdata":"Syntax: MATTRIB name <ROWNAME=row-name>\n           <COLNAME=column-name> <LABEL=label> <FORMAT=format>;\n\nThe inputs to the MATTRIB subroutine are as follows: \n\n  name \n  is a character matrix or quoted literal giving the name of a matrix. \n\n  row-name \n  is a character matrix or quoted literal specifying row names. \n\n  column-name \n  is a character matrix or quoted literal specifying column names. \n\n  label \n  is a character matrix or quoted literal associating a label with the matrix. The \n  label argument has a maximum length of 256 characters. \n\n  format \n  is a valid SAS format. \n  The MATTRIB statement associates printing attributes with matrices. Each matrix \n  can be associated with a ROWNAME= matrix and a COLNAME= matrix, which is used \n  whenever the matrix is printed to label the rows and columns, respectively. The \n  statement is written as the keyword MATTRIB followed by a list of one or more \n  names and attribute associations. It is not necessary to specify all attributes. \n  The attribute associations are applied to the previous name."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ROWNAME=","StatementOptionHelp":{"#cdata":"[Syntax: ROWNAME=row-name] \n          \nRequires a character matrix or quoted literal specifying row names."},"StatementOptionType":"V"},{"StatementOptionName":"COLNAME=","StatementOptionHelp":{"#cdata":"[Syntax: COLNAME=column-name] \n          \nRequires a character matrix or quoted literal specifying column names."},"StatementOptionType":"V"},{"StatementOptionName":"LABEL=","StatementOptionHelp":{"#cdata":"[Syntax: LABEL=label] \n          \nRequires a character matrix or quoted literal associating a label with the matrix. The label \nargument has a maximum length of 256 characters."},"StatementOptionType":"V"},{"StatementOptionName":"FORMAT=","StatementOptionHelp":{"#cdata":"[Syntax: FORMAT=format] \n          \nSpecifies a valid SAS format."},"StatementOptionType":"V"}]}},{"StatementName":"PRINT","StatementHelp":{"#cdata":"Syntax: PRINT <matrices> <(expression)> <\"message\">\n  <pointer-controls> <[options]>;\n\nThe inputs to the PRINT statement are as follows: \n\n  matrices \n  are the names of matrices. \n\n  (expression) \n  is an expression in parentheses that is evaluated. The result of the evaluation is printed. \n  The evaluation of a subscripted matrix used as an expression results in printing the submatrix. \n\n  \"message\" \n  is a message in quotes. \n\n  pointer-controls \n  control the pointer for printing. For example, using a comma (,) skips a single line and \n  using a slash (/) skips to a new page. \n\n  [options] \n  specified in brackets after the matrix name to which they apply.  \n\nThe PRINT statement prints the specified matrices or message."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"COLNAME=","#comment":{},"StatementOptionType":"V"},{"StatementOptionName":"LABEL=","#comment":{},"StatementOptionType":"V"},{"StatementOptionName":"FORMAT=","#comment":{},"StatementOptionType":"V"}]}},{"StatementName":"PURGE","StatementHelp":{"#cdata":"Syntax: PURGE; \n      \nThe PURGE data processing statement is used to remove observations marked for deletion \nand to renumber the remaining observations. This closes the gaps created by deleted \nrecords. Execution of this statement can be time-consuming because it involves rewriting \nthe entire data set. \n\nCAUTION: Any indexes associated with the data set are lost after a purge. \n\nIML does not do an automatic purge for you at quit time."},"StatementOptions":null},{"StatementName":"PUT","StatementHelp":{"#cdata":"Syntax: PUT <operand> <record-directives> <positionals> <format>;\n\nThe inputs to the PUT statement are as follows: \n\noperand \nspecifies the value you want to output to the current position in the record. The operand can \nbe either a variable name, a literal value, or an expression in parentheses. The operand can be \nfollowed immediately by an output format specification. \n\nrecord-directives \nstart new records. There are three types: \n  holding @ \n  at the end of a PUT statement, instructs IML to put a hold on the current record so that IML \n  can write more to the record with later PUT statements. Otherwise, IML automatically begins the \n  next record for the next PUT statement. \n\n  / --  writes out the current record and begins forming a new record. \n  > operand -- specifies that the next record written will start at the indicated byte position \n    in the file (for RECFM=N files only). The operand is a literal number, a variable name, or an \n    expression in parentheses.\n\npositionals \nspecify the column on the record to which the PUT statement should go. There are two types \nof positionals: \n\n  @ operand \n  specifies to go to the indicated column, where operand is a literal number, a variable name, \n  or an expression in parentheses. For example, @30 means to go to column 30. \n\n  + operand \n  specifies that the indicated number of columns are to be skipped, where operand is a literal \n  number, a variable name, or an expression in parentheses. \n\nformat \nspecifies a valid SAS or user-defined output format. These are of the form w.d or $w. for \nstandard numeric and character formats, respectively, where w is the width of the field \nand d is the decimal parameter, if any. They can also be a named format of the form NAME, \nwhere NAME is the name of the format. If the width is unspecified, then a default width \nis used; this is 9 for numeric variables. \n\nThe PUT statement writes to the file specified \nin the previously executed FILE statement, putting the values from IML variables."},"StatementOptions":null},{"StatementName":"READ","StatementHelp":{"#cdata":"Syntax: READ <range> <VAR operand> <WHERE(expression)>\n  <INTO name <[ROWNAME=row-name\n  COLNAME=column-name]> ;\n\nThe inputs to the READ function are as follows: \nrange -- specifies a range of observations. \n\n  operand -- selects a set of variables. \n\n  expression -- is evaluated for being true or false. \n\n  name -- is the name of the target matrix. \n\n  row-name -- is a character matrix or quoted literal giving descriptive row labels. \n\n  column-name \n  is a character matrix or quoted literal giving descriptive column labels. \n  The clauses and options are explained in the following lists. \n\nUse the READ statement to read variables or records from the current SAS data set into \ncolumn matrices of the VAR clause or into the single matrix of the INTO clause. When the \nINTO clause is used, each variable in the VAR clause becomes a column of the target matrix, \nand all variables in the VAR clause must be of the same type. If you specify no VAR clause, \nthe default variables for the INTO clause are all numeric variables. Read all character \nvariables into a target matrix by using VAR _CHAR_."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"VAR","StatementOptionHelp":{"#cdata":"Specifies a set of variables. \n          \nYou can specify a set of variables to use with the VAR clause. The operand in the \nVAR clause can be one of the following: \n\n  o a literal containing variable names \n  o the name of a matrix containing variable names \n  o an expression in parentheses yielding variable names \n  o one of keywords described in the following list: \n  \n    _ALL_ \n    for all variables \n\n    _CHAR_ \n    for all character variables \n\n    _NUM_ \n    for all numeric variables."},"StatementOptionType":"S"},{"StatementOptionName":"WHERE","StatementOptionHelp":{"#cdata":"[Syntax: WHERE(variable comparison-op operand)] \n \nwhere:\n\nvariable -- is a variable in the SAS data set. \ncomparison-op -- is one of the several comparison operators (<, <=, =, >, >=, ^=, ?, etc.)\n\nThe WHERE clause conditionally selects observations, within the range specification, \naccording to conditions given in the clause."},"StatementOptionType":"S"},{"StatementOptionName":"ALL","StatementOptionHelp":{"#cdata":"[range] \n          \nSpecifies all observations."},"StatementOptionType":"S"},{"StatementOptionName":"CURRENT","StatementOptionHelp":{"#cdata":"[range] \n          \nSpecifies the current observation (this is the default for the LIST statement)."},"StatementOptionType":"S"},{"StatementOptionName":"NEXT","StatementOptionHelp":{"#cdata":"[range][Syntax: NEXT <number>] \n          \nSpecifies the next observation or the next number of observations."},"StatementOptionType":"S"},{"StatementOptionName":"AFTER","StatementOptionHelp":{"#cdata":"[range] \n          \nSpecifies all observations after the current one."},"StatementOptionType":"S"},{"StatementOptionName":"POINT","StatementOptionHelp":{"#cdata":"[range][Syntax: POINT operand] \n          \nspecifies observations by number, where operand can one of the following: \n\nOperand   \n  o a single record number (Example: point 5)\n  o a literal giving several point record numbers (Example: {2 5 10})   \n  o the name of a matrix containing record numbers (Example: point p)   \n  o an expression in parentheses (Example: point (p+1)\n  \nIf the current data set has an index in use, the POINT option is invalid."},"StatementOptionType":"S"},{"StatementOptionName":"_ALL_","StatementOptionHelp":{"#cdata":"For all variables"},"StatementOptionType":"S"},{"StatementOptionName":"_CHAR_","StatementOptionHelp":{"#cdata":"For all character variables"},"StatementOptionType":"S"},{"StatementOptionName":"_NUM_","StatementOptionHelp":{"#cdata":"For all numeric variables"},"StatementOptionType":"S"}]}},{"StatementName":"REMOVE","StatementHelp":{"#cdata":"Syntax: REMOVE <MODULE=(module-list) <matrix-list>;\n\nThe inputs to the REMOVE statement are as follows: \n\n  module-list \n  specifies a module or modules to remove from storage. \n\n  matrix-list \n  specifies a matrix or matrices to remove from storage. \n  \nThe REMOVE statement removes matrices or modules or both from the current \nlibrary storage."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"MODULE=","StatementOptionHelp":{"#cdata":"[Syntax: MODULE=(module-list)] \n          \nRemoves modules."},"StatementOptionType":"V"},{"StatementOptionName":"_ALL_","StatementOptionHelp":{"#cdata":"Removes all matrices or all modules."},"StatementOptionType":"S"}]}},{"StatementName":"REPLACE","StatementHelp":{"#cdata":"Syntax: REPLACE <range> <VAR operand> <WHERE(expression)>;\n\nThe inputs to the REPLACE statement are as follows: \n\n  range \n  specifies a range of observations \n\n  operand \n  selects a set of variables \n\n  expression \n  is evaluated for being true or false \n\nThe REPLACE statement replaces the values of observations in a SAS data set with current \nvalues of IML matrices with the same name. Use the range, VAR, and WHERE arguments to \nlimit replacement to specific variables and observations. Replacement matrices should be \nthe same type as the data set variables. The REPLACE statement uses matrix elements in row \norder replacing the value in the ith observation with the ith matrix element. If there are \nmore observations in range than matrix elements, the REPLACE statement continues to use \nthe last matrix element."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"VAR","StatementOptionHelp":{"#cdata":"Specifies a set of variables. \n          \nYou can specify a set of variables to use with the VAR clause. The operand in the \nVAR clause can be one of the following: \n\n  o a literal containing variable names \n  o the name of a matrix containing variable names \n  o an expression in parentheses yielding variable names \n  o one of keywords described in the following list: \n  \n    _ALL_ \n    for all variables \n\n    _CHAR_ \n    for all character variables \n\n    _NUM_ \n    for all numeric variables."},"StatementOptionType":"S"},{"StatementOptionName":"WHERE","StatementOptionHelp":{"#cdata":"[Syntax: WHERE(expression)] \n          \nThe WHERE clause conditionally selects observations that are contained within the range \nspecification. The general form of the WHERE clause is \n\n  WHERE(variable comparison-op operand) \n \nwhere:\n\nvariable -- is a variable in the SAS data set. \ncomparison-op -- is one of the several comparison operators (<, <=, =, >, >=, ^=, ?, etc.)"},"StatementOptionType":"S"},{"StatementOptionName":"ALL","StatementOptionHelp":{"#cdata":"[range] \n          \nSpecifies all observations."},"StatementOptionType":"S"},{"StatementOptionName":"CURRENT","StatementOptionHelp":{"#cdata":"[range] \n          \nSpecifies the current observation (this is the default for the LIST statement)."},"StatementOptionType":"S"},{"StatementOptionName":"NEXT","StatementOptionHelp":{"#cdata":"[range][Syntax: NEXT <number>] \n          \nSpecifies the next observation or the next number of observations."},"StatementOptionType":"S"},{"StatementOptionName":"AFTER","StatementOptionHelp":{"#cdata":"[range] \n          \nSpecifies all observations after the current one."},"StatementOptionType":"S"},{"StatementOptionName":"POINT","StatementOptionHelp":{"#cdata":"[range][Syntax: POINT operand] \n          \nSpecifies observations by number, where operand is one of the following: \n\nOperand   \n  o a single record number (Example: point 5)\n  o a literal giving several point record numbers (Example: {2 5 10})   \n  o the name of a matrix containing record numbers (Example: point p)   \n  o an expression in parentheses (Example: point (p+1)\n  \nIf the current data set has an index in use, the POINT option is invalid."},"StatementOptionType":"S"}]}},{"StatementName":"SETIN","StatementHelp":{"#cdata":"Syntax: SETIN SAS-data-set <NOBS name> <POINT operand>;\n\nThe inputs to the SETIN statement are as follows: \n\n  SAS-data-set \n  can be specified with a one-level name (for example, A) or a two-level name (for example, \n  SASUSER.A). \n\n  name \n  is the name of a variable to contain the number of observations in the data set. \n\n  operand \n  specifies the current observation. \n  \nThe SETIN statement chooses the specified data set from among the data sets already opened \nfor input by the EDIT or USE statement. This data set becomes the current input data set for \nsubsequent data management statements. The NOBS option is not required. If specified, the NOBS \noption returns the number of observations in the data set in the scalar variable name. The POINT \noption makes the specified observation the current one. It positions the data set to a particular \nobservation. The SHOW datasets command lists data sets already opened for input."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"NOBS","StatementOptionHelp":{"#cdata":"Returns the number of observations in the data set in the scalar variable name.]"},"StatementOptionType":"S"},{"StatementOptionName":"POINT","StatementOptionHelp":{"#cdata":"Makes the specified observation the current one. It positions the data set to a particular observation."},"StatementOptionType":"S"}]}},{"StatementName":"SETOUT","StatementHelp":{"#cdata":"Syntax: SETOUT SAS-data-set <NOBS name> <POINT operand>;\n\nThe inputs to the SETOUT statement are as follows: \n\n  SAS-data-set \n  can be specified with a one-level name (for example, A) or a two-level name (for example, \n  SASUSER.A). \n\n  name \n  is the name of a variable to contain the number of observations in the data set \n\n  operand \n  specifies the observation to be made the current observation. \n   \nThe SETOUT statement chooses the specified data set from among those data sets already \nopened for output by the EDIT or CREATE statement. This data set becomes the current \noutput data set for subsequent data management statements. If specified, the NOBS option \nreturns the number of observations currently in the data set in the scalar variable name. \nThe POINT option makes the specified observation the current one."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"NOBS","StatementOptionHelp":{"#cdata":"Syntax: NOBS name \n          \nReturns the number of observations currently in the data set in the scalar \nvariable name.]"},"StatementOptionType":"S"},{"StatementOptionName":"POINT","StatementOptionHelp":{"#cdata":"Syntax: POINT operand \n          \nMakes the specified observation the current one."},"StatementOptionType":"S"}]}},{"StatementName":"SORT","StatementHelp":{"#cdata":"Syntax: SORT <DATA=>SAS-data-set <OUT=SAS-data-set>\n  BY <DESCENDING> variables;\n\nThe SORT statement sorts the observations in a SAS data set by one or more variables, \nstores the resulting sorted observations in a new SAS data set, or replaces the original. \nAs opposed to all other IML data processing statements, it is mandatory that the data set \nto be sorted be closed prior to the execution of the SORT statement."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"DATA=","StatementOptionHelp":{"#cdata":"[Syntax: DATA=SAS-data-set] \n          \nNames the SAS data set to be sorted. It can be specified with a one-level name \n(for example, A) or a two-level name (for example, SASUSER.A)."},"StatementOptionType":"DV"},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"[Syntax: OUT=SAS-data-set] \n          \nSpecifies a name for the output data set. If this clause is omitted, the DATA= data set \nis sorted and the sorted version replaces the original data set."},"StatementOptionType":"DV"},{"StatementOptionName":"BY","StatementOptionHelp":{"#cdata":"[Syntax: BY variables] \n          \nSpecifies the variables to be sorted. A BY clause must be used with the SORT statement."},"StatementOptionType":"V"},{"StatementOptionName":"DESCENDING","StatementOptionHelp":{"#cdata":"Specifies the variables are to be sorted in descending order."},"StatementOptionType":"V"}]}},{"StatementName":"STORE","StatementHelp":{"#cdata":"Syntax: STORE <MODULE=(module-list)> <matrix-list>;\n\nThe inputs to the STORE statement are as follows. \n\n  module-list \n  is a list of module names. \n\n  matrix-list \n  is a list of matrix names. \n  \nThe STORE statement stores matrices or modules in the storage library."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"MODULE=","StatementOptionHelp":{"#cdata":"[Syntax: MODULE=(module-list)] \n          \nStores modules. module-list is a list of module names."},"StatementOptionType":"V"},{"StatementOptionName":"_ALL_","StatementOptionHelp":{"#cdata":"Stores all matrices or all modules."},"StatementOptionType":"S"}]}},{"StatementName":"SUMMARY","StatementHelp":{"#cdata":"Syntax: SUMMARY <CLASS operand> <VAR operand> <WEIGHT operand>\n  <STAT operand> <OPT operand> <WHERE(expression)>;\n\nwhere the operands used by most clauses take either a matrix name, a matrix literal, \nor an expression yielding a matrix name or value. \n\nThe SUMMARY statement computes statistics for numeric variables for an entire data set or \na subset of observations in the data set. The statistics can be stratified by the use of \nCLASS variables. The computed statistics are displayed in tabular form and optionally can \nbe saved in matrices. Like most other IML data processing statements, the SUMMARY statement \nworks on the current data set."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"CLASS","StatementOptionHelp":{"#cdata":"[Syntax: CLASS operand] \n          \nSpecifies the variables in the current input SAS data set to be used to group the \nsummaries. The operand is a character matrix containing the names of the variables."},"StatementOptionType":"S"},{"StatementOptionName":"VAR","StatementOptionHelp":{"#cdata":"[Syntax: VAR operand] \n          \nCalculates statistics for a set of numeric variables from the current input data set. \nThe operand is a character matrix containing the names of the variables. Also, the special \nkeyword _NUM_ can be used as a VAR operand to specify all numeric variables. If the VAR \nclause is missing, the SUMMARY statement produces only the number of observations in each \nclass group."},"StatementOptionType":"S"},{"StatementOptionName":"WEIGHT","StatementOptionHelp":{"#cdata":"[Syntax: WEIGHT operand] \n          \nSpecifies a character value containing the name of a numeric variable in the current \ndata set whose values are to be used to weight each observation. Only one variable can \nbe specified."},"StatementOptionType":"S"},{"StatementOptionName":"STAT","StatementOptionHelp":{"#cdata":"[Syntax: STAT operand] \n          \nComputes the statistics specified. The operand is a character matrix containing the names \nof statistics."},"StatementOptionType":"S"},{"StatementOptionName":"OPT","StatementOptionHelp":{"#cdata":"[Syntax: OPT operand] \n          \nSets the PRINT or NOPRINT and SAVE or NOSAVE options. The NOPRINT option suppresses the \nprinting of the results from the SUMMARY statement. The SAVE option requests that the \nSUMMARY statement save the resultant statistics in matrices. The operand is a character \nmatrix containing one or more of the options."},"StatementOptionType":"S"},{"StatementOptionName":"WHERE","StatementOptionHelp":{"#cdata":"[Syntax: WHERE(variable comparison-op operand)] \n          \nConditionally selects observations, within the range specification, according to \nconditions given in expression."},"StatementOptionType":"S"}]}},{"StatementName":"USE","StatementHelp":{"#cdata":"Syntax: USE SAS-data-set <VAR operand> <WHERE(expression)> <NOBS name>;\n\nThe inputs to the USE statement are as follows: \n\nSAS-data-set \ncan be specified with a one-level name (for example, A) or a two-level name (for example, \nSASUSER.A). For more information about specifying SAS data sets, see the chapter on SAS \ndata sets in SAS Language Reference: Concepts. \n\n  operand \n  selects a set of variables. \n\n  expression \n  is evaluated for being true or false. \n\n  name \n  is the name of a variable to contain the number of observations. \n  \nIf the data set has not already been opened, the USE statement opens the data set for \nread access. The USE statement also makes the data set the current input data set so \nthat subsequent statements act on it. The USE statement optionally can define selection \ncriteria that are used to control access."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"VAR","StatementOptionHelp":{"#cdata":"[Syntax: VAR operand\n          \nThe VAR clause specifies a set of variables to use, where operand can be \nspecified as one of the following: \n\n  o a literal containing variable names \n  o a character matrix containing variable names \n  o an expression in parentheses yielding variable names \n  o one of the keywords described in the following list: \n  \n    _ALL_ -- for all variables \n    _CHAR_ -- for all character variables \n    _NUM_ -- for all numeric variables]"},"StatementOptionType":"S","SubOptionsKeywords":"_ALL_|_CHAR_|_NUM_"},{"StatementOptionName":"WHERE","StatementOptionHelp":{"#cdata":"[Syntax: WHERE(expression)] \n          \nThe WHERE clause conditionally selects observations, within the range specification, \naccording to conditions given in the clause. The general form of the WHERE clause is \nas follows:  \n\n  WHERE(variable comparison-op operand) \n \nwhere:\n\nvariable -- is a variable in the SAS data set. \ncomparison-op -- is one of the several comparison operators (<, <=, =, >, >=, ^=, ?, etc.)"},"StatementOptionType":"S"},{"StatementOptionName":"NOBS","StatementOptionHelp":{"#cdata":"[Syntax: NOBS name] \n          \nSpecifies the name of a variable to contain the number of observations."},"StatementOptionType":"S"},{"StatementOptionName":"_ALL_","StatementOptionHelp":{"#cdata":"For all variables"},"StatementOptionType":"S"},{"StatementOptionName":"_CHAR_","StatementOptionHelp":{"#cdata":"For all character variables"},"StatementOptionType":"S"},{"StatementOptionName":"_NUM_","StatementOptionHelp":{"#cdata":"For all numeric variables"},"StatementOptionType":"S"}]}},{"StatementName":"WINDOW","StatementHelp":{"#cdata":"Syntax: WINDOW <CLOSE=>window-name <window-options>\n  <GROUP=group-name field-specs>\n  GROUP=group-name field-specs>;\n\nwhere\n\nwindow-name \nspecifies a name 1 to 8 characters long for the window. This name is displayed in the \nupper-left border of the window. \n\nwindow-options \ncontrol the size, position, and other attributes of the window.\n\nfield-specs \nare a sequence of field specifications made up of positionals, field operands, formats, \nand options. These are described in the next section\n\nThe WINDOW statement defines a window on the display and can include a number of fields. \nThe DISPLAY statement actually writes values to the window."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"CLOSE=","StatementOptionHelp":{"#cdata":"[Syntax: CLOSE=window-name] \n          \nCloses the window."},"StatementOptionType":"V"},{"StatementOptionName":"GROUP=","StatementOptionHelp":{"#cdata":"[Syntax: GROUP=group-name] \n          \nStarts a repeating sequence of groups of fields defined for the window. The group-name \nspecification is a name 1 to 8 characters long used to identify a group of fields in a \nlater DISPLAY statement."},"StatementOptionType":"V"},{"StatementOptionName":"CMNDLINE=","StatementOptionHelp":{"#cdata":"[Syntax: CMNDLINE=name] \n          \nSpecifies the name of a variable in which the command line entered by the user \nwill be stored."},"StatementOptionType":"V"},{"StatementOptionName":"COLOR=","StatementOptionHelp":{"#cdata":"Syntax: COLOR=operand"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"WHITE","@Value2":"BLACK","@Value3":"GREEN","@Value4":"MAGENTA","@Value5":"RED","@Value6":"YELLOW","@Value7":"CYAN","@Value8":"GRAY","@Value9":"BLUE"},"StatementOptionToolTips":{"@ToolTip1":"WHITE background color","@ToolTip2":"BLACK background color","@ToolTip3":"GREEN background color","@ToolTip4":"MAGENTA background color","@ToolTip5":"RED background color","@ToolTip6":"YELLOW background color","@ToolTip7":"CYAN background color","@ToolTip8":"GRAY background color","@ToolTip9":"BLUE background color"}},{"StatementOptionName":"COLUMNS=","StatementOptionHelp":{"#cdata":"[Syntax: COLUMNS=operand] \n          \nSpecifies the starting number of columns for the window. The operand is either \na literal number, a variable name, or an expression in parentheses. The default \nvalue is 78 columns."},"StatementOptionType":"V"},{"StatementOptionName":"ICOLUMN=","StatementOptionHelp":{"#cdata":"[Syntax: ICOLUMN=operand] \n          \nSpecifies the initial starting column position of the window on the display. The \noperand is either a literal number or a variable name. The default value is column 1."},"StatementOptionType":"V"},{"StatementOptionName":"IROW=","StatementOptionHelp":{"#cdata":"[Syntax: IROW=operand] \n          \nSpecifies the initial starting row position of the window on the display. The \noperand is either a literal number or a variable name. The default value is row 1."},"StatementOptionType":"V"},{"StatementOptionName":"MSGLINE=","StatementOptionHelp":{"#cdata":"[Syntax: MSGLINE=operand] \n          \nSpecifies the message to be displayed on the standard message line when the window \nis made active. The operand is almost always the name of a variable, but a character \nliteral can be used."},"StatementOptionType":"V"},{"StatementOptionName":"ROWS=","StatementOptionHelp":{"#cdata":"[Syntax: ROWS=operand] \n          \nDetermines the starting number of rows of the window. The operand is either a literal \nnumber, the name of a variable containing the number, or an expression in parentheses \nyielding the number. The default value is 23 rows."},"StatementOptionType":"V"},{"StatementOptionName":"PROTECT=|P=","StatementOptionType":"V"}]}},{"StatementName":"RESET","StatementHelp":{"#cdata":"Syntax: RESET <options>;\n\nThe RESET statement sets processing options. Note that the prefix NO \nturns off the feature where indicated. For options that take operands, \nthe operand should be a literal, a name of a matrix containing the value, \nor an expression in parentheses. The SHOW options statement displays the \ncurrent settings of all of the options."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"AUTONAME","StatementOptionHelp":{"#cdata":"Specifies that rows are automatically labeled ROW1, ROW2, and so on, and columns \nare labeled COL1, COL2, and so on, when a matrix is printed. Row-name and \ncolumn-name attributes specified in the PRINT statement or associated via the \nMATTRIB statement override the default labels. The AUTONAME option causes the \nSPACES option to be reset to 4."},"StatementOptionType":"S"},{"StatementOptionName":"NOAUTONAME","StatementOptionHelp":{"#cdata":"Specifies that rows are not automatically labeled ROW1, ROW2, and so on, and columns \nare labeled COL1, COL2, and so on, when a matrix is printed."},"StatementOptionType":"S"},{"StatementOptionName":"CENTER","StatementOptionHelp":{"#cdata":"Specifies that output from the PRINT statement is centered on the page. The default \nis CENTER. This resets the global CENTER/NOCENTER option for the SAS session."},"StatementOptionType":"S"},{"StatementOptionName":"NOCENTER","StatementOptionHelp":{"#cdata":"Specifies that output from the PRINT statement is not centered on the page. The \ndefault is CENTER. This resets the global CENTER/NOCENTER option for the SAS \nsession."},"StatementOptionType":"S"},{"StatementOptionName":"CLIP","StatementOptionHelp":{"#cdata":"Specifies that SAS/IML graphs are automatically clipped outside the viewport; that is, \nany data falling outside the current viewport is not displayed. NOCLIP is the default."},"StatementOptionType":"S"},{"StatementOptionName":"NOCLIP","StatementOptionHelp":{"#cdata":"Specifies that SAS/IML graphs are not automatically clipped outside the viewport; that is, \nany data falling outside the current viewport is not displayed. NOCLIP is the default."},"StatementOptionType":"S"},{"StatementOptionName":"DEFLIB=","StatementOptionHelp":{"#cdata":"[Syntax: DEFLIB=operand] \n          \nSpecifies the default libname for SAS data sets when no other libname is given. \nThis defaults to USER if a USER libname is set up, or WORK if not. The libname \noperand can be specified with or without quotes."},"StatementOptionType":"V"},{"StatementOptionName":"DETAILS","StatementOptionHelp":{"#cdata":"Specifies that additional information is printed from a variety of operations, \nsuch as when files are opened and closed."},"StatementOptionType":"S"},{"StatementOptionName":"NODETAILS","StatementOptionHelp":{"#cdata":"Specifies that no additional information is printed from a variety of operations, \nsuch as when files are opened and closed."},"StatementOptionType":"S"},{"StatementOptionName":"FLOW","StatementOptionHelp":{"#cdata":"Specifies that operations are shown as executed. It is used for debugging only. \nThe default is NOFLOW."},"StatementOptionType":"S"},{"StatementOptionName":"NOFLOW","StatementOptionHelp":{"#cdata":"Specifies that operations are not shown as executed. It is used for debugging \nonly. The default is NOFLOW."},"StatementOptionType":"S"},{"StatementOptionName":"NOFUZZ","StatementOptionHelp":{"#cdata":"[Syntax: NOFUZZ] \n          \nSpecifies that very small numbers are printed as zero rather than in scientific notation."},"StatementOptionType":"S"},{"StatementOptionName":"FUZZ=","StatementOptionHelp":{"#cdata":"[Syntax: FUZZ<=number>] \n          \nSpecifies that very small numbers are printed in scientific notation. If the absolute \nvalue of the number is less than the value specified in number, it will be printed as \n0. The number argument is optional, and the default value varies across hosts but is \ntypically around 1E-12. The default is NOFUZZ."},"StatementOptionType":"S|V"},{"StatementOptionName":"FW=","StatementOptionHelp":{"#cdata":"[Syntax: FW=number] \n          \nSets the field width for printing numeric values. The default field width is 9."},"StatementOptionType":"V"},{"StatementOptionName":"LINESIZE=","StatementOptionHelp":{"#cdata":"[Syntax: LINESIZE=n] \n          \nSpecifies the linesize for printing. The default value is usually 78. This resets \nthe global LINESIZE option for the SAS session."},"StatementOptionType":"V"},{"StatementOptionName":"LOG","StatementOptionHelp":{"#cdata":"Specifies that output is routed to the log file rather than to the print file. \nOn the log, the results are interleaved with the statements and messages. \n\nThe default is NOLOG."},"StatementOptionType":"S"},{"StatementOptionName":"NOLOG","StatementOptionHelp":{"#cdata":"Routes output to the OUTPUT window in the SAS windowing environment and to the \nlisting file in batch mode. The default is NOLOG."},"StatementOptionType":"S"},{"StatementOptionName":"PRINTADV=","StatementOptionHelp":{"#cdata":"[Syntax: PRINTADV=n] \n          \nInserts blank lines into the log before printing out the value of a matrix. The \ndefault, PRINTADV=2, causes two blank lines to be inserted."},"StatementOptionType":"S"},{"StatementOptionName":"PRINTALL","StatementOptionHelp":{"#cdata":"Specifies that the intermediate and final results are printed automatically. \nThe default is NOPRINTALL."},"StatementOptionType":"S"},{"StatementOptionName":"NOPRINTALL","StatementOptionHelp":{"#cdata":"Specifies that the intermediate and final results are not printed automatically. \nThis is the default."},"StatementOptionType":"S"},{"StatementOptionName":"SPACES=","StatementOptionHelp":{"#cdata":"[Syntax: SPACES=n] \n          \nSpecifies the number of spaces between adjacent matrices printed across the page. \nThe default value is 1, except when AUTONAME is on. Then, the default value is 4."},"StatementOptionType":"S"},{"StatementOptionName":"STORAGE=","StatementOptionHelp":{"#cdata":"[Syntax: STORAGE=<libname.>memname;] \n          \nSpecifies the file to be the current library storage for STORE and LOAD statements. \nThe default library storage is WORK.IMLSTOR. The libname argument is optional and \ndefaults to SASUSER. It can be specified with or without quotes."},"StatementOptionType":"DV"}]}},{"StatementName":"SHOW","StatementHelp":{"#cdata":"Syntax: SHOW operands;\n\nThe SHOW statement prints system information."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ALL","StatementOptionHelp":{"#cdata":"Shows all the information included by OPTIONS, SPACE, DATASETS, FILES, and MODULES."},"StatementOptionType":"S"},{"StatementOptionName":"ALLNAMES","StatementOptionHelp":{"#cdata":"Behaves like NAMES, but also shows names without values."},"StatementOptionType":"S"},{"StatementOptionName":"CONTENTS","StatementOptionHelp":{"#cdata":"Shows the names and attributes of the variables in the current SAS data set."},"StatementOptionType":"S"},{"StatementOptionName":"DATASETS","StatementOptionHelp":{"#cdata":"shows all open SAS data sets."},"StatementOptionType":"S"},{"StatementOptionName":"FILES","StatementOptionHelp":{"#cdata":"Shows all open files."},"StatementOptionType":"S"},{"StatementOptionName":"MEMORY","StatementOptionHelp":{"#cdata":"Returns the size of the largest chunk of main memory available."},"StatementOptionType":"S"},{"StatementOptionName":"MODULES","StatementOptionHelp":{"#cdata":"Shows all modules that exist in the current IML environment. A module already referenced but not yet defined is listed as undefined."},"StatementOptionType":"S"},{"StatementOptionName":"NAMES","StatementOptionHelp":{"#cdata":"Shows attributes of all matrices having values. Attributes include number of rows, number of columns, data type, and size."},"StatementOptionType":"S"},{"StatementOptionName":"OPTIONS","StatementOptionHelp":{"#cdata":"shows current settings of all IML options."},"StatementOptionType":"S"},{"StatementOptionName":"PAUSE","StatementOptionHelp":{"#cdata":"Shows the status of all paused modules that are pending resume."},"StatementOptionType":"S"},{"StatementOptionName":"SPACE","StatementOptionHelp":{"#cdata":"Shows the workspace and symbolspace size and their current usage."},"StatementOptionType":"S"},{"StatementOptionName":"STORAGE","StatementOptionHelp":{"#cdata":"Shows the modules and matrices in the current IML library storage."},"StatementOptionType":"S"},{"StatementOptionName":"WINDOWS","StatementOptionHelp":{"#cdata":"Shows all active windows opened by WINDOW statements."},"StatementOptionType":"S"}]}},{"StatementName":"INFILE","StatementHelp":{"#cdata":"Syntax: INFILE operand <options>;\n\nThe inputs to the INFILE statement are as follows: \n\n  operand \n  is either a predefined filename or a quoted string containing the filename or character \n  expression in parentheses referring to the pathname. \n\n  options \n  options available for the INFILE statement.\n\nYou can use the INFILE statement to open an external file for input or, if the file \nis already open, to make it the current input file so that subsequent INPUT statements \nread from it."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"LENGTH=","StatementOptionHelp":{"#cdata":"[Syntax: LENGTH=variable] \n          \nSpecifies a variable in which the length of a record is stored as IML reads it in."},"StatementOptionType":"V"},{"StatementOptionName":"RECFM=","StatementOptionHelp":{"#cdata":"[Syntax: RECFM=N] \n          \nSpecifies that the file is to be read in as a pure binary file rather than as a file \nwith record separator characters. To do this, you must use the byte operand (<) in the \nINPUT statement to get new records rather than use separate input statements or the \nnew line (/) operator."},"StatementOptionType":"V"},{"StatementOptionName":"FLOWOVER","StatementOptionHelp":{"#cdata":"Enables the INPUT statement to go to the next record to obtain values for the variables."},"StatementOptionType":"S"},{"StatementOptionName":"MISSOVER","StatementOptionHelp":{"#cdata":"Tolerates attempted reading past the end of the record by assigning missing values \nto variables read past the end of the record."},"StatementOptionType":"V"},{"StatementOptionName":"STOPOVER","StatementOptionHelp":{"#cdata":"Treats going past the end of a record as an error condition, which triggers an end-of-file condition."},"StatementOptionType":"V"}]}},{"StatementName":"CALL","StatementHelp":{"#cdata":"Syntax: CALL name <(arguments)> ;\n     \nThe inputs to the CALL statement are as follows: \n\n  name \n  is the name of a user-defined module or an IML subroutine or function. \n\n  arguments \n  are arguments to the module or subroutine. \n\nThe CALL statement executes a subroutine. The order of resolution for the CALL statement \nis as follows: \n\n  1.IML built-in subroutine \n  2. user-defined module \n  \nThis resolution order needs to be considered only if you have defined a module with the \nsame name as an IML built-in subroutine. "},"StatementOptions":null},{"StatementName":"EDIT","StatementHelp":{"#cdata":"Syntax: EDIT SAS-data-set <VAR operand> <WHERE(expression)>\n    <NOBS name>;\n\nThe inputs to the EDIT statement are as follows: \nSAS-data-set \ncan be specified with a one-level name (for example, A) or a two-level name\n(for example, SASUSER.A). For more information about specifying SAS data sets,\nrefer to the chapter on SAS data sets in SAS Language Reference: Concepts. \n\n\noperand \nselects a set of variables. \n\n\nexpression \nselects observations conditionally. \n\n\nname \nnames a variable to contain the number of observations. \nThe EDIT statement opens a SAS data set for reading and updating. If the data\nset has already been opened, the EDIT statement makes it the current input and\noutput data sets. "},"StatementOptions":{"StatementOption":[{"StatementOptionName":"VAR","StatementOptionHelp":{"#cdata":"Selects a set of variables."},"StatementOptionType":"S"},{"StatementOptionName":"NOBS","StatementOptionHelp":{"#cdata":"Names a variable to contain the number of observations."},"StatementOptionType":"S"}]}},{"StatementName":"PACKAGE HELP","StatementHelp":{"#cdata":"Syntax: PACKAGE HELP packagename<(collection )>; \n\nThe PACKAGE HELP statement is experimental in SAS/IML 14.1. If an installed package provides \ndocumentation, the PACKAGE HELP statement displays the documentation. The documentation often \nincludes the syntax and purpose of the SAS/IML modules that the package defines.\n\nYou must specify the following argument: \npackagename \n  specifies the name of the package. \n\nYou can also specify the following option in parentheses: \ncollection \n  requests that only the specified collection be searched. Valid values for collection \n  are PRIVATE, PUBLIC, and SYSTEM."},"StatementOptions":null},{"StatementName":"PACKAGE INFO","StatementHelp":{"#cdata":"Syntax: PACKAGE INFO packagename<(collection )> \u2026; \n\nThe PACKAGE INFO statement is experimental in SAS/IML 14.1. The PACKAGE INFO statement displays \ninformation about one or more installed packages. \n\nYou must specify the following argument: \npackagename \n  specifies the name of the package. You can specify multiple names in a single statement. \n\nYou can also specify the following option in parentheses: \ncollection \n  requests that only the specified collection be searched. Valid values for collection are \n  PRIVATE, PUBLIC, and SYSTEM."},"StatementOptions":null},{"StatementName":"PACKAGE INSTALL","StatementHelp":{"#cdata":"Syntax: PACKAGE INSTALL \"fullname\"<(collection <PARSETIME> )> \u2026; \n\nPACKAGE INSTALL fileref<(collection <PARSETIME> )> \u2026; \n\nThe PACKAGE INSTALL statement is experimental in SAS/IML 14.1. Packages are distributed as ZIP files. \nThe PACKAGE INSTALL statement unzips the ZIP file and installs the package in a predetermined location. \n\nYou can specify the package to be installed in two ways: \n\"fullname\" \n  specifies the ZIP file\u2019s fully qualified name (which includes both the path and the filename) \n  in quotation marks. You can specify multiple names in a single statement. \nfileref \n  specifies a file reference that was previously created by the FILENAME statement. \n\nYou can also specify the following options in parentheses: \ncollection \n  specifies the collection into which the package is to be installed. You can specify PUBLIC or \n  PRIVATE; you cannot install a package in the SYSTEM collection. By default, the package is \n  installed in the PRIVATE collection. At some sites, you might need administrative privileges \n  in order to install a package in the PUBLIC collection. \nPARSETIME \n  requests that the package be installed at parse time, rather than at run time. This option \n  applies only to IMLPLUS programs in the SAS/IML Studio environment."},"StatementOptions":{"StatementOption":{"StatementOptionName":"PARSETIME"}}},{"StatementName":"PACKAGE LIBNAME","StatementHelp":{"#cdata":"Syntax: PACKAGE LIBNAME libref packagename; \n\nThe PACKAGE LIBNAME statement is experimental in SAS/IML 14.1. The PACKAGE LIBNAME statement creates \na SAS libref that points to the data directory for a package. You must load a package before you can \nuse the PACKAGE LIBNAME statement. \n\nYou must specify the following arguments: \nlibref \n  specifies the name of a SAS libref to be created. \npackagename \n  specifies the name of the package."},"StatementOptions":null},{"StatementName":"PACKAGE LIST","StatementHelp":{"#cdata":"Syntax: PACKAGE LIST <collection> ; \n\nThe PACKAGE LIST statement is experimental in SAS/IML 14.1. The PACKAGE LIST statement lists the packages \nthat are installed in the specified collection (or in all collections if a collection is not specified). \n\nYou can specify the following option: \ncollection \n  requests that only packages in the specified collection be listed. Valid values for collection are PRIVATE, \n  PUBLIC, and SYSTEM. By default, the PACKAGE LIST statement lists packages in all collections."},"StatementOptions":null},{"StatementName":"PACKAGE LOAD","StatementHelp":{"#cdata":"Syntax: PACKAGE LOAD packagename<(collection <VERSION=version> )> \u2026; \n\nThe PACKAGE LOAD statement is experimental in SAS/IML 14.1. The PACKAGE LOAD statement executes the package \nsource files. Usually the source files define SAS/IML modules. However, a package might also define SAS/IML \nmatrices, create data sets, define macro variables, or carry out a computation. \n\nYou must specify the following argument: \npackagename \n  specifies the name of the package. You can specify multiple names in a single statement. \n\nYou can also specify the following options in parentheses: \ncollection \n  requests that only the specified collection be searched for the file to be executed. Valid values for collection \n  are PRIVATE, PUBLIC, and SYSTEM. For more information about collections, see the PACKAGE statement . \nVERSION=version \n  specifies the minimum required version number for loading a package. A version number is a text string \n  that contains up to four numbers that are separated by decimal points. For example, valid values are \"1.0\", \n  \"2.7.1\", and \"3.1.4.1\". When the PACKAGE LOAD statement finds a specified package, it checks the package \n  version. If the package version is greater than or equal to version, the package is loaded. Otherwise, \n  the statement displays an error message."},"StatementOptions":{"StatementOption":{"StatementOptionName":"VERSION="}}},{"StatementName":"PACKAGE UNINSTALL","StatementHelp":{"#cdata":"Syntax: PACKAGE UNINSTALL packagename<(collection <NOWARN> <PARSETIME> )> \u2026; \n\nThe PACKAGE UNINSTALL statement is experimental in SAS/IML 14.1. The PACKAGE UNINSTALL statement uninstalls \na package that is installed in the specified collection. \n\nYou must specify the following argument: \npackagename \n  specifies the name of the package. You can specify multiple names in a single statement. \n\nYou can also specify the following options in parentheses: \ncollection \n  requests that only the specified collection be searched for the package to uninstall. Valid values\n  for collection are PRIVATE and PUBLIC. By default, the PACKAGE UNINSTALL statement looks for the \n  package in the PRIVATE collection. If you have administrative privileges to uninstall a package in \n  the PUBLIC collection, you can specify the PUBLIC collection in parentheses after the package name. \n  You cannot uninstall a package in the SYSTEM collection. \nNOWARN \n  requests that no warning message be reported if the specified package is not installed. \nPARSETIME \n  requests that the package be installed at parse time, rather than at run time. This option applies \n  only to IMLPLUS programs in the SAS/IML Studio environment."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"NOWARN"},{"StatementOptionName":"PARSETIME"}]}},{"StatementName":"SUBMIT","StatementHelp":{"#cdata":"Syntax: SUBMIT <parameters> </ options> ; \n  language statements \nENDSUBMIT ; \n\nThe SUBMIT statement enables you to submit SAS statements for processing from within a SAS/IML program. \nYou can use the SUBMIT statement to call SAS procedures, DATA steps, and macros. All text between the \nSUBMIT statement and the ENDSUBMIT statement are referred to as a SUBMIT block. The SUBMIT block is \nprocessed by the SAS language processor."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"OK=","StatementOptionHelp":{"#cdata":"Syntax: OK=ok-matrix\n          \nSpecifies the name of a matrix. The matrix is set to\u00a01 if the SUBMIT block executes without error, \nand to\u00a00 otherwise. "},"StatementOptionType":"V"},{"StatementOptionName":"R","StatementOptionHelp":{"#cdata":"specifies that statements in the SUBMIT block are processed by the R statistical software. You can use the R option to call functions in the R language, provided that the following statements are true: \nthe R statistical software is installed on the SAS workspace server. \n\nThe SAS system administrator at your site has enabled the RLANG SAS system option."},"StatementOptionType":"S"}]}},{"StatementName":"ENDSUBMIT","StatementHelp":{"#cdata":"Syntax: ENDSUBMIT ; \n\nYou can use the ENDSUBMIT statement in conjunction with the SUBMIT statement to submit SAS statements \nfor processing from within a SAS/IML program. All statements between the SUBMIT and the ENDSUBMIT \nstatements are referred to as a SUBMIT block. The SUBMIT block is processed by the SAS language processor."},"StatementOptions":null}]}}}