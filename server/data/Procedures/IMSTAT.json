{"Procedure":{"Name":"IMSTAT","ProductGroup":"LASR ANALYTICS","ProcedureHelp":{"#cdata":"Syntax: PROC IMSTAT <options>; \n    AGGREGATE variable-name (aggregate-variable-options) / ID=variable-name< options>;\n    ARM ITEM=item-variable TRAN=transaction-variable </ options>;\n    ASSESS <variable-list> / Y=response-variable <options>; \n    BOXPLOT <variable-list> </ options>;\n    CLUSTER <variable-list> </ options>;\n    CORR <variable-list> </ options>;\n    CROSSTAB row*column </ options>;\n    DECISIONTREE target-variable </ options>;\n    DISTINCT <variable-list> </ options>;\n    FORECAST timestamp-variable </ options>;\n    FREQUENCY variable-list </ options>;\n    GENMODEL dependent-variable <(class-variables)> = model-effects </ options>;\n    GLM dependent-variable <(class-variables)> = model-effects </ options>;\n    GROUPBY <variable-list> </ options>;\n    HISTOGRAM <variable-list> </ options>;\n    HYPERGROUP <variable-list> </ options>;\n    KDE variable-list </ options>;\n    LOGISTIC dependent-variable <(class-variables)> = model-effects </ options>;\n    MDSUMMARY variable-list </ <set-specification,...> options>;\n    NEURAL <target-variable> </ options>;\n    OPTIMIZE <options>;\n    PERCENTILE <variable-list> </ options>;\n    RANDOMWOODS target-variable </ options>;\n    REGCORR <variable-list> </ options>;\n    SUMMARY <variable-list> </ options>;\n    TEXTPARSE TXT=text-variable ID=document-ID <options>;\n    TOPK <variable-list> </ options>;\n    TRANSFORM (request1) <(request2) ...> </ options>;\n    \nThe analytic statements of the IMSTAT procedure are used to perform in-memory analytics \nwith a SAS LASR Analytic Server. All analyses are performed on in-memory tables."},"ProcedureOptions":{"ProcedureOption":[{"ProcedureOptionName":"BATCHMODE|BATCH","ProcedureOptionHelp":{"#cdata":"Syntax: BATCHMODE\n\nBy default, the IMSTAT procedure operates in interactive mode. If your program contains errors that \nprevent SAS from parsing or executing statements, the errors are reported in the SAS log, but they \ndo not stop the procedure. If the errors are fatal errors such as running out of memory on the SAS \nclient, the procedure stops. \n\nIn contrast, when the BATCHMODE option is specified in the PROC IMSTAT statement, the procedure \nbehaves with respect to error handling as if it were not an interactive procedure. Whenever an \nerror occurs, the procedure terminates and sets the SYSERR macro variable."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"DATA=","ProcedureOptionHelp":{"#cdata":"Syntax: DATA=libref.member-name\n\nSpecifies the table to access from memory. The libref must be assigned from a SAS LASR Analytic Server \nengine LIBNAME statement."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"FMTLIBXML=","ProcedureOptionHelp":{"#cdata":"Syntax: FMTLIBXML=file-reference\n\nSpecifies the file reference for a format stream. For more information, see  FMTLIBXML \nin the LASR procedure."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"IMMEDIATE|SINGLESTEP","ProcedureOptionHelp":{"#cdata":"Syntax: IMMEDIATE\n\nSpecifies that the procedure executes one statement at a time rather than accumulating \nstatements in RUN blocks."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"NODATE","ProcedureOptionHelp":{"#cdata":"Syntax: NODATE\n\nSpecifies to suppress the display of time and date-dependent information in results \nfrom the TABLEINFO statement."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"NOPREPARSE|NOPREP","ProcedureOptionHelp":{"#cdata":"Syntax: NOPREPARSE\n\nPrevents the procedure from preparsing and pregenerating code for temporary expressions, \nscoring programs, and other user-written SAS statements. \n\nWhen this option is specified, the user-written statements are sent to the server \"as is\" \nand then the server attempts to generate code from it. If the server detects problems with \nthe code, the error messages might not to be as detailed as the messages that are generated \nby SAS client. If you are debugging your user-written program, then you might want to preparse \nand pregenerate code in the procedure. However, if your SAS statements compile and run as you \nwant them to, then you can specify this option to avoid the work of parsing and generating code \non the SAS client. \n\nWhen you specify this option in the PROC IMSTAT statement, the option applies to all statements \nthat can generate code. You can also exclude specific statements from preparsing by using the \nNOPREPARSE option in statements that allow temporary columns or the SCORE statement."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"NOPRINT","ProcedureOptionHelp":{"#cdata":"Syntax: NOPRINT\n\nThis option suppresses the generation of ODS tables and other printed output in the IMSTAT procedure. \nYou can use this option to suppress printed output during execution of the actions, and then use the \nREPLAY statement to print the tables at a later point in the procedure execution."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"NOTIMINGMSG|NOTIME","ProcedureOptionHelp":{"#cdata":"Syntax: NOTIMINGMSG\n\nWhen an action completes successfully, the IMSTAT procedure generates a SAS log message that \ncontains the execution time of the request. Specify this option to suppress the message."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"PGMMSG|PROGMST","ProcedureOptionHelp":{"#cdata":"Syntax: PGMMSG\n\nSpecifies to capture messages associated with user-provided SAS statements on the server in a \ntemporary table. Messages are produced when parsing errors occur, when code generation fails, \nor by PUT statements in a SAS program. \n\nYou can use this option as a debugging feature for SAS code that you submit through temporary \ncolumn expressions. The macro variable _PGMMSG_ is used in the IMSTAT procedure to capture the \nname of the table. The _TEMPLAST_ macro variable is also updated in case this temporary table \nis the most recently created temporary table."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"SIGNER=","ProcedureOptionHelp":{"#cdata":"Syntax: SIGNER=\"authorization-web-service-uri\" \n\nSpecifies the URI for the SAS LASR Authorization web service. For more information, \nsee SAS Visual Analytics: Administration Guide. \n\nExample SIGNER=\"https://server.example.com/SASLASRAuthorization\""},"ProcedureOptionType":"V"},{"ProcedureOptionName":"TEMPTABLEINFO|TEMPINFO","ProcedureOptionHelp":{"#cdata":"Syntax: TEMPTABLEINFO\n\nSpecifies to add additional information for temporary tables to the ODS table that is created \non the SAS client. The information includes the time at which the temporary table was created \nin the server, the number of rows, and the number of columns."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"TEMPTABLESQUEEZE|TEMPSQUEEZE","ProcedureOptionHelp":{"#cdata":"Syntax: TEMPTABLESQUEEZE\n\nRequests that the temporary tables generated in the PROC IMSTAT session are automatically \nsqueezed (compressed). You can use the INFO option in the COMPRESS statement to determine \nthe compression ratio that was applied to the table."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"UCA|UCACOLLATION","ProcedureOptionHelp":{"#cdata":"Syntax: UCA\n\nSpecifies that you want to use Unicode Collation Algorithms (UCA) to determine the ordering \nof character variables in the GROUPBY= operations and other operations that depend on the order \nof formatted values."},"ProcedureOptionType":"S"}]},"ProcedureStatements":{"ProcedureStatement":[{"StatementName":"AGGREGATE","StatementHelp":{"#cdata":"Syntax: AGGREGATE variable-name <(variable-options)> / < options>;\n      \nThe AGGREGATE statement aggregates the values of one or more variables according to variable-specific \noptions. The statement supports both numeric and class variables."},"StatementOptions":{"#comment":[{},{}],"StatementOption":[{"StatementOptionName":"AGGREGATOR=|AGG=|ACCUMULATE=","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"V"},{"StatementOptionName":"CHARN=","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"V"},{"StatementOptionName":"CHARRANGE","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"S|V"},{"StatementOptionName":"FORMAT=","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"V"},{"StatementOptionName":"N=","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"V"},{"StatementOptionName":"PERCENTILE=","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"V"},{"StatementOptionName":"RANGE","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"S|V"},{"StatementOptionName":"ALIGN=","StatementOptionHelp":{"#cdata":"Syntax: ALIGN= <BEGINNING | MIDDLE | ENDING>\n\nSpecifies the alignment of the representative value with respect to an interval or bin. \nThe following example specifies a bin of width 5 years and the representing value of a \nbin is the bin\u2019s beginning value, by default. Given the bins [1985, 1990], [1990, 1995],\n\u2026, [2000, 2005], and ALIGN=ENDING, the representing values of these bins are 1990, 1995,..., 2005. \n\nAlias: The values for the ALIGN= option have aliases of B, BEG, M, MID, and E, END, respectively.  \nDefault BEGINNING \n\nExample:\ndata example.stocks(partition=(stock));\n   set sashelp.stocks;\nrun;\n\nproc imstat data=example.stocks;  \n    aggregate close (agg=mean) close (agg=std) \n              / id=date idfmt=\"year.\"  \n              bin=('01jan1985'd, '01jan1990'd)\n              align=m  \n              partition=\"IBM\";\nrun;\n    table example.&_templast_;\n    fetch / format orderby=(date) to=20;\nquit;"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"BEGINNING","@Value2":"MIDDLE","@Value3":"ENDING"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the representing value of a bin is the bin\u2019s beginning value.","@ToolTip2":"Specifies that the representing value of a bin is the bin\u2019s middle value.","@ToolTip3":"Specifies that the representing value of a bin is the bin\u2019s ending value."}},{"StatementOptionName":"BIN=","StatementOptionHelp":{"#cdata":"Syntax: BIN=(lower-number, upper-number) \n\nSpecifies the minimum and maximum values of one bin. The boundaries for additional bins \nare extrapolated from the range in the bin that you specify. For example, if the values \nof the ID= variable range from 0 to 100, and you specify BIN=(5, 15), then the server \nconstructs 11 bins. The first bin is [\u20135, 5], the second bin is (5, 15], and the last \nbin is (95, 105]. The values on the upper boundary of a bin belong to this bin. The \nvalues on the lower boundary of a bin belong to the adjacent lower bin. \n\nInteraction The BIN= option has no effect unless the ID= option is specified. \n\nTip If you are working with time series data, the INTERVAL= option is an alternative \nand offers a convenient syntax for binning time series values."},"StatementOptionType":"V"},{"StatementOptionName":"EDGEID=","StatementOptionHelp":{"#cdata":"Syntax: EDGEID=variable-name\n\nSpecifies the variable to use for identifying the order of the analysis variable. It is required \nwhen you specify one of the following aggregation methods: \n\n\u2022 FIRST \n\u2022 FIRSTNOTEMPTY, FNE \n\u2022 LAST \n\u2022 LASTNOTEMPTY, LNE\n \nExample:\n\ndata example.stocks;\n    set sashelp.stocks;\n run;\n\nproc imstat data=example.stocks;\n    where stock=\"IBM\" and date >= '01jan2003'd;\n\n    aggregate close (agg=fne) close (agg=lne) close (agg=mean) \n              / id=date idfmt=\"yyq6.\"\n                edgeid=date interval=\"quarter\";\nquit;"},"StatementOptionType":"V"},{"StatementOptionName":"GROUPBY=","StatementOptionHelp":{"#cdata":"Syntax: GROUPBY=(variable-list) \n\nSpecifies a list of variable names, or a single variable name, to use as GROUPBY variables \nin the order of the grouping hierarchy. If you do not specify any GROUPBY variable names, \nthen the calculation is performed across the entire table\u2014possibly subject to a WHERE clause."},"StatementOptionType":"V"},{"StatementOptionName":"GROUPBYLIMIT=","StatementOptionHelp":{"#cdata":"Syntax: GROUPBYLIMIT=n\n\nSpecifies the maximum number of levels in a GROUPBY set. When the software determines \nthat there are at least n levels in the GROUPBY set, it abandons the action, returns\na message, and does not produce a result set. You can specify the GROUPBYLIMIT= option \nif you want to avoid creating excessively large result sets in GROUPBY operations."},"StatementOptionType":"V"},{"StatementOptionName":"GROUPFILTER=","StatementOptionHelp":{"#cdata":"Syntax: GROUPFILTER=(filter-options) \n\nSpecifies a section of the group-by hierarchy to be included in the computation. With this option, \nyou can request that the server performs the analysis for only a subset of all possible groupings. \nThe subset is determined by applying the group filter to a temporary table that you generate with \nthe GROUPBY statement. \n\nYou can specify the following suboptions in the GROUPFILTER option: \n\nDESCENDING | DESC - specifies the top section or the bottom section of the groupings to be collected. \nLIMIT=n - specifies the maximum number of distinct groupings to be collected, where integer n >= 0. \nSCOREGT=f | SGT=f - specifies the exclusive lower bound for the numeric scores of the distinct groupings to collect. \nSCORELT=f | SLT= - specifies the exclusive upper bound for the numeric scores of the distinct groupings to collect. \nVALUEGT=(\"format-name1\" <, \"format-name2\" ...>) | VGT=\n  - specifies the exclusive lower bound of the group-by variable\u2019s formatted values for the distinct groupings to collect. \nVALUELT=(\"format-name1\" <, \"format-name2\" ...>)  | VLT=\n  - specifies the exclusive upper bound of the group-by variable\u2019s formatted values for the distinct groupings to collect. \nTABLE=table-with-groupby-results\n  - specifies the in-memory table from which to load the group-by hierarchy. \n  \nInteraction: If you specify the GROUPFILTER= option, then the GROUPBY= and FORMATS= options have no effect."},"StatementOptionType":"V","SubOptionsKeywords":"DESCENDING|DESC|LIMIT=|SCOREGT=|SGT=|SCORELT=|VLT=|VALUEGT=|VGT=|VALUELT=|VLT=|TABLE="},{"StatementOptionName":"ID=","StatementOptionHelp":{"#cdata":"Syntax: ID=variable-name\n\nSpecifies a numeric variable that identifies the time associated with each observation in the \ninput table. The values of the ID= variable are typically SAS date, time, or datetime values, \nbut that is not a requirement."},"StatementOptionType":"V"},{"StatementOptionName":"IDFORMAT=|IDFMT=","StatementOptionHelp":{"#cdata":"Syntax: IDFORMAT=(\"format-specification\") \n\nSpecifies the format for the ID= variable. If you do not specify this option, the default \nformat for the variable is applied. If the ID= option is not specified, this option is ignored."},"StatementOptionType":"V"},{"StatementOptionName":"IDEND=","StatementOptionHelp":{"#cdata":"Syntax: IDEND=numeric-value\n\nSpecifies the end value of the ID= variable to be included in the analysis. If the last ID= \nvariable value is less than the specified IDEND= value, then the series is extended with \nmissing values. If the last ID= variable value is greater than the specified IDEND= value, \nthen the series is truncated. \n\nThe IDEND= value can be a date ('13SEP1998'd), a time ('12:34:56't), a datetime \n('01MAY88:12:34:56'dt) or a numeric value. If the ID= option is not specified, then \nthis option is ignored."},"StatementOptionType":"V"},{"StatementOptionName":"IDSTART=","StatementOptionHelp":{"#cdata":"Syntax: IDSTART=numeric-value\n\nSpecifies the beginning value of the ID= variable to be included in the analysis. If the first ID= \nvariable value is greater than the specified IDSTART= value, then the series is prefixed with missing \nvalues. If the first ID= variable value is less than the specified IDSTART= value, then the series is \ntruncated. If the ID= option is not specified, then this option is ignored."},"StatementOptionType":"V"},{"StatementOptionName":"INTERVAL=","StatementOptionHelp":{"#cdata":"Syntax: INTERVAL=\"interval\" \n\nSpecifies the time period for the accumulation of observations. For example, if you specify \nINTERVAL='MONTH', then the AGGREGATE statement summarizes the observations in monthly intervals. \nIf the ID= option is not specified, then this option is ignored."},"StatementOptionType":"V"},{"StatementOptionName":"JUMPINGWINDOW","StatementOptionHelp":{"#cdata":"Specifies that during aggregation, a window considers data within a specified multiple of intervals. \nA jumping window resets the aggregation process when the specified range of time expires. If you \ndo not specify the JUMPINGWINDOW option, a window always retains the same multiple of intervals."},"StatementOptionType":"S"},{"StatementOptionName":"KEEP=|TABLEVARS=","StatementOptionHelp":{"#cdata":"Syntax: KEEP=(variable-name1 <variable-name2...>) \n\nSpecifies one or more variables to transfer from the active table to the ODS table output or \ntemporary table. When multiple input observations contribute to an output observation (this \nis the most common situation), then the minimum value is used. \n\nInteraction This option is ignored unless a PARTITION, GROUPBY=, or ID= option is also specified."},"StatementOptionType":"V"},{"StatementOptionName":"KEEPRECORD","StatementOptionHelp":{"#cdata":"Specifies to output an aggregated value for each input observation by aggregating input observations \nwhose ID= values are specified by INTERVAL= and WINDOWINT= options. Be aware that using this option \ncan increase the volume of the result set."},"StatementOptionType":"S"},{"StatementOptionName":"NOEMPTYINTERVAL","StatementOptionHelp":{"#cdata":"Specifies that intervals that no ID= variable value belongs to are omitted from the output. By \ndefault, the empty intervals contain missing values."},"StatementOptionType":"S"},{"StatementOptionName":"NOMISSING|NOMISS","StatementOptionHelp":{"#cdata":"Specifies that you do not want to include missing values in the determination of group-by values. \nThis option also applies to analysis variables when you specify AGGREGATOR=NDISTINCT."},"StatementOptionType":"S"},{"StatementOptionName":"OFFSET=|DIF=","StatementOptionHelp":{"#cdata":"Syntax: OFFSET=\n\nSpecifies the time series shift in order to match up with an existing time series. It can be used \nto match up with existing time series from previous year, for example."},"StatementOptionType":"V"},{"StatementOptionName":"PARTIALTOINTERVAL=|PARTIALTODATE=","StatementOptionHelp":{"#cdata":"Syntax: PARTIALTOINTERVAL=numeric-value\n\nPARTIALTODATE=numeric-value\n\nSpecifies the time value when the aggregation within an interval or a bin is terminated. For example, \nif you specify INTERVAL='MONTH' and PARTIALTOINTERVAL='10FEB98'd, then the action aggregates records \nfrom the first 10 days of each month only."},"StatementOptionType":"V"},{"StatementOptionName":"PARTIALTOWINDOW=","StatementOptionHelp":{"#cdata":"Syntax: PARTIALTOWINDOW=numeric-value\n\nSpecifies the time value when the aggregation within a window interval or a window bin is terminated. \nFor example, if you specify WINDOWINT='YEAR', PARTIALTOWINDOW='10FEB98'd, and JUMPINGWINDOW, then the \naction aggregates records from the first 41 days of each year for each interval, except the interval \ncontains all 31 days from January of each year. The PARTIALTOWINDOW= and PARTIALTOINTERVAL= options \ncan be used together. \n\nIn addition to the above specification, if you specify INTERVAL='MONTH', PARTIALTOINTERVAL='08FEB98'd, \nthen the action counts only the first 8 days from JANUARY and the first 8 days from FEBURARY when it \naggregates on intervals FEBURARY, \u2026 , DECEMBER for each year. \n\nInteraction: This option is ignored unless you specify the JUMPINGWINDOW option, because the starting \ntime of a sliding window (a non-jumping window) is varying."},"StatementOptionType":"V"},{"StatementOptionName":"PARTITION","StatementOptionHelp":{"#cdata":"Syntax: PARTITION <=partition-key>\n\nSpecifies that when the active table is partitioned, then the aggregation is performed separately \nfor each specified partition-key. If you do not specify a partition-key, the analysis is performed \nfor all partitions. You can use the PARTITIONINFO statement to retrieve the valid partition key \nvalues for a table."},"StatementOptionType":"S|V"},{"StatementOptionName":"SAVE=","StatementOptionHelp":{"#cdata":"Syntax: SAVE=table-name\n\nSaves the result table so that you can use it in other IMSTAT procedure statements like STORE, \nREPLAY, and FREE. The value for table-name must be unique within the scope of the procedure execution. \nThe name of a table that has been freed with the FREE statement can be used again in subsequent \nSAVE= options."},"StatementOptionType":"V"},{"StatementOptionName":"SUBBINOFFSET=","StatementOptionHelp":{"#cdata":"Syntax: SUBBINOFFSET=n\n\n\nSpecifies the offset from the start of a bin. n must be positive and less or equal than the \nbin width. If the specified n is out of range, then this option is ignored. \n\nInteraction You must specify ID= and BIN= to use this option."},"StatementOptionType":"V"},{"StatementOptionName":"SUBBINWIDTH=","StatementOptionHelp":{"#cdata":"Syntax: SUBBINWIDTH=n\n\nSpecifies the width of the sub-bin within a bin. For example, if the values of the ID= variable \nrange from 0 to 100, and you specify BIN=(5, 15), SUBBINOFFSET=2, and SUBBINWIDTH=5, then this \naction summarizes the observations with ID= variable values that fall into the ranges [\u20133, 2], \n(7, 12], (17, 22], \u2026, (97, 102]. n must be positive and the sum of SUBBINOFFSET= and SUBBINWIDTH= \nmust be less or equal to the bin width. If the specified n is out of range, then this option is ignored. \n\nInteraction You must specify ID= and BIN= to use this option."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary \nvariables or a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPTABLE","StatementOptionHelp":{"#cdata":"Generates an in-memory temporary table from the result set. The IMSTAT procedure displays the \nname of the table and stores it in the &_TEMPLAST_ macro variable, provided that the statement \nexecuted successfully. \n\nWhen the IMSTAT procedure exits, all temporary tables created during the IMSTAT session are \nremoved. Temporary tables are not displayed on a TABLEINFO request, unless the temporary table \nis the active table for the request. \n\nInteraction: The TEMPTABLE option requires a group-by analysis or a partitioned analysis with this statement."},"StatementOptionType":"S"},{"StatementOptionName":"WINDOWBIN=","StatementOptionHelp":{"#cdata":"Syntax: WINDOWBIN=(lower-number, upper-number) \n\nSpecifies the minimum and maximum values of a time window for the aggregation of observations with \nrespect to each bin. The construction of this option is similar to the BIN= option. If the width of \nthe window is not a multiple of the width of the bin, then the action fails. If the value for \nlower-number is not equal to that of BIN= option, the action fails."},"StatementOptionType":"V"},{"StatementOptionName":"WINDOWINT=","StatementOptionHelp":{"#cdata":"Syntax: WINDOWINT=\"interval\" \n\nSpecifies the time window for the aggregation of observations with respect to each time interval. \nFor example, if you specify INTERVAL='MONTH' and WINDOWINT='YEAR', then the AGGREGATE statement \nsummarizes a year\u2019s worth of observations before the end of each monthly interval."},"StatementOptionType":"V"},{"StatementOptionName":"WINDOWOFFSET=|WINDOWDIF=","StatementOptionHelp":{"#cdata":"Syntax: WINDOWOFFSET=n\n\nSpecifies the time series shift in terms of an integer multiple of the WINDOWINT= or WINDOWBIN= \nvalue. For example, if you specify WINDOWINT='YEAR' and WINDOWOFFSET=\u20133, then at each time interval, \nthe aggregated records are from three years earlier."},"StatementOptionType":"V"}]}},{"StatementName":"ARM","StatementHelp":{"#cdata":"Syntax: ARM ITEM=item-variable TRAN=transaction-variable </ options>; \n      \nThe ARM statement is used to perform associative rule mining (ARM). You can use it to derive \nfrequent itemsets, perform association rule mining, and sequence mining. "},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ITEM=","StatementOptionHelp":{"#cdata":"Syntax: ITEM=item-variable\n\nSpecifies the name of the variable in the active table that identifies items."},"StatementOptionType":"RV"},{"StatementOptionName":"TRAN=","StatementOptionHelp":{"#cdata":"Syntax: TRAN=transaction-variable\n\nSpecifies the name of the variable in the active table that identifies transactions."},"StatementOptionType":"RV"},{"StatementOptionName":"AGGREGATE=|AGG=","StatementOptionHelp":{"#cdata":"Syntax: AGGREGATE=aggregation-method\n\n\nLists the aggregator for which the score of an itemset at each occurrence in a data set is aggregated \ninto a final score of such itemset. If the WEIGHT= variable is not specified, then the aggregator \nspecification is ignored. \n\nDefault: SUM \nInteraction: You must specify the WEIGHT= option to use this option."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"MAX","@Value2":"MEAN","@Value3":"MIN","@Value4":"SUM"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the maximum value.","@ToolTip2":"Specifies the arithmetic mean.","@ToolTip3":"Specifies the minimum value.","@ToolTip4":"Specifies the sum of nonmissing values."}},{"StatementOptionName":"FREQ=","StatementOptionHelp":{"#cdata":"Syntax: FREQ=variable\n\nSpecifies the numeric frequency variable to use for computing the score of each frequent itemset \nalong with WEIGHT= option. When the FREQ= variable is not specified, the score of a frequent \nitemset equates the value of the WEIGHT= variable scaled by 1. Negative values for the specified \nvariable are considered missing."},"StatementOptionType":"V"},{"StatementOptionName":"ITEMAGG=","StatementOptionHelp":{"#cdata":"Syntax: ITEMAGG=aggregation-method\n\nLists the aggregator for which the values of the WEIGHT= variable, and optionally the FREQ= variable, \nare rolled up into the score of an itemset at each occurrence in the data set, provided that a WEIGHT= \nvariable is specified. If the WEIGHT= variable is not specified, then the aggregator specification is \nignored. The aggregation methods are identical to the list in the AGGREGATE= option."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"MAX","@Value2":"MEAN","@Value3":"MIN","@Value4":"SUM"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the maximum value.","@ToolTip2":"Specifies the arithmetic mean.","@ToolTip3":"Specifies the minimum value.","@ToolTip4":"Specifies the sum of nonmissing values."}},{"StatementOptionName":"ITEMFMT=","StatementOptionHelp":{"#cdata":"Syntax: ITEMFMT=(\"format-specification\") \n\nSpecifies the formats for the ITEM= variable. If you do not specify the ITEMFMT= option, then the \nunformatted values of the ITEM= variable are used. \n\nEnclose the format specification in quotation marks."},"StatementOptionType":"V"},{"StatementOptionName":"ITEMSTBL","StatementOptionHelp":{"#cdata":"Specifies to save the derived frequent itemsets in a temporary table. By default, the frequent itemsets are not saved."},"StatementOptionType":"S"},{"StatementOptionName":" MAXITEMS=","StatementOptionHelp":{"#cdata":"Syntax: MAXITEMS=n\n\nSpecifies the maximal number of items to allow in a frequent itemset. The value must be greater \nthan or equal to 1. If an invalid value is specified, then it is replaced with 1, the default value. \n\nDefault 1"},"StatementOptionType":"V"},{"StatementOptionName":"MINITEMS=","StatementOptionHelp":{"#cdata":"Syntax: MINITEMS=n\n\nSpecifies the minimal number of items to allow in a frequent itemset. The value must be greater than \nor equal to zero. If an invalid value is specified, then it is replaced with 0, the default value. \n\nIf you specify MAXITEMS= < MINITEMS=, the server swaps the values. If you specify MAXITEMS = MINITEMS, \nthe server assigns MAXITEMS = MINITEMS + 1. \n\nDefault 0"},"StatementOptionType":"V"},{"StatementOptionName":"NOMISSING|NOMISS","StatementOptionHelp":{"#cdata":"Specifies that missing values of the ITEM= and TRAN= variables are excluded from analysis. By default, \nmissing values of the ITEM= variable are considered a separate item. Missing values of the TRAN= \nvariable are considered a separate transaction."},"StatementOptionType":"S"},{"StatementOptionName":"PARTITION|PART","StatementOptionHelp":{"#cdata":"Syntax: PARTITION <=partition-key>\n\nSpecifies to use partitioning variables. When only PARTITION is specified and the table is partitioned \nfirst by the TRAN= variable, and the TRANFMT= option is specified, the associative rule mining is performed \nseparately for each value of the partition key. If a value for partition-key is specified, then the associative \nrule mining is performed on that partition only."},"StatementOptionType":"S|V"},{"StatementOptionName":"RELSUPPORT","StatementOptionHelp":{"#cdata":"Specifies that the values for LOWER= and UPPER= in the SUPPORT option are relative to the most frequent \nitemset. For example, if 500 is the support of the most frequent itemset, then specifying RELSUPPORT \nSUPPORT(LOWER=0.1 UPPER=0.5) means the minimum and the maximum supports for the analysis are 50 and \n250, respectively. When using this option, the values for LOWER= and UPPER= must be between 0 and 1. \nOtherwise, they are set to the default values 0.05 and 1.0, respectively."},"StatementOptionType":"S"},{"StatementOptionName":"RULES","StatementOptionHelp":{"#cdata":"Syntax: RULES(<suboptions>) \n\nSpecifies the requirements for how association rules are generated from frequent itemsets. The following suboptions are available: \n\nAGGREGATE=aggregation-method\n  lists the aggregator for which the score of a rule at each occurrence in a data set is aggregated into a final score of such rule. \n  If the WEIGHT= variable is not specified, then the aggregator specification is ignored. \n\n  The available aggregation methods are as follows: MAX, MEAN, MIN, SUM\n\nFREQ=variable-name\n  specifies the numeric frequency variable to use for computing the score of each association rule along \n  with ORDER= option. When a FREQ= variable is not specified, the score of an association rule equates the \n  value of the ORDER= variable scaled by 1. Negative values for the specified variable are considered missing. \n\nITEMAGG=aggregation-method\n  lists the aggregator for which the values of the WEIGHT= variable, and optionally the FREQ= variable, \n  are rolled up into the score of a rule at each occurrence in the data set, provided that a WEIGHT= variable \n  is specified. If you do not specify a WEIGHT= variable, then the aggregator specification is ignored. The \n  aggregation methods are identical to the list in the AGGREGATE= option. \n\nNUMLHS(<LOWER=lower-value> <UPPER=upper-value>)\n  specifies the minimum and maximum number of items in the left-hand side (LHS) of a rule to allow. \n  If you specify UPPER= < LOWER=, the server swaps the values. \n\nNUMRHS(<LOWER=lower-value> <UPPER=upper-value>)\nspecifies the minimum and maximum number of items in the right-hand side (RHS) of a rule to allow. \nIf you specify UPPER= < LOWER=, the server swaps the values. \n\nSCORE(<LOWER=lower-value> <UPPER=upper-value>) \n  specifies the minimum and maximum scores of the association rules that are derived. If you specify \n  UPPER= < LOWER=, the server swaps the values. If you specify the same value for LOWER= and UPPER=, \n  the server adds \u03b5 (0.1110223024625157e-12) to value and uses the result for UPPER=. \n\nWEIGHT=variable-name\n  specifies the numeric weight variable to use for computing the score of each association rule, along \n  with FREQ= variable. If you do not specify a WEIGHT= variable, then the AGGREGATE=, FREQ=, and ITEMAGG= \n  options are ignored."},"StatementOptionType":"S","SubOptionsKeywords":"AGGREGATE=|CONFIDENCE|LOWER=|UPPER=|FREQ=|ITEMAGG=|NUMLH|NUMRHS|SCORE|WEIGHT="},{"StatementOptionName":"SAVE=","StatementOptionHelp":{"#cdata":"Syntax: SAVE=table-name\n\nSaves the result table so that you can use it in other IMSTAT procedure statements like STORE, \nREPLAY, and FREE. The value for table-name must be unique within the scope of the procedure \nexecution. The name of a table that has been freed with the FREE statement can be used again \nin subsequent SAVE= options."},"StatementOptionType":"V"},{"StatementOptionName":"SCORE","StatementOptionHelp":{"#cdata":"Syntax: SCORE(<LOWER=lower-value> <UPPER=upper-value>) \n\nSpecifies the minimum and maximum scores of the frequent itemsets that are derived. If you specify \nUPPER= < LOWER=, the server swaps the values. If you specify the same value for LOWER= and UPPER=, \nthe server adds \u03b5 (0.1110223024625157e-12) to value and uses the result for UPPER=."},"StatementOptionType":"S","SubOptionsKeywords":"LOWER=|UPPER="},{"StatementOptionName":"SEQUENCES","StatementOptionHelp":{"#cdata":"Syntax: SEQUENCES(TIME=t <sub-options>) \n\nSpecifies the requirements for how sequences are generated from the original table. The sequences \ndo not necessarily depend on previously generated frequent itemsets. You can specify the following \nsub-options in SEQUENCES option: \n\nADJACENT\n  specifies that any two events of a sequence must be adjacent to each other in time in a transaction. \n\nAGGREGATE=aggregation-method\n  lists the aggregator for which the score of a sequence at each occurrence in a data set is aggregated into a final \n  score of such sequence. If the WEIGHT= variable is not specified, then the aggregator specification is ignored. \n\n  The available aggregation methods are as follows: MAX, MEAN, MIN, SUM\n  \nFREQ=variable-name\n  specifies the numeric frequency variable to use for computing the score of each sequence along with WEIGHT= option. \nINCLUDEMISSTIME\n  indicates that records with a missing value for the TIME= variable are considered for sequence analysis.\nITEMAGG=aggregation-method\n  lists the aggregator for which the values of the WEIGHT= variable, and optionally the FREQ= variable, are rolled \n  up into the score of a rule at each occurrence in the data set, provided that a WEIGHT= variable is specified. \nITEMSETFILTER=|FILTER= SINGLETONS | ALLITEMS | NONE\n  specifies how the sequences are filtered by frequent itemsets. The SINGLETONS setting means that each item of any \n  sequence has to be a frequent singleton. The ALLITEMS setting means the set of all distinct items of any sequence \n  have to be a frequent itemset. The NONE setting indicates that sequences are not influenced by what frequent itemsets \n  are derived. \nLASRRULE=table-name\n  specifies an in-memory table that contains trained association rules. The rules are used to score the current \n  active transaction table.\nLASRSEQU=table-name\n  specifies an in-memory table that contains trained sequences. The sequences are used to score the current active \n  transaction table. \nMAXITEMS=n\n  specifies the maximal number of items to allow in any sequence. The value must be greater than or equal to 1.\nMAXDURATION=t\n  specifies the maximum duration to allow between the onset time of the first item and the time of the last item in a sequence.\nMAXWINDOW=t\n  specifies the maximum difference to allow between the onset of any two adjacent items in a sequence.\nMINDURATION=t\n  specifies the minimum difference to allow between the onset time of the last item and the first item in a sequence. \nMINITEMS=n\n  specifies the minimal number of items to allow in a sequence. The value must be greater than or equal to 1.\nMINWINDOW=t\n  specifies the minimum difference to allow between the onset of any two adjacent items in a sequence.\nNODUP\n  specifies that duplicated items within a sequence are not allowed. \nNOMERGE\n  specifies that a transaction supports only one sequence with the same number of events in that transaction. \nSCORE(<LOWER=lower-value> <UPPER=upper-value>) \n  specifies the minimum and maximum scores of the sequences that are derived. \nSUPPORT(<LOWER=lower-value> <UPPER=upper-value>) \n  specifies the minimum and maximum support of one sequence allowed in the analysis. By default, LOWER=1 and UPPER= is not set.\nTIME=t\n  specifies the numeric variable to use for sorting the items in a sequence. This option is required for sequence analysis. \nTIMEAGG=aggregation-method\n  specifies how to aggregate the time values when two adjacent events are the same in a sequence. \n  The available aggregation methods are as follows: MAX, MEAN, MIN\nWEIGHT=variable-name\n  specifies the numeric weight variable to use for computing the score of each sequence, along with FREQ= variable.\nWINDOWAGG=aggregation-method\n  is used with the MINWINDOW= and MAXWINDOW= options. It lists the aggregator for which the values of the TIME= variable \n  to update the anchor time. The default value is MEAN. \n  The available aggregation methods are as follows: MAX, MEAN, MIN"},"StatementOptionType":"S","SubOptionsKeywords":"ADJACENT|AGGREGATE=|FREQ=|INCLUDEMISSTIME|ITEMAGG=|ITEMSETFILTER=|FILTER=|LASRRULE=|LASRSEQU=|MAXITEMS=|MAXDURATION=|MAXWINDOW=|MINITEMS=|MINWINDOW=|NODUP|NOMERGE|SCORE|SUPPORT|TIME=|TIMEAGG=|WEIGHT=|WINDOWAGG="},{"StatementOptionName":"SEQUSTBL","StatementOptionHelp":{"#cdata":"Specifies to save the derived sequences from frequent itemsets to a temporary table. By default, \nthe ARM statement does not save sequences."},"StatementOptionType":"V"},{"StatementOptionName":"SUPPORT","StatementOptionHelp":{"#cdata":"Syntax: SUPPORT(<LOWER=lower-value> <UPPER=upper-value>) \n\nSpecifies the minimum and maximum frequencies to allow for derived frequent itemsets. If RELSUPPORT \nis not specified, then LOWER= and UPPER= are the minimum and maximum frequencies of frequent items \nthat appeared in the transactions. If RELSUPPORT is specified, then specify the two values as the \nratios for the minimum and maximum frequencies of frequent itemsets to the frequency of the most \nfrequent itemset. \n\nBy default, LOWER=1 when RELSUPPORT is not specified and LOWER=0.05 when RELSUPPORT is specified."},"StatementOptionType":"S","SubOptionsKeywords":"LOWER=|UPPER="},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary variables \nor a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined through \nSAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"},{"StatementOptionName":"TRANFMT=","StatementOptionHelp":{"#cdata":"Syntax: TRANFMT=(\"format-specification\") \n\n\nSpecifies the formats for the TRAN= variable. If you do not specify the TRANFMT= option, then the unformatted \nvalues of the TRAN= variable are used. \n\nEnclose the format specification in quotation marks."},"StatementOptionType":"S"},{"StatementOptionName":"WEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT=variable\n\nSpecifies the numeric weight variable to use for computing the score of each frequent itemset, along \nwith FREQ= variable. If you do not specify a WEIGHT= variable, then the AGGREGATE=, FREQ=, and ITEMAGG= \noptions are ignored."},"StatementOptionType":"V"}]}},{"StatementName":"ASSESS","StatementHelp":{"#cdata":"Syntax: ASSESS <variable-list> / Y=response-variable <options>; \n      \nThe ASSESS statement is used to assess one model or several models. For a set of classification \nmodels, the ASSESS statement returns three types of assessments: lift-related assessments, \nassessments related to a receiver operating characteristic (ROC), and concordance statistics. \nFor a set of regression models, the ASSESS statement returns the summary statistics of the \nresponse variable for each bin of the predictions after a quantile binning of the predictions."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"Y=|RESPONSE=","StatementOptionHelp":{"#cdata":"Syntax: Y= | RESPONSE= response-variable\n\nSpecifies the response variable for model assessment."},"StatementOptionType":"RV"},{"StatementOptionName":"CUTSTEP=|STEP=","StatementOptionHelp":{"#cdata":"Syntax: CUTSTEP=n\n\nSpecifies a number between 0 and 1 that defines the step size in receiver operating characteristic (ROC) calculations."},"StatementOptionType":"V"},{"StatementOptionName":"DESCENDING|DESC","StatementOptionHelp":{"#cdata":"Specifies that the levels of the GROUPBY variables are to be arranged in descending order."},"StatementOptionType":"S"},{"StatementOptionName":"EPSILON=","StatementOptionHelp":{"#cdata":"Syntax: EPSILON=e\n\nSpecifies the tolerance that is used in determining the convergence of the iterative algorithm for the percentile calculation. \n\nDefault 1e-5"},"StatementOptionType":"V"},{"StatementOptionName":"EVENT=","StatementOptionHelp":{"#cdata":"Syntax: EVENT=\"quoted-strings\" \n\nSpecifies the formatted value of the response variable that represents the event. When this option \nis not specified, the ASSESS statement performs model assessment for a regression model and the response \nvariable must be numeric."},"StatementOptionType":"V"},{"StatementOptionName":"FORMATS=","StatementOptionHelp":{"#cdata":"Syntax: FORMATS=(\"format-specification\",...) \n\nSpecifies the formats for the GROUPBY= variables. If you do not specify the FORMAT= option, or if you \ndo not specify the GROUPBY= option, the default format is applied for that variable. \n\nEnclose each format specification in quotation marks and separate each format specification with a comma."},"StatementOptionType":"V"},{"StatementOptionName":"GROUPBY=","StatementOptionHelp":{"#cdata":"Syntax: GROUPBY=(variable-list) \n\nSpecifies a list of variable names, or a single variable name, to use as GROUPBY variables \nin the order of the grouping hierarchy. If you do not specify any GROUPBY variable names, \nthen the calculation is performed across the entire table\u2014possibly subject to a WHERE clause."},"StatementOptionType":"V"},{"StatementOptionName":"GROUPBYLIMIT=","StatementOptionHelp":{"#cdata":"Syntax: GROUPBYLIMIT=n\n\nSpecifies the maximum number of levels in a GROUPBY set. When the software determines that there \nare at least n levels in the GROUPBY set, it abandons the action, returns a message, and does not \nproduce a result set. You can specify the GROUPBYLIMIT= option if you want to avoid creating \nexcessively large result sets in GROUPBY operations."},"StatementOptionType":"V"},{"StatementOptionName":"GROUPFILTER=","StatementOptionHelp":{"#cdata":"Syntax: GROUPFILTER=(groupfilter-options) \n\nSpecifies a section of the GROUPBY= hierarchy to include in the ASSESS computation."},"StatementOptionType":"V"},{"StatementOptionName":"MAXITER=","StatementOptionHelp":{"#cdata":"Syntax: MAXITER=i\n\nSpecifies a positive integer that determines the maximum number of iterations for the percentile algorithm. \n\nDefault 5 \u00d7 the number of bins (NBINS= option)."},"StatementOptionType":"V"},{"StatementOptionName":"MERGEBINS=","StatementOptionHelp":{"#cdata":"Syntax: MERGEBINS=b\n\nSpecifies the number of bins to create when a numeric GROUPBY variable exceeds the MERGELIMIT=n \nspecification. If you specify a MERGELIMIT, but do not specify a value for the MERGEBINS= option, \nthe server automatically calculates the number of bins."},"StatementOptionType":"V"},{"StatementOptionName":"MERGELIMIT=","StatementOptionHelp":{"#cdata":"Syntax: MERGELIMIT=n\n\nSpecifies that when the number of unique values in a numeric GROUPBY variable exceeds n, the variable \nis automatically binned and the GROUPBY structure is determined based on the binned values of the variable, \nrather than the unique formatted values. \n\nFor example, if you specify MERGELIMIT=500, any numeric GROUPBY variable with more than 500 unique \nformatted values is binned. Instead of returning results for more than 500 groups, the results are \nreturned for the bins. You can specify the number of bins with the MERGEBINS= option."},"StatementOptionType":"V"},{"StatementOptionName":"NBINS=","StatementOptionHelp":{"#cdata":"Syntax: NBINS=n\n\nSpecifies the number of bins to use in the lift calculations."},"StatementOptionType":"V"},{"StatementOptionName":"NOMISSING","StatementOptionHelp":{"#cdata":"Specifies that you do not want to include missing values in the determination of Group-By values. \nBy default, levels with missing values are included."},"StatementOptionType":"V"},{"StatementOptionName":"PARTITION|PART","StatementOptionHelp":{"#cdata":"Syntax: PARTITION <=partition-key>\n\nWhen you specify this option and the table is partitioned, the results are calculated separately \nfor each value of the partition key. In other words, the partition variables function as automatic \nGROUPBY variables. This mode of executing calculations by partition is more efficient than using the \nGROUPBY= option. With a partitioned table, the server takes advantage of knowing that observations for \na partition cannot be located on more than one worker node. \n\nIf you do not specify a partition-key, the analysis is performed for all partitions. If you do specify \na partition-key, the analysis is carried out for the specified key value only. You can use the PARTITIONINFO \nstatement to retrieve the valid partition key values for a table. \n\nYou can specify a partition-key in two ways. You can supply a single quoted string that is passed to the \nserver, or you can specify the elements of a composite key separated by commas."},"StatementOptionType":"S|V"},{"StatementOptionName":"RAWORDER","StatementOptionHelp":{"#cdata":"Specifies that the ordering of the GROUPBY variables is based on the raw values of the variables \ninstead of the formatted values."},"StatementOptionType":"S"},{"StatementOptionName":"SAVE=","StatementOptionHelp":{"#cdata":"Syntax: SAVE=table-name\n\nSaves the result table so that you can use it in other IMSTAT procedure statements like STORE, REPLAY, \nand FREE. The value for table-name must be unique within the scope of the procedure execution. The name \nof a table that has been freed with the FREE statement can be used again in subsequent SAVE= options."},"StatementOptionType":"V"},{"StatementOptionName":"SETSIZE","StatementOptionHelp":{"#cdata":"Requests that the server estimate the size of the result set. The procedure does not create a result \ntable if the SETSIZE option is specified. Instead, the procedure reports the number of rows that are \nreturned by the request and the expected memory consumption for the result set (in KB). If you specify \nthe SETSIZE option, the SAS log includes the number of observations and the estimated result set size."},"StatementOptionType":"S"},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary variables \nor a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPTABLE","StatementOptionHelp":{"#cdata":"Generates an in-memory temporary table from the result set. The IMSTAT procedure displays the name \nof the table and stores it in the &_TEMPLAST_ macro variable, provided that the statement executed \nsuccessfully. \n\nWhen the IMSTAT procedure exits, all temporary tables created during the IMSTAT session are removed. \nTemporary tables are not displayed on a TABLEINFO request, unless the temporary table is the active \ntable for the request."},"StatementOptionType":"S"},{"StatementOptionName":"YFORMAT=|YFMT=","StatementOptionHelp":{"#cdata":"Syntax: YFORMAT=\"quoted-string\" \n\nSpecifies the format for the response variable. This format produces the event specified in the EVENT= option."},"StatementOptionType":"V"}]}},{"StatementName":"BOXPLOT","StatementHelp":{"#cdata":"Syntax: BOXPLOT <variable-list> </ options>; \n\nvariable-list\n  specifies one or more numeric variables. If you do not specify this option, then all numeric variables \n  in the table are used. \n\nThe BOXPLOT statement generates a table with the information that can be used to generate a box plot. \nIt does not generate the plot."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"DESCENDING|DESC","StatementOptionHelp":{"#cdata":"Specifies that the levels of the GROUPBY variables are to be arranged in descending order."},"StatementOptionType":"S"},{"StatementOptionName":"FORMATS=","StatementOptionHelp":{"#cdata":"Syntax: FORMATS=(\"format-specification\",...) \n\nSpecifies the formats for the GROUPBY= variables. If you do not specify the FORMATS= option, \nor if you omit the entry for a GROUPBY variable, the default format is applied for that variable. \n\nEnclose each format specification in quotation marks and separate each format specification with a comma. \n\nExample: \n\nproc imstat data=lasr1.table1;\n   boxplot x / groupby=(a b) formats=(\"8.3\", \"$10\");\nquit;"},"StatementOptionType":"V"},{"StatementOptionName":"GROUPBY=","StatementOptionHelp":{"#cdata":"Syntax: GROUPBY=(variable-list) \n\nSpecifies a list of variable names, or a single variable name, to use as GROUPBY variables in the\norder of the grouping hierarchy. If you do not specify any GROUPBY variable names, then the calculation \nis performed across the entire table\u2014possibly subject to a WHERE clause."},"StatementOptionType":"V"},{"StatementOptionName":"GROUPBYLIMIT=","StatementOptionHelp":{"#cdata":"Syntax: GROUPBYLIMIT=n\n\nSpecifies the maximum number of levels in a GROUPBY set. When the software determines that there \nare at least n levels in the GROUPBY set, it abandons the action, returns a message, and does not \nproduce a result set. You can specify the GROUPBYLIMIT= option if you want to avoid creating excessively \nlarge result sets in GROUPBY operations."},"StatementOptionType":"V"},{"StatementOptionName":"MERGEBINS=","StatementOptionHelp":{"#cdata":"Syntax: MERGEBINS=b\n\nSpecifies the number of bins to create when a numeric GROUPBY variable exceeds the MERGELIMIT=n \nspecification. If you specify a MERGELIMIT, but do not specify a value for the MERGEBINS= option, \nthe server automatically calculates the number of bins."},"StatementOptionType":"V"},{"StatementOptionName":"MERGELIMIT=","StatementOptionHelp":{"#cdata":"Syntax: MERGELIMIT=n\n\nSpecifies that when the number of unique values in a numeric GROUPBY variable exceeds n, the variable \nis automatically binned and the GROUPBY structure is determined based on the binned values of the variable, \nrather than the unique formatted values. \n\nFor example, if you specify MERGELIMIT=500, any numeric GROUPBY variable with more than 500 unique \nformatted values is binned. Instead of returning results for more than 500 groups, the results are \nreturned for the bins. You can specify the number of bins with the MERGEBINS= option."},"StatementOptionType":"V"},{"StatementOptionName":"NOUTLIERBINS=|NOUTBINS=","StatementOptionHelp":{"#cdata":"Syntax: NOUTLIERBINS=b\n\nSpecifies the number of bins for reporting outliers. The default number of bins is 10 if you do \nnot specify an NOUTLIERBINS= value, but do specify the OUTLIERS option. Specifying a nonzero value \nfor NOUTLIERBINS= implies the specification of the OUTLIERS option. \n\nAlias  \nDefault 10"},"StatementOptionType":"V"},{"StatementOptionName":"OUTLIERS","StatementOptionHelp":{"#cdata":"Specifies to include outliers in computations and results. If the NOUTLIMIT=n option is specified, \nthen the server returns up to n outliers on the high and low ends of the distribution. Otherwise, \noutliers are binned into NOUTLIERBINS=b bins."},"StatementOptionType":"S"},{"StatementOptionName":"PARTITION|PART","StatementOptionHelp":{"#cdata":"Syntax: PARTITION <=partition-key>\n\nWhen you specify this option and the table is partitioned, the results are calculated separately \nfor each value of the partition key. In other words, the partition variables function as automatic \nGROUPBY variables. This mode of executing calculations by partition is more efficient than using the \nGROUPBY= option. With a partitioned table, the server takes advantage of knowing that observations for \na partition cannot be located on more than one worker node. \n\nIf you do not specify a partition-key, the analysis is performed for all partitions. If you do specify \na partition-key, the analysis is carried out for the specified key value only. You can use the PARTITIONINFO \nstatement to retrieve the valid partition key values for a table. \n\nYou can specify a partition-key in two ways. You can supply a single quoted string that is passed to the server, or you can specify the elements of a composite key separated by commas."},"StatementOptionType":"S|V"},{"StatementOptionName":"RAWORDER","StatementOptionHelp":{"#cdata":"Specifies that the ordering of the GROUPBY variables is based on the raw values of the variables \ninstead of the formatted values."},"StatementOptionType":"S"},{"StatementOptionName":"SAVE=","StatementOptionHelp":{"#cdata":"Syntax: SAVE=table-name\n\nSaves the result table so that you can use it in other IMSTAT procedure statements like STORE, REPLAY, \nand FREE. The value for table-name must be unique within the scope of the procedure execution. The name \nof a table that has been freed with the FREE statement can be used again in subsequent SAVE= options."},"StatementOptionType":"V"},{"StatementOptionName":"SETSIZE","StatementOptionHelp":{"#cdata":"Requests that the server estimate the size of the result set. The procedure does not create a result \ntable if the SETSIZE option is specified. Instead, the procedure reports the number of rows that are \nreturned by the request and the expected memory consumption for the result set (in KB). If you specify \nthe SETSIZE option, the SAS log includes the number of observations and the estimated result set size."},"StatementOptionType":"S"},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary variables \nor a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"}]}},{"StatementName":"CLUSTER","StatementHelp":{"#cdata":"Syntax: CLUSTER <variable-list> </ options>; \n      \nThe CLUSTER statement can be used to perform a k-means cluster analysis that uses the Euclidean \ndistance between values or it can use a density-based algorithm\u2014DBSCAN\u2014that was originally developed \nto discover clusters in large spatial databases with noise."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"BUBMAXPTS=","StatementOptionHelp":{"#cdata":"Syntax: BUBMAXPTS=n\n\nSpecifies the maximum number of points in each bubble and must exceed the value specified in the BUBMINPTS= option. \n\nApplies to METHOD=DBSCAN"},"StatementOptionType":"V"},{"StatementOptionName":"BUBMINPTS=","StatementOptionHelp":{"#cdata":"Syntax: BUBMINPTS=n\n\nSpecifies the minimum number of points in each bubble. \n\nDefault: 1 \nApplies to METHOD=DBSCAN"},"StatementOptionType":"V"},{"StatementOptionName":"CLUSTINFO","StatementOptionHelp":{"#cdata":"Specifies to save the cluster center that each observation belongs to, and the distance between them, \ninto the temporary table. \n\nInteraction You must specify the TEMPTABLE option along with this option."},"StatementOptionType":"V"},{"StatementOptionName":"CODE","StatementOptionHelp":{"#cdata":"Syntax: CODE <(code-generation-options)>\n\nRequests that the server produce SAS scoring code based on the actions that it performed during the \nanalysis. This option is available when the METHOD=KMEANS only. \n\nThe server generates DATA step code. By default, the code is replayed as an ODS table by the procedure \nas part of the output of the statement. More frequently, you might want to write the scoring code to an \nexternal file by specifying options. \n\nThe scoring code computes a value for a cluster identifier and includes it in the ClusterID variable. \nWhen you run the scoring code, if any variables in an observation have missing values, then the row \nis given a ClusterID of \u20131. \n\nCOMMENT\n  specifies to add comments to the code in addition to the header block. The header block is added by default. \nFILENAME=|FILE='path' \n  specifies the name of the external file to which the scoring code is written. This suboption applies only \n  to the scoring code itself. \nFORMATWIDTH=|FMTW=k\n  specifies the width to use in formatting derived numbers such as parameter estimates in the scoring code. \n  The server applies the BEST format, and the default format for code generation is BEST20. Range: 4 to 32\nLABELID=id\n  specifies a group identifier for group processing. The identifier is an integer and is used to create array \n  names and statement labels in the generated code. \nLINESIZE=|LS=n\n  specifies the line size for the generated code. \n  Default: 72 \n  Range: 64 to 256"},"StatementOptionType":"S","SubOptionsKeywords":"COMMENT|FILENAME=|FILE=|FORMATWIDTH=|FMTW=|LABELID=|LINESIZE="},{"StatementOptionName":"CONV=","StatementOptionHelp":{"#cdata":"Syntax: CONV=c\n\nSpecifies the convergence criterion c for the k-means analysis. When the relative change in within-cluster \nsum of squares (WCSS) between successive iterations is less than c, the analysis is presumed to have converged. \n\nDefault 1e>-5 \nApplies to METHOD=KMEANS"},"StatementOptionType":"V"},{"StatementOptionName":"DISP=","StatementOptionHelp":{"#cdata":"Syntax: DISP=(variable-list) \n\nDISP=variable-name\n\nSpecifies the variable or variables to include in the clustering results. Use this option with the \nNSAMP= option to generate output that is suitable for graphing."},"StatementOptionType":"V"},{"StatementOptionName":"DIST=","StatementOptionHelp":{"#cdata":"Syntax: DIST= EUC | SQUAREDEUC | MANHATTAN | MAXIMUM | COSINE | JACCARD | HAMMING \n\nSpecifies the distance measure used in the DBSCAN method. The k-means method uses DIST=EUC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"EUC","@Value2":"SQUAREDEUC","@Value3":"MANHATTAN","@Value4":"MAXIMUM","@Value5":"COSINE","@Value6":"JACCARD","@Value7":"HAMMING"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the EUC method.","@ToolTip2":"Specifies the SQUAREDEUC method.","@ToolTip3":"Specifies the MANHATTAN method.","@ToolTip4":"Specifies the MAXIMUM method.","@ToolTip5":"Specifies the COSINE method.","@ToolTip6":"Specifies the JACCARD method.","@ToolTip7":"Specifies the HAMMING method."}},{"StatementOptionName":"DMAX=","StatementOptionHelp":{"#cdata":"Syntax: DMAX=v\n\nSpecifies the maximum diameter of bubbles with the specified DIST= distance measure. \n\nDefault 0"},"StatementOptionType":"V"},{"StatementOptionName":"EPS=","StatementOptionHelp":{"#cdata":"Syntax: EPS=r\n\nSpecifies the distance value for neighborhood querying in the DBSCAN method. You must specify a value \nfor r when METHOD=DBSCAN. There is no default value since r is a distance measurement and depends on \nthe range of the data. \n\nThe values of EPS= and MINPTS= are important for the number of clusters that DBSCAN can find. The EPS= \nvalue determines the minimal radius of the clusters in terms of the distance measurement."},"StatementOptionType":"V"},{"StatementOptionName":"FREQ=","StatementOptionHelp":{"#cdata":"Syntax: FREQ=(variable-list) \n\nFREQ=variable-name\n\nSpecifies the variable or variables that are used to perform the frequency analysis for each cluster. \nThe procedure generates separate output tables for each variable."},"StatementOptionType":"V"},{"StatementOptionName":"INITMETHOD=|INIT=","StatementOptionHelp":{"#cdata":"Syntax: INITMETHOD=FORGY | RAND | AVG\n\nSpecifies the method for obtaining the initial estimate of cluster assignment. For the INIT=FORGY \npartition method, the initial mean centers are computed from NUMCLUS \u00d7 nt \u00d7 nn observations where \nnt and nn are the number of threads and number of nodes used by the server. \n\nWhen you specify INIT=RAND, all methods are assigned randomly to one of the NUMCLUS clusters. \nWhen you specify INIT=AVG, the initial centers are formed by averaging the observations on a \nthread-by-thread basis. \n\nDefault FORGY"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"FORGY","@Value2":"RAND","@Value3":"AVG"},"StatementOptionToolTips":{"@ToolTip1":"For the INIT=FORGY partition method, the initial mean centers are computed from NUMCLUS \u00d7 nt \u00d7 nn  observations where nt and nn are the number of threads and number of nodes used by the server.","@ToolTip2":"When you specify INIT=RAND, all methods are assigned randomly to one of the NUMCLUS clusters.","@ToolTip3":"When you specify INIT=AVG, the initial centers are formed by averaging the observations on a  thread-by-thread basis."}},{"StatementOptionName":"MAXITER=","StatementOptionHelp":{"#cdata":"Syntax: MAXITER=i\n\nSpecifies a positive integer that determines the maximum number of iterations for clustering. \n\nDefault 10"},"StatementOptionType":"V"},{"StatementOptionName":"METHOD=","StatementOptionHelp":{"#cdata":"Syntax: METHOD=KMEANS | DBSCAN\n\nSpecifies the clustering method for the analysis. \n\nDefault KMEANS"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"KMEANS","@Value2":"DBSCAN"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the KMEANS clustering method.","@ToolTip2":"Specifies the DBSCAN clustering method."}},{"StatementOptionName":"MINPTS=","StatementOptionHelp":{"#cdata":"Syntax: MINPTS=n\n\nSpecifies the minimum number of points required in one cluster for the DBSCAN method. The EPS= and \nMINPTS= options can have a dramatic effect on the clusters that are generated with the DBSCAN method. \nYou should exercise care in specifying the values for these options. \n\nDefault 1, which means that any cluster should contain at least one data point."},"StatementOptionType":"V"},{"StatementOptionName":"NOCASE","StatementOptionHelp":{"#cdata":"Specifies that the comparison between terms and the values of character variables is case insensitive. By default, comparisons are case sensitive."},"StatementOptionType":"S"},{"StatementOptionName":"NOIDF","StatementOptionHelp":{"#cdata":"Specifies that only the term frequency is used to construct the vectors, and not the inverse document frequency."},"StatementOptionType":"S"},{"StatementOptionName":"NONORM","StatementOptionHelp":{"#cdata":"Specifies that the term frequency-inverse document frequency (TF-IDF) vectors are not normalized."},"StatementOptionType":"S"},{"StatementOptionName":"NOPREPARSE|NOPREP","StatementOptionHelp":{"#cdata":"Prevents the procedure from preparsing and pregenerating code for temporary expressions, scoring \nprograms, and other user-written SAS statements. \n\nWhen this option is specified, the user-written statements are sent to the server \"as is\" and then \nthe server attempts to generate code from it. If the server detects problems with the code, the error \nmessages might not to be as detailed as the messages that are generated by SAS client. If you are \ndebugging your user-written program, then you might want to preparse and pregenerate code in the \nprocedure. However, if your SAS statements compile and run as you want them to, then you can specify \nthis option to avoid the work of parsing and generating code on the SAS client. \n\nWhen you specify this option in the PROC IMSTAT statement, the option applies to all statements that \ncan generate code. You can also exclude specific statements from preparsing by using the NOPREPARSE \noption in statements that allow temporary columns or the SCORE statement."},"StatementOptionType":"S"},{"StatementOptionName":"NREP=","StatementOptionHelp":{"#cdata":"Syntax: NREP=k\n\nSpecifies the number of representative points for each bubble. \n\nDefault 1"},"StatementOptionType":"V"},{"StatementOptionName":"NSAMP=","StatementOptionHelp":{"#cdata":"Syntax: NSAMP=k\n\nSpecifies the number of sample points that are returned for each cluster. Note that this returns \nthe k nearest and k farthest points from the cluster centers including their distances. \n\nDefault 0"},"StatementOptionType":"V"},{"StatementOptionName":"NUMCLUSTERS=|NUMCLUS=","StatementOptionHelp":{"#cdata":"Syntax: NUMCLUSTERS=number\n\nSpecifies the number of clusters for the k-means analysis. \n\nDefault 2"},"StatementOptionType":"V"},{"StatementOptionName":"SAVE=","StatementOptionHelp":{"#cdata":"Syntax: SAVE=table-name\n\nSaves the result table so that you can use it in other IMSTAT procedure statements like STORE, \nREPLAY, and FREE. The value for table-name must be unique within the scope of the procedure \nexecution. The name of a table that has been freed with the FREE statement can be used again \nin subsequent SAVE= options."},"StatementOptionType":"V"},{"StatementOptionName":"SAVETERMS","StatementOptionHelp":{"#cdata":"Specifies to save the TF-IDF vectors into the temporary table along with clustering results. \n\nInteraction You must specify the TEMPTABLE option along with this option."},"StatementOptionType":"S"},{"StatementOptionName":"SAVEVECTORS|SAVEVEC","StatementOptionHelp":{"#cdata":"Specifies to save the distance vectors to the temporary table along with clustering results. \nWhen the VARS= option already includes the variables used to obtain the distance vectors, \nthese variables are not saved again\n\nInteraction: You must specify the TEMPTABLE option along with this option."},"StatementOptionType":"S"},{"StatementOptionName":"SEED=","StatementOptionHelp":{"#cdata":"Syntax: SEED=number\n\nSpecifies the random number seed to use when the initialization methods INIT=FORGY or INIT=RAND \nare also specified. Specifying a nonzero number results in a reproducible random number stream \nfor the specific combination of number of threads and number of worker nodes in the server."},"StatementOptionType":"V"},{"StatementOptionName":"SETSIZE","StatementOptionHelp":{"#cdata":"Requests that the server estimate the size of the result set. The procedure does not create a result \ntable if the SETSIZE option is specified. Instead, the procedure reports the number of rows that \nare returned by the request and the expected memory consumption for the result set (in KB). If you \nspecify the SETSIZE option, the SAS log includes the number of observations and the estimated result \nset size."},"StatementOptionType":"S"},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary variables \nor a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPTABLE","StatementOptionHelp":{"#cdata":"Generates an in-memory temporary table from the result set. The IMSTAT procedure displays the name \n of the table and stores it in the &_TEMPLAST_ macro variable, provided that the statement executed \n successfully. \n\nWhen the IMSTAT procedure exits, all temporary tables created during the IMSTAT session are removed. \nTemporary tables are not displayed on a TABLEINFO request, unless the temporary table is the active \ntable for the request."},"StatementOptionType":"S"},{"StatementOptionName":"TERMS=","StatementOptionHelp":{"#cdata":"Syntax: TERMS=(\"term1\" <, \"term2\"...>) \n\nSpecifies the terms used in computing term frequency. Each string represents one term. Specifying the \nTERMS= option triggers the use of TF-IDF to compute distance vectors for character variables. The TERMS= \noption is useful if you have a fairly small number of terms to pass to the server. If the number of terms \nis large, you might want to use the TERMDATA= option instead."},"StatementOptionType":"V"},{"StatementOptionName":"TERMDATA=","StatementOptionHelp":{"#cdata":"Syntax: TERMDATA=table-name\n\nSpecifies an in-memory table in the server that contains the term list. Specifying the TERMDATA= \noption triggers the use of TF-IDF to compute distance vectors for character variables. If you \nspecify both the TERMS= and TERMDATA= options, the server uses the union of the two sets in the \nTF-IDF calculation. Note that the IMSTAT procedure assumes that the TERMDATA= table already exists \nin the server."},"StatementOptionType":"V"},{"StatementOptionName":"TIMEOUT=","StatementOptionHelp":{"#cdata":"Syntax: TIMEOUT=seconds\n\nSpecifies the maximum number of seconds that the server should run the statement. If the time-out \nis reached, the server terminates the request and generates an error and error message. By default, \nthere is no time-out."},"StatementOptionType":"V"},{"StatementOptionName":"TOKENS=","StatementOptionHelp":{"#cdata":"Syntax: TOKENS=(\"token1\" <, \"token2\"...>) \n\nSpecifies the tokens that separate terms when scanning character variables. If you do not specify \nthe tokens (term delimiters), then the terms are compared against the full raw length of the \ncharacter variable. \n\nFor example, if the term list is \"better\", \"worse\", and the variable Opinion contains \"Recent news \nis better than last week,\" then without a token list that contains the \" \" (blank) delimiter, the \nterm \"better\" is not counted. In other words, the absence of the blank token prevents the TF-IDF \nfrom scanning \"better\". If your token list is large, you might want to use the TOKENDATA= option \ninstead."},"StatementOptionType":"V"},{"StatementOptionName":"TOKENDATA=","StatementOptionHelp":{"#cdata":"Syntax: TOKENDATA=table-name\n\nSpecifies an in-memory table in the server that contains the tokens list."},"StatementOptionType":"V"},{"StatementOptionName":"VARS=","StatementOptionHelp":{"#cdata":"Syntax: VARS=variable-name\n\nVARS=(variable-name1 <, variable-name2, ...>) \n\nSpecifies the names of the variables to transfer to a temporary table in the server. This option \nis ignored unless you score an in-memory table and the TEMPTABLE option is specified. The observations \nwith these variables are copied to the generated temporary table."},"StatementOptionType":"V"}]}},{"StatementName":"CORR","StatementHelp":{"#cdata":"Syntax: CORR <variable-list> </ options>; \n\nvariable-list\n  specifies one or more numeric variables. If you do not specify this option, then all numeric \n  variables in the table are used. \n  \nThe CORR statement is used to calculate a matrix of pairwise correlations of numeric variables \nin an in-memory table."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"SAVE=","StatementOptionHelp":{"#cdata":"Syntax: SAVE=table-name\n\nSaves the result table so that you can use it in other IMSTAT procedure statements like STORE, REPLAY, \nand FREE. The value for table-name must be unique within the scope of the procedure execution. The name \nof a table that has been freed with the FREE statement can be used again in subsequent SAVE= options."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary variables \nor a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"}]}},{"StatementName":"CROSSTAB","StatementHelp":{"#cdata":"Syntax: CROSSTAB row-variable </ options>; \n\nCROSSTAB row*column </ options>; \n\nThe CROSSTAB statement is used to calculate one and two dimensional tables. You can use GROUPBY= \nvariables, partitioned tables, a WEIGHT= variable to calculate multiple statistics for each table \ncell, and calculate marginal versions of the statistics as well. "},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ACROSSBY|ACROSS","StatementOptionHelp":{"#cdata":"Specifies that the levels of row and column variables are the same across the GROUPBY= variables. \nIf you specify this option, then the tables in each group are shown with the same row and column \nlayout. If the ACROSSBY option is not specified, then the particular row and column levels might \nbe different among the groups based on which values of the row and column variables occur in each \ngroup."},"StatementOptionType":"S"},{"StatementOptionName":"AGGREGATE=|AGG=","StatementOptionHelp":{"#cdata":"Syntax: AGGREGATE=(statistic(s)) \n\nSpecifies the statistics to use as aggregation methods for which crosstabulations are computed \nwhen a WEIGHT variable is also specified. If no WEIGHT variable is specified, then the N aggregator \nis applied. In other words, the crosstabulation shows the frequency with which the values occur when \nno WEIGHT variable is specified. If you specify multiple aggregation methods, then the server computes \na crosstabulation for each method. \n\nThe available aggregation methods are as follows: \n\n  CSS corrected sum of squares \n  CV coefficient of variation \n  MAX maximum value \n  MEAN arithmetic mean \n  MIN minimum value \n  N number of observations \n  PROBT p-value for the t-statistic  \n  STD standard deviation \n  STDERR standard error \n  SUM sum of the nonmissing values \n  TSTAT t-statistic for the null hypothesis that the mean equals zero  \n  USS uncorrected sum of squares \n  VAR sample variance"},"StatementOptionType":"V"},{"StatementOptionName":"ASSOCIATION|MEASURES","StatementOptionHelp":{"#cdata":"Specifies to calculate the measures of association between the row and column variable of the cross \ntabulation. The option generates the following measures: the Gamma statistic, Kendall's Tau-b, \nStuart's Tau-c, Somers' measures, Lambda measures, and uncertainty measures."},"StatementOptionType":"S"},{"StatementOptionName":"CHISQ","StatementOptionHelp":{"#cdata":"Computes Chi-square statistics for the test of independence of the row and column variables and \ntheir asymptotic p-values. The option calculates the Pearson Chi-square statistic as well as the \nlikelihood-ratio test."},"StatementOptionType":"S"},{"StatementOptionName":"COLBINS=|XBINS=","StatementOptionHelp":{"#cdata":"Syntax: COLBINS=b\n\nSpecifies the number of bins to use in binning the column variable."},"StatementOptionType":"V"},{"StatementOptionName":"DESCENDING|DESC","StatementOptionHelp":{"#cdata":"Specifies that the levels of the GROUPBY variables are to be arranged in descending order."},"StatementOptionType":"S"},{"StatementOptionName":"FORMATS=","StatementOptionHelp":{"#cdata":"Syntax: FORMATS=(\"format-specification\",...) \n\nSpecifies the formats for the GROUPBY= variables. If you do not specify the FORMATS= option, \nor if you omit the entry for a GROUPBY variable, the default format is applied for that variable. \n\nEnclose each format specification in quotation marks and separate each format specification with a comma."},"StatementOptionType":"V"},{"StatementOptionName":"GROUPBY=","StatementOptionHelp":{"#cdata":"Syntax: GROUPBY=(variable-list) \n\nSpecifies a list of variable names, or a single variable name, to use as GROUPBY variables in the order \nof the grouping hierarchy. If you do not specify any GROUPBY variable names, then the calculation is \nperformed across the entire table\u2014possibly subject to a WHERE clause."},"StatementOptionType":"V"},{"StatementOptionName":"GROUPBYLIMIT=","StatementOptionHelp":{"#cdata":"Syntax: GROUPBYLIMIT=n\n\nSpecifies the maximum number of levels in a GROUPBY set. When the software determines that there \nare at least n levels in the GROUPBY set, it abandons the action, returns a message, and does not \nproduce a result set. You can specify the GROUPBYLIMIT= option if you want to avoid creating \nexcessively large result sets in GROUPBY operations."},"StatementOptionType":"V"},{"StatementOptionName":"MARGINS=","StatementOptionHelp":{"#cdata":"Syntax: MARGINS= ROW | COL | ALL | NONE\n\nSpecifies whether to calculate marginal values in addition to the crosstabulation. The default \nis MARGINS=NONE, which specifies that no marginal values are calculated. The MARGINS=ROW setting \ncalculates margins for the row variable only. The MARGINS=COL setting calculates margins for the \ncolumn variable only. The MARGINS=ALL setting calculates row margins, column margins, and the \noverall margin. \n\nThese calculations are repeated for each aggregate method in the CROSSTAB request. \n\nDefault NONE"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"ROW","@Value2":"COL","@Value3":"ALL","@Value4":"NONE"},"StatementOptionToolTips":{"@ToolTip1":"The MARGINS=ROW setting calculates margins for the row variable only.","@ToolTip2":"The MARGINS=COL setting calculates margins for the column variable only.","@ToolTip3":"The MARGINS=ALL setting calculates row margins, column margins, and the overall margin.","@ToolTip4":"Specifies that no marginal values are calculated."}},{"StatementOptionName":"MERGEBINS=","StatementOptionHelp":{"#cdata":"Syntax: MERGEBINS=b\n\nSpecifies the number of bins to create when a numeric GROUPBY variable exceeds the MERGELIMIT=n \nspecification. If you specify a MERGELIMIT, but do not specify a value for the MERGEBINS= option, \nthe server automatically calculates the number of bins."},"StatementOptionType":"V"},{"StatementOptionName":"MERGELIMIT=","StatementOptionHelp":{"#cdata":"Syntax: MERGELIMIT=n\n\nSpecifies that when the number of unique values in a numeric GROUPBY variable exceeds n, the variable \nis automatically binned and the GROUPBY structure is determined based on the binned values of the variable, \nrather than the unique formatted values."},"StatementOptionType":"V"},{"StatementOptionName":"NOEMPTY|FULLCELL","StatementOptionHelp":{"#cdata":"\n\nSpecifies that empty cells are not returned to the SAS session (only full cells are returned). \nWhen this option is specified, the server arranges the results into a vector of nonzero values \nwith row and column indices. This sparse storage is memory efficient when the table has many \nempty cells."},"StatementOptionType":"S"},{"StatementOptionName":"NOPREPARSE|NOPREP","StatementOptionHelp":{"#cdata":"Prevents the procedure from preparsing and pregenerating code for temporary expressions, scoring \nprograms, and other user-written SAS statements. \n\nWhen this option is specified, the user-written statements are sent to the server \"as is\" and then \nthe server attempts to generate code from it. If the server detects problems with the code, the error \nmessages might not to be as detailed as the messages that are generated by SAS client. If you are \ndebugging your user-written program, then you might want to preparse and pregenerate code in the \nprocedure. However, if your SAS statements compile and run as you want them to, then you can specify \nthis option to avoid the work of parsing and generating code on the SAS client. \n\nWhen you specify this option in the PROC IMSTAT statement, the option applies to all statements that \ncan generate code. You can also exclude specific statements from preparsing by using the NOPREPARSE \noption in statements that allow temporary columns or the SCORE statement."},"StatementOptionType":"S"},{"StatementOptionName":"NOTEMPPART|NOTP","StatementOptionHelp":{"#cdata":"Specifies that the temporary table generated by the TEMPTABLE option is not partitioned by the GROUPBY= \nvariables. When you request a temporary table with the CROSSTAB statement, by default, the server creates \na partitioned table. When the number of groups is large, this can result in many small partitions, and \nrequires extra memory resources to store the partition information for the temporary table. By specifying \nthis option, the temporary table is organized similarly to the default table, but is not a partitioned table."},"StatementOptionType":"S"},{"StatementOptionName":"PARTITION|PART","StatementOptionHelp":{"#cdata":"Syntax: PARTITION <=partition-key>\n\nWhen you specify this option and the table is partitioned, the results are calculated separately \nfor each value of the partition key. In other words, the partition variables function as automatic \nGROUPBY variables. This mode of executing calculations by partition is more efficient than using the \nGROUPBY= option. With a partitioned table, the server takes advantage of knowing that observations for \na partition cannot be located on more than one worker node. \n\nIf you do not specify a partition-key, the analysis is performed for all partitions. If you do specify \na partition-key, the analysis is carried out for the specified key value only. You can use the PARTITIONINFO \nstatement to retrieve the valid partition key values for a table. \n\nYou can specify a partition-key in two ways. You can supply a single quoted string that is passed to the \nserver, or you can specify the elements of a composite key separated by commas."},"StatementOptionType":"S|V"},{"StatementOptionName":"RAWORDER","StatementOptionHelp":{"#cdata":"Specifies that the ordering of the GROUPBY variables is based on the raw values of the variables \ninstead of the formatted values."},"StatementOptionType":"S"},{"StatementOptionName":"ROWBINS=|YBINS=","StatementOptionHelp":{"#cdata":"Syntax: ROWBINS=n\n\nSpecifies the number of bins to use for binning the row variable."},"StatementOptionType":"V"},{"StatementOptionName":"SAVE=","StatementOptionHelp":{"#cdata":"Syntax: SAVE=table-name\n\nSaves the result table so that you can use it in other IMSTAT procedure statements like STORE, REPLAY, \nand FREE. The value for table-name must be unique within the scope of the procedure execution. The name \nof a table that has been freed with the FREE statement can be used again in subsequent SAVE= options."},"StatementOptionType":"V"},{"StatementOptionName":"SETSIZE","StatementOptionHelp":{"#cdata":"Requests that the server estimate the size of the result set. The procedure does not create a result \ntable if the SETSIZE option is specified. Instead, the procedure reports the number of rows that are \nreturned by the request and the expected memory consumption for the result set (in KB). If you specify \nthe SETSIZE option, the SAS log includes the number of observations and the estimated result set size."},"StatementOptionType":"S"},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary variables \nor a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPTABLE","StatementOptionHelp":{"#cdata":"Generates an in-memory temporary table from the result set. The IMSTAT procedure displays the name \nof the table and stores it in the &_TEMPLAST_ macro variable, provided that the statement executed \nsuccessfully. \n\nWhen the IMSTAT procedure exits, all temporary tables created during the IMSTAT session are removed. \nTemporary tables are not displayed on a TABLEINFO request, unless the temporary table is the active \ntable for the request. \n\nInteraction The TEMPTABLE option requires a group-by analysis or a partitioned analysis with this \nstatement."},"StatementOptionType":"S"},{"StatementOptionName":"WEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT=variable-name\n\nSpecifies the numeric weight variable to use for calculating the statistics in the table cell and \nthe margins of the table. If no WEIGHT variable is specified, then the only aggregate method that \nis available to the CROSSTAB statement is N. In this case, then number of observations (frequency) \nis reported in each table cell."},"StatementOptionType":"V"}]}},{"StatementName":"DECISIONTREE","StatementHelp":{"#cdata":"Syntax: DECISIONTREE target-variable </ options>; \n      \nThe DECISIONTREE statement provides an implementation of a C4.5 decision tree method for classification. \nYou specify a single column as the target variable when you generate the decision tree. You can also score \nagainst the generated tree."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ASSESS","StatementOptionHelp":{"#cdata":"Specifies that predicted probabilities are added to the temporary result table for the event levels. \nYou can use these predicted probabilities in an ASSESS statement."},"StatementOptionType":"S"},{"StatementOptionName":"CODE","StatementOptionHelp":{"#cdata":"Syntax: CODE <(code-generation-options)>\n\nRequests that the server produce SAS scoring code based on the actions that it performed during the \nanalysis. The server generates DATA step code. By default, the code is replayed as an ODS table by \nthe procedure as part of the output of the statement. More frequently, you might want to write the \nscoring code to an external file by specifying options.\n\nCOMMENT\n  specifies to add comments to the code in addition to the header block. The header block is added by default. \nFILENAME=|FILE='path' \n  specifies the name of the external file to which the scoring code is written. This suboption applies only \n  to the scoring code itself. \nFORMATWIDTH=|FMTW=k\n  specifies the width to use in formatting derived numbers such as parameter estimates in the scoring code. \n  The server applies the BEST format, and the default format for code generation is BEST20. Range: 4 to 32\nLABELID=id\n  specifies a group identifier for group processing. The identifier is an integer and is used to create array \n  names and statement labels in the generated code. \nLINESIZE=|LS=n\n  specifies the line size for the generated code. \n  Default: 72 \n  Range: 64 to 256\nNOTRIM\n  specifies to format the variables using the full format width with padding. By default, leading and trailing \n  blanks are removed from the formatted values. \nREPLACE\n  specifies to overwrite the external file if a file with the specified name already exists. The option \n  has no effect unless you specify the FILENAME= option."},"StatementOptionType":"S","SubOptionsKeywords":"COMMENT|FILENAME=|FILE=|FORMATWIDTH=|FMTW=|LABELID=|LINESIZE=|NOTRIM|REPLACE"},{"StatementOptionName":"CFLEV=","StatementOptionHelp":{"#cdata":"Syntax: CFLEV=number\n\nSpecifies a value between 0 and 1 that controls the aggressiveness of tree pruning according to the \nC4.5 algorithm. Smaller numbers indicate to more aggressive pruning. See the  PRUNE option."},"StatementOptionType":"V"},{"StatementOptionName":"DETAIL","StatementOptionHelp":{"#cdata":"Requests detailed information about the classification results when scoring a table against a previously \ncalculated tree."},"StatementOptionType":"S"},{"StatementOptionName":"FORMATS=","StatementOptionHelp":{"#cdata":"Syntax: FORMATS=(\"format-specification\",...) \n\nSpecifies the formats for the input variables. If you do not specify the FORMATS= option, the default \nformat is applied for that variable. \n\nEnclose each format specification in quotation marks and separate each format specification with a comma."},"StatementOptionType":"V"},{"StatementOptionName":"GAIN","StatementOptionHelp":{"#cdata":"Specifies that the splitting criterion is changed to information gain. Typically, this criterion \nintends to generate trees with more nodes than information gain ratio."},"StatementOptionType":"S"},{"StatementOptionName":"GREEDY","StatementOptionHelp":{"#cdata":"Specifies how to perform splitting under specific circumstances. \n\nAssuming that one variable has q levels, when binary splitting is performed and q is less than 15, \nor option MAXBRANCH > 2 and q < 12, all possible binary splits are enumerated and the split with \nthe largest gain or gain ratio is chosen for the variable. \n\nWhen q is less than 1024 and splitting is not just binary, local greedy searches are applied to \ndetermine the optimum local split. Specifically, when the variable is numeric, q levels (similar \nto q bins) are sorted by value. \n\nWhen the variable is nominal, the q levels are ordered by random weights. The best binary splitting \nis applied until the desired number of branches is reached. Only a local optimum can be found with \nthis technique. \n\nFor values of q \u2265 1024, the default k-means clustering algorithm is applied to determine the splits."},"StatementOptionType":"S"},{"StatementOptionName":"IMPUTE","StatementOptionHelp":{"#cdata":"Specifies how to treat observations with nonmissing values for the target variable during scoring. \nWhen this option is specified, the observed values are used as the predicted values. That is, the \nobserved value is assumed to be known without error. Only the observations with missing values for \nthe target variable are then scored against the decision tree based on their values for the input \nvariables. \n\nThe IMPUTE option is useful if you want to replace missing values of a target variable with classified \nvalues based on the decision tree."},"StatementOptionType":"S"},{"StatementOptionName":"INPUT=","StatementOptionHelp":{"#cdata":"Syntax: INPUT=variable-name\n\nINPUT=(variable-name1 <variable-name2, ...>) \n\nSpecifies the variables to use for building the tree. You can add the target variable to the input \nlist if you want to assign a format to the target variable by using the FORMATS= option. Any numeric \nvariable that is not specified in the NOMINAL= option is binned according to the NBINS= specification."},"StatementOptionType":"V"},{"StatementOptionName":"LEAFSIZE=","StatementOptionHelp":{"#cdata":"Syntax: LEAFSIZE=m\n\nSpecifies the minimal number of observations on each node. When the number of observations on a tree \nnode is less than m, the node is changed to a leaf during the building of the decision tree. \n\nInteraction Specifying the LEAFSIZE option affects the pruning of the tree."},"StatementOptionType":"V"},{"StatementOptionName":"MAXBRANCH=","StatementOptionHelp":{"#cdata":"Syntax: MAXBRANCH=n\n\nSpecifies the maximum number of children (branches) to allow for each level of the tree. \n\nDefault 2"},"StatementOptionType":"V"},{"StatementOptionName":"MAXLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: MAXLEVEL=n\n\nSpecifies the maximum number of the tree level. \n\nDefault 6"},"StatementOptionType":"V"},{"StatementOptionName":"MULTVAR","StatementOptionHelp":{"#cdata":"Specifies to allow a variable to appear multiple times when traversing the tree from top to bottom."},"StatementOptionType":"S"},{"StatementOptionName":"NBINS=","StatementOptionHelp":{"#cdata":"Syntax: NBINS=k\n\nSpecifies the number of bins to use in the calculation of the decision tree. The number of bins affects \nthe accuracy of the tree. The accuracy increases as values of k increase. However, computing time and \nmemory consumption also increase as values of k increase."},"StatementOptionType":"V"},{"StatementOptionName":"NBINSTARGET=","StatementOptionHelp":{"#cdata":"Syntax: NBINSTARGET=k\n\nSpecifies the number of bins to use for a numeric target variable. The number of bins affects the \naccuracy of the tree. The accuracy increases as values of k increase. However, computing time and \nmemory consumption also increase as values of k increase. When k is greater than zero, the numeric \ntarget variable is binned into equally sized bins first and then the bins are used to perform the \nclassification. \n\nDefault 0"},"StatementOptionType":"V"},{"StatementOptionName":"NOMINAL=","StatementOptionHelp":{"#cdata":"Syntax: NOMINAL=variable-name\n\nNOMINAL=(variable-list) \n\nSpecifies the numeric variables to use as nominal variables. Binning is not applied to the specified \nvariables. The target variable is always treated as a nominal variable and does not need to be listed."},"StatementOptionType":"V"},{"StatementOptionName":"NOMISSOBS","StatementOptionHelp":{"#cdata":"Specifies to ignore observations that have missing values in the analysis variables when building a \ndecision tree. When scoring a data set, any observations with missing values in the analysis variables \nfor the decision tree are ignored when this option is specified. \n\nWhen this option is not specified, the RANDOMWOODS statement builds a tree by applying the following policy for missing values: \n\n\u2022 for an interval variable, the smallest machine value is assigned \n \n\u2022 for a nominal variable, missing values are represented by a separate level"},"StatementOptionType":"S"},{"StatementOptionName":"NOPREPARSE|NOPREP","StatementOptionHelp":{"#cdata":"Prevents the procedure from preparsing and pregenerating code for temporary expressions, scoring programs, \nand other user-written SAS statements. \n\nWhen this option is specified, the user-written statements are sent to the server \"as is\" and then the \nserver attempts to generate code from it. If the server detects problems with the code, the error messages \nmight not to be as detailed as the messages that are generated by SAS client. If you are debugging your \nuser-written program, then you might want to preparse and pregenerate code in the procedure. However, \nif your SAS statements compile and run as you want them to, then you can specify this option to avoid \nthe work of parsing and generating code on the SAS client. \n\nWhen you specify this option in the PROC IMSTAT statement, the option applies to all statements that \ncan generate code. You can also exclude specific statements from preparsing by using the NOPREPARSE \noption in statements that allow temporary columns or the SCORE statement."},"StatementOptionType":"S"},{"StatementOptionName":"NOPRUNEOBS","StatementOptionHelp":{"#cdata":"Specifies not to prune any observations when building a decision tree."},"StatementOptionType":"S"},{"StatementOptionName":"NOSCORE","StatementOptionHelp":{"#cdata":"Suppresses the generation of the scoring temporary table when the TEMPTABLE option is specified. In \nthis case, the server generates only one temporary table and the table contains the decision tree."},"StatementOptionType":"S"},{"StatementOptionName":"PRUNE","StatementOptionHelp":{"#cdata":"Requests to prune the tree according to the C4.5 algorithm. Pruning can increase the error of \nmisclassification. You can control the aggressiveness of pruning with the CFLEV= option. \nSmaller values for the CFLEV= option result in more aggressive pruning."},"StatementOptionType":"S"},{"StatementOptionName":"PRUNEGROW","StatementOptionHelp":{"#cdata":"Specifies to enable C4.5 pruning when building a classification decision tree. The tree could have \nlarge a misclassification rate but the building process is performed quickly."},"StatementOptionType":"S"},{"StatementOptionName":"REG","StatementOptionHelp":{"#cdata":"Specifies to build a regression tree. Minimal cost-complexity pruning is applied to prune the tree."},"StatementOptionType":"S"},{"StatementOptionName":"SAVE=","StatementOptionHelp":{"#cdata":"Syntax: SAVE=table-name\n\nSaves the result table so that you can use it in other IMSTAT procedure statements like STORE, \nREPLAY, and FREE. The value for table-name must be unique within the scope of the procedure \nexecution. The name of a table that has been freed with the FREE statement can be used again \nin subsequent SAVE= options."},"StatementOptionType":"V"},{"StatementOptionName":"SCOREDATA=","StatementOptionHelp":{"#cdata":"Syntax: SCOREDATA=table-name\n\nSpecifies the in-memory table that contains the scoring data. The table must exist in-memory on the \nserver. The DECISIONTREE statement in the IMSTAT procedure does not transfer a local data set to the \nserver."},"StatementOptionType":"V"},{"StatementOptionName":"SETSIZE","StatementOptionHelp":{"#cdata":"Requests that the server estimate the size of the result set. The procedure does not create a result \ntable if the SETSIZE option is specified. Instead, the procedure reports the number of rows that \nare returned by the request and the expected memory consumption for the result set (in KB). If \nyou specify the SETSIZE option, the SAS log includes the number of observations and the estimated \nresult set size."},"StatementOptionType":"S"},{"StatementOptionName":"STAT","StatementOptionHelp":{"#cdata":"Specifies to generate two additional tables that contain statistical information about the variables \nthat are used in the decision tree. One table contains the variable importance information, which is \ndetermined by the total Gini reduction. The second table contains the variable splitting information \nfor each node in the decision tree."},"StatementOptionType":"S"},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary variables \nor a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPTABLE","StatementOptionHelp":{"#cdata":"Specifies to store the results in a temporary table. The type of information that is stored depends \non whether you are building a decision tree or scoring a table with a decision tree. \n\nWhen you are building a decision tree, the generated decision tree is stored in the server and the \ninput table is automatically scored using this tree. The scoring details are saved in a temporary \ntable. The _TEMPTREE_ macro variable stores the name of the temporary table for the tree. The \n_TEMPSCORE_ macro variable stores the name of the temporary table that has the scoring results of \ntraversing the decision tree. You can suppress the generation of the scoring temporary table \n(_TEMPSCORE_) during the tree building phase by specifying the NOSCORE option. \n\nWhen you are scoring a table using a decision tree, the TEMPTABLE option requests to store the \nscoring details in a temporary table in the server. The IMSTAT procedure displays the name of the \ntable and stores it in the _TEMPSCORE_ macro variable. Be aware that the DETAIL option can generate \na very large amount of scoring results when the in-memory table that is specified in the SCOREDATA= \noption is large. Observations from the scored data set can be transferred to the temporary table using \nthe VARS= option."},"StatementOptionType":"S"},{"StatementOptionName":"TIMEOUT=","StatementOptionHelp":{"#cdata":"Syntax: TIMEOUT=s\n\nSpecifies the maximum number of seconds that the server should run the statement. If the time-out \nis reached, the server terminates the request and generates an error and error message. By default, \nthere is no time-out."},"StatementOptionType":"V"},{"StatementOptionName":"TREEDATA=|TREETAB=|TREELASRTAB=|SCORETAB=","StatementOptionHelp":{"#cdata":"Syntax: TREEDATA=libref.member-name\n\nTREETAB=saved-table\nTREELASRTAB=table-name\n\nSpecifies the saved table that contains the generated tree. In order to score a (validation) data \nset against the generated tree, you need the validation data and a representation of the tree. \nSpecify these options as follows: \n\n\u2022 The TREEDATA= option is used to specify the name of a SAS data set that stores the generated tree. \n  The data set is local to the SAS client.  \n\u2022 The TREETAB= option is used to specify a table on the SAS client that stores the generated tree.  \n\u2022 The TREELASRTAB= option is used to specify a valid decision tree that is stored in an in-memory table. \n \nThe data set with the observations to score is specified in the SCOREDATA= option."},"StatementOptionType":"V"},{"StatementOptionName":"VARS=","StatementOptionHelp":{"#cdata":"Syntax: VARS=variable-name\n\nVARS=(variable-name1 <variable-name2, ...>) \n\nSpecifies the variables to transfer from the input table to the temporary table in the server that \ncontains the results of scoring a decision tree. This option has no effect unless you specify the \nTEMPTABLE option and you score a decision tree."},"StatementOptionType":"V"}]}},{"StatementName":"DISTINCT","StatementHelp":{"#cdata":"Syntax: DISTINCT <variable-list> </ options>;\n      \nThe DISTINCT statement calculates the count of unique raw values of variables. You can specify \nthe variables to calculate in the variable list. If no list is specified, the count of unique \nraw values is calculated for all variables. "},"StatementOptions":{"StatementOption":[{"StatementOptionName":"FORMATS=","StatementOptionHelp":{"#cdata":"Syntax: FORMATS=(\"format-specification\",...) \n\nSpecifies the formats for the GROUPBY= variables. If you do not specify the FORMAT= option, \nor if you do not specify the GROUPBY= option, the default format is applied for that variable. \n\nEnclose each format specification in quotation marks and separate each format specification with a comma."},"StatementOptionType":"V"},{"StatementOptionName":"GROUPBY=","StatementOptionHelp":{"#cdata":"Syntax: GROUPBY=(variable-list) \n\nSpecifies a list of variable names, or a single variable name, to use as GROUPBY variables in the \norder of the grouping hierarchy. If you do not specify any GROUPBY variable names, then the calculation \nis performed across the entire table\u2014possibly subject to a WHERE clause."},"StatementOptionType":"V"},{"StatementOptionName":"GROUPBYLIMIT=","StatementOptionHelp":{"#cdata":"Syntax: GROUPBYLIMIT=n\n\nSpecifies the maximum number of levels in a GROUPBY set. When the software determines that there \nare at least n levels in the GROUPBY set, it abandons the action, returns a message, and does not \nproduce a result set. You can specify the GROUPBYLIMIT= option if you want to avoid creating excessively \nlarge result sets in GROUPBY operations."},"StatementOptionType":"V"},{"StatementOptionName":"GROUPFILTER=","StatementOptionHelp":{"#cdata":"Syntax: GROUPFILTER=(filter-options) \n\nSpecifies a section of the group-by hierarchy to be included in the computation. With this option, \nyou can request that the server performs the analysis for only a subset of all possible groupings. \nThe subset is determined by applying the group filter to a temporary table that you generate with \nthe GROUPBY statement. \n\nYou can specify the following suboptions in the GROUPFILTER option: \n\nDESCENDING | DESC - specifies the top section or the bottom section of the groupings to be collected. \nLIMIT=n - specifies the maximum number of distinct groupings to be collected, where integer n >= 0. \nSCOREGT=f | SGT=f - specifies the exclusive lower bound for the numeric scores of the distinct groupings to collect. \nSCORELT=f | SLT= - specifies the exclusive upper bound for the numeric scores of the distinct groupings to collect. \nVALUEGT=(\"format-name1\" <, \"format-name2\" ...>) | VGT=\n  - specifies the exclusive lower bound of the group-by variable\u2019s formatted values for the distinct groupings to collect. \nVALUELT=(\"format-name1\" <, \"format-name2\" ...>)  | VLT=\n  - specifies the exclusive upper bound of the group-by variable\u2019s formatted values for the distinct groupings to collect. \nTABLE=table-with-groupby-results\n  - specifies the in-memory table from which to load the group-by hierarchy. \n  \nInteraction: If you specify the GROUPFILTER= option, then the GROUPBY= and FORMATS= options have no effect."},"StatementOptionType":"V","SubOptionsKeywords":"DESCENDING|DESC|LIMIT=|SCOREGT=|SGT=|SCORELT=|SLT=|VALUEGT=|VGT=|VALUELT=|VLT=|TABLE="},{"StatementOptionName":"MAXNVALS=","StatementOptionHelp":{"#cdata":"Syntax: MAXNVALS=n\n\nSpecifies the maximum size that trees are allowed to consume during the calculation of distinct counts. \nIf you execute a DISTINCT statement with a GROUPBY= or PARTITION= option, then the MAXNVALS limit applies \nwithin the groups or partitions. \n\nDefault 6"},"StatementOptionType":"V"},{"StatementOptionName":"NOMISSING|NOMISS","StatementOptionHelp":{"#cdata":"\n\nSpecifies that you do not want to include missing values in the determination of the distinct count."},"StatementOptionType":"S"},{"StatementOptionName":"NOPREPARSE|NOPREP","StatementOptionHelp":{"#cdata":"Prevents the procedure from preparsing and pregenerating code for temporary expressions, scoring \nprograms, and other user-written SAS statements. \n\nWhen this option is specified, the user-written statements are sent to the server \"as is\" and then \nthe server attempts to generate code from it. If the server detects problems with the code, the error \nmessages might not to be as detailed as the messages that are generated by SAS client. If you are \ndebugging your user-written program, then you might want to preparse and pregenerate code in the \nprocedure. However, if your SAS statements compile and run as you want them to, then you can specify \nthis option to avoid the work of parsing and generating code on the SAS client. \n\nWhen you specify this option in the PROC IMSTAT statement, the option applies to all statements that \ncan generate code. You can also exclude specific statements from preparsing by using the NOPREPARSE \noption in statements that allow temporary columns or the SCORE statement."},"StatementOptionType":"S"},{"StatementOptionName":"NOTEMPPART|NOTP","StatementOptionHelp":{"#cdata":"Specifies that the temporary table generated by the TEMPTABLE option is not partitioned by the GROUPBY= \nvariables. When you request a temporary table with the CROSSTAB statement, by default, the server creates \na partitioned table. When the number of groups is large, this can result in many small partitions, and \nrequires extra memory resources to store the partition information for the temporary table. By specifying \nthis option, the temporary table is organized similarly to the default table, but is not a partitioned table."},"StatementOptionType":"S"},{"StatementOptionName":"ORDERBY=","StatementOptionHelp":{"#cdata":"Syntax: ORDERBY=(variable-list) \n\nSpecifies one or more variables by which to order the result set. The variables specified in \nvariable-list are either one or more of the GROUPBY= variables or one or more of the analysis \nvariables. If you specify an incorrect variable, the server returns an error and no result set. \nSeparate multiple variables with a space."},"StatementOptionType":"V"},{"StatementOptionName":"ORDERBYDESC","StatementOptionHelp":{"#cdata":"Specifies the sort order for the result set. The default is ascending order. Specifying this option \narranges the results in descending order. This option has no effect unless you specify the ORDERBY= option."},"StatementOptionType":"S"},{"StatementOptionName":"PARTITION","StatementOptionHelp":{"#cdata":"Syntax: PARTITION <=partition-key>\n\nWhen you specify this option and the table is partitioned, the results are calculated separately \nfor each value of the partition key. In other words, the partition variables function as automatic \nGROUPBY variables. This mode of executing calculations by partition is more efficient than using the \nGROUPBY= option. With a partitioned table, the server takes advantage of knowing that observations for \na partition cannot be located on more than one worker node. \n\nIf you do not specify a partition-key, the analysis is performed for all partitions. If you do specify \na partition-key, the analysis is carried out for the specified key value only. You can use the PARTITIONINFO \nstatement to retrieve the valid partition key values for a table. \n\nYou can specify a partition-key in two ways. You can supply a single quoted string that is passed to the \nserver, or you can specify the elements of a composite key separated by commas."},"StatementOptionType":"S|V"},{"StatementOptionName":"RESULTLIMIT=","StatementOptionHelp":{"#cdata":"Syntax: RESULTLIMIT=k\n\nSpecifies that the number of items that are returned to the client is limited to k times the number \nof analysis variables if you also specify the GROUPBY= or ORDERBY= option."},"StatementOptionType":"V"},{"StatementOptionName":"SAVE=","StatementOptionHelp":{"#cdata":"Syntax: SAVE=table-name\n\nSaves the result table so that you can use it in other IMSTAT procedure statements like STORE, REPLAY, \nand FREE. The value for table-name must be unique within the scope of the procedure execution. The name \nof a table that has been freed with the FREE statement can be used again in subsequent SAVE= options."},"StatementOptionType":"V"},{"StatementOptionName":"SETSIZE","StatementOptionHelp":{"#cdata":"Requests that the server estimate the size of the result set. The procedure does not create a result \ntable if the SETSIZE option is specified. Instead, the procedure reports the number of rows that are \nreturned by the request and the expected memory consumption for the result set (in KB). If you specify \nthe SETSIZE option, the SAS log includes the number of observations and the estimated result set size."},"StatementOptionType":"S"},{"StatementOptionName":"SORTAGG=","StatementOptionHelp":{"#cdata":"Syntax: SORTAGG=aggregation-method\n\nSpecifies the aggregator for which the ordering of the result set is based, if the ORDERBY= option is specified. \n\nThe available aggregation methods are as follows: \n\n  N number of observations \n  NMISS number of missing observations \n\nInteraction: You must specify the ORDERBY= option to use this option."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"N","@Value2":"NMISS"},"StatementOptionToolTips":{"@ToolTip1":"Number of observations","@ToolTip2":"Number of missing observations"}},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary variables \nor a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPTABLE","StatementOptionHelp":{"#cdata":"Generates an in-memory temporary table from the result set. The IMSTAT procedure displays the name \nof the table and stores it in the &_TEMPLAST_ macro variable, provided that the statement executed \nsuccessfully. \n\nWhen the IMSTAT procedure exits, all temporary tables created during the IMSTAT session are removed. \nTemporary tables are not displayed on a TABLEINFO request, unless the temporary table is the active \ntable for the request. \n\nInteraction The TEMPTABLE option requires a group-by analysis or a partitioned analysis with this statement."},"StatementOptionType":"S"},{"StatementOptionName":"VARFORMATS=","StatementOptionHelp":{"#cdata":"Syntax: VARFORMATS=(\"format-specification\",...) \n\nSpecifies the formats for the analysis variables. If you do not specify this option, the distinct \ncount is based on the number of distinct unformatted values of a variable. Note that the FORMATS= \noption controls the formatting of the GROUPBY= variables and the VARFORMATS= option controls the \nformatting of the analysis variables. It is possible to specify a different format for a variable \nif it appears as a GROUPBY variable and as an analysis variable. \n\nYou can specify a combination of formatted and unformatted value counts by submitting an empty \nstring as the format for variables that you do not wish to format. For example, in the following \ncode the distinct count of variable Invoice is based on the formatted values according to the \nuser-defined format PRICE20. The distinct count of variable Msrp is based on its unformatted values. \n\nExample:\nproc imstat data=example.cars;\n   distinct msrp invoice / varformats=(\"\", \"PRICE20\");\nrun;"},"StatementOptionType":"V"}]}},{"StatementName":"FORECAST","StatementHelp":{"#cdata":"Syntax: FORECAST timestamp-variable </ options>; \nFORECAST DATA=libref.member-name timestamp-variable </ options>; \n\ntimestamp-variable\n  specifies the name of the SAS datetime variable to use. \n\nThe FORECAST statement computes predicted values, measures of precision, and confidence limits for \nobserved and future (forecast) values of a time series. The models generated by the FORECAST statement \nbelong to the exponential smoothing method (ESM) and autoregressive integrated moving average (ARIMA) families."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"DATA=","StatementOptionHelp":{"#cdata":"Syntax: DATA=libref.member-name\n\nSpecifies the libref and table name of a SAS data set when you specify the DATA= option. The data set \nmust contain the timestamp variable and one or more of the analysis variables. The procedure then sends \nthese values to the server to request the forecast calculation. With this option, there is no aggregation, \nas the values read from the data set are assumed to constitute the series of interest."},"StatementOptionType":"RV"},{"StatementOptionName":"AGGREGATE=|AGG=","StatementOptionHelp":{"#cdata":"Syntax: AGGREGATE=(aggregation-methods) \n\nSpecifies the aggregate method on which the ordering of the result set is based. The available \naggregation methods are as follows: \n\n  CSS corrected sum of squares \n  CV coefficient of variation \n  MAX maximum value \n  MEAN arithmetic mean \n  MIN minimum value \n  N number of observations\n  PROBT p-value for the t-statistic  \n  STD standard deviation \n  STDERR standard error \n  SUM sum of the nonmissing values \n  TSTAT t-statistic for the null hypothesis that the mean equals zero  \n  USS uncorrected sum of squares \n  VAR sample variance"},"StatementOptionType":"V"},{"StatementOptionName":"CONTROLVARS=|CONTROL=","StatementOptionHelp":{"#cdata":"Syntax: CONTROLVARS=(variable1-name <variable2-name...>) \n\nSpecifies the controllable variables used in goal seeking. Control variables act like independent \nvariables in the automatic modeling step. Only control variables are passed to the optimization step \nin goal seeking. The optimization determines the best values for the control variables that meet the \nvalues of the GOAL= variable. \n\nVariables listed as control variables cannot appear in the list of independent variables. \n\nWhen you also specify INDEP= variables, the goal-seeking analysis gives precedence to controllable \nvariables over non-controllable (specified with the INDEP= option) for its variable selection. \nRelative precedence of controllable variables is maintained, as is relative precedence of non-\ncontrollable variables."},"StatementOptionType":"V"},{"StatementOptionName":"FORMATS=","StatementOptionHelp":{"#cdata":"Syntax: FORMATS=(\"format-specification\",...) \n\nSpecifies the format for the time stamp variable. The observations are grouped by the formatted \nvalues of the time stamp variable. If multiple values map to the same formatted value, the smallest \nis kept as the representative value. These values form the time stamps for the forecast. \n\nIf you do not specify the FORMATS= option, the default format is applied for the time stamp variable. \n\nInteraction: This option has no effect if you specify a data set with the DATA= option."},"StatementOptionType":"V"},{"StatementOptionName":"FRAME=|WINDOW=","StatementOptionHelp":{"#cdata":"Syntax: FRAME=LEAD | HORIZON\nFRAME=TAIL | HISTORY\nFRAME=BOTH\n\nSpecifies how to compose the main result table. The default is FRAME=BOTH and the result set contains \nthe observed series (the history) as well as the forecast (the horizon). If you specify FRAME=LEAD (or \nFRAME=HORIZON), then only the future values are returned. You can control the length of the horizon with \nthe LEAD= option. \n\nIf you specify FRAME=TAIL (or FRAME=HISTORY), then only the results for the historic values are returned. \nThe returned values are the aggregated values, their predicted values, residuals, prediction standard \nerrors, and confidence limits. You can control the number of the historical records with the TAIL= option. \n\nDefault: BOTH"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"LEAD|HORIZON","@Value2":"TAIL|HISTORY","@Value3":"BOTH"},"StatementOptionToolTips":{"@ToolTip1":"If you specify FRAME=LEAD (or FRAME=HORIZON), then only the future values are returned. You can  control the length of the horizon with the LEAD= option.","@ToolTip2":"If you specify FRAME=TAIL (or FRAME=HISTORY), then only the results for the historic values are returned.  The returned values are the aggregated values, their predicted values, residuals, prediction standard  errors, and confidence limits. You can control the number of the historical records with the TAIL= option.","@ToolTip3":"The result set contains the observed series (the history) as well as the forecast (the horizon)."}},{"StatementOptionName":"GOALVAR=|GOAL=","StatementOptionHelp":{"#cdata":"Syntax: GOALVAR=variable-name\n\nSpecifies the variable in the active table that contains the goal (the desired forecast) for goal seeking. \n\nInteraction: You must use the DATA= option to perform forecasting with goal seeking."},"StatementOptionType":"V"},{"StatementOptionName":"HOST=","StatementOptionHelp":{"#cdata":"Syntax: HOST=\"host-name\" \n\nSpecifies the machine to which you want to connect to produce the forecast when you specify the DATA= \noption in the FORECAST statement. If you do not specify the host information, it is determined from \nthe active table."},"StatementOptionType":"V"},{"StatementOptionName":"INDEP=|INDEPVARS=","StatementOptionHelp":{"#cdata":"Syntax: INDEP=variable-name\nINDEP=(variable-list) \n\nSpecifies the independent variables used in automatic modeling. When you specify one or more independent \nvariables, the server performs model selection automatically and determines the best-fitting time series \nmodel and the important independent variables. If any variables are selected, a table is generated to show \nthe actual and predicted values for each variable. Specify the INFO option to view the Forecast Information \ntable that displays the selected time series model. \n\nVariables that are listed as independent variables cannot appear in the list of control variables."},"StatementOptionType":"V"},{"StatementOptionName":"INFO","StatementOptionHelp":{"#cdata":"\nSpecifies to display a forecast information table for each analysis variable. Each table provides \ninformational details about the forecast. For example, you can learn from this table what time units \nwere applied and which method was used to compute the forecast. \n\nThe server performs automatic model selection. The available methods and the associated ARIMA models \nare as follows: \n\nDamped-trend exponential smoothing ARIMA(1, 1, 2) \nLinear exponential smoothing ARIMA(0, 2, 2) \nSeasonal exponential smoothing ARIMA( 0, 1, p + 1)(0, 1, 0)p \nSimple exponential smoothing ARIMA(0, 1, 1) \nWinters method (additive) ARIMA( 0, 1, p + 1)(0, 1, 0)p \nWinters method (multiplicative) There is no ARIMA equivalent."},"StatementOptionType":"S"},{"StatementOptionName":"LEAD=","StatementOptionHelp":{"#cdata":"Syntax: LEAD=n\n\nSpecifies the forecast horizon (in number of time intervals). \n\nDefault: 12 \nInteraction: This option has no effect if you specify a data set with the DATA= option."},"StatementOptionType":"V"},{"StatementOptionName":"LOWERBOUNDS|LOWER","StatementOptionHelp":{"#cdata":"Syntax: LOWERBOUNDS<=>(boundary-specification1 <, boundary-specification2...>\n\nSpecifies lower boundary variables for the control variables. A boundary-specification is specified \nwith the following form: \n\n  control-variable = boundary-variable\n\nFor example, in the following FORECAST statement the variable Pricelb in data set Merged2 contains \nthe lower boundary values for the control variable Price, and the variable Priceub contains the \nupper boundary values for the control variable Price. \n\nExample forecast data=merged2 date / dep    =sale\n                             control=price\n                             lower(price=pricelb)\n                             upper(price=priceub)\n                             goal   =gsale\n                             lead   =12;"},"StatementOptionType":"S|V"},{"StatementOptionName":"NOPREPARSE|NOPREP","StatementOptionHelp":{"#cdata":"Specifies to prevent the procedure from pre-parsing and pre-generating code for temporary expressions, \nscoring programs, and other user-written SAS statements. \n\nWhen this option is specified, the user-written statements are sent to the server \"as-is\" and then the \nserver attempts to generate code from it. If the server detects problems with the code, the error messages \nmight not to be as detailed as the messages that are generated by SAS client. If you are debugging your \nuser-written program, then you might want to pre-parse and pre-generate code in the procedure. However, \nif your SAS statements compile and run as you want them to, then you can specify this option to avoid the \nwork of parsing and generating code on the SAS client. \n\nInteraction: This option has no effect if you specify a data set with the DATA= option."},"StatementOptionType":"S"},{"StatementOptionName":"PORT=","StatementOptionHelp":{"#cdata":"Syntax: PORT=number\n\nSpecifies to use the server that is listening on that port to produce the forecast when you specify \nthe DATA= option in the FORECAST statement. You can use this option with the HOST= option to use a \nspecific server. If you do not specify a PORT= value, the behavior of the FORECAST statement depends \non whether a table is active. If there is no active table, then the IMSTAT procedure tries to connect \nto the server using the LASRPORT macro variable. If a table is active, then a connection is made to the\nserver that has the active table."},"StatementOptionType":"V"},{"StatementOptionName":"STAMPLIMIT=","StatementOptionHelp":{"#cdata":"Syntax: STAMPLIMIT=m\n\nSpecifies a hard limit for the number of time stamps. If that number reaches m, then execution stops \nand the server generates an error message. This option is useful to protect against the generation of \nvery large result sets. You can also limit the number of time stamps used in the forecast with the TAIL= \noption. Using the TAIL= option also reduces the size of the result set."},"StatementOptionType":"V"},{"StatementOptionName":"SAVE=","StatementOptionHelp":{"#cdata":"Syntax: SAVE=table-name\n\nSaves the result table so that you can use it in other IMSTAT procedure statements like STORE, REPLAY, \nand FREE. The value for table-name must be unique within the scope of the procedure execution. The name \nof a table that has been freed with the FREE statement can be used again in subsequent SAVE= options."},"StatementOptionType":"V"},{"StatementOptionName":"TAIL=","StatementOptionHelp":{"#cdata":"Syntax: TAIL=k\n\nSpecifies the number of most recent time intervals on which to base the estimation of the predicted \nand forecasted values. The TAIL= option enables you to restrict the length of the series that is used \nin the forecast. \n\nFor example, if the aggregation results in 500 unique values of the time stamp, then specifying TAIL=30 \nuses only the thirty most recent values in the estimation procedure. If you do not specify the TAIL= option, \nthen all the aggregated time stamps are used in the estimation procedure. This option can also limit the size \nof the result set since at most k observations are used in the computation of the forecast. \n\nInteraction: This option has no effect if you specify a data set with the DATA= option."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary \nvariables or a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"},{"StatementOptionName":"UPPERBOUNDS|UPPER","StatementOptionHelp":{"#cdata":"Syntax: UPPERBOUNDS<=>(boundary-specification1 <, boundary-specification2...>\n\nSpecifies upper boundary variables for the control variables. A boundary-specification is specified \nwith the following form: \n\n  control-variable = boundary-variable\n\nThe boundary specification is identical to the LOWERBOUNDS= option."},"StatementOptionType":"S|V"},{"StatementOptionName":"VARS=","StatementOptionHelp":{"#cdata":"Syntax: VARS=variable-name\nVARS=(variable-list) \n\nSpecifies one or more numeric analysis variables to forecast. If you do not specify the VARS= option, \na forecast is produced for all numeric variables in the active table. If you specify a data set with \nthe DATA= option, you must specify the analysis variables in the VARS= option. If you do not, the \nserver generates an error."},"StatementOptionType":"V"},{"StatementOptionName":"WEIGHTVAR=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHTVAR=variable-name\n\nSpecifies the optional weight variable for goal-seeking analysis."},"StatementOptionType":"V"}]}},{"StatementName":"FREQUENCY","StatementHelp":{"#cdata":"Syntax: FREQUENCY variable-list </ options>; \n      \nThe FREQUENCY statement is used to calculate a frequency distribution for one or more variables."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"DESCENDING|DESC","StatementOptionHelp":{"#cdata":"Specifies that the levels of the GROUPBY variables are to be arranged in descending order."},"StatementOptionType":"S"},{"StatementOptionName":"FORMATS=","StatementOptionHelp":{"#cdata":"Syntax: FORMATS=(\"format-specification\", ...) \n<!---->\nSpecifies the format to apply to each variable. Specify the list as a comma-separated list and \nenclose each format specification in quotation marks. If you do not specify a format, then the \ndefault format for the variable is used."},"StatementOptionType":"V"},{"StatementOptionName":"MERGEBINS=","StatementOptionHelp":{"#cdata":"Syntax: MERGEBINS=b\n\nSpecifies the number of bins to create when a numeric GROUPBY variable exceeds the MERGELIMIT=n \nspecification. If you specify a MERGELIMIT, but do not specify a value for the MERGEBINS= option, \nthe server automatically calculates the number of bins."},"StatementOptionType":"V"},{"StatementOptionName":"MERGELIMIT=","StatementOptionHelp":{"#cdata":"Syntax: MERGELIMIT=n\n\nSpecifies that when the number of unique values in a numeric GROUPBY variable exceeds n, the variable \nis automatically binned and the GROUPBY structure is determined based on the binned values of the variable, \nrather than the unique formatted values. \n\nFor example, if you specify MERGELIMIT=500, any numeric GROUPBY variable with more than 500 unique \nformatted values is binned. Instead of returning results for more than 500 groups, the results are \nreturned for the bins. You can specify the number of bins with the MERGEBINS= option."},"StatementOptionType":"V"},{"StatementOptionName":"NOEMPTY|FULLCELL","StatementOptionHelp":{"#cdata":"\n\nSpecifies that empty cells are not returned to the SAS session (only full cells are returned). \nWhen this option is specified, the server eliminates all levels with zero frequency from the \nresult set."},"StatementOptionType":"S"},{"StatementOptionName":"NOMISS|NOMISSING","StatementOptionHelp":{"#cdata":"Specifies that missing values are excluded in the calculation of formatted values. By default, \nlevels with missing values are included."},"StatementOptionType":"S"},{"StatementOptionName":"RAWORDER","StatementOptionHelp":{"#cdata":"Specifies that the ordering of the GROUP BY value is based on the raw values of the variables instead \nof the formatted values."},"StatementOptionType":"S"},{"StatementOptionName":"SAVE=","StatementOptionHelp":{"#cdata":"Syntax: SAVE=table-name\n\nSaves the result table so that you can use it in other IMSTAT procedure statements like STORE, REPLAY, \nand FREE. The value for table-name must be unique within the scope of the procedure execution. The name \nof a table that has been freed with the FREE statement can be used again in subsequent SAVE= options."},"StatementOptionType":"V"},{"StatementOptionName":"SETSIZE","StatementOptionHelp":{"#cdata":"Requests that the server estimate the size of the result set. The procedure does not create \na result table if the SETSIZE option is specified. Instead, the procedure reports the number \nof rows that are returned by the request and the expected memory consumption for the result \nset (in KB). If you specify the SETSIZE option, the SAS log includes the number of observations \nand the estimated result set size."},"StatementOptionType":"S"},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary \nvariables or a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"}]}},{"StatementName":"GENMODEL","StatementHelp":{"#cdata":"Syntax: GENMODEL dependent-variable <(class-variables)> = model-effects </ options>; \n      \nThe GENMODEL statement is used to fit statistical models from the class of generalized linear \nmodels and some related models."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ALLIDVARS","StatementOptionHelp":{"#cdata":"Requests that all variables in the input table are treated as ID variables when a scoring table \nis produced. In other words, if this option is specified, all variables from the input table, \nincluding computed columns, are transferred to the scoring table. This option has no effect \nunless you specify the SCORE option."},"StatementOptionType":"V"},{"StatementOptionName":"ALPHA=","StatementOptionHelp":{"#cdata":"Syntax: ALPHA=number\n\nSpecifies a number between 0 and 1 from which to determine the confidence level for approximate \nconfidence intervals of the parameter estimates. The default is \u03b1 = 0.05, which leads to \n100 x (1- \u03b1)% = 95% confidence limits for the parameter estimates. \n\nDefault 0.05"},"StatementOptionType":"V"},{"StatementOptionName":"CI","StatementOptionHelp":{"#cdata":"Syntax: CI\n\nSpecifies to add confidence intervals to the table of parameter estimates. The confidence level \nis 100*(1-\u03b1)% where \u03b1 is determined by the ALPHA= option. The default value is \u03b1 = 0.05. This \nvalue is equivalent to a 95% confidence limit. \n\nDefault 0.05"},"StatementOptionType":"V"},{"StatementOptionName":"CLASSFORMATS=|CLASSFMT=","StatementOptionHelp":{"#cdata":"Syntax: CLASSFORMATS=(\"format-name1\"<, \"format-name2\" ...>) \n\nSpecifies the formats for the classification variables in the model. If you do not specify the \nCLASSFORMATS= option, the default format is applied for the classification variable. That default \nformat was determined when the table was originally loaded into the server. In the following example, \nthe CLASSFORMAT= values apply to variables x1 and x2. \n\nExample:\n\n  genmodel y (x1 x2) = x3-x7 / classformats=(\"YN.\", \"F8.\");"},"StatementOptionType":"V"},{"StatementOptionName":"CODE","StatementOptionHelp":{"#cdata":"Syntax: CODE <(code-generation-options)>\n\nRequests that the server produce SAS scoring code based on the actions that it performed during the \nanalysis. The server generates DATA step code. By default, the code is replayed as an ODS table by \nthe procedure as part of the output of the statement. More frequently, you might want to write the \nscoring code to an external file by specifying options.\n\nCOMMENT\n  specifies to add comments to the code in addition to the header block. The header block is added by default. \nFILENAME=|FILE='path' \n  specifies the name of the external file to which the scoring code is written. This suboption applies only \n  to the scoring code itself. \nFORMATWIDTH=|FMTW=k\n  specifies the width to use in formatting derived numbers such as parameter estimates in the scoring code. \n  The server applies the BEST format, and the default format for code generation is BEST20. Range: 4 to 32\nLABELID=id\n  specifies a group identifier for group processing. The identifier is an integer and is used to create array \n  names and statement labels in the generated code. \nLINESIZE=|LS=n\n  specifies the line size for the generated code. \n  Default: 72 \n  Range: 64 to 256\nNOTRIM\n  specifies to format the variables using the full format width with padding. By default, leading and trailing \n  blanks are removed from the formatted values. \nREPLACE\n  specifies to overwrite the external file if a file with the specified name already exists. The option \n  has no effect unless you specify the FILENAME= option."},"StatementOptionType":"S","SubOptionsKeywords":"COMMENT|FILENAME=|FILE=|FORMATWIDTH=|FMTW=|LABELID=|LINESIZE=|NOTRIM|REPLACE"},{"StatementOptionName":"DIST=","StatementOptionHelp":{"#cdata":"Syntax: DIST=distribution\n\nSpecifies the distribution of the response variable."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"BETA","@Value2":"BINARY|BERNOULLI","@Value3":"EXPONENTIAL|EXPO","@Value4":"GAMMA|GAM","@Value5":"GENPOISSON","@Value6":"GEOMETRIC|GEOM","@Value7":"INVGAUSS|IGAUSSIAN|IG","@Value8":"NEGBINOMIAL|NEGBIN|NB","@Value9":"NORMAL|GAUSSIAN|GAUSS","@Value10":"POISSON|POI","@Value11":"T|STUDENT","@Value12":"WEIBULL"},"StatementOptionToolTips":{"@ToolTip1":"Beta distribution","@ToolTip2":"Binary or Bernoully distribution","@ToolTip3":"Exponential distribution","@ToolTip4":"Gamma distribution","@ToolTip5":"Generalized Poisson distribution","@ToolTip6":"Geometric distribution","@ToolTip7":"Inverse Gaussian distribution","@ToolTip8":"Negative binomial distribution","@ToolTip9":"Normal or Gaussian distribution","@ToolTip10":"Poisson distribution","@ToolTip11":"Student's t-distribution","@ToolTip12":"Weibull distribution"}},{"StatementOptionName":"EXCLUDE=","StatementOptionHelp":{"#cdata":"Syntax: EXCLUDE=(list-of-ODS-tables) \n\nSpecifies the result tables that you want to exclude from being generated on the server and from \nbeing sent to the client. The GENMODEL statement can generate the following tables: \n\nModelInfo - Information about the model\u2014constant across groups or partitions.\nClassLevels | Class - Information about the classification variables, such as the number of levels and their values. \nConvergenceStatus | Convergence - Convergence status of optimization\nDimensions | Dim - Model dimensions\nFitStatistics | Fit - Fit statistics customary for generalized linear models\nOptIterHistory | IterHist - Iteration history\nParmEstimates | ParameterEstimates | Pest - The solutions for the linear model coefficients \nTests3 - Type III tests of model effects"},"StatementOptionType":"V"},{"StatementOptionName":"FORMATS=","StatementOptionHelp":{"#cdata":"Syntax: FORMATS=(\"format-specification\"<,...>) \n\nSpecifies the formats for the GROUPBY variables. If you do not specify the FORMATS= option, \nor if you omit the entry for a GROUPBY variable, the default format is applied for that variable. \n\nEnclose each format specification in quotation marks and separate each format specification with a comma."},"StatementOptionType":"V"},{"StatementOptionName":"FCONV=","StatementOptionHelp":{"#cdata":"Syntax: FCONV=r\n\nSpecifies a relative function convergence criterion. For all techniques except NMSIMP, termination \nrequires a small relative change of the function value in successive iterations."},"StatementOptionType":"V"},{"StatementOptionName":"FREQ=","StatementOptionHelp":{"#cdata":"Syntax: FREQ=variable-name\n\nSpecifies the numeric variable that provides frequencies for the analysis. For example, if the \nFREQ= variable has the value 5, then it implies that the record represents five such observations \nwith identical values for the modeling variables. If you specify a FREQ= variable, then only the \nobservations with a value that is not missing and greater than zero for the variable are used in \nthe analysis."},"StatementOptionType":"V"},{"StatementOptionName":"GCONV=","StatementOptionHelp":{"#cdata":"Syntax: GCONV=r\n\nSpecifies a relative gradient convergence criterion. For all optimization techniques except CONGRA \nand NMSIMP, termination requires that the normalized predicted function reduction is small. The \ndefault value is r = 1e-8. \n\nThe GCONV convergence criterion is assumed to be met if that value is less than or equal to r. \n\nNote that it is possible that the relative gradient reduction is small, even if one or more gradients \nis still substantial in absolute value. If this situation occurs, you can disable the GCONV criterion \nby setting r=0. If the optimization would have stopped early due to meeting the GCONV criterion, the \niterative process usually takes one more step until the gradients are small in absolute value."},"StatementOptionType":"V"},{"StatementOptionName":"GROUPBY=","StatementOptionHelp":{"#cdata":"Syntax: GROUPBY=(variable-list) \n\nSpecifies a list of variable names, or a single variable name, to use as GROUPBY variables \nin the order of the grouping hierarchy. If you do not specify any GROUPBY variable names, \nthen the calculation is performed across the entire table\u2014possibly subject to a WHERE clause."},"StatementOptionType":"V"},{"StatementOptionName":"GROUPFILTER=","StatementOptionHelp":{"#cdata":"Syntax: GROUPFILTER=(filter-options) \n\nSpecifies a section of the group-by hierarchy to be included in the computation. With this option, \nyou can request that the server performs the analysis for only a subset of all possible groupings. \nThe subset is determined by applying the group filter to a temporary table that you generate with \nthe GROUPBY statement. \n\nYou can specify the following suboptions in the GROUPFILTER option: \n\nDESCENDING | DESC - specifies the top section or the bottom section of the groupings to be collected. \nLIMIT=n - specifies the maximum number of distinct groupings to be collected, where integer n >= 0. \nSCOREGT=f | SGT=f - specifies the exclusive lower bound for the numeric scores of the distinct groupings to collect. \nSCORELT=f | SLT= - specifies the exclusive upper bound for the numeric scores of the distinct groupings to collect. \nVALUEGT=(\"format-name1\" <, \"format-name2\" ...>) | VGT=\n  - specifies the exclusive lower bound of the group-by variable\u2019s formatted values for the distinct groupings to collect. \nVALUELT=(\"format-name1\" <, \"format-name2\" ...>)  | VLT=\n  - specifies the exclusive upper bound of the group-by variable\u2019s formatted values for the distinct groupings to collect. \nTABLE=table-with-groupby-results\n  - specifies the in-memory table from which to load the group-by hierarchy. \n  \nInteraction: If you specify the GROUPFILTER= option, then the GROUPBY= and FORMATS= options have no effect."},"StatementOptionType":"V","SubOptionsKeywords":"DESCENDING|DESC|LIMIT=|SCOREGT=|SGT=|SCORELT=|SLT=|VALUEGT=|VGT=|VALUELT=|VLT=|TABLE="},{"StatementOptionName":"IDVARS=|ID=","StatementOptionHelp":{"#cdata":"Syntax: IDVARS=(variable-list) \n\nIDVARS=variable-name\n\nSpecifies the variables from the active table to transfer to the temporary table that is created \nby scoring the input table. This option has no effect unless the SCORE option is also specified. \n(See the SCORE option for details about which variables are added to the temporary table by default.) \nThe IDVARS= option should be used to transfer additional columns from the input table to the scoring table. \n\nTip Instead of this option, you can specify the ALLIDVARS option to transfer all variables from the \ninput table to the scoring table."},"StatementOptionType":"V"},{"StatementOptionName":"ITDETAILS|ITDETAIL","StatementOptionHelp":{"#cdata":"Requests to add details about the iterative model fitting process (an iteration history) to the \nODS output tables."},"StatementOptionType":"S"},{"StatementOptionName":"KEYORDER","StatementOptionHelp":{"#cdata":"Requests that the results for a partitioned analysis are displayed in the order of the partition keys. \nIf this option is not specified, then results are displayed by using the partitions on the first worker \nnode followed by the partitions on the second node, and so on. Without this option, the results are likely \nto have random ordering of the partitions. The KEYORDER option makes result collection less efficient but \nproduces a natural, predictable order."},"StatementOptionType":"S"},{"StatementOptionName":"LINK=","StatementOptionHelp":{"#cdata":"Syntax: LINK=function\n\n\nSpecifies the link function to use for the model fitting process. If you do not specify a link \nfunction, the server selects the most appropriate function for the distribution of the data."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"IDENTITY|IDENT","@Value2":"LOGIT","@Value3":"PROBIT","@Value4":"LOG","@Value5":"LOGLOG","@Value6":"CLOGLOG|CLL","@Value7":"RECIP","@Value8":"POWMINUS2","@Value9":"POWER|POW|POM"},"StatementOptionToolTips":{"@ToolTip1":"Identity link function","@ToolTip2":"Logit link function","@ToolTip3":"Probit link function","@ToolTip4":"Logarithmic link function","@ToolTip5":"Log-log link function","@ToolTip6":"Complementary log-log link function","@ToolTip7":"Reciprocal link function","@ToolTip8":"Power(-2) link function","@ToolTip9":"Power link function"}},{"StatementOptionName":"MAXFUNC=|MAXFU=","StatementOptionHelp":{"#cdata":"Syntax: MAXFUNC=n\n\n\nSpecifies the maximum number n of function calls in the iterative model fitting process.\n\nThe default value depends on the optimization technique as follows: \n\n---------------------------------------------------------------------------------------------\nOptimization Technique      Default Number of Function Calls\n---------------------------------------------------------------------------------------------\nTRUREG, NRRIDG, and NEWRAP  125 \nQUANEW and DBLDOG           500\nCONGRA                      1000\nNMSIMP                      3000"},"StatementOptionType":"V"},{"StatementOptionName":"MAXITER=|MAXIT=","StatementOptionHelp":{"#cdata":"Syntax: MAXITER=i\n\nSpecifies the maximum number of iterations in the iterative model fitting process. The default \nvalue depends on the optimization technique as follows:\n\n---------------------------------------------------------------------------------------------\nOptimization Technique      Default Number of Function Calls\n---------------------------------------------------------------------------------------------\nTRUREG, NRRIDG, and NEWRAP  50 \nQUANEW and DBLDOG           200\nCONGRA                      400\nNMSIMP                      1000"},"StatementOptionType":"V"},{"StatementOptionName":"MAXTESTLEV=","StatementOptionHelp":{"#cdata":"Syntax: MAXTESTLEV=n\n\nSpecifies the maximum number of levels in an effect for which the server generates Type III tests. \nThe idea behind the MAXTESTLEV= option is that testing effects for significance that have a large \nnumber of levels is typically not meaningful. The effects tend to be highly significant anyway, \nbut determining the exact significance level is computationally intensive. The default value is \n300 and implies that no test statistics are produced for any effect that has more than 300 levels. \n\nDefault 300"},"StatementOptionType":"V"},{"StatementOptionName":"NOCLPRINT","StatementOptionHelp":{"#cdata":"Syntax: NOCLPRINT <=n>\n\nSpecifies the number of levels for each classification variables to show in the Class Level Information \nODS table. If you do not specify the NOCLPRINT option, all unique values are shown in the order of the \nclass variable levelization. If you specify NOCLPRINT=n, then the values are shown for those classification \nvariables that have less than n levels only. The value for n must be at least 1. \n\nIf you specify the NOCLPRINT option without specifying a value for n, then n = 0 is assumed. This enables \nyou to get a listing of the classification variables in the model. This might be useful if you did not \nidentify classification variables explicitly\u2014without listing their (possibly many) levels."},"StatementOptionType":"S|V"},{"StatementOptionName":"NOINT","StatementOptionHelp":{"#cdata":"Suppresses the inclusion of an intercept in the model. By default, all models contain an intercept term."},"StatementOptionType":"S"},{"StatementOptionName":"NOPREPARSE|NOPREP","StatementOptionHelp":{"#cdata":"Prevents the procedure from preparsing and pregenerating code for temporary expressions, scoring \nprograms, and other user-written SAS statements. \n\nWhen this option is specified, the user-written statements are sent to the server \"as is\" and then \nthe server attempts to generate code from it. If the server detects problems with the code, the error \nmessages might not to be as detailed as the messages that are generated by SAS client. If you are \ndebugging your user-written program, then you might want to preparse and pregenerate code in the \nprocedure. However, if your SAS statements compile and run as you want them to, then you can specify \nthis option to avoid the work of parsing and generating code on the SAS client. \n\nWhen you specify this option in the PROC IMSTAT statement, the option applies to all statements that \ncan generate code. You can also exclude specific statements from preparsing by using the NOPREPARSE \noption in statements that allow temporary columns or the SCORE statement."},"StatementOptionType":"S"},{"StatementOptionName":"NOSTDERR|NOSTD","StatementOptionHelp":{"#cdata":"Prevents the computation of the covariance matrix and the standard errors of the parameter estimates. \nWhen you specify this option, the Type III tests for the model effects are also not available."},"StatementOptionType":"S"},{"StatementOptionName":"OFFSET=","StatementOptionHelp":{"#cdata":"Syntax: OFFSET=variable-name\n          \nSpecifies the offset variable for the analysis. An offset variable can be thought of as a regressor \nvariable whose regression coefficient is known to be 1. Offsets are used to shift the linear predictors \nby a certain amount. For example, an offset can be used to accommodate constants in the underlying model. \nIn generalized linear models, offsets arise frequently when the data represents a value relative to some \nmeasure of size."},"StatementOptionType":"V"},{"StatementOptionName":"PARTITION|PART","StatementOptionHelp":{"#cdata":"Syntax: PARTITION<=partition-key>\n\nSpecifies to fit the model separately for each value of the partition key. In other words, \nthe partition variables function as automatic group-by variables for the request. \n\nIf you do not specify a value for partition-key, then the analysis is performed for all \npartitions. If you do specify a value, then the analysis is performed for the specified \nkey value only. You can use the PARTITIONINFO statement to retrieve the valid partition-key \nvalues for a table."},"StatementOptionType":"S|V"},{"StatementOptionName":"SELECT=","StatementOptionHelp":{"#cdata":"Syntax: SELECT=(list-of-ODS-tables) \n\nSpecifies the list of ODS tables that you want to display for the analysis. The specified list \nreplaces the default tables that are generated by the server and displayed."},"StatementOptionType":"V"},{"StatementOptionName":"SHOWSELECTED|SHOWSEL","StatementOptionHelp":{"#cdata":"Requests that the server perform variable selection for the model. A backward selection method is used, \nwhere the significance level for an effect to remain in the model is determined by the SLSTAY= option. \nThis option performs variable selection like the VARSEL option, but in contrast to the latter option, \nit displays output only for the selected effects."},"StatementOptionType":"S"},{"StatementOptionName":"SLSTAY=","StatementOptionHelp":{"#cdata":"Syntax: SLSTAY=\u03b1\n\nSpecifies the significance level used in determining whether effects should stay in the model \nduring variable selection. \n\nDefault: 0.1 \nRange: 0 to 1"},"StatementOptionType":"V"},{"StatementOptionName":"TECHNIQUE=|TECH=","StatementOptionHelp":{"#cdata":"Syntax: TECHNIQUE=value\n\nSpecifies the optimization technique for the iterative model-fitting process. \n\nThe factors that go into choosing a particular optimization technique for a particular problem \nare complex. Trial and error can be involved. \n\nDefault NRRIDG"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"CONGRA","@Value2":"DBLDOG","@Value3":"NMSIMP","@Value4":"NEWRAP","@Value5":"NRRIDG","@Value6":"QUANEW","@Value7":"TRUREG","@Value8":"NONE"},"StatementOptionToolTips":{"@ToolTip1":"CONGRA (CG): performs a conjugate-gradient optimization","@ToolTip2":"DBLDOG (DD): performs a version of the double-dogleg optimization","@ToolTip3":"NMSIMP (NS): performs a Nelder-Mead simplex optimization","@ToolTip4":"NEWRAP (NRA): performs a (modified) Newton-Raphson optimization that combines a line-search algorithm with ridging","@ToolTip5":"NRRIDG (NRR): performs a (modified) Newton-Raphson optimization with ridging","@ToolTip6":"QUANEW (QN): performs a quasi-Newton optimization","@ToolTip7":"TRUREG (TR): performs a trust-region optimization","@ToolTip8":"NONE: does not perform any optimization. This value can be useful to perform a grid search without optimization."}},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary \nvariables or a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPTABLE","StatementOptionHelp":{"#cdata":"Generates an in-memory temporary table from the result set. The IMSTAT procedure displays the \nname of the table and stores it in the &_TEMPLAST_ macro variable, provided that the statement \nexecuted successfully. \n\nWhen the IMSTAT procedure exits, all temporary tables created during the IMSTAT session are \nremoved. Temporary tables are not displayed on a TABLEINFO request, unless the temporary table \nis the active table for the request."},"StatementOptionType":"S"},{"StatementOptionName":"VALIDATE=|VALPROP=","StatementOptionHelp":{"#cdata":"Syntax: VALIDATE=f\n\nSpecifies the proportion f in the validation data set. \n\nRange: 0 to 1  \n\nInteraction: If you specify both the ROLEVAR= option and the VALIDATE= option, then the ROLEVAR= \nsetting supersedes the VALIDATE= option."},"StatementOptionType":"V"},{"StatementOptionName":"VARSELECTION|VARSEL","StatementOptionHelp":{"#cdata":"Specifies that the server perform variable selection for the model. A backward selection method \nis used, where the significance level for an effect to remain in the model is determined by the \nSLSTAY= option. In contrast to the SHOWSEL option, all effects are reported in the IMSTAT output."},"StatementOptionType":"S"},{"StatementOptionName":"WEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT=variable-name\n\nSpecifies the numeric variable to use as a weighing variable in solving the linear model."},"StatementOptionType":"V"}]}},{"StatementName":"GLM","StatementHelp":{"#cdata":"Syntax: GLM dependent-variable <(class-variables)> = model-effects </ options>; \n      \nThe GLM statement is used to fit models that are similar to those handled by the GLM procedure. \nThere are some important differences in syntax and functionality between the GLM procedure and \nthe GLM statement in IMSTAT."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ALLIDVARS","StatementOptionHelp":{"#cdata":"Requests that all variables in the input table are treated as ID variables when a scoring table \nis produced. In other words, if this option is specified, all variables from the input table, \nincluding computed columns, are transferred to the scoring table. This option has no effect \nunless you specify the SCORE option."},"StatementOptionType":"V"},{"StatementOptionName":"ALPHA=","StatementOptionHelp":{"#cdata":"Syntax: ALPHA=number\n\nSpecifies a number between 0 and 1 from which to determine the confidence level for approximate \nconfidence intervals of the parameter estimates. The default is \u03b1 = 0.05, which leads to \n100 x (1- \u03b1)% = 95% confidence limits for the parameter estimates. \n\nDefault 0.05"},"StatementOptionType":"V"},{"StatementOptionName":"CHISQ","StatementOptionHelp":{"#cdata":"Requests that p-values in the table of parameter estimates and Type III tests are determined as \nprobabilities under a x2 distribution. This means that instead of two-sided p-values based on the \nt distribution, the p-values are computed as two-sided probabilities under a standard normal \ndistribution. Similarly, the assumption of F distributions with finite denominator degrees of \nfreedom is ignored in lieu of assuming infinite degrees of freedom."},"StatementOptionType":"S"},{"StatementOptionName":"CI","StatementOptionHelp":{"#cdata":"Syntax: CI\n\nSpecifies to add confidence intervals to the table of parameter estimates. The confidence level \nis 100*(1-\u03b1)% where \u03b1 is determined by the ALPHA= option. The default value is \u03b1 = 0.05. This \nvalue is equivalent to a 95% confidence limit. \n\nDefault 0.05"},"StatementOptionType":"V"},{"StatementOptionName":"CLASSFORMATS=|CLASSFMT=","StatementOptionHelp":{"#cdata":"Syntax: CLASSFORMATS=(\"format-name1\"<, \"format-name2\" ...>) \n\nSpecifies the formats for the classification variables in the model. If you do not specify the \nCLASSFORMATS= option, the default format is applied for the classification variable. That default \nformat was determined when the table was originally loaded into the server. In the following example, \nthe CLASSFORMAT= values apply to variables x1 and x2. \n\nExample:\n\n  genmodel y (x1 x2) = x3-x7 / classformats=(\"YN.\", \"F8.\");"},"StatementOptionType":"V"},{"StatementOptionName":"CODE","StatementOptionHelp":{"#cdata":"Syntax: CODE <(code-generation-options)>\n\nRequests that the server produce SAS scoring code based on the actions that it performed during the \nanalysis. The server generates DATA step code. By default, the code is replayed as an ODS table by \nthe procedure as part of the output of the statement. More frequently, you might want to write the \nscoring code to an external file by specifying options.\n\nCOMMENT\n  specifies to add comments to the code in addition to the header block. The header block is added by default. \nFILENAME=|FILE='path' \n  specifies the name of the external file to which the scoring code is written. This suboption applies only \n  to the scoring code itself. \nFORMATWIDTH=|FMTW=k\n  specifies the width to use in formatting derived numbers such as parameter estimates in the scoring code. \n  The server applies the BEST format, and the default format for code generation is BEST20. Range: 4 to 32\nLABELID=id\n  specifies a group identifier for group processing. The identifier is an integer and is used to create array \n  names and statement labels in the generated code. \nLINESIZE=|LS=n\n  specifies the line size for the generated code. \n  Default: 72 \n  Range: 64 to 256\nNOTRIM\n  specifies to format the variables using the full format width with padding. By default, leading and trailing \n  blanks are removed from the formatted values. \nREPLACE\n  specifies to overwrite the external file if a file with the specified name already exists. The option \n  has no effect unless you specify the FILENAME= option."},"StatementOptionType":"S","SubOptionsKeywords":"COMMENT|FILENAME=|FILE=|FORMATWIDTH=|FMTW=|IMSTAT|IMSTATONLY|LABELID=|LINESIZE=|LS=|NOTRIM|REPLACE"},{"StatementOptionName":"EXCLUDE=","StatementOptionHelp":{"#cdata":"Syntax: EXCLUDE=(list-of-ODS-tables) \n\nSpecifies the result tables that you want to exclude from being generated on the server and from \nbeing sent to the client. The GLM statement can generate the following tables: \n\nModelInfo - Information about the model\u2014constant across groups or partitions.\nClassLevels | Class - Information about the classification variables, such as the number of levels and their values. \nDimensions | Dim - Model dimensions\nFitStatistics | Fit - Fit statistics customary for generalized linear models \nOverallAnova | GlobalAnova - Model, source, and error decomposition of variation \nModelAnova | ANOVA - Variance decomposition with significance tests for all model effects\nParmEstimates | ParameterEstimates | Pest - The solutions for the linear model coefficients \nResponseProfile | Resp - Information about the values of the binary response variable such as the level order and frequency\nTests3 - Type III tests of model effects"},"StatementOptionType":"V"},{"StatementOptionName":"FORMATS=","StatementOptionHelp":{"#cdata":"Syntax: FORMATS=(\"format-specification\"<,...>) \n\nSpecifies the formats for the GROUPBY variables. If you do not specify the FORMATS= option, \nor if you omit the entry for a GROUPBY variable, the default format is applied for that variable. \n\nEnclose each format specification in quotation marks and separate each format specification with a comma."},"StatementOptionType":"V"},{"StatementOptionName":"FREQ=","StatementOptionHelp":{"#cdata":"Syntax: FREQ=variable-name\n\nSpecifies the numeric variable that provides frequencies for the analysis. For example, if the \nFREQ= variable has the value 5, then it implies that the record represents five such observations \nwith identical values for the modeling variables. If you specify a FREQ= variable, then only the \nobservations with a value that is not missing and greater than zero for the variable are used in \nthe analysis."},"StatementOptionType":"V"},{"StatementOptionName":"GROUPBY=","StatementOptionHelp":{"#cdata":"Syntax: GROUPBY=(variable-list) \n\nSpecifies a list of variable names, or a single variable name, to use as GROUPBY variables \nin the order of the grouping hierarchy. If you do not specify any GROUPBY variable names, \nthen the calculation is performed across the entire table\u2014possibly subject to a WHERE clause."},"StatementOptionType":"V"},{"StatementOptionName":"GROUPBYMODE=","StatementOptionHelp":{"#cdata":"Syntax: GROUPBYMODE= DATA | MODEL | LASR\n\nSpecifies the parallelization technique for group-by processing. The default is GROUPBYMODE=MODEL \nin which threads solve separate models following a lateral reconciliation of cross-product matrices. \nThis mode is appropriate in situations with many groups and relatively small cross-product matrices. \nModel-parallel processing minimizes passes through the data. \n\nSpecify GROUPBYMODE=DATA to form the cross-product matrices in parallel across the data and one group \nat a time. This data-parallel technique is appropriate in situations with few groups and many observations \nper group or in applications with large cross-product matrices. Data-parallel processing consumes fewer \nresources than model-parallel processing but passes through the data more often. \n\nIf you specify GROUPBYMODE=LASR, then the server examines the data structure of the groups to select the \nparallelization mode. \n\nDefault MODEL"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"DATA","@Value2":"MODEL","@Value3":"LASR"},"StatementOptionToolTips":{"@ToolTip1":"Specify GROUPBYMODE=DATA to form the cross-product matrices in parallel across the data and one group at a time.","@ToolTip2":"The default is GROUPBYMODE=MODEL in which threads solve separate models following a lateral reconciliation of cross-product matrices.","@ToolTip3":"If you specify GROUPBYMODE=LASR, then the server examines the data structure of the groups to select the parallelization mode."}},{"StatementOptionName":"GROUPFILTER","StatementOptionHelp":{"#cdata":"Syntax: GROUPFILTER=(filter-options) \n\nSpecifies a section of the group-by hierarchy to be included in the computation. With this option, \nyou can request that the server performs the analysis for only a subset of all possible groupings. \nThe subset is determined by applying the group filter to a temporary table that you generate with \nthe GROUPBY statement. \n\nYou can specify the following suboptions in the GROUPFILTER option: \n\nDESCENDING | DESC - specifies the top section or the bottom section of the groupings to be collected. \nLIMIT=n - specifies the maximum number of distinct groupings to be collected, where integer n >= 0. \nSCOREGT=f | SGT=f - specifies the exclusive lower bound for the numeric scores of the distinct groupings to collect. \nSCORELT=f | SLT= - specifies the exclusive upper bound for the numeric scores of the distinct groupings to collect. \nVALUEGT=(\"format-name1\" <, \"format-name2\" ...>) | VGT=\n  - specifies the exclusive lower bound of the group-by variable\u2019s formatted values for the distinct groupings to collect. \nVALUELT=(\"format-name1\" <, \"format-name2\" ...>)  | VLT=\n  - specifies the exclusive upper bound of the group-by variable\u2019s formatted values for the distinct groupings to collect. \nTABLE=table-with-groupby-results\n  - specifies the in-memory table from which to load the group-by hierarchy. \n  \nInteraction: If you specify the GROUPFILTER= option, then the GROUPBY= and FORMATS= options have no effect."},"StatementOptionType":"V","SubOptionsKeywords":"DESCENDING|DESC|LIMIT=|SCOREGT=|SGT=|SCORELT=|SLT=|VALUEGT=|VGT=|VALUELT=|VLT=|TABLE="},{"StatementOptionName":"IDVARS=|ID=","StatementOptionHelp":{"#cdata":"Syntax: IDVARS=(variable-list) \n\nIDVARS=variable-name\n\nSpecifies the variables from the active table to transfer to the temporary table that is created \nby scoring the input table. This option has no effect unless the SCORE option is also specified. \n(See the SCORE option for details about which variables are added to the temporary table by default.) \nThe IDVARS= option should be used to transfer additional columns from the input table to the scoring table. \n\nTip Instead of this option, you can specify the ALLIDVARS option to transfer all variables from the \ninput table to the scoring table."},"StatementOptionType":"V"},{"StatementOptionName":"INCLUDEMISS","StatementOptionHelp":{"#cdata":"Specifies to treat missing values for classification variables as valid levels. If the INCLUDEMISS \noption is not specified, observations with missing values in the classification variables are not \nused in the analysis."},"StatementOptionType":"S"},{"StatementOptionName":"INFORMATIVE|INFORMMISS","StatementOptionHelp":{"#cdata":"Requests that missing values are handled by modeling them through extra model effects. These effects \nconsist of dummy variables that take on the value 1 when the value of a continuous model variable that \nis involved in the effect is missing. Otherwise, they are assigned the value 0. The missing value in the \noriginal model effect is replaced with the average value for the effect for the nonmissing values. \n\nFor continuous-by-class effects, such as A*x, where A is a classification variable and x is a continuous \nvariable, informative missingness creates multiple dummy columns and substitutes the effect mean of x that \ncorresponds to the respective level of A. \n\nSpecifying the INFORMATIVE option implies the INCLUDEMISS option. That is, when you choose to model \ninformative missingness, then missing values for classification variables are treated as valid levels."},"StatementOptionType":"S"},{"StatementOptionName":"KEYORDER","StatementOptionHelp":{"#cdata":"Requests that the results for a partitioned analysis are displayed in the order of the partition keys. \nIf this option is not specified, then results are displayed by using the partitions on the first worker \nnode followed by the partitions on the second node, and so on. Without this option, the results are likely \nto have random ordering of the partitions. The KEYORDER option makes result collection less efficient but \nproduces a natural, predictable order."},"StatementOptionType":"S"},{"StatementOptionName":"MAXTESTLEV=","StatementOptionHelp":{"#cdata":"Syntax: MAXTESTLEV=n\n\nSpecifies the maximum number of levels in an effect for which the server generates Type III tests. \nThe idea behind the MAXTESTLEV= option is that testing effects for significance that have a large \nnumber of levels is typically not meaningful. The effects tend to be highly significant anyway, \nbut determining the exact significance level is computationally intensive. The default value is \n300 and implies that no test statistics are produced for any effect that has more than 300 levels. \n\nDefault 300"},"StatementOptionType":"V"},{"StatementOptionName":"NAME=","StatementOptionHelp":{"#cdata":"Syntax: NAME=SAS-name\n\nSpecifies the name to use for identifying the model in the server output and in the temporary table \nof results generated by the TEMPTABLE option. SAS name rules apply. For example, the following statements \nadd the 'Model' entry to the ModelInformation table. \n\nproc imstat;\n   table hps.iris;\n   glm sepalwidth = sepallength / name = FirstModel;\nrun;"},"StatementOptionType":"V"},{"StatementOptionName":"NOCLPRINT","StatementOptionHelp":{"#cdata":"Syntax: NOCLPRINT <=n>\n\nSpecifies the number of levels for each classification variables to show in the Class Level Information \nODS table. If you do not specify the NOCLPRINT option, all unique values are shown in the order of the \nclass variable levelization. If you specify NOCLPRINT=n, then the values are shown for those classification \nvariables that have less than n levels only. The value for n must be at least 1. \n\nIf you specify the NOCLPRINT option without specifying a value for n, then n = 0 is assumed. This enables \nyou to get a listing of the classification variables in the model. This might be useful if you did not \nidentify classification variables explicitly\u2014without listing their (possibly many) levels."},"StatementOptionType":"S|V"},{"StatementOptionName":"NOINT","StatementOptionHelp":{"#cdata":"Suppresses the inclusion of an intercept in the model. By default, all models contain an intercept term."},"StatementOptionType":"S"},{"StatementOptionName":"NOPREPARSE|NOPREP","StatementOptionHelp":{"#cdata":"Prevents the procedure from preparsing and pregenerating code for temporary expressions, scoring \nprograms, and other user-written SAS statements. \n\nWhen this option is specified, the user-written statements are sent to the server \"as is\" and then \nthe server attempts to generate code from it. If the server detects problems with the code, the error \nmessages might not to be as detailed as the messages that are generated by SAS client. If you are \ndebugging your user-written program, then you might want to preparse and pregenerate code in the \nprocedure. However, if your SAS statements compile and run as you want them to, then you can specify \nthis option to avoid the work of parsing and generating code on the SAS client. \n\nWhen you specify this option in the PROC IMSTAT statement, the option applies to all statements that \ncan generate code. You can also exclude specific statements from preparsing by using the NOPREPARSE \noption in statements that allow temporary columns or the SCORE statement."},"StatementOptionType":"S"},{"StatementOptionName":"PARTITION|PART","StatementOptionHelp":{"#cdata":"Syntax: PARTITION<=partition-key>\n\nSpecifies to fit the model separately for each value of the partition key. In other words, \nthe partition variables function as automatic group-by variables for the request. \n\nIf you do not specify a value for partition-key, then the analysis is performed for all \npartitions. If you do specify a value, then the analysis is performed for the specified \nkey value only. You can use the PARTITIONINFO statement to retrieve the valid partition-key \nvalues for a table."},"StatementOptionType":"V"},{"StatementOptionName":"ROLEVAR=|ROLE=","StatementOptionHelp":{"#cdata":"Syntax: ROLEVAR=variable-name\n\nSpecifies a variable in the in-memory table that defines whether an observation belongs to the \ntraining set, the validation set, or is to be excluded from the analysis. The role variable can \nhave a numeric or character type, and it can be a temporary computed variable. \n\nIf the role variable data type is numeric, the values of variable-name are interpreted as follows: \n\n\u2022 value = 1: this observation is in the training set  \n\u2022 value = 2: this observation is in the validation set  \n\u2022 any other value: this observation is to be excluded from the analysis \n \nIf the role variable data type is character, the values of variable-name are interpreted as follows: \n\n\u2022 If the first non-blank character is 't' or 'T', then the observation is in the training set.  \n\u2022 If the first non-blank character is 'v' or 'V', then he observation is in the validation set.  \n\u2022 Any other value for the first non-blank character, including an all blank entry, leads to the \n  exclusion of the observation from the analysis. \n\nInteractions: You can divide the data at random into training and validation sets by providing the VALIDATE= and SEED= options.  \nIf you specify both the ROLEVAR= option and the VALIDATE= options, then the ROLEVAR= setting supersedes the VALIDATE= option."},"StatementOptionType":"V"},{"StatementOptionName":"SCORE","StatementOptionHelp":{"#cdata":"Syntax: SCORE <(score-statistic1score-statistic2...)>\n\nRequests that the active table be scored after the model is fit and the results be stored in a \ntemporary table. The server automatically adds all model variables to the temporary table with \nthe score results. These results include the response variable, the class variables, all explanatory \nvariables from which effects are formed, and the WEIGHT=, and FREQ= variables. \n\nIf you do not specify the list of score statistics, default statistics are computed. These statistics \nare identified with Yes in the Default column in the table below. You can request that the following \nstatistics be computed for each observation: \n--------------------------------------------------------------------------------------------------------------------------------------\nKeyword and Aliases     Column Name     Description                                       Default\n--------------------------------------------------------------------------------------------------------------------------------------\nPRED, PREDICTED, MEAN   _PRED_          Predicted value                            Yes\nRESID, RESIDUAL, R      _RESID_         Raw residual (observed - predicted)        Yes\nSTUDENT                 _STUDENT_       Studentized residual                       Yes\nRSTUDENT                _RSTUDENT_      Studentized residual with the current observation removed  Yes\nLEVERAGE, H             _LEVERAGE_      Leverage value of the observation          Yes\nSTDP                    _STDP_          Standard error of the mean predicted value  No\nSTDR                    _STDR_          Standard error of the residual              No\nSTDI                    _STDI_          Standard error of the (individual) predicted value  No\nLCLM, LOWERMEAN         _LCLM_          Lower confidence limit for the mean of the predicted value No\nUCLM, UPPERMEAN         _UCLM_          Upper confidence limit for the mean of the predicted value No\nLCL, LOWERPRED          _LCL_           Lower confidence limit for the predicted value    No\nUCL, UPPERPRED          _UCL_           Upper confidence limit for the predicted value    No\nCOOKD, COOKSD           _COOKD_         Cook's D influence measure No\nDFFITS                  _DFFITS_        Standardized influence of the observation on predicted value    No\nCOVRATIO                _COVRATIO_      Standardized influence of the observation on the covariance matrix of the parameter estimates  No\nLIKEDIST, LD            _LIKEDIST_      Displacement (distance) of log-likelihood when the observation is removed (assuming normal distribution) No"},"StatementOptionType":"S|V"},{"StatementOptionName":"SEED=","StatementOptionHelp":{"#cdata":"Syntax: SEED=number\n\nSpecifies the random number seed for generating random numbers. The random number is used to determine \nwhether an observation belongs to the training or validation data set. The SEED= option has no effect \nunless you specify the VALPROP= option. If the specified number is negative or zero, the random number \ngeneration is based on the computer clock of the server\u2014this generates a non-reproducible random number \nsequence."},"StatementOptionType":"V"},{"StatementOptionName":"SELECT=","StatementOptionHelp":{"#cdata":"Syntax: SELECT=(list-of-ODS-tables) \n\nSpecifies the list of ODS tables that you want to display for the analysis. The specified list replaces \nthe default tables that are generated by the server and displayed. See the EXCLUDE= option for the list \nof default tables and the table names that you can display."},"StatementOptionType":"V"},{"StatementOptionName":"SHOWSELECTED|SHOWSEL","StatementOptionHelp":{"#cdata":"Requests that the server perform variable selection for the model. A backward selection method is used, \nwhere the significance level for an effect to remain in the model is determined by the SLSTAY= option. \nThis option performs variable selection like the VARSEL option, but in contrast to the latter option, \nit displays output only for the selected effects."},"StatementOptionType":"S"},{"StatementOptionName":"SLSTAY=","StatementOptionHelp":{"#cdata":"Syntax: SLSTAY=\u03b1\n\nSpecifies the significance level used in determining whether effects should stay in the model \nduring variable selection. \n\nDefault: 0.1 \nRange: 0 to 1"},"StatementOptionType":"V"},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary \nvariables or a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPTABLE","StatementOptionHelp":{"#cdata":"Generates an in-memory temporary table from the result set. The IMSTAT procedure displays the \nname of the table and stores it in the &_TEMPLAST_ macro variable, provided that the statement \nexecuted successfully. \n\nWhen the IMSTAT procedure exits, all temporary tables created during the IMSTAT session are \nremoved. Temporary tables are not displayed on a TABLEINFO request, unless the temporary table \nis the active table for the request."},"StatementOptionType":"S"},{"StatementOptionName":"VALIDATE=|VALPROP=","StatementOptionHelp":{"#cdata":"Syntax: VALIDATE=f\n\nSpecifies the proportion f in the validation data set. \n\nRange: 0 to 1  \n\nInteraction: If you specify both the ROLEVAR= option and the VALIDATE= option, then the ROLEVAR= \nsetting supersedes the VALIDATE= option."},"StatementOptionType":"V"},{"StatementOptionName":"VARSELECTION|VARSEL","StatementOptionHelp":{"#cdata":"Specifies that the server perform variable selection for the model. A backward selection method \nis used, where the significance level for an effect to remain in the model is determined by the \nSLSTAY= option. In contrast to the SHOWSEL option, all effects are reported in the IMSTAT output."},"StatementOptionType":"S"},{"StatementOptionName":"VIF","StatementOptionHelp":{"#cdata":"Produces variance inflation factors and tolerances, the reciprocal of the VIF, for the parameter estimates."},"StatementOptionType":"S"},{"StatementOptionName":"WEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT=variable-name\n\nSpecifies the numeric variable to use as a weighing variable in solving the linear model."},"StatementOptionType":"V"}]}},{"StatementName":"GROUPBY","StatementHelp":{"#cdata":"Syntax: GROUPBY <variable-list> </ options>; \n      \nThe GROUPBY statement derives the grouping hierarchy of the distinct formatted values for the \nspecified variables. If no list of variable names is specified, the grouping hierarchy is computed \nfor all variables in the active table. The statement can return a section of all distinct groupings \nto the client or save the entire grouping set as a temporary table in the server."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"AGGREGATE=|AGG=","StatementOptionHelp":{"#cdata":"Syntax: AGGREGATE=(aggregation-method) \n\nLists the aggregator on which the ordering of the result set is based. \n\nLists the aggregator for which the values of the WEIGHT variable are rolled up into a rank order score, \nprovided that a WEIGHT= variable is specified. If no WEIGHT= variable is specified, then the aggregator \nspecification is ignored. \n\nThe available aggregation methods for the GROUPBY statement are as follows: \n\n  MAX maximum value \n  MEAN arithmetic mean \n  MIN minimum value \n  N counts the nonmissing values of the weight variable \n  SUM sum of the weight values \n  \nDefault SUM"},"StatementOptionType":"V"},{"StatementOptionName":"DESCENDING","StatementOptionHelp":{"#cdata":"Specifies to arrange the returned grouping hierarchy of the variables in descending order of the item \nrankings. If this option is not specified, the returned items are arranged in ascending order. When \ncombined with the LIMIT=n option, the GROUPBY statement can either return the top n or the bottom n \ndistinct groupings. \n\nInteraction The DESCENDING option is ignored if the TEMPTABLE option is specified."},"StatementOptionType":"S"},{"StatementOptionName":"FREQ=","StatementOptionHelp":{"#cdata":"Syntax: FREQ=variable-name\n\nSpecifies the numeric frequency variable that is used to compute the ranking of a distinct grouping. \nWhen this option is specified, the AGGREGATE= and WEIGHT= options are ignored. The following GROUPBY \nstatement requests the top 5 groupings of Region and then Product from the Prdsale table. The groupings \nare rank ordered by the sum of the Actual column: \n\nExample:\n\nproc imstat data = mylasr.prdsale;\n    groupby region product / freq = actual limit = 5;\nrun;"},"StatementOptionType":"V"},{"StatementOptionName":"LIMIT=","StatementOptionHelp":{"#cdata":"Syntax: LIMIT=n\n\nSpecifies the maximum number of distinct groupings to be returned. When combined with the DESCENDING \noption, the GROUPBY statement can either return the top n or the bottom n distinct groupings. The value \nfor n must be a positive integer. For example, the commands below return the bottom 5 groupings according \nto their Score values: \n\nDefault: 0 \nInteraction: This option is ignored if the TEMPTABLE option is specified.  \nTip: If n is zero, then all distinct groupings are returned (up to 231\u20131). With high-cardinality data sets, \nsetting n to zero can significantly delay the response of the server."},"StatementOptionType":"V"},{"StatementOptionName":"NOMISSING|NOMISS","StatementOptionHelp":{"#cdata":"Specifies that missing values are excluded in the determination of GROUPBY values. By default, levels \nwith missing values are included."},"StatementOptionType":"S"},{"StatementOptionName":"NOTEMPPART","StatementOptionHelp":{"#cdata":"Specifies that the temporary table that is generated by the TEMPTABLE option is not partitioned \nby the group-by variables. When you create a temporary table with the GROUPBY statement, by default, \nthe server partitions the table and each partition has a single row. When the number of groups is \nlarge, this results in many tiny partitions and requires additional memory resources to store the \npartition information for the temporary table. \n\nBy specifying this option, the temporary table is organized similarly to the default table, but it \nis not partitioned. This also enables more efficient processing of the table in threaded computations. \nFor example, it is more efficient if you were to add computed columns to the table that you want to use \nas dimension keys in subsequent SCHEMA statements."},"StatementOptionType":"S"},{"StatementOptionName":"ORDER=","StatementOptionHelp":{"#cdata":"Syntax: ORDER=rank-order-type\n\nSpecifies the rank ordering to use for sorting the distinct groupings. The following \nrank-order types are valid in the GROUPBY statement: \n\n  FREQ frequency count of the variables \n  VALUE formatted values of the variables \n  WEIGHT aggregate values of the WEIGHT= variables \n\nDefault FREQ"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"FREQ","@Value2":"VALUE","@Value3":"WEIGHT"},"StatementOptionToolTips":{"@ToolTip1":"Specifies to order by frequency count","@ToolTip2":"Specifies to order by raw or formatted values of the variable","@ToolTip3":"Specifies to order by the aggregate values of the WEIGHT= variable "}},{"StatementOptionName":"PARTITION","StatementOptionHelp":{"#cdata":"Syntax: PARTITION <=partition-key>\n\nSpecifies that when the active table is partitioned, then the variable-list that you specify for the \nGROUPBY statement is expanded to include the partition variables. The partition variables are added \nto the beginning of the variable-list. \n\nIf you do not specify a partition-key, the analysis is performed for all partitions. If you do specify \na partition-key, the analysis is carried out for the specified key value only. You can use the PARTITIONINFO \nstatement to retrieve the valid partition key values for a table."},"StatementOptionType":"S|V"},{"StatementOptionName":"SAVE=","StatementOptionHelp":{"#cdata":"Syntax: SAVE=table-name\n\nSaves the result table so that you can use it in other IMSTAT procedure statements like STORE, REPLAY, \nand FREE. The value for table-name must be unique within the scope of the procedure execution. The name \nof a table that has been freed with the FREE statement can be used again in subsequent SAVE= options."},"StatementOptionType":"V"},{"StatementOptionName":"SETSIZE","StatementOptionHelp":{"#cdata":"Requests that the server estimate the size of the result set. The procedure does not create a result \ntable if the SETSIZE option is specified. Instead, the procedure reports the number of rows that are \nreturned by the request and the expected memory consumption for the result set (in KB). If you specify \nthe SETSIZE option, the SAS log includes the number of observations and the estimated result set size."},"StatementOptionType":"S"},{"StatementOptionName":"SCOREGT=|SGT=","StatementOptionHelp":{"#cdata":"Syntax: SCOREGT=f\n\nSpecifies the exclusive lower bound of the numeric rank order scores of the distinct groupings to \nreturn. All distinct groupings with numeric rank order scores that are greater than f are returned. \n\nInteraction: This option is ignored if the TEMPTABLE option is specified."},"StatementOptionType":"V"},{"StatementOptionName":"SCORELT=|SLT=","StatementOptionHelp":{"#cdata":"Syntax: SCORELT=f\n\nSpecifies the exclusive upper bound of the numeric rank order scores of the distinct groupings \nto return. All distinct groupings with numeric rank order scores that are less than f are returned. \n \nInteraction: This option is ignored if the TEMPTABLE option is specified."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary \nvariables or a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPTABLE","StatementOptionHelp":{"#cdata":"Generates an in-memory temporary table from the result set. The IMSTAT procedure displays the \nname of the table and stores it in the &_TEMPLAST_ macro variable, provided that the statement \nexecuted successfully. \n\nWhen the IMSTAT procedure exits, all temporary tables created during the IMSTAT session are \nremoved. Temporary tables are not displayed on a TABLEINFO request, unless the temporary table \nis the active table for the request."},"StatementOptionType":"S"},{"StatementOptionName":"VALUEGT=|VGT=","StatementOptionHelp":{"#cdata":"Syntax: VALUEGT=(\"format-specification\", ...) \n\nSpecifies the exclusive lower bound of the variable\u2019s formatted values of the distinct groupings \nto return. All distinct groupings with formatted values for the variable that are lexicographically \ngreater than the specified bound are returned. \n\nInteraction: This option is ignored if the TEMPTABLE option is specified."},"StatementOptionType":"V"},{"StatementOptionName":"VALUELT=|VLT=","StatementOptionHelp":{"#cdata":"Syntax: VALUELT=(\"format-specification\", ...) \n\nSpecifies the exclusive upper bound of the variable\u2019s formatted values of the distinct groupings \nto return. All distinct groupings with formatted values for the variable that are lexicographically \nless than the specified bound are returned. \n\nInteraction: This option is ignored if the TEMPTABLE option is specified."},"StatementOptionType":"V"},{"StatementOptionName":"VARFORMATS=","StatementOptionHelp":{"#cdata":"Syntax: VARFORMATS=(\"format-specification\", ...) \n\nSpecifies the formats for the variables. If you do not specify the VARFORMATS= option, the default \nformats are applied for the variables."},"StatementOptionType":"V"},{"StatementOptionName":"WEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT=variable-name\n\nSpecifies the numeric weight variable to use for computing the rank order score of a distinct grouping. \n\nInteraction: When the WEIGHT= option is specified, the server sets the ORDER= option to ORDER=WEIGHT."},"StatementOptionType":"V"}]}},{"StatementName":"HISTOGRAM","StatementHelp":{"#cdata":"Syntax: HISTOGRAM <variable-list> </ options>; \n\nvariable-list\n  specifies a single variable or a list of numeric variables. Separate each variable name by at least one space. \n  If you do not specify this option, a histogram table is calculated for each numeric variable. \n  \nThe HISTOGRAM statement calculates a histogram table for numeric variables."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"BINVALS=","StatementOptionHelp":{"#cdata":"Syntax: BINVALS=list-of-values\n\nSpecifies an array of NBINS lower bin boundaries as list-of-values. The histogram binning then uses \nthose values strictly and does not alter them so that they are equally spaced (or \u201cnice\u201d). This option \nis useful to compute a histogram with bins that are the same as those of another histogram so that the \nvalues can be compared or overlaid. The bins do not need to be equally spaced."},"StatementOptionType":"V"},{"StatementOptionName":"EQUALFREQ|EQUAL","StatementOptionHelp":{"#cdata":"Specifies to create bins such that each bin contains the same fraction of the data."},"StatementOptionType":"S"},{"StatementOptionName":"MAX=","StatementOptionHelp":{"#cdata":"Syntax: MAX=number\n\nSpecifies the upper end of the range to determine the histogram bins. By default, the maximum value \nis determined from the data (subject to the WHERE clause). The bins of the histogram can extend beyond \nthe extreme values when the \"nice-ing\" algorithm places bin boundaries on numbers that are convenient \nto label on axes."},"StatementOptionType":"V"},{"StatementOptionName":"MIN=","StatementOptionHelp":{"#cdata":"Syntax: MIN=number\n\nSpecifies the lower end of the range to determine the histogram bins. By default, the minimum \nvalue is determined from the data (subject to the WHERE clause). The bins of the histogram can \nextend beyond the extreme values when the \"nice-ing\" algorithm places bin boundaries on numbers \nthat are convenient to label on axes."},"StatementOptionType":"V"},{"StatementOptionName":"NBINS=","StatementOptionHelp":{"#cdata":"Syntax: NBINS=k\n\nSpecifies the number of bins to use for calculating the histogram."},"StatementOptionType":"V"},{"StatementOptionName":"NOEMPTYBIN","StatementOptionHelp":{"#cdata":"Prevents bins without observations from being displayed. The leading and trailing empty bins are trimmed. \nAny internal empty bins are combined into the first non-empty bin to the immediate right. The mid-value \nof the bin into which the empty bins are combined is not adjusted. If the mid-value is not missing, then \nyou can use the asymmetry of a bin as an indicator that it was combined with empty bins."},"StatementOptionType":"S"},{"StatementOptionName":"NONICE","StatementOptionHelp":{"#cdata":"Specifies that the \"nice-ing\" algorithm is suspended. The boundaries of the histogram are based on \nthe actual range of the data (subject to the WHERE clause) or on the MIN= and MAX= values that you \nspecify. The bin boundaries are not guaranteed to fall on \"nice\" values."},"StatementOptionType":"S"},{"StatementOptionName":"OUTLIERBIN","StatementOptionHelp":{"#cdata":"Specifies that outliers are placed in special bins in the two tails. Outliers with values that fall \nbelow Q1 \u2013 1.5*IQR are placed in the left-most bin. Outliers with a value that is above Q3 + 1.5*IQR \nare placed in the right-most bin. IQR is the inter-quartile range, which covers the central 50% of the \ndistribution of the variable. The mid-value reported by the IMSTAT procedure can be used as an indicator \nwhether a bin is an outlier bin. The mid-value is set to 1 for an outlier bin and set to missing otherwise. \n\nInteraction: This option is ignored if you specify the EQUALFREQ option."},"StatementOptionType":"S"},{"StatementOptionName":"ROUNDINGDIRECTON=","StatementOptionHelp":{"#cdata":"Syntax: ROUNDINGDIRECTON=direction\n\nSpecifies the direction to round numbers when a rounding factor is specified. For example, if you \nspecify ROUNDINGFACTOR=5, a bin boundary of 6.2 is rounded up to 10, down to 5, and nearest to 5."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"UP","@Value2":"DOWN","@Value3":"NEAREST"},"StatementOptionToolTips":{"@ToolTip1":"Round up to a multiple of the ROUNDINGFACTOR= value.","@ToolTip2":"Round down to a multiple of the ROUNDINGFACTOR= value.","@ToolTip3":"Round to the nearest multiple of the ROUNDINGFACTOR= value."}},{"StatementOptionName":"ROUNDINGFACTOR=","StatementOptionHelp":{"#cdata":"Syntax: ROUNDINGFACTOR=value\n\nSpecifies the factor to use for rounding up internal bin boundaries. The lower bound of the left-most \nbin and the upper bound of the right-most bin are not rounded. For example, when you work with prices \nin dollars, specifying ROUNDINGFACTOR=0.01 rounds the bin boundaries to cents. In the event that the \nspecified rounding factor is greater than the bin width and multiple bins round up to the same number, \nthe bins are collapsed into a single bin."},"StatementOptionType":"V"},{"StatementOptionName":"SAVE=","StatementOptionHelp":{"#cdata":"Syntax: SAVE=table-name\n\nSaves the result table so that you can use it in other IMSTAT procedure statements like STORE, REPLAY, \nand FREE. The value for table-name must be unique within the scope of the procedure execution. The name \nof a table that has been freed with the FREE statement can be used again in subsequent SAVE= options."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary variables \nor a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"}]}},{"StatementName":"HYPERGROUP","StatementHelp":{"#cdata":"Syntax: HYPERGROUP <variable-list> </ options>; \n      \nvariable-list\n  specifies the variables to include in the analysis. The variables must have a character data type. \n  Separate variable names with a space. If you do not specify any variables, then all character variables \n  in the active table are used in the analysis. \n\nThe HYPERGROUP statement analyzes a graph whose vertices are identified by values of the analysis \nvariables and whose edges are named by those variables within the same observation. The analysis \nthat can be performed falls into three general areas: structural analysis of the overall graph, \ncentrality calculation for individual vertices, and layout of the graph in either 2-D or 3-D space. "},"StatementOptions":{"StatementOption":[{"StatementOptionName":"C=","StatementOptionHelp":{"#cdata":"Syntax: C=relative-strength\n\nSpecifies the relative strength of local forces to global forces with regard to laying out the \npositions of vertices and edges. The Walshaw layout is a force-directed algorithm that finds \npositions of vertices so that no vertices are too close together and so that (usually) edges \nare about the same length. The force term in a force-directed layout algorithm is related to \nsprings. Imagine each vertex is a ring and each edge is a spring whose ends are hooked around \nthe rings of the vertices to which the edge connects. \n\nDefault: 0.01 \nApplies to LAYOUT=WALSHAW"},"StatementOptionType":"V"},{"StatementOptionName":"CENTRALITY","StatementOptionHelp":{"#cdata":"Specifies to quantify the importance of each vertex among its peers. Many types of centrality have \nbeen defined. The HYPERGROUP statement supports five that are commonly used. Four of these are based \non shortest paths (the smallest number of edges in a path from one vertex to the other). The fifth is \na geometric measure that can be calculated when graph layout is performed."},"StatementOptionType":"S"},{"StatementOptionName":"CLOSITERS=","StatementOptionHelp":{"#cdata":"Syntax: CLOSITERS=n\n\nSpecifies the number of layout iterations that are performed before a sub-algorithm determines the \nvertices that are close to each other. Increasing the value can improve performance because more \niterations are performed between attempts to evaluate which nodes are too close together. \n\nDefault: 3"},"StatementOptionType":"V"},{"StatementOptionName":"COMMALGORITHM=|COMMALG=","StatementOptionHelp":{"#cdata":"Syntax: COMMALGORITHM= ASYNCHRONOUS |\n\nCOMMALGORITHM= SYNCHRONOUS | SEMISYNCHRONOUS\nCOMMALGORITHM= LLSYNCHRONOUS | LLSEMISYNCHRONOUS\n\nSpecifies a particular label propagation algorithm when STRUCTURAL=COMMUNITY analysis is specified. \nThe LL prefix indicates to use a parallel version of the algorithm."},"StatementOptionType":"V"},{"StatementOptionName":"COMMITERS=","StatementOptionHelp":{"#cdata":"Syntax: COMMITERS=n\n\nSpecifies the number of iterations to perform while determining communities. Communities are determined \nby a variant of the label propagation algorithm described in Raghavan, Reka, and Kumara (2007). The \nalgorithm is iterative, and stops when COMMITERS= iterations have been performed. \n\nThe algorithm might perform fewer iterations than are specified if all vertices have this property: \na community c is formed by a set of vertices so that for any vertex v in c, the number of edges directed \nfrom v to other vertices in c outnumber or tie the number of edges directed from v to vertices outside c. \n\nDefault: 20 \nTip: The synchronous algorithms that are available with the COMMALG= option can require larger values for \n  COMMITERS= for convergence to occur."},"StatementOptionType":"V"},{"StatementOptionName":"COMMLAYOUTS","StatementOptionHelp":{"#cdata":"Specifies to lay out coordinates for the community graph that is produced with the STRUCTURE=COMMUNITY \n(or BOTH) option. The coordinates shown are returned in the _TEMPHYPGRP3_ and TEMPEDGES3_ tables."},"StatementOptionType":"S"},{"StatementOptionName":"COMMMAX=","StatementOptionHelp":{"#cdata":"Syntax: COMMMAX=n\n\nSpecifies the maximum number of iterations to perform to determine labeling for communities. For the \nlabel propagation algorithm used when you specify STRUCTURAL=COMMUNITY, this option, together with \nCOMMPRECENDENCE, alters tie-breaking schemes when there is a choice as to what value should be assigned \nto a vertex label. \n\nLabel propagation is an epidemic algorithm. Avoid setting COMMMAX= too low, because low values tend to \ninfect vertices with the wrong label in early iterations. Different combinations of this option with \nCOMMPRECEDENCE can affect the number and quality of the communities found. Refer to Cardasco and \nGargano (2011 and 2012) for a description the algorithm and these options."},"StatementOptionType":"V"},{"StatementOptionName":"COMMPRECEDENCE|COMMPRE","StatementOptionHelp":{"#cdata":"Syntax: \n\nAn option for tuning the label propagation algorithm used with STRUCTUAL=COMMUNITIES analysis. \nSee the explanation of the COMMMAX= option for details."},"StatementOptionType":"V"},{"StatementOptionName":"CREATETEMPLAST=","StatementOptionHelp":{"#cdata":"Syntax: CREATETEMPLAST= NEVER | ALWAYS | MULTIPLE\n\nSpecifies when to create the _TEMPLAST_ temporary table that identifies the hypergroups and analysis \nvariables. If you use a large active table with the HYPERGROUP statement, then the _TEMPLAST_ temporary \ntable can be large as well. \n\nDefault: ALWAYS"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NEVER","@Value2":"ALWAYS","@Value3":"MULTIPLE"},"StatementOptionToolTips":{"@ToolTip1":"Specifies to never create the _TEMPLAST_ temporary table. Be aware that the other in-memory temporary  tables like _TEMPHYPGRP_ and _TEMPEDGES_ are created. These have summarized information about the  hypergroups and are smaller than the _TEMPLAST_ table.","@ToolTip2":"Specifies to create the _TEMPLAST_ temporary table. ","@ToolTip3":"Specifies to create the _TEMPLAST_ temporary table when the analysis results in more than one hypergroup."}},{"StatementOptionName":"FAR_AWAY=","StatementOptionHelp":{"#cdata":"Syntax: FAR_AWAY=d\n\nSpecifies how to tune the layouts when LAYOUY=WALSHAW is specified. \n\nWhen FAR_AWAY=1, the default value, the Walshaw algorithm models global forces between vertices \nif these vertices are not far away from each other. How far away is determined is complicated, \ndepends on the size of the graph, and depends on what stage of graph partitioning is being performed. \nThe FAR_AWAY= option expresses a multiple of the usual value that the algorithm would calculate. \n\nIn other words, if d is usually the greatest distance between two vertices that are allowed to exert \na global force on each another, then specifying FAR_AWAY=2 indicates that vertices that are twice d \naway from each other are allowed to exert global forces. Of course, the farther away vertices are from \neach other, the weaker are the global forces, but even vertices farther away (but not excluded), can be \ninfluential if there are enough vertices to include. The FAR_AWAY= option controls how many of the distant \nvertices can exert pull. \n\nThe result of using larger values for FAR_AWAY= is similar to using larger values for C=. In both cases, \nthe larger values for the options makes the layouts more spacious, at the expense of laying out all edges \nto have similar lengths. A distinctive feature of larger FAR_AWAY= values is that it causes vertices to be \npositioned farther from the center toward the nearest pane border. \n\nDefault: 1"},"StatementOptionType":"V"},{"StatementOptionName":"FORMATS=","StatementOptionHelp":{"#cdata":"Syntax: FORMATS=(\"format-specification\",...) \n\nSpecifies the formats for the GROUPBY= variables. If you do not specify the FORMAT= option, or if you \ndo not specify the GROUPBY= option, the default format is applied for that variable. \n\nEnclose each format specification in quotation marks and separate each format specification with a comma."},"StatementOptionType":"V"},{"StatementOptionName":"GRAPHPARTITION","StatementOptionHelp":{"#cdata":"Specifies to tune the layout to improve the separation of vertices. This option can increase the \nprocessing duration. \n\nApplies to LAYOUT=WALSHAW or LAYOUT=FRUCHGOLD"},"StatementOptionType":"S"},{"StatementOptionName":"GROUPBY=","StatementOptionHelp":{"#cdata":"Syntax: GROUPBY=(variable-list) \n\nSpecifies a list of variable names, or a single variable name, to use as GROUPBY variables in the order \nof the grouping hierarchy. If you do not specify any GROUPBY variable names, then the calculation is \nperformed across the entire table\u2014possibly subject to a WHERE clause."},"StatementOptionType":"V"},{"StatementOptionName":"GROUPBYLIMIT=","StatementOptionHelp":{"#cdata":"Syntax: GROUPBYLIMIT=n\n\nSpecifies the maximum number of levels in a GROUPBY set. When the software determines that there are \nat least n levels in the GROUPBY set, it abandons the action, returns a message, and does not produce \na result set. You can specify the GROUPBYLIMIT= option if you want to avoid creating excessively large \nresult sets in GROUPBY operations."},"StatementOptionType":"V"},{"StatementOptionName":"GROUPFILTER=","StatementOptionHelp":{"#cdata":"Syntax: GROUPFILTER=(groupfilter-options) \n\nSpecifies a section of the GROUPBY= hierarchy to include in the HYPERGROUP computation."},"StatementOptionType":"V"},{"StatementOptionName":"HEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: HEIGHT=z\n\nSpecifies the maximum value for the frame's coordinate space in the Z-axis. \n\nBe aware that the MARGIN= value is subtracted from the HEIGHT= value. \n\nDefault: 100 units \nInteraction: This option is used only when you specify the THREED option."},"StatementOptionType":"V"},{"StatementOptionName":"HIGHDEGREE=","StatementOptionHelp":{"#cdata":"Syntax: HIGHDEGREE= 0 | 1\n\nSpecifies to enable a heuristic that begins partitioning by eliminating vertices of unusually high degree. \nSome graphs have many vertices with low degree. The degree of a vertex is the number of edges that originate \nfrom or are directed toward the vertex. However, some graphs might have some vertices with very high degree. \nIt is often beneficial to treat these high degree vertices as partitions early in the partitioning algorithm, \neven if they do not strictly split a graph. This simplifies the processing so that from what is left of the \nremaining graphs are less dense and faster to process. \n\nDefault: 0 (disabled) \nRange: 0 or 1"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"0","@Value2":"1"},"StatementOptionToolTips":{"@ToolTip1":"Specifies to disable a heuristic that begins partitioning by eliminating vertices of unusually high degree. ","@ToolTip2":"Specifies to enable a heuristic that begins partitioning by eliminating vertices of unusually high degree."}},{"StatementOptionName":"LAYOUT=","StatementOptionHelp":{"#cdata":"Syntax: LAYOUT= WALSHAW | FRUCHGOLD | OTHER\n\nSpecifies one of three force-directed algorithms to use for graph layout. \n\nIf you specify either LAYOUT=WALSHAW or LAYOUT=FRUCHGOLD, you can also specify the GRAPHPARTITION \noption, so that graph partitioning is used. \n\nThe WALSHAW option performs the algorithm described by C. Walshaw (2000). The FRUCHGOLD option \nperforms the algorithm described by T.M.J. Fruchterman and E.M. Reingold (1991). Specifying OTHER \nperforms an algorithm that is proprietary to SAS. \n\nThe force term in force-directed layout algorithm is related to springs. Imagine each vertex is a \nring and each edge is a spring whose ends are hooked around the rings of the vertices the edge connects. \nEach spring is equally springy. If a spring is too compressed, it wants to push apart the vertices at its \nends. If the spring is too extended, the spring wants to pull the vertices closer together. In addition, \nvertices that are near each other but are not connected by an edge are modeled as if there is a temporary \nspring between them that is capable of only repulsion. This method for modeling is done to prevent laying \nout vertices too closely to each other. Of course, if vertices are very close, the repulsion is very great. \n\nDefault LAYOUT=WALSHAW"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"WALSHAW","@Value2":"FRUCHGOLD","@Value3":"OTHER"},"StatementOptionToolTips":{"@ToolTip1":"The WALSHAW option performs the algorithm described by C. Walshaw (2000).","@ToolTip2":"The FRUCHGOLD option performs the algorithm described by T.M.J. Fruchterman and E.M. Reingold (1991).","@ToolTip3":"Specifying OTHER performs an algorithm that is proprietary to SAS."}},{"StatementOptionName":"LENGTH=","StatementOptionHelp":{"#cdata":"Syntax: LENGTH=y\n\nSpecifies the maximum value for the frame's coordinate space in the Y-axis. \n\nBe aware that the MARGIN= value is subtracted from the LENGTH= value. \n\nDefault: 100 units"},"StatementOptionType":"V"},{"StatementOptionName":"MARGIN=","StatementOptionHelp":{"#cdata":"Syntax: MARGIN=n\n\nSpecifies the size of the border around the frame's coordinate space to remain free of vertices. \nFor example, if you specify LENGTH=100, WIDTH=100, and MARGIN=12, then the frame coordinate space \nis 100 \u00d7 100 units and vertices have coordinates within the corners (12, 12), (12, 88), (88, 12), \nand (88, 88)."},"StatementOptionType":"V"},{"StatementOptionName":"MAXNODES=","StatementOptionHelp":{"#cdata":"Syntax: MAXNODES=n\n\nSpecifies to tune graph partitioning by specifying the maximum number of nodes to permit in a partition. \nEach time a partitioning is performed, the resulting set of partitioned subgraphs is examined. If any \nexceed the maximum number of nodes specified in this option, then the partitioning is repeated on those \npartitions. \n\nDefault: 4"},"StatementOptionType":"V"},{"StatementOptionName":"MAXNVALS=","StatementOptionHelp":{"#cdata":"Syntax: MAXNVALS=i\n\nSpecifies a positive integer that determines the maximum number of iterations for the percentile algorithm. \n\nDefault: 1000"},"StatementOptionType":"V"},{"StatementOptionName":"NITERATIONS=|NITERS=","StatementOptionHelp":{"#cdata":"Syntax: NITERATIONS=i\n\nSpecifies a positive integer that determines the maximum number of iterations to execute for the \nforced-directed layout algorithm. A value between 200 and 5000 produces good results with most \ndata sets. The LAYOUT=WALSHAW layout algorithm might stop before completing all NITER= iterations \nif the algorithm detects that convergence has occurred. \n\nIf you specify NITERS=0, then it is the same as specifying the NOCOORD option. \n\nDefault: 1000"},"StatementOptionType":"V"},{"StatementOptionName":"NOCOLOR|NOCOLOUR","StatementOptionHelp":{"#cdata":"\n\nSpecifies not to run the graph partitioning algorithm to assign colors to strongly connected \ncommunities. The algorithm is run by default. This option is useful if you do not use the color \nvalues. You can avoid the processing that is performed to assign color categories."},"StatementOptionType":"S"},{"StatementOptionName":"NOCOORD","StatementOptionHelp":{"#cdata":"Specifies not to perform graph layout of vertices and edges. Graph layout is the most time-consuming \ncalculation that the HYPERGROUP statement performs. This option is useful if you do not need a visual \nor geometric layout, or calculation of centroid centrality. This option can improve the response time \nand conserve machine resources."},"StatementOptionType":"S"},{"StatementOptionName":"NOPENDANTS","StatementOptionHelp":{"#cdata":"Specifies to simplify the graph layout by removing pendants (nodes of degree one). This option \nis performed repeatedly until no pendants remain in the graph."},"StatementOptionType":"S"},{"StatementOptionName":"NOVARS","StatementOptionHelp":{"#cdata":"Specifies not to transfer additional variables to the _TEMPLAST_ table. See also VARS=."},"StatementOptionType":"S"},{"StatementOptionName":"PARTITION|PART","StatementOptionHelp":{"#cdata":"Syntax: PARTITION <=partition-key>\n\nWhen you specify this option and the table is partitioned, the results are calculated separately \nfor each value of the partition key. In other words, the partition variables function as automatic \nGROUPBY variables. This mode of executing calculations by partition is more efficient than using the \nGROUPBY= option. With a partitioned table, the server takes advantage of knowing that observations \nfor a partition cannot be located on more than one worker node. \n\nIf you do not specify a partition-key, the analysis is performed for all partitions. If you do \nspecify a partition-key, the analysis is carried out for the specified key value only. You can use \nthe PARTITIONINFO statement to retrieve the valid partition key values for a table. \n\nYou can specify a partition-key in two ways. You can supply a single quoted string that is passed \nto the server, or you can specify the elements of a composite key separated by commas."},"StatementOptionType":"S|V"},{"StatementOptionName":"RADIANS","StatementOptionHelp":{"#cdata":"Specifies to return the centroid centrality angles in radians rather than degrees. \n\nApplies to CENTRALITY option"},"StatementOptionType":"S"},{"StatementOptionName":"SAVE=","StatementOptionHelp":{"#cdata":"Syntax: SAVE=table-name\n\nSaves the result table so that you can use it in other IMSTAT procedure statements like STORE, REPLAY, \nand FREE. The value for table-name must be unique within the scope of the procedure execution. The name \nof a table that has been freed with the FREE statement can be used again in subsequent SAVE= options."},"StatementOptionType":"V"},{"StatementOptionName":"SCALECOORDS","StatementOptionHelp":{"#cdata":"Specifies to scale vertex coordinate values so that they are within the boundaries specified with \nthe LENGTH=, WIDTH=, and HEIGHT= options. This option is useful when you specify LAYOUT=FRUCHGOLD \nor LAYOUT=OTHER algorithm and GRAPHPARTITION is not specified."},"StatementOptionType":"S"},{"StatementOptionName":"SEPARATOR=","StatementOptionHelp":{"#cdata":"Syntax: SEPARATOR= NODES | VERTICES\nSEPARATOR= ARCS | EDGES\nSEPARATOR= HYBRID\n\nSpecifies how to tune the graph partitioning algorithm by indicating how to choose partition separators. \n\nGraph partitioning works to find separators that are small and partitions that are large. A vertex \nseparator is a set of vertices that, if removed from the graph, results in two or more separate sub-graphs \nthat correspond to partitions. An edge separator is a set of edges that, if removed, results in two or more \nseparate sub-graphs that correspond to partitions. There is never an edge between vertices in separate partitions. \n\nBy default, SEPARATOR=HYBRID. In this case, a vertex separator is ultimately determined, but in the initial \nstages of graph partitioning, edge separators are determined. As graph partitioning continues, vertex separation is used. \n\nDefault HYBRID"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"VERTICES","@Value2":"NODES","@Value3":"EDGES","@Value4":"ARCS","@Value5":"HYBRID"},"StatementOptionToolTips":{"@ToolTip1":"A vertex separator is a set of vertices that, if removed from the graph, results in two or more  separate sub-graphs that correspond to partitions.","@ToolTip2":"Alias for VERTICES. Same as SEPARATOR=VERTICES.","@ToolTip3":"An edge separator is a set of edges that, if removed, results in two or more separate sub-graphs  that correspond to partitions. There is never an edge between vertices in separate partitions.","@ToolTip4":"Alias for EDGES. Same as SEPARATOR=EDGES.","@ToolTip5":"In this case, a vertex separator is ultimately determined, but in the initial stages of graph  partitioning, edge separators are determined. As graph partitioning continues, vertex separation  is used. "}},{"StatementOptionName":"SETSIZE","StatementOptionHelp":{"#cdata":"Requests that the server estimate the size of the result set. The procedure does not create a result \ntable if the SETSIZE option is specified. Instead, the procedure reports the number of rows that are \nreturned by the request and the expected memory consumption for the result set (in KB). If you specify \nthe SETSIZE option, the SAS log includes the number of observations and the estimated result set size."},"StatementOptionType":"S"},{"StatementOptionName":"STRUCTURAL=","StatementOptionHelp":{"#cdata":"Syntax: STRUCTURAL= NONE | COLOR | COLOUR | COMMUNITY | BOTH\n\nHypergroups (completely disconnected subsets) are always identified within the graph. Specify this \noption to request additional structural analyses that identify strongly connected components within \neach hypergroup. This option enables you to find subsets of the graph whose vertices have many \ninterrelationships internally, but fewer between the subset. Unlike hypergroups, these subsets are \nnot disconnected from each other. \n\nWhen you specify this option, two additional temporary tables are created for vertices and edges. \nThese tables depict the strongly connected components as a graph. Using these tables, it is possible \nto zoom out from the detailed graph\u2014to depict the mesostructure or macrostructure of the graph. In a \nsense, this is the graph theory equivalent of aggregation on numeric quantities. \n\nDefault: NONE"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"COLOR|COLOUR","@Value3":"COMMUNITY","@Value4":"BOTH"},"StatementOptionToolTips":{"@ToolTip1":"","@ToolTip2":"Specifies to identify the strongly connected components with the graph partition algorithm and  assigns a color value to each component. A color value is assigned to each vertex and edge.  The following table identifies each component, table, and column name that includes a color  value.  --------------------------------------------------- Component   Table Name      Column Name --------------------------------------------------- Vertices    _TEMPHYPGRP_    _COLOR_ Edges       _TEMPEDGES_     _SCOLOR_ and _TCOLOR_   In addition, the graph of the derived components is described in the _TEMPHYPGRP2_ and _TEMPEDGES2_ temporary tables.","@ToolTip3":"Specifies to identify the strongly connected components with the label propagation algorithm and  assign each component with a community value. A community value is assigned to each vertex and  edge. The following table identifies each component, table, and column name that includes a  community value.   --------------------------------------------------- Component   Table Name      Column Name --------------------------------------------------- Vertices    _TEMPHYPGRP_    _COMMUNITY_ Edges       _TEMPEDGES_     SCOMMUNITY_ and _TCOMMUNITY_","@ToolTip4":"Specifies to perform COLOR and COMMUNITY analysis."}},{"StatementOptionName":"TEMPTABLE","StatementOptionHelp":{"#cdata":"Specifies to store the results of the analysis in in-memory tables on the server. You do not need \nto specify this option because the HYPERGROUP statement always generates in-memory tables for the \nresult sets."},"StatementOptionType":"S"},{"StatementOptionName":"THREED|D3","StatementOptionHelp":{"#cdata":"Specifies to graph the layout in three dimensions instead of two dimensions. The HEIGHT= option \ncontrols the maximum values for the Z-axis."},"StatementOptionType":"S"},{"StatementOptionName":"TOPLEFT","StatementOptionHelp":{"#cdata":"Specifies to produce the graph layout coordinates and centroid centrality angles based on an origin\nat the top left corner of the drawing window. By default, the HYPERGROUP statement generates coordinates \nbased on an origin at bottom left corner of the drawing window."},"StatementOptionType":"S"},{"StatementOptionName":"VARFORMATS=","StatementOptionHelp":{"#cdata":"Syntax: VARFORMATS=(\"format-specification\",...) \n\nSpecifies the formats to apply to the variables. If you do not specify the VARFORMATS= option, \nthe default formats are applied to the variables."},"StatementOptionType":"V"},{"StatementOptionName":"VARIABLES=|VARS=","StatementOptionHelp":{"#cdata":"Syntax: VARIABLES=(variable-1 ... variable-n) \n\nSpecifies the variables from the active table to transfer to the generated _TEMPLAST_ table as \nadditional ID variables. The variables that are specified after the HYPERGROUP statement are \nalways transferred. By default, all variables are transferred."},"StatementOptionType":"V"},{"StatementOptionName":"WIDTH=","StatementOptionHelp":{"#cdata":"Syntax: WIDTH=x\n\nSpecifies the maximum value for the frame's coordinate space in the X-axis. \n\nBe aware that the MARGIN= value is subtracted from the WIDTH= value. \n\nDefault: 100 units"},"StatementOptionType":"V"}]}},{"StatementName":"KDE","StatementHelp":{"#cdata":"Syntax: KDE variable-list </ options>; \n\nvariable-list\n  specifies a one or more numeric variables. \n\nThe KDE statement calculates kernel-density estimates of the distribution of one or more numeric \nvariables from an in-memory table. You can choose between normal, tricube, and quadratic kernel \nfunctions. The default is to use a normal kernel function. The number of points returned are \ndetermined by the center region of a multi-threaded, inverse finite Fourier transform."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"BANDWIDTH=","StatementOptionHelp":{"#cdata":"Syntax: BANDWIDTH=b\n\nSpecifies the standardized bandwidth of the kernel function. The default bandwidths are optimal values \nthat minimize the asymptotic mean integrated squared errors of the kernel function. The actual bandwidth \nfor the kernel estimator is a multiple of the standardized bandwidth, the inter-quartile range of the data, \nand n-1/5. Larger values for bandwidth result in smoother density estimates. However, specifying a bandwidth \nthat is too large can result in density estimates that omit important aspects of the distribution at finer \ngranularity."},"StatementOptionType":"V"},{"StatementOptionName":"KERNEL=","StatementOptionHelp":{"#cdata":"Syntax: KERNEL= NORMAL | TRICUBE | QUADRATIC\n\nSpecifies the kernel function. \n\nDefault: NORMAL"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NORMAL","@Value2":"TRICUBE","@Value3":"QUADRATIC"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the NORMAL kernel function.","@ToolTip2":"Specifies the TRICUBE kernel function.","@ToolTip3":"Specifies the QUADRATIC kernel function."}},{"StatementOptionName":"MAX=|UPPER=","StatementOptionHelp":{"#cdata":"Syntax: MAX=number\n\nSpecifies the largest value to consider in the density calculation. If a value is not specified, \nthen the largest value in the data range is used, subject to the WHERE clause."},"StatementOptionType":"V"},{"StatementOptionName":"MIN=|LOWER=","StatementOptionHelp":{"#cdata":"Syntax: MIN=number\n\nSpecifies the smallest value to consider in the density calculation. If a value is not specified, \nthe smallest value in the data range is used, subject to the WHERE clause."},"StatementOptionType":"V"},{"StatementOptionName":"MULTIPLER=","StatementOptionHelp":{"#cdata":"Syntax: MULTIPLER=number\n\nSpecifies a scaling factor for the calculated density. \n\nDefault: 1"},"StatementOptionType":"V"},{"StatementOptionName":"NPOINTS=","StatementOptionHelp":{"#cdata":"Syntax: NPOINTS=n\n\nSpecifies the number of points from which to calculate the center region of the inverse finite \nFourier transform. The value of the NPOINTS= option is adjusted to the largest integer of power \nof 2 that is equal to or smaller than n. For example, specifying NPOINTS=40 is adjusted to 32. \nThe number of density points returned depends on the distribution of the data. \n\nDefault: 512 \nRange: 16 to 512"},"StatementOptionType":"V"},{"StatementOptionName":"SAVE=","StatementOptionHelp":{"#cdata":"Syntax: SAVE=table-name\n\nSaves the result table so that you can use it in other IMSTAT procedure statements like STORE, REPLAY, \nand FREE. The value for table-name must be unique within the scope of the procedure execution. The name \nof a table that has been freed with the FREE statement can be used again in subsequent SAVE= options."},"StatementOptionType":"V"},{"StatementOptionName":"SCALE=","StatementOptionHelp":{"#cdata":"Syntax: SCALE= PERCENT | COUNT | PROPORTION\n\nSpecifies the units in which the density is calculated."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"PERCENT","@Value2":"COUNT","@Value3":"PROPORTION"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that density is calculated in percent.","@ToolTip2":"Specifies that density is calculated as a count.","@ToolTip3":"Specifies that density is calculated as a proportion."}},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary variables \nor a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"}]}},{"StatementName":"LOGISTIC","StatementHelp":{"#cdata":"Syntax: LOGISTIC dependent-variable <(class-variables)> = model-effects </ options>\n\nLOGISTIC event-variable / trial-variable <(class-variables)> = model-effects </ options> \n\ndependent-variable\n  specifies the variable to model. This variable is also referred to as the response variable. \nevent-variable\n  specifies the name of the variable that indicates the count of positive responses. \nmodel-effects\n  specifies a list of variables to use for modeling the dependent variable. \ntrial-variable\n  specifies the name of the variable that indicates the total number of trials. \n\nThe LOGISTIC statement can model binary data with logit, probit, log-log, and complementary \nlog-log link functions. It can also model binomial data with the same set of link functions."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ALLIDVARS","StatementOptionHelp":{"#cdata":"Requests that all variables in the input table are treated as ID variables when a scoring table \nis produced. In other words, if this option is specified, all variables from the input table, \nincluding computed columns, are transferred to the scoring table. This option has no effect \nunless you specify the SCORE option."},"StatementOptionType":"V"},{"StatementOptionName":"ALPHA=","StatementOptionHelp":{"#cdata":"Syntax: ALPHA=number\n\nSpecifies a number between 0 and 1 from which to determine the confidence level for approximate \nconfidence intervals of the parameter estimates. The default is \u03b1 = 0.05, which leads to \n100 x (1- \u03b1)% = 95% confidence limits for the parameter estimates. \n\nDefault 0.05"},"StatementOptionType":"V"},{"StatementOptionName":"CI","StatementOptionHelp":{"#cdata":"Syntax: CI\n\nSpecifies to add confidence intervals to the table of parameter estimates. The confidence level \nis 100*(1-\u03b1)% where \u03b1 is determined by the ALPHA= option. The default value is \u03b1 = 0.05. This \nvalue is equivalent to a 95% confidence limit. \n\nDefault 0.05"},"StatementOptionType":"V"},{"StatementOptionName":"CLASSFORMATS=|CLASSFMT=","StatementOptionHelp":{"#cdata":"Syntax: CLASSFORMATS=(\"format-name1\"<, \"format-name2\" ...>) \n\nSpecifies the formats for the classification variables in the model. If you do not specify the \nCLASSFORMATS= option, the default format is applied for the classification variable. That default \nformat was determined when the table was originally loaded into the server. In the following example, \nthe CLASSFORMAT= values apply to variables x1 and x2. \n\nExample:\n\n  logistic y (x1 x2) = x3-x7 / classformats=(\"YN.\", \"F8.\");"},"StatementOptionType":"V"},{"StatementOptionName":"CODE","StatementOptionHelp":{"#cdata":"Syntax: CODE <(code-generation-options)>\n\nRequests that the server produce SAS scoring code based on the actions that it performed during the \nanalysis. The server generates DATA step code. By default, the code is replayed as an ODS table by \nthe procedure as part of the output of the statement. More frequently, you might want to write the \nscoring code to an external file by specifying options.\n\nCOMMENT\n  specifies to add comments to the code in addition to the header block. The header block is added by default. \nFILENAME=|FILE='path' \n  specifies the name of the external file to which the scoring code is written. This suboption applies only \n  to the scoring code itself. \nFORMATWIDTH=|FMTW=k\n  specifies the width to use in formatting derived numbers such as parameter estimates in the scoring code. \n  The server applies the BEST format, and the default format for code generation is BEST20. Range: 4 to 32\nLABELID=id\n  specifies a group identifier for group processing. The identifier is an integer and is used to create array \n  names and statement labels in the generated code. \nLINESIZE=|LS=n\n  specifies the line size for the generated code. \n  Default: 72 \n  Range: 64 to 256\nNOTRIM\n  specifies to format the variables using the full format width with padding. By default, leading and trailing \n  blanks are removed from the formatted values. \nREPLACE\n  specifies to overwrite the external file if a file with the specified name already exists. The option \n  has no effect unless you specify the FILENAME= option."},"StatementOptionType":"S","SubOptionsKeywords":"COMMENT|FILENAME=|FILE=|FORMATWIDTH=|FMTW=|LABELID=|LINESIZE=|NOTRIM|REPLACE"},{"StatementOptionName":"DESCENDING|DESC","StatementOptionHelp":{"#cdata":"Specifies to model the largest ordered value for the dependent variable instead of the smallest. \nThis option is useful for modeling responses with the value of 1 instead of modeling for value 0."},"StatementOptionType":"S"},{"StatementOptionName":"EXCLUDE=","StatementOptionHelp":{"#cdata":"Syntax: EXCLUDE=(list-of-ODS-tables) \n\nSpecifies the result tables that you want to exclude from being generated on the server and from \nbeing sent to the SAS session. The LOGISTIC statement can generate the following tables: \n\nModelInfo - Information about the model\u2014constant across groups or partitions.\nClassLevels | Class - Information about the classification variables, such as the number of levels and their values. \nConvStatus | Convergence - Convergence status of optimization\nDimensions | Dim - Model dimensions\nFitStatistics | Fit - Fit statistics customary for regression models\nGlobalTest | Global - Test of the hypothesis that the model fits as well as a null model without explanatory variables \nIterHistory | IterHist - Iteration history\nParmEstimates | ParameterEstimates | Pest - The solutions for the linear model coefficients \nResponseProfile | Resp - Information about the values of the binary response variable such as the level order and frequency\nTests3 - Type III tests of model effects"},"StatementOptionType":"V"},{"StatementOptionName":"FORMATS=","StatementOptionHelp":{"#cdata":"Syntax: FORMATS=(\"format-specification\"<,...>) \n\nSpecifies the formats for the GROUPBY variables. If you do not specify the FORMATS= option, \nor if you omit the entry for a GROUPBY variable, the default format is applied for that variable. \n\nEnclose each format specification in quotation marks and separate each format specification with a comma."},"StatementOptionType":"V"},{"StatementOptionName":"FCONV=","StatementOptionHelp":{"#cdata":"Syntax: FCONV=r\n\nSpecifies a relative function convergence criterion. For all techniques except NMSIMP, termination \nrequires a small relative change of the function value in successive iterations."},"StatementOptionType":"V"},{"StatementOptionName":"FREQ=","StatementOptionHelp":{"#cdata":"Syntax: FREQ=variable-name\n\nSpecifies the numeric variable that provides frequencies for the analysis. For example, if the \nFREQ= variable has the value 5, then it implies that the record represents five such observations \nwith identical values for the modeling variables. If you specify a FREQ= variable, then only the \nobservations with a value that is not missing and greater than zero for the variable are used in \nthe analysis."},"StatementOptionType":"V"},{"StatementOptionName":"GCONV=","StatementOptionHelp":{"#cdata":"Syntax: GCONV=r\n\nSpecifies a relative gradient convergence criterion. For all optimization techniques except CONGRA \nand NMSIMP, termination requires that the normalized predicted function reduction is small. The \ndefault value is r = 1e-8. \n\nThe GCONV convergence criterion is assumed to be met if that value is less than or equal to r. \n\nNote that it is possible that the relative gradient reduction is small, even if one or more gradients \nis still substantial in absolute value. If this situation occurs, you can disable the GCONV criterion \nby setting r=0. If the optimization would have stopped early due to meeting the GCONV criterion, the \niterative process usually takes one more step until the gradients are small in absolute value."},"StatementOptionType":"V"},{"StatementOptionName":"GROUPBY=","StatementOptionHelp":{"#cdata":"Syntax: GROUPBY=(variable-list) \n\nSpecifies the names of the Group-by variables in the order of the grouping hierarchy. If no variable \nnames are specified, the model is fit across the entire table\u2014possibly subject to a WHERE clause. \n\nIf you work on a partitioned table, you can also use the PARTITION option to fit the model for a \nspecific partition or separately for all partitions. Operations on partitions are much more efficient \nthan a group-by analysis. \n\nBecause fitting logistic models requires an iterative method, the Group-by analysis for these models \nis a data-parallel technique where the model in each group is fit separately, assigning different rows \nof the group to different threads."},"StatementOptionType":"V"},{"StatementOptionName":"GROUPFILTER","StatementOptionHelp":{"#cdata":"Syntax: GROUPFILTER=(filter-options) \n\nSpecifies a section of the group-by hierarchy to be included in the computation. With this option, \nyou can request that the server performs the analysis for only a subset of all possible groupings. \nThe subset is determined by applying the group filter to a temporary table that you generate with \nthe GROUPBY statement. \n\nYou can specify the following suboptions in the GROUPFILTER option: \n\nDESCENDING | DESC - specifies the top section or the bottom section of the groupings to be collected. \nLIMIT=n - specifies the maximum number of distinct groupings to be collected, where integer n >= 0. \nSCOREGT=f | SGT=f - specifies the exclusive lower bound for the numeric scores of the distinct groupings to collect. \nSCORELT=f | SLT= - specifies the exclusive upper bound for the numeric scores of the distinct groupings to collect. \nVALUEGT=(\"format-name1\" <, \"format-name2\" ...>) | VGT=\n  - specifies the exclusive lower bound of the group-by variable\u2019s formatted values for the distinct groupings to collect. \nVALUELT=(\"format-name1\" <, \"format-name2\" ...>)  | VLT=\n  - specifies the exclusive upper bound of the group-by variable\u2019s formatted values for the distinct groupings to collect. \nTABLE=table-with-groupby-results\n  - specifies the in-memory table from which to load the group-by hierarchy. \n  \nInteraction: If you specify the GROUPFILTER= option, then the GROUPBY= and FORMATS= options have no effect."},"StatementOptionType":"V","SubOptionsKeywords":"DESCENDING|DESC|LIMIT=|SCOREGT=|SGT=|SCORELT=|SLT=|VALUEGT=|VGT=|VALUELT=|VLT=|TABLE="},{"StatementOptionName":"IDVARS=|ID=","StatementOptionHelp":{"#cdata":"Syntax: IDVARS=(variable-list) \n\nIDVARS=variable-name\n\nSpecifies the variables from the active table to transfer to the temporary table that is created \nby scoring the input table. This option has no effect unless the SCORE option is also specified. \n(See the SCORE option for details about which variables are added to the temporary table by default.) \nThe IDVARS= option should be used to transfer additional columns from the input table to the scoring table. \n\nTip Instead of this option, you can specify the ALLIDVARS option to transfer all variables from the \ninput table to the scoring table."},"StatementOptionType":"V"},{"StatementOptionName":"ITDETAILS|ITDETAIL","StatementOptionHelp":{"#cdata":"Requests to add details about the iterative model fitting process (an iteration history) to the \nODS output tables."},"StatementOptionType":"S"},{"StatementOptionName":"KEYORDER","StatementOptionHelp":{"#cdata":"Requests that the results for a partitioned analysis are displayed in the order of the partition keys. \nIf this option is not specified, then results are displayed by using the partitions on the first worker \nnode followed by the partitions on the second node, and so on. Without this option, the results are likely \nto have random ordering of the partitions. The KEYORDER option makes result collection less efficient but \nproduces a natural, predictable order."},"StatementOptionType":"S"},{"StatementOptionName":"LINK=","StatementOptionHelp":{"#cdata":"Syntax: LINK=function\n\nSpecifies the link function to use for the model fitting process. See the following list for the available functions: \n\n\u2022 LOGIT \n\u2022 PROBIT \n\u2022 LOGLOG \n\u2022 CLOGLOG\n \nDefault: LOGIT"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"LOGIT","@Value2":"PROBIT","@Value3":"LOGLOG","@Value4":"CLOGLOG|CLL"},"StatementOptionToolTips":{"@ToolTip1":"Logit link function","@ToolTip2":"Probit link function","@ToolTip3":"Log-log link function","@ToolTip4":"Complementary log-log link function"}},{"StatementOptionName":"MAXFUNC=|MAXFU=","StatementOptionHelp":{"#cdata":"Syntax: MAXFUNC=n\n\n\nSpecifies the maximum number n of function calls in the iterative model fitting process.\n\nThe default value depends on the optimization technique as follows: \n\n---------------------------------------------------------------------------------------------\nOptimization Technique      Default Number of Function Calls\n---------------------------------------------------------------------------------------------\nTRUREG, NRRIDG, and NEWRAP  125 \nQUANEW and DBLDOG           500\nCONGRA                      1000\nNMSIMP                      3000"},"StatementOptionType":"V"},{"StatementOptionName":"MAXITER=|MAXIT=","StatementOptionHelp":{"#cdata":"Syntax: MAXITER=i\n\nSpecifies the maximum number of iterations in the iterative model fitting process. The default \nvalue depends on the optimization technique as follows:\n\n---------------------------------------------------------------------------------------------\nOptimization Technique      Default Number of Function Calls\n---------------------------------------------------------------------------------------------\nTRUREG, NRRIDG, and NEWRAP  50 \nQUANEW and DBLDOG           200\nCONGRA                      400\nNMSIMP                      1000"},"StatementOptionType":"V"},{"StatementOptionName":"MAXTESTLEV=","StatementOptionHelp":{"#cdata":"Syntax: MAXTESTLEV=n\n\nSpecifies the maximum number of levels in an effect for which the server generates Type III tests. \nThe idea behind the MAXTESTLEV= option is that testing effects for significance that have a large \nnumber of levels is typically not meaningful. The effects tend to be highly significant anyway, \nbut determining the exact significance level is computationally intensive. The default value is \n300 and implies that no test statistics are produced for any effect that has more than 300 levels. \n\nDefault 300"},"StatementOptionType":"V"},{"StatementOptionName":"NAME=","StatementOptionHelp":{"#cdata":"Syntax: NAME=SAS-name\n\nSpecifies the name to use for identifying the model in the server output and in the temporary \ntable of results generated by the TEMPTABLE option. SAS name rules apply. For example, the \nfollowing statements add the 'Model' entry to the ModelInformation table. \n\nproc imstat;\n   table hps.neuralgia;\n   logistic pain = treatment sex duration / name = LogisModel\nrun;"},"StatementOptionType":"V"},{"StatementOptionName":"NOCLPRINT","StatementOptionHelp":{"#cdata":"Syntax: NOCLPRINT <=n>\n\nSpecifies the number of levels for each classification variables to show in the Class Level Information \nODS table. If you do not specify the NOCLPRINT option, all unique values are shown in the order of the \nclass variable levelization. If you specify NOCLPRINT=n, then the values are shown for those classification \nvariables that have less than n levels only. The value for n must be at least 1. \n\nIf you specify the NOCLPRINT option without specifying a value for n, then n = 0 is assumed. This enables \nyou to get a listing of the classification variables in the model. This might be useful if you did not \nidentify classification variables explicitly\u2014without listing their (possibly many) levels."},"StatementOptionType":"S|V"},{"StatementOptionName":"NOINT","StatementOptionHelp":{"#cdata":"Suppresses the inclusion of an intercept in the model. By default, all models contain an intercept term."},"StatementOptionType":"S"},{"StatementOptionName":"NOPREPARSE|NOPREP","StatementOptionHelp":{"#cdata":"Prevents the procedure from preparsing and pregenerating code for temporary expressions, scoring \nprograms, and other user-written SAS statements. \n\nWhen this option is specified, the user-written statements are sent to the server \"as is\" and then \nthe server attempts to generate code from it. If the server detects problems with the code, the error \nmessages might not to be as detailed as the messages that are generated by SAS client. If you are \ndebugging your user-written program, then you might want to preparse and pregenerate code in the \nprocedure. However, if your SAS statements compile and run as you want them to, then you can specify \nthis option to avoid the work of parsing and generating code on the SAS client. \n\nWhen you specify this option in the PROC IMSTAT statement, the option applies to all statements that \ncan generate code. You can also exclude specific statements from preparsing by using the NOPREPARSE \noption in statements that allow temporary columns or the SCORE statement."},"StatementOptionType":"S"},{"StatementOptionName":"NOSTDERR|NOSTD","StatementOptionHelp":{"#cdata":"Prevents the computation of the covariance matrix and the standard errors of the parameter estimates. \nWhen you specify this option, the Type III tests for the model effects are also not available."},"StatementOptionType":"S"},{"StatementOptionName":"OFFSET=","StatementOptionHelp":{"#cdata":"Syntax: OFFSET=variable-name\n          \nSpecifies the offset variable for the analysis. An offset variable can be thought of as a regressor \nvariable whose regression coefficient is known to be 1. Offsets are used to shift the linear predictors \nby a certain amount. For example, an offset can be used to accommodate constants in the underlying model. \nIn generalized linear models, offsets arise frequently when the data represents a value relative to some \nmeasure of size."},"StatementOptionType":"V"},{"StatementOptionName":"PARTITION|PART","StatementOptionHelp":{"#cdata":"Syntax: PARTITION<=partition-key>\n\nSpecifies to fit the model separately for each value of the partition key. In other words, \nthe partition variables function as automatic group-by variables for the request. \n\nIf you do not specify a value for partition-key, then the analysis is performed for all \npartitions. If you do specify a value, then the analysis is performed for the specified \nkey value only. You can use the PARTITIONINFO statement to retrieve the valid partition-key \nvalues for a table. \n\nYou can specify a partition-key in two ways. You can supply a single quoted string that is \npassed to the server, or you can specify the elements of a composite key separated by commas."},"StatementOptionType":"V"},{"StatementOptionName":"ROLEVAR=|ROLE=","StatementOptionHelp":{"#cdata":"Syntax: ROLEVAR=variable-name\n\nSpecifies a variable in the in-memory table that defines whether an observation belongs to the \ntraining set, the validation set, or is to be excluded from the analysis. The role variable can \nhave a numeric or character type, and it can be a temporary computed variable. \n\nIf the role variable data type is numeric, the values of variable-name are interpreted as follows: \n\n\u2022 value = 1: this observation is in the training set  \n\u2022 value = 2: this observation is in the validation set  \n\u2022 any other value: this observation is to be excluded from the analysis \n \nIf the role variable data type is character, the values of variable-name are interpreted as follows: \n\n\u2022 If the first non-blank character is 't' or 'T', then the observation is in the training set.  \n\u2022 If the first non-blank character is 'v' or 'V', then he observation is in the validation set.  \n\u2022 Any other value for the first non-blank character, including an all blank entry, leads to the \n  exclusion of the observation from the analysis. \n\nInteractions: You can divide the data at random into training and validation sets by providing the VALIDATE= and SEED= options.  \nIf you specify both the ROLEVAR= option and the VALIDATE= options, then the ROLEVAR= setting supersedes the VALIDATE= option."},"StatementOptionType":"V"},{"StatementOptionName":"SCORE","StatementOptionHelp":{"#cdata":"Syntax: SCORE <(score-statistic1score-statistic2...)>\n\nRequests that the active table be scored after the model is fit and the results be stored in a \ntemporary table. The server automatically adds all model variables to the temporary table with \nthe score results. These results include the response variable, the class variables, all explanatory \nvariables from which effects are formed, and the WEIGHT=, and FREQ= variables. \n\nIf you do not specify the list of score statistics, default statistics are computed. These statistics \nare identified with Yes in the Default column in the table below. You can request that the following \nstatistics be computed for each observation: \n--------------------------------------------------------------------------------------------------------------------------------------\nKeyword and Aliases     Column Name     Description                                Default\n--------------------------------------------------------------------------------------------------------------------------------------\nPRED, PREDICTED, LINP   _PRED_          Predicted linear predictor value           Yes\nRESID, RESIDUAL, R      _RESID_         Raw residual (on a linear scale)           Yes\nLEVERAGE, H             _LEVERAGE_      Measure of how extreme an observation is in the regressor space Yes\nILINK, MEAN, PROB       _ILINK_         Inversely linked linear predictor, the predicted mean of the response Yes  \nPEARSON, RESCHI         _PEARSON_       Pearson residual, also known as the Chi-square residual Yes\nDEVRESID, RESDEV        _DEVRESID_      Deviance residual                           Yes\nLIKEDIST, LD, RESLIKE   _LIKEDIST_      Likelihood displacement                     Yes\nSTDRES, STDRESCHI       _STDRESCHI_     Standardized Pearson Chi-square residual    Yes\nSTDP                    _STDP_          Standard error of the mean predicted value  No\nLCLM, LOWERMEAN         _LCLM_          Lower confidence limit for the mean of the predicted value No\nUCLM, UPPERMEAN         _UCLM_          Upper confidence limit for the mean of the predicted value No\nLCL, LOWERPRED          _LCL_           Lower confidence limit for the predicted value    No\nUCL, UPPERPRED          _UCL_           Upper confidence limit for the predicted value    No\nDIFDEV                  _DIFDEV_        Change in the deviance due to the deletion of the observation No\nDIFCHISQ                _DIFCHISQ_      Change in the Pearson statistic due to deletion of the observation No"},"StatementOptionType":"S|V"},{"StatementOptionName":"SELECT=","StatementOptionHelp":{"#cdata":"Syntax: SELECT=(list-of-ODS-tables) \n\nSpecifies the list of ODS tables that you want to display for the analysis. The specified list \nreplaces the default tables that are generated by the server and displayed. See the EXCLUDE= option \nfor the list of default tables and the table names that you can display."},"StatementOptionType":"V"},{"StatementOptionName":"SHOWSELECTED|SHOWSEL","StatementOptionHelp":{"#cdata":"Requests that the server perform variable selection for the model. A backward selection method is used, \nwhere the significance level for an effect to remain in the model is determined by the SLSTAY= option. \nThis option performs variable selection like the VARSEL option, but in contrast to the latter option, \nit displays output only for the selected effects."},"StatementOptionType":"S"},{"StatementOptionName":"SLSTAY=","StatementOptionHelp":{"#cdata":"Syntax: SLSTAY=\u03b1\n\nSpecifies the significance level used in determining whether effects should stay in the model \nduring variable selection. \n\nDefault: 0.1 \nRange: 0 to 1"},"StatementOptionType":"V"},{"StatementOptionName":"TECHNIQUE=|TECH=","StatementOptionHelp":{"#cdata":"Syntax: TECHNIQUE=value\n\nSpecifies the optimization technique.\n\nDefault: NRRIDG"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"CONGRA","@Value2":"DBLDOG","@Value3":"DUQUANEW","@Value4":"NMSIMP","@Value5":"NEWRAP","@Value6":"NRRIDG","@Value7":"QUANEW","@Value8":"TRUREG","@Value9":"NONE"},"StatementOptionToolTips":{"@ToolTip1":"CONGRA (CG): performs a conjugate-gradient optimization","@ToolTip2":"DBLDOG (DD): performs a version of the double-dogleg optimization","@ToolTip3":"DUQUANEW (DQN) performs a (dual) quasi-Newton optimization.","@ToolTip4":"NMSIMP (NS): performs a Nelder-Mead simplex optimization","@ToolTip5":"NEWRAP (NRA): performs a (modified) Newton-Raphson optimization that combines a line-search algorithm with ridging","@ToolTip6":"NRRIDG (NRR): performs a (modified) Newton-Raphson optimization with ridging","@ToolTip7":"QUANEW (QN): performs a quasi-Newton optimization","@ToolTip8":"TRUREG (TR): performs a trust-region optimization","@ToolTip9":"NONE:  Specifies not to perform any optimization. This value can be useful to perform a grid search without optimization."}},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary \nvariables or a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPTABLE","StatementOptionHelp":{"#cdata":"Generates an in-memory temporary table from the result set. The IMSTAT procedure displays the \nname of the table and stores it in the &_TEMPLAST_ macro variable, provided that the statement \nexecuted successfully. \n\nWhen the IMSTAT procedure exits, all temporary tables created during the IMSTAT session are \nremoved. Temporary tables are not displayed on a TABLEINFO request, unless the temporary table \nis the active table for the request."},"StatementOptionType":"S"},{"StatementOptionName":"VALIDATE=|VALPROP=","StatementOptionHelp":{"#cdata":"Syntax: VALIDATE=f\n\nSpecifies the proportion f in the validation data set. \n\nRange: 0 to 1  \n\nInteraction: If you specify both the ROLEVAR= option and the VALIDATE= option, then the ROLEVAR= \nsetting supersedes the VALIDATE= option."},"StatementOptionType":"V"},{"StatementOptionName":"VARSELECTION|VARSEL","StatementOptionHelp":{"#cdata":"Specifies that the server perform variable selection for the model. A backward selection method \nis used, where the significance level for an effect to remain in the model is determined by the \nSLSTAY= option. In contrast to the SHOWSEL option, all effects are reported in the IMSTAT output."},"StatementOptionType":"S"},{"StatementOptionName":"WEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT=variable-name\n\nSpecifies the numeric variable to use as a weighing variable in solving the linear model."},"StatementOptionType":"V"}]}},{"StatementName":"MDSUMMARY","StatementHelp":{"#cdata":"Syntax: MDSUMMARY variable-list </ <set-specification,...> options>; \n      \nThe MDSUMMARY statement calculates a multi-dimensional summary for numeric variables."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"GROUPBY=","StatementOptionHelp":{"#cdata":"Syntax: GROUPBY=variable-name\n\nGROUPBY=(variable-list) \n\nSpecifies the list of GROUP BY variables for this set-specification. A GROUPBY= specification is required."},"StatementOptionType":"V"},{"StatementOptionName":"FORMATS=","StatementOptionHelp":{"#cdata":"Syntax: FORMATS=(\"format-specification\",...) \n\nSpecifies the formats for the GROUPBY= variables. If you do not specify the FORMAT= option, \nthe default format is applied for that variable. Enclose each format specification in quotation \nmarks and separate each format specification with a comma. \n\nYou can omit the assignment of a format for a GROUPBY= variable by entering an empty string. \nFor example, FORMATS=(\"$10.\", \"\", \"BEST4.\") specifies to format the first variable, with $10 \nand the third variable with BEST4.. The default format is applied to the second variable. The \nFORMATS= element of the set-specification is optional."},"StatementOptionType":"V"},{"StatementOptionName":"FILTER=","StatementOptionHelp":{"#cdata":"Syntax: FILTER=\"expression\" \n\nSpecifies an optional WHERE clause for this set-specification. The filter is applied separately \nfor each set and possibly in addition to an overall WHERE clause."},"StatementOptionType":"V"},{"StatementOptionName":"DESCENDING|DESC","StatementOptionHelp":{"#cdata":"Specifies that the levels of the GROUPBY variables are to be arranged in descending order."},"StatementOptionType":"S"},{"StatementOptionName":"GROUPBYLIMIT=","StatementOptionHelp":{"#cdata":"Syntax: GROUPBYLIMIT=n\n\nSpecifies the maximum number of levels in a GROUPBY set. When the software determines that there \nare at least n levels in the GROUPBY set, it abandons the action, returns a message, and does not \nproduce a result set. You can specify the GROUPBYLIMIT= option if you want to avoid creating \nexcessively large result sets in GROUPBY operations."},"StatementOptionType":"V"},{"StatementOptionName":"NOPREPARSE|NOPREP","StatementOptionHelp":{"#cdata":"Prevents the procedure from preparsing and pregenerating code for temporary expressions, scoring \nprograms, and other user-written SAS statements. \n\nWhen this option is specified, the user-written statements are sent to the server \"as is\" and then \nthe server attempts to generate code from it. If the server detects problems with the code, the error \nmessages might not to be as detailed as the messages that are generated by SAS client. If you are \ndebugging your user-written program, then you might want to preparse and pregenerate code in the \nprocedure. However, if your SAS statements compile and run as you want them to, then you can specify \nthis option to avoid the work of parsing and generating code on the SAS client. \n\nWhen you specify this option in the PROC IMSTAT statement, the option applies to all statements that \nan generate code. You can also exclude specific statements from preparsing by using the NOPREPARSE \noption in statements that allow temporary columns or the SCORE statement."},"StatementOptionType":"S"},{"StatementOptionName":"RAWORDER","StatementOptionHelp":{"#cdata":"Specifies that the ordering of the GROUPBY variables is based on the raw values of the variables \ninstead of the formatted values."},"StatementOptionType":"S"},{"StatementOptionName":"SAVE=","StatementOptionHelp":{"#cdata":"Syntax: SAVE=table-name\n\nSaves the result table so that you can use it in other IMSTAT procedure statements like STORE, REPLAY, \nand FREE. The value for table-name must be unique within the scope of the procedure execution. The name \nof a table that has been freed with the FREE statement can be used again in subsequent SAVE= options."},"StatementOptionType":"V"},{"StatementOptionName":"SETSIZE","StatementOptionHelp":{"#cdata":"Requests that the server estimate the size of the result set. The procedure does not create a result \ntable if the SETSIZE option is specified. Instead, the procedure reports the number of rows that are \nreturned by the request and the expected memory consumption for the result set (in KB). If you specify \nthe SETSIZE option, the SAS log includes the number of observations and the estimated result set size."},"StatementOptionType":"S"},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary variables \nor a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPTABLE","StatementOptionHelp":{"#cdata":"Generates an in-memory temporary table from the result set. The IMSTAT procedure displays the name \nof the table and stores it in the &_TEMPLAST_ macro variable, provided that the statement executed \nsuccessfully. \n\nWhen the IMSTAT procedure exits, all temporary tables created during the IMSTAT session are removed. \nTemporary tables are not displayed on a TABLEINFO request, unless the temporary table is the active \ntable for the request."},"StatementOptionType":"S"}]}},{"StatementName":"NEURAL","StatementHelp":{"#cdata":"Syntax: NEURAL <target-variable> </ options>; \n      \nThe NEURAL statement trains feed-forward artificial neural networks (ANN) and can use the \ntrained networks to score data sets. When you do not specify a target variable, the server \nencodes the input nodes for the purpose of dimensionality reduction."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ACTIVATION=|ACT=|ACTIVATE=","StatementOptionHelp":{"#cdata":"Syntax: ACTIVATION=(activation-function-for-a-hidden-layer ...) \n\nSpecifies the activation function for the neurons on each hidden layer. The following functions \nare available: \n\n  IDENTITY \n    specifies the identify function. Values range between -\u221e and \u221e. For an input value of t, the function \n    returns the same value, t.  \n  LOGISTIC \n    specifies the logistic function. Values range between zero and one. For an input value of t, the function \n    returns logistic function. Click image for alternative formats..  \n  EXP \n    specifies the exponential function. Values range between zero and \u221e. For an input value of t, the \n    function returns Exponential Function. Click image for alternative formats..  \n  SIN \n    specifies the sine function. Values range between zero and 1, inclusively. For an input value of t, the \n    function returns Sine Function. Click image for alternative formats..  \n  TANH \n    specifies the hyperbolic tangent function. Values range between \u20131 and 1. For an input value of t, the \n    function returns Hyperbolic Tangent Function. Click image for alternative formats..  \n\nDefault: TANH"},"StatementOptionType":"V","SubOptionsKeywords":"IDENTITY|LOGISTIC|EXP|SIN|TANH"},{"StatementOptionName":"ARCHITECTURE=|ARCH=","StatementOptionHelp":{"#cdata":"Syntax: ARCHITECTURE= GLIM | MLP | DIRECT\n\nSpecifies the network architecture to be trained. The GLIM architecture (Generalized Linear Model) \nspecifies a two-layer perceptron (one is the input layer and the other is the output layer) without \nhidden layers or units. The MLP architecture specifies a multilayer perceptron with one or more hidden \nlayers. The DIRECT architecture is an extension of MLP with direct connections between the input layer \nand the output layer. \n\nDefault: GLIM."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"GLIM","@Value2":"MLP","@Value3":"DIRECT"},"StatementOptionToolTips":{"@ToolTip1":"The GLIM architecture (Generalized Linear Model) specifies a two-layer perceptron (one is the input  layer and the other is the output layer) without  hidden layers or units.","@ToolTip2":"The MLP architecture specifies a multilayer perceptron with one or more hidden layers.","@ToolTip3":"The DIRECT architecture is an extension of MLP with direct connections between the input layer and  the output layer. "}},{"StatementOptionName":"ASSESS","StatementOptionHelp":{"#cdata":"\n\nSpecifies that predicted probabilities are added to the scored data for all the levels of the \nnominal target variable when scoring is performed with the TEMPTABLE and LASRANN= options. It \nadds variables _NN_Level_ and _NN_P_ to the results. You can use these predicted probabilities \nin an ASSESS statement. \n\nInteraction: You must specify the TEMPTABLE and LASRANN= options along with this option."},"StatementOptionType":"S"},{"StatementOptionName":"BIAS=","StatementOptionHelp":{"#cdata":"Syntax: BIAS=r\n\nSpecifies a fixed bias value for all the hidden and output neurons. In this case, the bias parameters \nare fixed and are not optimized."},"StatementOptionType":"V"},{"StatementOptionName":"CODE","StatementOptionHelp":{"#cdata":"Syntax: CODE <(code-generation-options)>\n\nRequests that the server produce SAS scoring code based on the actions that it performed during the \nanalysis. The server generates DATA step code. By default, the code is replayed as an ODS table by \nthe procedure as part of the output of the statement. More frequently, you might want to write the \nscoring code to an external file by specifying options.\n\nCOMMENT\n  specifies to add comments to the code in addition to the header block. The header block is added by default. \nFILENAME=|FILE='path' \n  specifies the name of the external file to which the scoring code is written. This suboption applies only \n  to the scoring code itself. \nFORMATWIDTH=|FMTW=k\n  specifies the width to use in formatting derived numbers such as parameter estimates in the scoring code. \n  The server applies the BEST format, and the default format for code generation is BEST20. Range: 4 to 32\nLABELID=id\n  specifies a group identifier for group processing. The identifier is an integer and is used to create array \n  names and statement labels in the generated code. \nLINESIZE=|LS=n\n  specifies the line size for the generated code. \n  Default: 72 \n  Range: 64 to 256\nNOTRIM\n  specifies to format the variables using the full format width with padding. By default, leading and trailing \n  blanks are removed from the formatted values. \nREPLACE\n  specifies to overwrite the external file if a file with the specified name already exists. The option \n  has no effect unless you specify the FILENAME= option."},"StatementOptionType":"S","SubOptionsKeywords":"COMMENT|FILENAME=|FILE=|FORMATWIDTH=|FMTW=|LABELID=|LINESIZE=|NOTRIM|REPLACE"},{"StatementOptionName":"COMBINATION=","StatementOptionHelp":{"#cdata":"Syntax: COMBINATION=(combination-function-for-a-hidden-layer ...) \n\nSpecifies the combination function for the neurons on each hidden layer. The available functions \nare described in the following list. When the COMBINATION= option is not specified, the hidden units \nuse the LINEAR function. \n\nADD adds all the incoming values without using any weights or biases. The function is defined as \n  Add Combination Function. Click image for alternative formats..  \nLINEAR uses a linear combination of the incoming values and weights. The function is defined as \n  Linear Combination Function. Click image for alternative formats. \nRADIAL uses a radial basis function with equal heights and unequal widths for all units in the layer. \n  The function is defined as EHradial Combination Function. Click image for alternative formats."},"StatementOptionType":"V","SubOptionsKeywords":"ADD|LINEAR|RADIAL"},{"StatementOptionName":"DELTA=","StatementOptionHelp":{"#cdata":"Syntax: DELTA=r\n\nSpecifies the annealing parameter when performing a simulated annealing (SA) global optimization. \nWithout the DELTA= option, the step size option (STEP=) and the temperature option (T=) are used \nto perform a Monte Carlo (MC) global optimization. With the addition of the DELTA= option, the \noptimization becomes simulated annealing where the temperature is scaled by DELTA \u00d7 T at every \nMC step."},"StatementOptionType":"V"},{"StatementOptionName":"DETAILS|DETAIL","StatementOptionHelp":{"#cdata":"Specifies to display the convergence status and iteration results for training the network."},"StatementOptionType":"S"},{"StatementOptionName":"ERROR=","StatementOptionHelp":{"#cdata":"Syntax: ERROR=error-function\n\nSpecifies the error function to train the network. For interval variables, the default error function is \nNORMAL. For nominal variables, the default error function is ENTROPY. The available functions are as follows: \n\n  GAMMA \n    uses the gamma distribution. The values of the target variable must be greater than zero.  \n  ENTROPY \n    uses the cross or relative entropy for independent targets. The values of the target variable must \n    be between zero and one.  \n  NORMAL \n    uses the normal distribution. The target variable can have any value.  \n  POISSON \n    uses the Poisson distribution. The values of the target variable must be greater than or equal to zero."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"GAMMA","@Value2":"ENTROPY","@Value3":"NORMAL","@Value4":"POISSON"},"StatementOptionToolTips":{"@ToolTip1":"Uses the gamma distribution. The values of the target variable must be greater than zero.  ","@ToolTip2":"Uses the cross or relative entropy for independent targets. The values of the target variable must  be between zero and one.","@ToolTip3":"Uses the normal distribution. The target variable can have any value.  ","@ToolTip4":"Uses the Poisson distribution. The values of the target variable must be greater than or equal to zero."}},{"StatementOptionName":"FCONV=","StatementOptionHelp":{"#cdata":"Syntax: FCONV=r\n\n\nSpecifies a relative function convergence criterion. \n\nDefault: 1e-5"},"StatementOptionType":"V"},{"StatementOptionName":"FORMATS=","StatementOptionHelp":{"#cdata":"Syntax: FORMATS=(\"format-specification\", ...) \n\nSpecifies the formats for the input variables. If you do not specify the FORMATS= option, the default \nformat is applied for that variable. Enclose each format specification in quotation marks and separate \neach format specification with a comma. \n\nExample:\nproc imstat data=lasr1.table1; \n    neural x / input=(a b) formats=(\"8.3\", \"$10\");\nquit;"},"StatementOptionType":"V"},{"StatementOptionName":"GCONV=","StatementOptionHelp":{"#cdata":"Syntax: GCONV=r\n\nSpecifies a relative gradient convergence criterion. \n\nDefault: 1e-5 \nInteraction: When TECH=NSIMP, there is no default value."},"StatementOptionType":"V"},{"StatementOptionName":"HIDDEN=|HIDDENS=","StatementOptionHelp":{"#cdata":"Syntax: HIDDEN=(positive-integer ...) \n\nSpecifies the number of hidden neurons for each hidden layer in the feed-forward artificial \nneural network model. For example, HIDDEN=(5 3) specifies two hidden layers. The first hidden \nlayer has five hidden neurons and the second has three hidden neurons. \n\nInteraction: When the HIDDEN= option is specified, the default architecture is MLP."},"StatementOptionType":"V"},{"StatementOptionName":"IMPUTE","StatementOptionHelp":{"#cdata":"Specifies to impute the output values with available target values when data is being scored. \nIn this case, you are interested only in predicting the missing values of the target variable. \nThis option can be used only when scoring is performed with the TEMPTABLE and LASRANN= options."},"StatementOptionType":"S"},{"StatementOptionName":"INPUT=","StatementOptionHelp":{"#cdata":"Syntax: INPUT=variable-name\n\nINPUT=(variable-name1 <variable-name2, ...>) \n\nSpecifies the input variables for the network. You can add the target variable to the input list \nif you want to assign a format to the target variable by using the FORMATS= option. The number of \ninput neurons on the input layer is determined by the number of input variables. The number of input \nvariables equals the total number of levels from the nominal variables plus the number of interval \nvariables."},"StatementOptionType":"V"},{"StatementOptionName":"LAMBDA=","StatementOptionHelp":{"#cdata":"Syntax: LAMBDA=\u03bb\n\nSpecifies the weight decay number. The value must be zero or greater. \n\nDefault: 0"},"StatementOptionType":"V"},{"StatementOptionName":"LASRANN=|ANNLASR=","StatementOptionHelp":{"#cdata":"Syntax: LASRANN=table-name\n\nSpecifies the table that contains the weights from a previously trained model. When the RESUME option \nis used with the LASRANN= option, training for that model resumes using the previously obtained weights \nas the new starting weights. Otherwise, the weights are used to score the active table."},"StatementOptionType":"V"},{"StatementOptionName":"LINESEARCH=","StatementOptionHelp":{"#cdata":"Syntax: LINESEARCH=i\n\nSpecifies the line-search method for the CONGRA and QUANEW optimization techniques. \n\nDefault: 2 \nRange: An integer between 1 and 8."},"StatementOptionType":"V"},{"StatementOptionName":"LISTNODE=","StatementOptionHelp":{"#cdata":"yntax: LISTNODE= ALL | INPUT | OUTPUT | HIDDEN\n\nSpecifies the nodes to be included in the temporary table that is generated when you score a table \nwith the NEURAL statement. When encoding of the input nodes is requested, the default is HIDDEN. \nThis option is particularly useful when encoding is applied to reduce the dimension of the input \nnodes. By reusing the node output values, machine learning algorithms in the NEURAL, CLUSTER, \nDECISIONTREE, and RANDOMWOODS statements can use the newly encoded vectors as input. \n\n  ALL specifies to include all the nodes in the temporary table.  \n  HIDDEN specifies to include the hidden nodes only. \n  INPUT specifies to include the input nodes only. \n  OUTPUT specifies to include the output nodes only."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"ALL","@Value2":"INPUT","@Value3":"OUTPUT","@Value4":"HIDDEN"},"StatementOptionToolTips":{"@ToolTip1":"Specifies to include all the nodes in the temporary table.","@ToolTip2":"Specifies to include the input nodes only.","@ToolTip3":"Specifies to include the output nodes only.","@ToolTip4":"Specifies to include the hidden nodes only."}},{"StatementOptionName":"LOWER=","StatementOptionHelp":{"#cdata":"Syntax: LOWER=r\n\nSpecifies a lower bound for the network weights. \n\nDefault: \u201310.0"},"StatementOptionType":"V"},{"StatementOptionName":"MAXFUNC=|MAXFU=","StatementOptionHelp":{"#cdata":"Syntax: MAXFUNC=n\n\n\nSpecifies the maximum number n of function calls in the iterative model fitting process.\n\nThe default value depends on the optimization technique as follows: \n\n---------------------------------------------------------------------------------------------\nOptimization Technique      Default Number of Function Calls\n---------------------------------------------------------------------------------------------\nTRUREG, NRRIDG, and NEWRAP  125 \nQUANEW and DBLDOG           500\nCONGRA                      1000\nNMSIMP                      3000\nLBFGS                       Number of iterations \u00d7 10 "},"StatementOptionType":"V"},{"StatementOptionName":"MAXITER=","StatementOptionHelp":{"#cdata":"Syntax: MAXITER=i\n\nSpecifies the maximum number of iterations in the model fitting process. The default value \nis 10 for all techniques."},"StatementOptionType":"V"},{"StatementOptionName":"MISSING=","StatementOptionHelp":{"#cdata":"Syntax: MISSING= MIN | MEAN | MAX\n\nSpecifies how to impute missing values for the input or target variables. When the MISSING= option \nis not specified, the observations with missing values are ignored. The MIN request imputes missing \nvalues for each variable with the minimum value. Similarly, the MAX request imputes the maximum value, \nand the MEAN request imputes the mean value. For nominal variables, a new missing category is created \nfor the missing values."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"MIN","@Value2":"MEAN","@Value3":"MAX"},"StatementOptionToolTips":{"@ToolTip1":"Imputes missing values for each variable with the minimum value.","@ToolTip2":"Imputes missing values for each variable with the mean value.","@ToolTip3":"Imputes missing values for each variable with the maximum value."}},{"StatementOptionName":"MULTINET=","StatementOptionHelp":{"#cdata":"Syntax: MULTINET=i\n\nSpecifies the number of networks to select out of the number of tries specified in the NUMTRIES= option. \nThe networks with the smallest errors are selected as the set of best networks. When data is scored, the \nmost frequent predicted values among the selected networks are used to make the final predictions. This \noption is required when performing Monte Carlo or simulated annealing optimizations. Those optimizations \nalso use the DELTA=, STEP=, and T= options."},"StatementOptionType":"V"},{"StatementOptionName":"NOPREPARSE|NOPREP","StatementOptionHelp":{"#cdata":"Prevents the procedure from preparsing and pregenerating code for temporary expressions, scoring \nprograms, and other user-written SAS statements. \n\nWhen this option is specified, the user-written statements are sent to the server \"as is\" and then \nthe server attempts to generate code from it. If the server detects problems with the code, the error \nmessages might not to be as detailed as the messages that are generated by SAS client. If you are \ndebugging your user-written program, then you might want to preparse and pregenerate code in the \nprocedure. However, if your SAS statements compile and run as you want them to, then you can specify \nthis option to avoid the work of parsing and generating code on the SAS client. \n\nWhen you specify this option in the PROC IMSTAT statement, the option applies to all statements that \ncan generate code. You can also exclude specific statements from preparsing by using the NOPREPARSE \noption in statements that allow temporary columns or the SCORE statement."},"StatementOptionType":"S"},{"StatementOptionName":"NOBIAS","StatementOptionHelp":{"#cdata":"Specifies no bias parameters for the hidden and output units."},"StatementOptionType":"S"},{"StatementOptionName":"NOMINAL=","StatementOptionHelp":{"#cdata":"Syntax: NOMINAL=variable-name\n\nNOMINAL=(variable-list) \n\nSpecifies the numeric variables to use as nominal variables. For the nominal input variables, neurons \nare created for every level. The values are coded as 0 or 1 indicator variables. Character variables \nare nominal and do not need to be included in the list."},"StatementOptionType":"V"},{"StatementOptionName":"NUMTRIES=","StatementOptionHelp":{"#cdata":"Syntax: NUMTRIES=i\n\nSpecifies the number of optimizations to perform with different weight initializations when training \nnetworks. The network with the smallest error is selected as the best network. This option is required \nwhen performing Monte Carlo or simulated annealing global optimizations that also use the DELTA=, STEP=, \nand T= options. \n\nDefault: 1"},"StatementOptionType":"V"},{"StatementOptionName":"RESUME","StatementOptionHelp":{"#cdata":"Specifies to resume a training optimization and use the weights that were obtained from previous training. \nThe initial weights for resuming the optimization are read from a temporary table with the LASRANN= option. \nThe specified framework of model options must be the same as the previous framework. \n\nInteraction The RESUME option cannot be used with the MULTINET= option."},"StatementOptionType":"S"},{"StatementOptionName":"SAVE=","StatementOptionHelp":{"#cdata":"Syntax: SAVE=table-name\n\nSaves the result table so that you can use it in other IMSTAT procedure statements like STORE, REPLAY, \nand FREE. The value for table-name must be unique within the scope of the procedure execution. The name \nof a table that has been freed with the FREE statement can be used again in subsequent SAVE= options."},"StatementOptionType":"V"},{"StatementOptionName":"SCOREDATA=","StatementOptionHelp":{"#cdata":"Syntax: SCOREDATA=table-name\n\nSpecifies the in-memory table that contains the scoring data. The table must exist in-memory on \nthe server. The NEURAL statement in the IMSTAT procedure does not transfer a local data set to \nthe server."},"StatementOptionType":"V"},{"StatementOptionName":"SEED=","StatementOptionHelp":{"#cdata":"Syntax: SEED=number\n\nSpecifies the random number seed to use for generating random numbers. The random numbers are used \nto initialize the network weights."},"StatementOptionType":"V"},{"StatementOptionName":"STD=","StatementOptionHelp":{"#cdata":"Syntax: STD= MIDRANGE | NONE | STD\n\nSpecifies the standardization to use on the input interval variables. \n\n  MIDRANGE Variables are scaled to a midrange of 0 and a half-range of 1.  \n  NONE Variables are not altered. \n  STD Variables are scaled to a mean of 0 and a standard deviation of 1.  \n\nDefault: STD"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"MIDRANGE","@Value2":"NONE","@Value3":"STD"},"StatementOptionToolTips":{"@ToolTip1":"Variables are scaled to a midrange of 0 and a half-range of 1.","@ToolTip2":"Variables are not altered.","@ToolTip3":"Variables are scaled to a mean of 0 and a standard deviation of 1."}},{"StatementOptionName":"STEP=","StatementOptionHelp":{"#cdata":"Syntax: STEP=r\n\nSpecifies a step size for perturbations on the network weights when performing Monte Carlo \nor simulated annealing global optimizations. \n\nDefault: 0.01"},"StatementOptionType":"V"},{"StatementOptionName":"T=","StatementOptionHelp":{"#cdata":"Syntax: T=r\n\nSpecifies the artificial temperature parameter when performing Monte Carlo or simulated \nannealing global optimizations. \n\nDefault: 1000"},"StatementOptionType":"V"},{"StatementOptionName":"TARGETACT=|TARACT=","StatementOptionHelp":{"#cdata":"Syntax: TARGETACT=activation-function-for-target-variable\n\nSpecifies the activation function for the neurons on the output layer. The available functions \nare IDENTITY, LOGISTIC, EXP, SIN, TANH, and SOFTMAX. The definitions of these functions are \ndescribed in the  ACTIVATION=(activation-function-for-a-hidden-layer ...) option. The SOFTMAX \nfunction is unique to this option and is described as follows: \n\nSOFTMAX performs the multiple logistic function. Values range between zero and one. For an input \nvalue of t, the function returns MLogistic Function. Click image for alternative formats. \n\nWhen the TARGETACT= option is not specified, the SOFTMAX function is used for nominal variables, \nand the IDENTITY function is used for interval variables. When the target variable is not provided \nfor the purpose of encoding the input nodes, the SOFTMAX function is used."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"IDENTITY","@Value2":"LOGISTIC","@Value3":"EXP","@Value4":"SIN","@Value5":"TANH","@Value6":"SOFTMAX"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the identity activation function for the neurons on the output layer.","@ToolTip2":"Specifies the logistic activation function for the neurons on the output layer.","@ToolTip3":"Specifies the exponential activation function for the neurons on the output layer.","@ToolTip4":"Specifies the sine activation function for the neurons on the output layer.","@ToolTip5":"Specifies the tanh activation function for the neurons on the output layer.","@ToolTip6":"Specifies the softmax activation function for the neurons on the output layer."}},{"StatementOptionName":"TARGETCOMB=|TARCOMB=","StatementOptionHelp":{"#cdata":"Syntax: TARGETCOMB=combination-function-for-target-variable\n\nSpecifies the combination function for the neurons on the target output nodes. The available \nfunctions are ADD, LINEAR, and RADIAL.\n\n  ADD adds all the incoming values without using any weights or biases. \n  LINEAR uses a linear combination of the incoming values and weights. \n  RADIAL uses a radial basis function with equal heights and unequal widths for all units in the layer. \n\nDefault: LINEAR"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"ADD","@Value2":"LINEAR","@Value3":"RADIAL"},"StatementOptionToolTips":{"@ToolTip1":"Adds all the incoming values without using any weights or biases.","@ToolTip2":"Uses a linear combination of the incoming values and weights.","@ToolTip3":"Uses a radial basis function with equal heights and unequal widths for all units in the layer. "}},{"StatementOptionName":"TECHNIQUE=|TECH=","StatementOptionHelp":{"#cdata":"Syntax: TECHNIQUE=value\n\nSpecifies the optimization technique for the iterative model-fitting process. \n\nDefault: LBFGS"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"CONGRA","@Value2":"DBLDOG","@Value3":"LBFGS","@Value4":"NMSIMP","@Value5":"QUANEW","@Value6":"TRUREG"},"StatementOptionToolTips":{"@ToolTip1":"CONGRA (CG): performs a conjugate-gradient optimization","@ToolTip2":"DBLDOG (DD): performs a version of the double-dogleg optimization","@ToolTip3":"LBFGS performs a limited-memory Broyden\u2013Fletcher\u2013Goldfarb\u2013Shanno optimization. ","@ToolTip4":"NMSIMP (NS): performs a Nelder-Mead simplex optimization","@ToolTip5":"QUANEW (QN): performs a quasi-Newton optimization","@ToolTip6":"TRUREG (TR): performs a trust-region optimization"}},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary \nvariables or a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPTABLE","StatementOptionHelp":{"#cdata":"Generates an in-memory temporary table from the result set. The IMSTAT procedure displays the \nname of the table and stores it in the &_TEMPLAST_ macro variable, provided that the statement \nexecuted successfully. \n\nWhen the IMSTAT procedure exits, all temporary tables created during the IMSTAT session are \nremoved. Temporary tables are not displayed on a TABLEINFO request, unless the temporary table \nis the active table for the request."},"StatementOptionType":"S"},{"StatementOptionName":"TIMEOUT=","StatementOptionHelp":{"#cdata":"Syntax: TIMEOUT=seconds\n\nSpecifies the maximum number of seconds that the server should run the statement. If the time-out \nis reached, the server terminates the request and generates an error and error message. By default, \nthere is no time-out."},"StatementOptionType":"V"},{"StatementOptionName":"UPPER=","StatementOptionHelp":{"#cdata":"Syntax: UPPER=r\n\nSpecifies an upper bound for the network weights. \n\nDefault: 10.0"},"StatementOptionType":"V"},{"StatementOptionName":"VARS=|IDVARS=","StatementOptionHelp":{"#cdata":"Syntax: VARS=variable-name\n\nVARS=(variable-name1 <, variable-name2, ...>) \n\nSpecifies the names of the variables to transfer from the active table to a temporary table that \ncontains the scoring results. This option is ignored unless you score an in-memory table and the \nTEMPTABLE option is specified. The observations with these variables are copied to the generated \ntemporary table."},"StatementOptionType":"V"},{"StatementOptionName":"WEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT=variable-name\n\nSpecifies a variable to weight the prediction errors (the difference between the output of the network \nvalue and the target value specified in the input data set) for each observation during training."},"StatementOptionType":"V"}]}},{"StatementName":"OPTIMIZE","StatementHelp":{"#cdata":"Syntax: OPTIMIZE <options>; \n      \nThe OPTIMIZE statement performs a non-linear optimization of an objective function that is defined \nthrough a SAS program. The expression defined in the SAS program and its analytic first and second \nderivatives are compiled into executable code. The code is then executed in multiple threads against \nthe data in an in-memory table. Like all other IMSTAT statements, the calculations are performed by \nthe server. You can choose from several first-order and second-order optimization algorithms."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ALPHA=","StatementOptionHelp":{"#cdata":"Syntax: ALPHA=number\n\nSpecifies a number between 0 and 1 from which to determine the confidence level for approximate \nconfidence intervals of the parameter estimates. The default is \u03b1 = 0.05, which leads to \n100 x (1- \u03b1)% = 95% confidence limits for the parameter estimates. \n\nDefault: 0.05"},"StatementOptionType":"V"},{"StatementOptionName":"BOUNDS=|BOUND=","StatementOptionHelp":{"#cdata":"Syntax: BOUNDS=(boundary-specification<, boundary-specification,...>) \n\nSpecifies boundary values for the parameters. A boundary-specification is specified in the following form: \n\n  parameter-name operator value\n\nparameter-name\n  specifies the parameter\noperator\n  is one of >=, GE, <=, LE, >, GT, <, LT, =, EQ. \nvalue\n  specifies the boundary value \n\nExample:\nBOUNDS=(s2 > 0, beta2 >= 0.2)"},"StatementOptionType":"V"},{"StatementOptionName":"CODE=|PGM=","StatementOptionHelp":{"#cdata":"Syntax: CODE=file-reference\n\nSpecifies a file reference to the SAS program that defines the objective function. The program must \nmake an assignment to the reserved symbol _OBJFNC_. The server then minimizes the negative of that \nfunction (or maximize the function). In other words, you should specify _OBJFNC_ to be the function \nthat you want to maximize across the in-memory table. The actual optimization is carried out as a \nminimization problem."},"StatementOptionType":"V"},{"StatementOptionName":"DEFSTART=|DEFVAL=","StatementOptionHelp":{"#cdata":"Syntax: DEFSTART=value\n\n\nSpecifies the default starting value for parameters whose starting value has not been specified. \nThe default value, 1, might not work well depending on the optimization. \n \nDefault: 1"},"StatementOptionType":"V"},{"StatementOptionName":"DUD|NODERIVATIVES","StatementOptionHelp":{"#cdata":"Specifies that you do not want to use analytic derivatives in the optimization. The option name \nis an acronym for \"do not use derivatives.\" Instead, the server calculates gradient vectors and \nHessian matrices from finite difference approximations. Generally, you should not rely on derivatives \ncalculated from finite differences if analytic derivatives are available. However, this option is \nuseful in situations where the objective function is not calculated independently for each row of \ndata. If derivatives of the objective function depend on lagged values, which are themselves functions \nof the parameters, then finite difference derivatives are called for."},"StatementOptionType":"S"},{"StatementOptionName":"FCONV=","StatementOptionHelp":{"#cdata":"Syntax: FCONV=r\n\nSpecifies a relative function convergence criterion. For all techniques except NMSIMP, termination \nrequires a small relative change of the function value in successive iterations."},"StatementOptionType":"V"},{"StatementOptionName":"GCONV=","StatementOptionHelp":{"#cdata":"Syntax: GCONV=r\n\nSpecifies a relative gradient convergence criterion. For all optimization techniques except CONGRA and NMSIMP, \ntermination requires that the normalized predicted function reduction is small. The default value is r = 1e-8."},"StatementOptionType":"V"},{"StatementOptionName":"ITDETAIL","StatementOptionHelp":{"#cdata":"\n\nRequests that the server produce an iteration history table for the optimization. This table displays \nthe objective function, its absolute change, and the largest absolute gradient across the iterations."},"StatementOptionType":"S"},{"StatementOptionName":"MAXFUNC=|MAXFU=","StatementOptionHelp":{"#cdata":"Syntax: MAXFUNC=n\n\n\nSpecifies the maximum number n of function calls in the iterative model fitting process.\n\nThe default value depends on the optimization technique as follows: \n\n---------------------------------------------------------------------------------------------\nOptimization Technique      Default Number of Function Calls\n---------------------------------------------------------------------------------------------\nTRUREG, NRRIDG, and NEWRAP  125 \nQUANEW and DBLDOG           500\nCONGRA                      1000\nNMSIMP                      3000"},"StatementOptionType":"V"},{"StatementOptionName":"MAXITER=|MAXIT=","StatementOptionHelp":{"#cdata":"Syntax: MAXITER=i\n\nSpecifies the maximum number of iterations in the iterative model fitting process. The default \nvalue depends on the optimization technique as follows:\n\n---------------------------------------------------------------------------------------------\nOptimization Technique      Default Number of Function Calls\n---------------------------------------------------------------------------------------------\nTRUREG, NRRIDG, and NEWRAP  50 \nQUANEW and DBLDOG           200\nCONGRA                      400\nNMSIMP                      1000"},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=t\n\nSpecifies an upper limit of t seconds of CPU time for the optimization process. The default value \nis the largest floating-point double representation value for the hardware used by the SAS LASR \nAnalytic Server. Note that the time specified by the MAXTIME= option is checked only once at the \nend of each iteration. The time is measured on the root node for the server. Therefore, the actual \nrunning time can be longer than the value specified by the MAXTIME= option."},"StatementOptionType":"V"},{"StatementOptionName":"MINITER=|MINIT=","StatementOptionHelp":{"#cdata":"Syntax: MINITER=i\n\nSpecifies the minimum number of iterations. \n\nDefault: 0"},"StatementOptionType":"V"},{"StatementOptionName":"NBEST=|BEST=","StatementOptionHelp":{"#cdata":"Syntax: NBEST=k\n\nRequests that only the k best points in the starting value grid are reproduced in the \"Starting Values\" \ntable. By default, the objective function is initially evaluated at all points in the starting value grid \nand the \"Starting Values\" table contains one row for each point on the grid. If you specify the NBEST= \noption, then only the k points with the smallest objective function value are shown."},"StatementOptionType":"V"},{"StatementOptionName":"NOEMPTY","StatementOptionHelp":{"#cdata":"Requests that result sets for optimizations without usable data are not generated."},"StatementOptionType":"S"},{"StatementOptionName":"NOPREPARSE|NOPREP","StatementOptionHelp":{"#cdata":"Specifies to prevent pre-parsing and pre-generating the program code that is referenced in the CODE= option. \nIf you know the code is correct, you can specify this option to save resources. The code is always parsed by \nthe server, but you might get more detailed error messages when the procedure parses the code rather than the \nserver. The server assumes that the code is correct. If the code fails to compile, the server indicates that \nit could not parse the code, but not where the error occurred."},"StatementOptionType":"S"},{"StatementOptionName":"NOSTDERR|NOSTD","StatementOptionHelp":{"#cdata":"Specifies to prevent calculating standard errors of the parameter estimates. The calculation \nof standard errors requires the derivation of the Hessian or cross-product Jacobian. If you \ndo not want standard errors, p-values, or confidence intervals for the parameter estimates, \nthen specifying this option saves computing resources."},"StatementOptionType":"S"},{"StatementOptionName":"PARAMETERS=|PARMS=","StatementOptionHelp":{"#cdata":"Syntax: PARAMETERS=(parameter-specification <, parameter-specification...>) \n\nSpecifies the parameters in the optimization and the starting values. You do not have to specify parameters \nand you do not have to specify starting values. If you omit the starting values, the default starting value \nis assigned. This default value is 1.0 and can be modified with the DEFSTART= option. \n\nIf you do not specify the parameter names, the server assumes that all symbols in your SAS program are \nparameters if they do not match column names in the in-memory table or are not special or temporary symbols. \nThis might not be what you want and you should examine the \"Starting Values\" and \"Parameter Estimates\" table \nin that case to make sure that the server designated the appropriate quantities as parameters in the optimization. \n\nIn the first example that follows, Intercept is assigned a starting value of 6. The remaining parameters start \nat 0 because the DEFSTART= option is 0. \n\nIn the second example that follows, the server evaluates the objective function initially for the Cartesian \nproduct set of all the parameter vectors. The server evaluates 1 \u00d7 3 \u00d7 2 \u00d7 1 = 6 parameter vectors. The \noptimization then starts from the vector associated with the best objective function value. \n  \nExamples:\nDEFSTART=0; PARMS=(Intercept = 6, a_0, b_0, c_0, x_1, x_2, x_3);  \nPARMS=(beta1 = -3.22, beta2 = 0.5 0.47 0.6, beta3 = -2.45 -2.0, s2 = 0.5); "},"StatementOptionType":"V"},{"StatementOptionName":"RESTRICT=","StatementOptionHelp":{"#cdata":"Syntax: RESTRICT=(one-restriction <, one-restriction>) \n\nSpecifies linear equality and inequality constraints for the optimization. A single restriction \ntakes on the general form \n\n  coefficient parameter ... coefficient parameter operator value\n\nInequality restrictions are expressed as constraints greater than (>) or greater than or equal (>=) \nthan the right hand side value. \n\nThe first example that follows shows the restriction \u03b21 \u2013 2 \u03b22 > 3. \n\nThe second example that follows shows how to use more than one restriction. Restrictions are separated \nby commas and the second example requests that the estimates for parameters dose1 and dose2 are the same, \nas well as the estimates for logd1 and logd2. \n\nExamples:\nRESTRICT=(1 beta1 -2 beta2 > 3) \nRESTRICT=(1 dose1 -1 dose2 = 0, 1 logd1 -1 logd2 = 0)"},"StatementOptionType":"V"},{"StatementOptionName":"SAVE=","StatementOptionHelp":{"#cdata":"Syntax: SAVE=table-name\n\nSaves the result table so that you can use it in other IMSTAT procedure statements like STORE, REPLAY, \nand FREE. The value for table-name must be unique within the scope of the procedure execution. The name \nof a table that has been freed with the FREE statement can be used again in subsequent SAVE= options."},"StatementOptionType":"V"},{"StatementOptionName":"SETSIZE","StatementOptionHelp":{"#cdata":"Requests that the server estimate the size of the result set. The procedure does not create a result \ntable if the SETSIZE option is specified. Instead, the procedure reports the number of rows that are \nreturned by the request and the expected memory consumption for the result set (in KB). If you specify \nthe SETSIZE option, the SAS log includes the number of observations and the estimated result set size."},"StatementOptionType":"S"},{"StatementOptionName":"TECHNIQUE=|TECH=","StatementOptionHelp":{"#cdata":"Syntax: TECHNIQUE=value\n\nSpecifies the optimization technique.\n\nDefault: DUQUANEW"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"CONGRA","@Value2":"DBLDOG","@Value3":"DUQUANEW","@Value4":"NMSIMP","@Value5":"NEWRAP","@Value6":"NRRIDG","@Value7":"QUANEW","@Value8":"TRUREG","@Value9":"NONE"},"StatementOptionToolTips":{"@ToolTip1":"CONGRA (CG): performs a conjugate-gradient optimization","@ToolTip2":"DBLDOG (DD): performs a version of the double-dogleg optimization","@ToolTip3":"DUQUANEW (DQN) performs a (dual) quasi-Newton optimization.","@ToolTip4":"NMSIMP (NS): performs a Nelder-Mead simplex optimization","@ToolTip5":"NEWRAP (NRA): performs a (modified) Newton-Raphson optimization that combines a line-search algorithm with ridging","@ToolTip6":"NRRIDG (NRR): performs a (modified) Newton-Raphson optimization with ridging","@ToolTip7":"QUANEW (QN): performs a quasi-Newton optimization","@ToolTip8":"TRUREG (TR): performs a trust-region optimization","@ToolTip9":"NONE:  Specifies not to perform any optimization. This value can be useful to perform a grid search without optimization."}}]}},{"StatementName":"PERCENTILE","StatementHelp":{"#cdata":"Syntax: PERCENTILE <variable-list> </ options>; \n      \nThe PERCENTILE statement computes percentiles for one or more numeric variables. "},"StatementOptions":{"StatementOption":[{"StatementOptionName":"DESCENDING|DESC","StatementOptionHelp":{"#cdata":"Specifies that the levels of the GROUPBY variables are to be arranged in descending order."},"StatementOptionType":"S"},{"StatementOptionName":"EPSILON=|EPS=","StatementOptionHelp":{"#cdata":"Syntax: EPSILON=number\n\nSpecifies the tolerance used for determining the convergence of the iterative algorithm for the \npercentile calculation. \n\nDefault: 1e-5"},"StatementOptionType":"V"},{"StatementOptionName":"FORMATS=","StatementOptionHelp":{"#cdata":"Syntax: FORMATS=(\"format-specification\",...) \n\nSpecifies the formats for the GROUPBY= variables. If you do not specify the FORMATS= option, or if \nyou omit the entry for a GROUPBY variable, the default format is applied for that variable. \n\nEnclose each format specification in quotation marks and separate each format specification with a comma. \n\nExample:\nproc imstat data=lasr1.table1;\n   percentile x*y / groupby=(a b) formats=(\"8.3\", \"$10\");\nquit;"},"StatementOptionType":"V"},{"StatementOptionName":"GROUPBY=","StatementOptionHelp":{"#cdata":"Syntax: GROUPBY=(variable-list) \n\nSpecifies a list of variable names, or a single variable name, to use as GROUPBY variables in the \norder of the grouping hierarchy. If you do not specify any GROUPBY variable names, then the calculation \nis performed across the entire table\u2014possibly subject to a WHERE clause."},"StatementOptionType":"V"},{"StatementOptionName":"GROUPBYLIMIT=","StatementOptionHelp":{"#cdata":"Syntax: GROUPBYLIMIT=n\n\nSpecifies the maximum number of levels in a GROUPBY set. When the software determines that there \nare at least n levels in the GROUPBY set, it abandons the action, returns a message, and does not \nproduce a result set. You can specify the GROUPBYLIMIT= option if you want to avoid creating \nexcessively large result sets in GROUPBY operations."},"StatementOptionType":"V"},{"StatementOptionName":"MAXITER=","StatementOptionHelp":{"#cdata":"Syntax: MAXITER=i\n\nSpecifies  the maximum number of iterations for the algorithm. The percentile algorithm is iterative. \nYou can limit the number of iterations with the MAXITER= option. You can also control the computational \ndemand with the EPSILON= option. That option affects the tolerance criterion by which the convergence of \nthe iterative algorithm is judged. Whether the percentile calculation has converged is displayed separately \nfor each of the calculated percentiles. \n\nDefault: 10"},"StatementOptionType":"V"},{"StatementOptionName":"MERGEBINS=","StatementOptionHelp":{"#cdata":"Syntax: MERGEBINS=b\n\nSpecifies the number of bins to create when a numeric GROUPBY variable exceeds the MERGELIMIT=n \nspecification. If you specify a MERGELIMIT, but do not specify a value for the MERGEBINS= option, \nthe server automatically calculates the number of bins."},"StatementOptionType":"V"},{"StatementOptionName":"MERGELIMIT=","StatementOptionHelp":{"#cdata":"Syntax: MERGELIMIT=n\n\nSpecifies that when the number of unique values in a numeric GROUPBY variable exceeds n, the variable \nis automatically binned and the GROUPBY structure is determined based on the binned values of the variable, \nrather than the unique formatted values. \n\nFor example, if you specify MERGELIMIT=500, any numeric GROUPBY variable with more than 500 unique \nformatted values is binned. Instead of returning results for more than 500 groups, the results are \nreturned for the bins. You can specify the number of bins with the MERGEBINS= option."},"StatementOptionType":"V"},{"StatementOptionName":"NOPREPARSE|NOPREP","StatementOptionHelp":{"#cdata":"Prevents the procedure from preparsing and pregenerating code for temporary expressions, scoring \nprograms, and other user-written SAS statements. \n\nWhen this option is specified, the user-written statements are sent to the server \"as is\" and then \nthe server attempts to generate code from it. If the server detects problems with the code, the error \nmessages might not to be as detailed as the messages that are generated by SAS client. If you are \ndebugging your user-written program, then you might want to preparse and pregenerate code in the \nprocedure. However, if your SAS statements compile and run as you want them to, then you can specify \nthis option to avoid the work of parsing and generating code on the SAS client. \n\nWhen you specify this option in the PROC IMSTAT statement, the option applies to all statements that \nan generate code. You can also exclude specific statements from preparsing by using the NOPREPARSE \noption in statements that allow temporary columns or the SCORE statement."},"StatementOptionType":"S"},{"StatementOptionName":"NOTEMPPART|NOTP","StatementOptionHelp":{"#cdata":"Specifies that the temporary table generated by the TEMPTABLE option is not partitioned by the \nGROUPBY= variables. When you request a temporary table with the SUMMARY statement, by default, \nthe server partitions the table and the size of a partition is equal to the number of analysis \nvariables in the variable-list of the SUMMARY statement. When the number of groups is large, this \ncan result in many small partitions, and requires extra memory resources to store the partition \ninformation for the temporary table. By specifying this option, the temporary table is organized \nsimilarly to the default table, but is not a partitioned table."},"StatementOptionType":"S"},{"StatementOptionName":"PARTITION|PART","StatementOptionHelp":{"#cdata":"Syntax: PARTITION <=partition-key>\n\nWhen you specify this option and the table is partitioned, the results are calculated separately \nfor each value of the partition key. In other words, the partition variables function as automatic \nGROUPBY variables. This mode of executing calculations by partition is more efficient than using the \nGROUPBY= option. With a partitioned table, the server takes advantage of knowing that observations for \na partition cannot be located on more than one worker node. \n\nIf you do not specify a partition-key, the analysis is performed for all partitions. If you do specify \na partition-key, the analysis is carried out for the specified key value only. You can use the PARTITIONINFO \nstatement to retrieve the valid partition key values for a table. \n\nYou can specify a partition-key in two ways. You can supply a single quoted string that is passed to the \nserver, or you can specify the elements of a composite key separated by commas."},"StatementOptionType":"S|V"},{"StatementOptionName":"RAWORDER","StatementOptionHelp":{"#cdata":"Specifies that the ordering of the GROUPBY variables is based on the raw values of the variables \ninstead of the formatted values."},"StatementOptionType":"S"},{"StatementOptionName":"SAVE=","StatementOptionHelp":{"#cdata":"Syntax: SAVE=table-name\n\nSaves the result table so that you can use it in other IMSTAT procedure statements like STORE, REPLAY, \nand FREE. The value for table-name must be unique within the scope of the procedure execution. The name \nof a table that has been freed with the FREE statement can be used again in subsequent SAVE= options."},"StatementOptionType":"V"},{"StatementOptionName":"SETSIZE","StatementOptionHelp":{"#cdata":"Requests that the server estimate the size of the result set. The procedure does not create a result \ntable if the SETSIZE option is specified. Instead, the procedure reports the number of rows that are \nreturned by the request and the expected memory consumption for the result set (in KB). If you specify \nthe SETSIZE option, the SAS log includes the number of observations and the estimated result set size."},"StatementOptionType":"S"},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary \nvariables or a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPTABLE","StatementOptionHelp":{"#cdata":"Generates an in-memory temporary table from the result set. The IMSTAT procedure displays the \nname of the table and stores it in the &_TEMPLAST_ macro variable, provided that the statement \nexecuted successfully. \n\nWhen the IMSTAT procedure exits, all temporary tables created during the IMSTAT session are \nremoved. Temporary tables are not displayed on a TABLEINFO request, unless the temporary table \nis the active table for the request."},"StatementOptionType":"S"},{"StatementOptionName":"VALUES=|VALS=","StatementOptionHelp":{"#cdata":"Syntax: VALUES=(percentiles) \n\nSpecifies the values for which to calculate the percentiles. The default is to calculate the 25th, \n50th, and 75th percentile. These are also known as the first, second, and third quartile. The second \nquartile is the median. \n\nRange: 0 to 100\n\nExample:\nThe following statement requests the 10th, 20th, \u2026., 90th percentile: \n\n  percentile invoice / values=(10 20 30 40 50 60 70 80 90);"},"StatementOptionType":"V"}]}},{"StatementName":"RANDOMWOODS","StatementHelp":{"#cdata":"Syntax: RANDOMWOODS target-variable </ options>; \n      \ntarget-variable\n  specifies a single column in the in-memory table as the target variable. The variable can be \n  a temporary calculated column. \n\nThe RANDOMWOODS statement builds a random forest of decision trees. Each tree is constructed \nfrom a bootstrap sample of the data, drawn with replacement, and is constructed from only a \nsubset of the variables specified in the INPUT= option."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ADDTREES","StatementOptionHelp":{"#cdata":"Requests that the temporary table that is generated by scoring a random forest is enhanced with \ninformation about the votes of the individual trees. The process of scoring a random forest means \nthat each tree votes on the predicted value and the predicted value for the forest is obtained by \nmajority vote. This option adds the votes for each tree in the forest. By default, only the overall \nvote is reported in the temporary table."},"StatementOptionType":"S"},{"StatementOptionName":"ASSESS","StatementOptionHelp":{"#cdata":"Specifies that predicted probabilities are added to the temporary result table for the event levels. \nYou can use these predicted probabilities in an ASSESS statement."},"StatementOptionType":"S"},{"StatementOptionName":"BOOTSTRAP=","StatementOptionHelp":{"#cdata":"Syntax: BOOTSTRAP=f\n\nSpecifies the fraction of the data in the bootstrap sample. \n\nDefault: f = 1 \u2013 exp(\u20131)  \nRange: 0 to 1"},"StatementOptionType":"V"},{"StatementOptionName":"CODE","StatementOptionHelp":{"#cdata":"Syntax: CODE <(code-generation-options)>\n\nRequests that the server produce SAS scoring code based on the actions that it performed during the \nanalysis. The server generates DATA step code. By default, the code is replayed as an ODS table by \nthe procedure as part of the output of the statement. More frequently, you might want to write the \nscoring code to an external file by specifying options.\n\nCOMMENT\n  specifies to add comments to the code in addition to the header block. The header block is added by default. \nFILENAME=|FILE='path' \n  specifies the name of the external file to which the scoring code is written. This suboption applies only \n  to the scoring code itself. \nFORMATWIDTH=|FMTW=k\n  specifies the width to use in formatting derived numbers such as parameter estimates in the scoring code. \n  The server applies the BEST format, and the default format for code generation is BEST20. Range: 4 to 32\nLABELID=id\n  specifies a group identifier for group processing. The identifier is an integer and is used to create array \n  names and statement labels in the generated code. \nLINESIZE=|LS=n\n  specifies the line size for the generated code. \n  Default: 72 \n  Range: 64 to 256\nNOTRIM\n  specifies to format the variables using the full format width with padding. By default, leading and trailing \n  blanks are removed from the formatted values. \nREPLACE\n  specifies to overwrite the external file if a file with the specified name already exists. The option \n  has no effect unless you specify the FILENAME= option."},"StatementOptionType":"S","SubOptionsKeywords":"COMMENT|FILENAME=|FILE=|FORMATWIDTH=|FMTW=|LABELID=|LINESIZE=|NOTRIM|REPLACE"},{"StatementOptionName":"EVENT=","StatementOptionHelp":{"#cdata":"Syntax: EVENT=(\"event1\" <, \"event2\u201d>...) \n\nSpecifies the event names of the target variable. This option is combined with the WEIGHT= option \nto specify the weight for each specific event. Observations with the specified event are reweighted \nwith the value from the WEIGHT= option. This option is useful for rare-event sampling."},"StatementOptionType":"V"},{"StatementOptionName":"FORMATS=","StatementOptionHelp":{"#cdata":"Syntax: FORMATS=(\"format-specification\",...) \n\nSpecifies the formats for the input variables. If you do not specify the FORMATS= option, the default \nformat is applied for that variable. Enclose each format specification in quotation marks and separate \neach format specification with a comma."},"StatementOptionType":"V"},{"StatementOptionName":"GAIN","StatementOptionHelp":{"#cdata":"Specifies that the splitting criterion is changed to information gain. Typically, this criterion \nintends to generate trees with more nodes than information gain ratio."},"StatementOptionType":"S"},{"StatementOptionName":"GREEDY","StatementOptionHelp":{"#cdata":"Syntax: \n\nSpecifies how to perform splitting under specific circumstances. \n\nAssuming that one variable has q levels, when binary splitting is performed and q is less than 15, \nor option MAXBRANCH > 2 and q < 12, all possible binary splits are enumerated and the split with \nthe largest gain or gain ratio is chosen for the variable. \n\nWhen q is less than 1024 and splitting is not just binary, local greedy searches are applied to \ndetermine the optimum local split. Specifically, when the variable is numeric, q levels (similar \nto q bins) are sorted by value. \n\nWhen the variable is nominal, the q levels are ordered by random weights. The best binary splitting \nis applied until the desired number of branches is reached. Only a local optimum can be found with \nthis technique. \n\nFor values of q \u2265 1024, the default k-means clustering algorithm is applied to determine the splits."},"StatementOptionType":"S"},{"StatementOptionName":"IMPUTE","StatementOptionHelp":{"#cdata":"Specifies how to treat observations with nonmissing values for the target variable during scoring. \nWhen this option is specified, the observed values are used as the predicted values. That is, the \nobserved value is assumed to be known without error. Only the observations with missing values for \nthe target variable are then scored against the random forest, based on their values for the input \nvariables. \n\nThis option is useful if you want to replace missing values of a target variable with classified \nvalues that are based on the random forest."},"StatementOptionType":"S"},{"StatementOptionName":"INPUT=","StatementOptionHelp":{"#cdata":"Syntax: INPUT=variable-name\n\nINPUT=(variable-list) \n\nSpecifies the variables to use for building the tree. You can add the target variable to the input \nlist if you want to assign a format to the target variable by using the FORMATS= option. Any numeric \nvariable that is not specified in the NOMINAL= option is binned according to the NBINS= specification. \n\nIn random forest implementations, all of the input variables do not participate in the construction \nof the trees. Each tree is built from a subset of the input variables. You can use the M= option to \naffect the selection of these input variables."},"StatementOptionType":"V"},{"StatementOptionName":"LEAFSIZE=","StatementOptionHelp":{"#cdata":"Syntax: LEAFSIZE=m\n\nSpecifies the minimal number of observations on each node. When the number of observations on a tree \nnode falls short of the specified leaf size m, the node is changed into a leaf during the building of \nthe tree. \n\nInteraction Specifying the LEAFSIZE option affects the pruning of the tree."},"StatementOptionType":"V"},{"StatementOptionName":"M=","StatementOptionHelp":{"#cdata":"Syntax: M=k\n\nSpecifies the number of input variables used to build a tree. The k variables are selected at random \nfrom the list of input variables for each tree. If not specified, then k defaults to the square root \nof the number of input variables, rounded up to the nearest integer."},"StatementOptionType":"V"},{"StatementOptionName":"MAXBRANCH=","StatementOptionHelp":{"#cdata":"Syntax: MAXBRANCH=n\n\nSpecifies the maximum number of children (branches) allowed for each level of the tree. \n\nDefault: 2"},"StatementOptionType":"V"},{"StatementOptionName":"MAXLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: MAXLEVEL=n\n\nSpecifies the maximum number of tree levels. \n\nDefault: 6"},"StatementOptionType":"V"},{"StatementOptionName":"NBINS=","StatementOptionHelp":{"#cdata":"Syntax: NBINS=k\n\nSpecifies the number of bins used in the calculation of the tree. The number of bins affects the \naccuracy of the tree and increases with k at the expense of computing time and memory consumption. \n\nDefault: 2"},"StatementOptionType":"V"},{"StatementOptionName":"NBINSTARGET=","StatementOptionHelp":{"#cdata":"Syntax: NBINSTARGET=k\n\nSpecifies the number of bins to use for a numeric target variable. The number of bins affects the \naccuracy of the tree. The accuracy increases as values of k increase. However, computing time and \nmemory consumption also increase as values of k increase. When k is greater than zero, the numeric \ntarget variable is binned into equally sized bins first and then the bins are used to perform the \nclassification. \n\nDefault: 0"},"StatementOptionType":"V"},{"StatementOptionName":"NOERROR","StatementOptionHelp":{"#cdata":"Specifies that the out-of-bag error is not computed when building a random decision forest. This \noption is useful to speed up the building process."},"StatementOptionType":"S"},{"StatementOptionName":"NOMINAL=","StatementOptionHelp":{"#cdata":"Syntax: NOMINAL=variable-name\n\nNOMINAL=(variable-list) \n\nSpecifies the numeric variables to use as nominal variables. Binning is not applied to the specified \nvariables. The target variable is always treated as a nominal variable and does not need to be listed."},"StatementOptionType":"V"},{"StatementOptionName":"NOMISSOBS","StatementOptionHelp":{"#cdata":"Specifies to ignore observations that have missing values in the analysis variables when building a \ndecision tree. When scoring a data set, any observations with missing values in the analysis variables \nfor the decision tree are ignored when this option is specified. \n\nWhen this option is not specified, the RANDOMWOODS statement builds a tree by applying the following policy for missing values: \n\n\u2022 for an interval variable, the smallest machine value is assigned \n \n\u2022 for a nominal variable, missing values are represented by a separate level"},"StatementOptionType":"S"},{"StatementOptionName":"NOPREPARSE|NOPREP","StatementOptionHelp":{"#cdata":"Prevents pre-parsing and pre-generating the program code that is referenced in the CODE= option. \nIf you know the code is correct, you can specify this option to save resources. The code is \nalways parsed by the server, but you might get more detailed error messages when the procedure \nparses the code rather than the server. The server assumes that the code is correct. If the code \nfails to compile, the server indicates that it could not parse the code, but not where the error \noccurred."},"StatementOptionType":"S"},{"StatementOptionName":"NTREE=","StatementOptionHelp":{"#cdata":"Syntax: NTREE=n\n\nSpecifies the number of trees to build for the random forest. \n\nDefault: 1"},"StatementOptionType":"V"},{"StatementOptionName":"REG","StatementOptionHelp":{"#cdata":"Specifies to build the random decision forest using regression trees. Minimal cost-complexity pruning \nis applied to prune the trees."},"StatementOptionType":"S"},{"StatementOptionName":"SAVE=","StatementOptionHelp":{"#cdata":"Syntax: SAVE=table-name\n\nSaves the result table so that you can use it in other IMSTAT procedure statements like STORE, REPLAY, \nand FREE. The value for table-name must be unique within the scope of the procedure execution. The name \nof a table that has been freed with the FREE statement can be used again in subsequent SAVE= options."},"StatementOptionType":"V"},{"StatementOptionName":"SCOREDATA=","StatementOptionHelp":{"#cdata":"Syntax: SCOREDATA=table-name\n\nSpecifies the in-memory table that contains the scoring data. The table must exist in-memory on \nthe server. The RANDOMWOODS statement in the IMSTAT procedure does not transfer a local data set \nto the server. \n\nIf you do not specify a table name for this option, the active table is used as the scoring input."},"StatementOptionType":"V"},{"StatementOptionName":"SEED=","StatementOptionHelp":{"#cdata":"Syntax: SEED=s\n\nSpecifies the random number seed for the random number generator in the server. The default value, \nzero, implies that the random number stream is based on the computer clock. Negative seed values \nalso lead to random number streams that are based on the computer clock. If you want a reproducible \nrandom number sequence between runs, specify a value that is greater than zero. \n\nDefault: 0"},"StatementOptionType":"V"},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary \nvariables or a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPTABLE","StatementOptionHelp":{"#cdata":"Specifies to save the results of the RANDOMWOODS statement in a temporary table. \n\nIf you build a random forest, the temporary table contains information about the forest. \n\nIf you score a random forest, the temporary table contains the predicted values for the observations \nin the input table that you scored. The temporary table also contains the variables that you specified \nto transfer from the input table and other statistics. This option is required when you perform scoring \nso that you can access the predictions for each observation. The IMSTAT procedure then displays the name \nof the table and stores it in the _TEMPSCORE_ macro variable, provided that the scoring action was successful. \nObservations from the table that you scored can be transferred to the temporary table using the VARS= option."},"StatementOptionType":"S"},{"StatementOptionName":"TIMEOUT=","StatementOptionHelp":{"#cdata":"Syntax: TIMEOUT=s\n\nSpecifies the maximum number of seconds that the statement should run in the server. If the computation \ndoes not complete before the time-out is reached, execution stops and the server generates an error message. \nThere is no default time-out."},"StatementOptionType":"V"},{"StatementOptionName":"TREEINFO","StatementOptionHelp":{"#cdata":"Specifies to display information about individual tress, when you build a tree. For example, the table \nthat is shown can display which variables are used in each tree. The option has no effect if you store \nthe tree in a temporary table."},"StatementOptionType":"S"},{"StatementOptionName":"TREELASR=|LASRTREE=","StatementOptionHelp":{"#cdata":"Syntax: TREELASR=table-name\n\nSpecifies the in-memory table that contains the information for the random forest if you want \nto score a table against the random forest. \n\nThe data set whose observations are to be scored is specified in the SCOREDATA= option. If you \ndo not specify the SCOREDATA= option, the active table is used as scoring input."},"StatementOptionType":"V"},{"StatementOptionName":"VARS=","StatementOptionHelp":{"#cdata":"Syntax: VARS=variable-name\n\nVARS=(variable-name1 <, variable-name2, ...>) \n\nSpecifies the variables to transfer from the input table to the temporary table in the server that \ncontains the results of scoring a decision tree. This option has no effect unless you specify the \nTEMPTABLE option and you score a decision tree."},"StatementOptionType":"V"},{"StatementOptionName":"WEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT=\n\nSpecifies the weight for each corresponding event in the EVENT= option."},"StatementOptionType":"V"}]}},{"StatementName":"REGCORR","StatementHelp":{"#cdata":"Syntax: REGCORR <variable-list> </ options>; \n\nvariable-list\n  specifies one or more numeric variables. If you do not specify this option, then all numeric variables \n  in the table are used. \n\nThe REGCORR statement calculates and returns the results for linear, quadratic, \nor cubic polynomial regression models. "},"StatementOptions":{"StatementOption":[{"StatementOptionName":"NBEST=","StatementOptionHelp":{"#cdata":"Syntax: NBEST=n\n\nSpecifies that results are returned only for the n regression with the highest R-square value \n(the highest coefficient of determination) . If n is smaller than the number of regressions \ncomputed by the statement, then the actual number of computed regression is returned."},"StatementOptionType":"V"},{"StatementOptionName":"ORDER=","StatementOptionHelp":{"#cdata":"Syntax: ORDER=1 | 2 | 3\n\nORDER=-1 | \u20132 | \u20133\n\nSpecifies the highest polynomial degree in the regression model. By default, ORDER=1, and the model \nis a simple linear regression. Specify ORDER=2 for a quadratic model and ORDER=3 for a cubic model. \n\nIf you specify a negative value for the ORDER= option, the server evaluates the best model for each \nvariable combination based on statistical principles. For example, if you specify ORDER=\u20132, the server \nreturns results for a linear regression provided that the removal of the quadratic term does not result \nin a poorer model\u2014as judged statistically. Similarly, with ORDER=\u20133, you might get results for a cubic, \nquadratic, or a linear regression. The results depend on which model is deemed to fit best. The evaluation \nof the models is done by the same rules that apply for the backward selection method in the REG procedure \u2014 \nthat is, coefficients that are not significant at the 0.1 significance level are removed. Furthermore, if \na higher-order term remains in the model, the lower-order polynomials are not being evaluated (for example, \nif the quadratic term is needed, the server does not try to remove the linear term). \n\nDefault: 1"},"StatementOptionType":"V"},{"StatementOptionName":"SAVE=","StatementOptionHelp":{"#cdata":"Syntax: SAVE=table-name\n\nSaves the result table so that you can use it in other IMSTAT procedure statements like STORE, REPLAY,\nand FREE. The value for table-name must be unique within the scope of the procedure execution. The name \nof a table that has been freed with the FREE statement can be used again in subsequent SAVE= options."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary variables \nor a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"},{"StatementOptionName":"VARWITH","StatementOptionHelp":{"#cdata":"\n\n\nIf this option is specified, the variable-list of size k is interpreted to consist of one response \nvariable and k\u20131 regressors. Otherwise, the variable-list is used to compute all pairs of regressions \nwhere the response variable cycles through the left-hand side of the list."},"StatementOptionType":"S"}]}},{"StatementName":"SUMMARY","StatementHelp":{"#cdata":"Syntax: SUMMARY <variable-list> </ options>; \n      \nvariable-list\n  Specifies one or more numeric variables. If you do not specify this option, then all numeric \n  variables in the table are used. \n\nThe SUMMARY statement is used to calculate descriptive statistics such as the sample mean, \nsample variance, number of observations, sum of squares, and so on. If you specify one or \nmore variables in the GROUPBY= option, the results are produced separately for each combination \nof the GROUPBY variables."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"AGGREGATE=|AGG=","StatementOptionHelp":{"#cdata":"Syntax: AGGREGATE=(aggregation-methods) \n\nLists the aggregator on which the ordering of the result set is based. \n\nThe available aggregation methods are as follows: \n\n  CSS corrected sum of squares \n  CV coefficient of variation \n  MAX maximum value \n  MEAN arithmetic mean \n  MIN minimum value \n  N number of observations \n  NMISS number of missing observations \n  PROBT p-value for the t-statistic  \n  STD standard deviation \n  STDERR standard error \n  SUM sum of the nonmissing values \n  TSTAT t-statistic for the null hypothesis that the mean equals zero  \n  USS uncorrected sum of squares \n  VAR sample variance"},"StatementOptionType":"V"},{"StatementOptionName":"DESCENDING|DESC","StatementOptionHelp":{"#cdata":"Specifies that the levels of the GROUPBY variables are to be arranged in descending order."},"StatementOptionType":"S"},{"StatementOptionName":"FORMATS=","StatementOptionHelp":{"#cdata":"Syntax: FORMATS=(\"format-specification\",...) \n\nSpecifies the formats for the GROUPBY= variables. If you do not specify the FORMATS= option, or if \nyou omit the entry for a GROUPBY variable, the default format is applied for that variable. \n\nEnclose each format specification in quotation marks and separate each format specification with a comma. \n\nExample:\nproc imstat data=lasr1.table1;\n   summary x*y / groupby=(a b) formats=(\"8.3\", \"$10\");\nquit;"},"StatementOptionType":"V"},{"StatementOptionName":"GROUPBY=","StatementOptionHelp":{"#cdata":"Syntax: GROUPBY=(variable-list) \n\nSpecifies a list of variable names, or a single variable name, to use as GROUPBY variables in the \norder of the grouping hierarchy. If you do not specify any GROUPBY variable names, then the calculation \nis performed across the entire table\u2014possibly subject to a WHERE clause."},"StatementOptionType":"V"},{"StatementOptionName":"GROUPBYLIMIT=","StatementOptionHelp":{"#cdata":"Syntax: GROUPBYLIMIT=n\n\nSpecifies the maximum number of levels in a GROUPBY set. When the software determines that there \nare at least n levels in the GROUPBY set, it abandons the action, returns a message, and does not \nproduce a result set. You can specify the GROUPBYLIMIT= option if you want to avoid creating \nexcessively large result sets in GROUPBY operations."},"StatementOptionType":"V"},{"StatementOptionName":"GROUPFILTER=","StatementOptionHelp":{"#cdata":"Syntax: GROUPFILTER=(filter-options) \n\nSpecifies a section of the group-by hierarchy to be included in the computation. With this option, \nyou can request that the server performs the analysis for only a subset of all possible groupings. \nThe subset is determined by applying the group filter to a temporary table that you generate with \nthe GROUPBY statement. \n\nYou can specify the following suboptions in the GROUPFILTER option: \n\nDESCENDING | DESC - specifies the top section or the bottom section of the groupings to be collected. \nLIMIT=n - specifies the maximum number of distinct groupings to be collected, where integer n >= 0. \nSCOREGT=f | SGT=f - specifies the exclusive lower bound for the numeric scores of the distinct groupings to collect. \nSCORELT=f | SLT= - specifies the exclusive upper bound for the numeric scores of the distinct groupings to collect. \nVALUEGT=(\"format-name1\" <, \"format-name2\" ...>) | VGT=\n  - specifies the exclusive lower bound of the group-by variable\u2019s formatted values for the distinct groupings to collect. \nVALUELT=(\"format-name1\" <, \"format-name2\" ...>)  | VLT=\n  - specifies the exclusive upper bound of the group-by variable\u2019s formatted values for the distinct groupings to collect. \nTABLE=table-with-groupby-results\n  - specifies the in-memory table from which to load the group-by hierarchy. \n  \nInteraction: If you specify the GROUPFILTER= option, then the GROUPBY= and FORMATS= options have no effect."},"StatementOptionType":"V","SubOptionsKeywords":"DESCENDING|DESC|LIMIT=|SCOREGT=|SGT=|SCORELT=|VLT=|VALUEGT=|VGT=|VALUELT=|VLT=|TABLE="},{"StatementOptionName":"MERGEBINS=","StatementOptionHelp":{"#cdata":"Syntax: MERGEBINS=b\n\nSpecifies the number of bins to create when a numeric GROUPBY variable exceeds the MERGELIMIT=n \nspecification. If you specify a MERGELIMIT, but do not specify a value for the MERGEBINS= option, \nthe server automatically calculates the number of bins."},"StatementOptionType":"V"},{"StatementOptionName":"MERGELIMIT=","StatementOptionHelp":{"#cdata":"Syntax: MERGELIMIT=n\n\nSpecifies that when the number of unique values in a numeric GROUPBY variable exceeds n, the variable \nis automatically binned and the GROUPBY structure is determined based on the binned values of the variable, \nrather than the unique formatted values. \n\nFor example, if you specify MERGELIMIT=500, any numeric GROUPBY variable with more than 500 unique \nformatted values is binned. Instead of returning results for more than 500 groups, the results are \nreturned for the bins. You can specify the number of bins with the MERGEBINS= option."},"StatementOptionType":"V"},{"StatementOptionName":"NOPREPARSE|NOPREP","StatementOptionHelp":{"#cdata":"Prevents the procedure from preparsing and pregenerating code for temporary expressions, scoring \nprograms, and other user-written SAS statements. \n\nWhen this option is specified, the user-written statements are sent to the server \"as is\" and then \nthe server attempts to generate code from it. If the server detects problems with the code, the error \nmessages might not to be as detailed as the messages that are generated by SAS client. If you are \ndebugging your user-written program, then you might want to preparse and pregenerate code in the \nprocedure. However, if your SAS statements compile and run as you want them to, then you can specify \nthis option to avoid the work of parsing and generating code on the SAS client. \n\nWhen you specify this option in the PROC IMSTAT statement, the option applies to all statements that \nan generate code. You can also exclude specific statements from preparsing by using the NOPREPARSE \noption in statements that allow temporary columns or the SCORE statement."},"StatementOptionType":"S"},{"StatementOptionName":"NOTEMPPART|NONTP","StatementOptionHelp":{"#cdata":"Specifies that the temporary table generated by the TEMPTABLE option is not partitioned by the \nGROUPBY= variables. When you request a temporary table with the SUMMARY statement, by default, \nthe server partitions the table and the size of a partition is equal to the number of analysis \nvariables in the variable-list of the SUMMARY statement. When the number of groups is large, this \ncan result in many small partitions, and requires extra memory resources to store the partition \ninformation for the temporary table. By specifying this option, the temporary table is organized \nsimilarly to the default table, but is not a partitioned table."},"StatementOptionType":"S"},{"StatementOptionName":"ORDERBY=","StatementOptionHelp":{"#cdata":"Syntax: ORDERBY=(variable-list) \n\nSpecifies the variables to use for ordering the result set. If a variable is not one of the numeric \nvariables in the variable-list for the SUMMARY statement, it is assumed to be one of the GROUPBY variables."},"StatementOptionType":"V"},{"StatementOptionName":"ORDERBYDESC","StatementOptionHelp":{"#cdata":"Specifies the sort order for the result set. The default is ascending order. Specify the ORDERBYDESC \noption to sort in descending order. Note that this option is different from setting the DESCENDING \noption. The DESCENDING option affects the order of the values for the GROUPBY variables."},"StatementOptionType":"S"},{"StatementOptionName":"PARTITION|PART","StatementOptionHelp":{"#cdata":"Syntax: PARTITION <=partition-key>\n\nWhen you specify this option and the table is partitioned, the results are calculated separately \nfor each value of the partition key. In other words, the partition variables function as automatic \nGROUPBY variables. This mode of executing calculations by partition is more efficient than using the \nGROUPBY= option. With a partitioned table, the server takes advantage of knowing that observations \nfor a partition cannot be located on more than one worker node. \n\nIf you do not specify a partition-key, the analysis is performed for all partitions. If you do specify \na partition-key, the analysis is carried out for the specified key value only. You can use the PARTITIONINFO \nstatement to retrieve the valid partition key values for a table. \n\nYou can specify a partition-key in two ways. You can supply a single quoted string that is passed to the \nserver, or you can specify the elements of a composite key separated by commas."},"StatementOptionType":"S|V"},{"StatementOptionName":"RAWORDER","StatementOptionHelp":{"#cdata":"Specifies that the ordering of the GROUPBY variables is based on the raw values of the variables instead \nof the formatted values."},"StatementOptionType":"S"},{"StatementOptionName":"SAVE=","StatementOptionHelp":{"#cdata":"Syntax: SAVE=table-name\n\nSaves the result table so that you can use it in other IMSTAT procedure statements like STORE, REPLAY, \nand FREE. The value for table-name must be unique within the scope of the procedure execution. The name \nof a table that has been freed with the FREE statement can be used again in subsequent SAVE= options."},"StatementOptionType":"V"},{"StatementOptionName":"SETSIZE","StatementOptionHelp":{"#cdata":"Requests that the server estimate the size of the result set. The procedure does not create a result \ntable if the SETSIZE option is specified. Instead, the procedure reports the number of rows that are \nreturned by the request and the expected memory consumption for the result set (in KB). If you specify \nthe SETSIZE option, the SAS log includes the number of observations and the estimated result set size."},"StatementOptionType":"S"},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary \nvariables or a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPTABLE","StatementOptionHelp":{"#cdata":"Generates an in-memory temporary table from the result set. The IMSTAT procedure displays the \nname of the table and stores it in the &_TEMPLAST_ macro variable, provided that the statement \nexecuted successfully. \n\nWhen the IMSTAT procedure exits, all temporary tables created during the IMSTAT session are \nremoved. Temporary tables are not displayed on a TABLEINFO request, unless the temporary table \nis the active table for the request. \n\nInteraction: The TEMPTABLE option requires a group-by analysis or a partitioned analysis with this statement."},"StatementOptionType":"S"},{"StatementOptionName":"TWELVEBIN","StatementOptionHelp":{"#cdata":"Specifies to augment the summary results with a 12-bin histogram. This option has no effect when \nthe summaries are computed in GROUPBY or partitioned mode."},"StatementOptionType":"S"}]}},{"StatementName":"TEXTPARSE","StatementHelp":{"#cdata":"Syntax: TEXTPARSE TXT=text-variable ID=document-ID <options>; \n      \nThe TEXTPARSE statement performs text analytics on the active in-memory table. You can separate \nthe documents in the table into terms, derive topics based on weighted term frequencies, and \nproject the active table onto the latent space defined by the topic-discovered topics."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"TXT=","StatementOptionHelp":{"#cdata":"Syntax: TXT=text-variable\n\nSpecifies the name of the variable that contains the text to analyze."},"StatementOptionType":"RV"},{"StatementOptionName":"ID=|DOCID=","StatementOptionHelp":{"#cdata":"Syntax: ID=document-ID\n\nSpecifies the name of the variable that identifies the documents in the table uniquely. The values \nare typically a row number or other value that identifies the rows. The document ID is important to \nperform joins of the result tables."},"StatementOptionType":"RV"},{"StatementOptionName":"CELLWGT=","StatementOptionHelp":{"#cdata":"Syntax: CELLWGT= NONE | LOG\n\nSpecifies how elements in the term \u00d7 document matrix are weighted. Elements in the matrix are assigned \nweight wi * g(fij), where wi is the term weight for the ith term, fij is the frequency of appearance of \nthis term in document j. \n\nIf CELLWGT=LOG, then g(fij) = log2(fij+1). The logarithmic function tempers the influence of very frequent terms. \n\nDefault: LOG"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"LOG"},"StatementOptionToolTips":{"@ToolTip1":"Elements in the term \u00d7 document matrix are not weighted.","@ToolTip2":"If CELLWGT=LOG, then g(fij) = log2(fij+1). The logarithmic function tempers the influence of very frequent terms."}},{"StatementOptionName":"ENTITIES=","StatementOptionHelp":{"#cdata":"Syntax: ENTITIES= NONE | STD\n\nDetermines whether the entity extractor should use the standard list of entities. When ENTITIES=STD, \nentity extraction is enabled and standard entities are used. Terms such as \"George W. Bush\" are then \nrecognized as an entity and given the corresponding entity role and attribute. For this example, the \nentity role is PERSON and the attribute is Entity. Although the entity is treated as the single term, \n\"george w bush,\" the individual tokens \"george,\" \"w,\" and \"bush\" are also included. \n\nDefault: NONE"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"STD"},"StatementOptionToolTips":{"@ToolTip1":"Entity extraction is not enabled and standard entities are not used.","@ToolTip2":"When ENTITIES=STD, entity extraction is enabled and standard entities are used."}},{"StatementOptionName":"EXACTWEIGHT|NOWTRND","StatementOptionHelp":{"#cdata":"\n\nSpecifies not to round the weights that are aggregated during topic derivation. By default, \nthe calculated weights are rounded to the nearest .001."},"StatementOptionType":"S"},{"StatementOptionName":"KEEP=","StatementOptionHelp":{"#cdata":"Syntax: KEEP=(variable-list) \n\nKEEP=variable-name\n\nSpecifies one or more variables to transfer from the input data to the temporary table with the \ndocument projection. You can use _ALL_ for all variables, _NUMERIC_ for all numeric variables, \nand other valid variable list names. By default, only the document ID (ID=) is transferred to \nthe projected document table so that it can be used to join with the active table."},"StatementOptionType":"V"},{"StatementOptionName":"NONOUNGROUPS|NONG","StatementOptionHelp":{"#cdata":"Specifies not to use the noun group extractor. By default, the server extracts noun groups and returns \nmaximal groups and subgroups (which do not include groups that contain determiners or prepositions). If \nstemming is turned on, then noun group elements are also stemmed."},"StatementOptionType":"S"},{"StatementOptionName":"NOSTEMMING|NOSTEM","StatementOptionHelp":{"#cdata":"Specifies not to stem words. By default, words are stemmed and terms such as \"advises\" and \"advising\" \nare mapped to the parent term \"advise.\""},"StatementOptionType":"S"},{"StatementOptionName":"NOTAGGING","StatementOptionHelp":{"#cdata":"Specifies not to tag terms. By default, terms are tagged and the server identifies a term's part of \nspeech based on context clues. The identified part of speech is provided in the Role variable of the \nTERMS table."},"StatementOptionType":"S"},{"StatementOptionName":"NUMLABELS=|NLABELS=","StatementOptionHelp":{"#cdata":"Syntax: NUMLABELS=n\n\nSpecifies the number of terms to use in labeling a topic. By default, the n = 5 terms with the \nlargest weight are used in constructing a label for the topic. \n\nDefault: 5"},"StatementOptionType":"V"},{"StatementOptionName":"REDUCEF=","StatementOptionHelp":{"#cdata":"Syntax: REDUCEF=n\n\nSpecifies the minimum document frequency of terms. By default, n = 4 and implies that a term is not \nkept for analysis unless it occurs in at least four documents. \n\nDefault: 4"},"StatementOptionType":"V"},{"StatementOptionName":"SAVE=","StatementOptionHelp":{"#cdata":"Syntax: SAVE=table-name\n\nSaves the result table so that you can use it in other IMSTAT procedure statements like STORE, REPLAY, \nand FREE. The value for table-name must be unique within the scope of the procedure execution. The name \nof a table that has been freed with the FREE statement can be used again in subsequent SAVE= options."},"StatementOptionType":"V"},{"StatementOptionName":"SELECT","StatementOptionHelp":{"#cdata":"Syntax: SELECT <=> (list-of-temporary-tables) \n\nSpecifies the results the server should store as temporary tables. By default, the server generates \nthe Terms table, which contains terms, their parent-child relationships, and weights. If you specify \nthe NUMTOPICS= option, the server also generates the Topics table. You can specify SELECT=(_ALL_) to \ngenerate all of the tables. \n\nThe possible values for the list specification are shown in the following table: \n-----------------------------------------------------------------------------------\nTable Name    Table Alias     Description\n----------------------------------------------------------------------------------- \n\nTERMS TERM  Contains summary information about the terms in the document collection. \nTERMDOC BAGOFWORDS |  BOW | PARENT | PARENTS Contains a compressed representation of the sparse term-by-document \n  frequency matrix in transactional style. The matrix is represented as a set of (row, column, value) triples. \nV SVDV  Contains the V matrix of the singular-value decomposition. \nU SUDV  Contains the rotated U matrix of the singular-value decomposition. \nPROJECTION  DOCPRO | PROJ Contains the projections of the columns of the term-by-document frequency matrix onto \n  the columns of U. Because each column of the term-by-document frequency matrix corresponds to a document, the \n  output forms a new representation of the input documents in a space with much lower dimensionality. \nTOPICS  Contains the topics and a label constructed from the most highly weighted terms. This is typically a small \n  table, as the number of topics is limited by k, the value of the singular-value decomposition or by the value \n  specified in the NUMTOPICS= option. \nTERMTOPICS  TERMBYTOPICS  A sparse representation of the terms by topic using the term ID and topic ID. This table \n  might be useful in joins involving terms or topics."},"StatementOptionType":"S|V"},{"StatementOptionName":"START=","StatementOptionHelp":{"#cdata":"Syntax: START=table-name\n\nSpecifies the name of the in-memory table that contains the terms that are to be kept for the analysis. \nThese terms are displayed in the Terms result table with a keep status of \"Y.\" The START= table must have \nvariable that is named Term and can also have a variable that is named Role. \n\nInteraction: If you specify both the START= option and the STOP= option, the STOP= specification takes precedence."},"StatementOptionType":"V"},{"StatementOptionName":"STOP=","StatementOptionHelp":{"#cdata":"Syntax: STOP=table-name\n\nSpecifies the name of the in-memory table that contains the terms to exclude from the analysis. \nThe STOP= table must contain a variable that is named Term and can also have a variable that is \nnamed Role. \n\nInteraction: If you specify both the START= option and the STOP= option, the STOP= specification \ntakes precedence."},"StatementOptionType":"V"},{"StatementOptionName":"SVD","StatementOptionHelp":{"#cdata":"Syntax: SVD(singular-value-decomposition-options) \n\nSpecifies how to perform the singular-value decomposition (SVD). The server carries out this \ndecomposition whenever you request a result table that depends on topics, or if you request \nto save the V or U matrix of the decomposition. You can specify the following SVD options \ninside the parentheses: \n\nK=k\n  specifies the number of dimensions to be extracted by SVD. This number is equal to the number \n  of topics for topic generation.\nMAXK=m\n  specifies the maximum value that the server should return as the recommended value of m. \nRESOLUTION=LOW | MED | HIGH\n  specifies the recommended number of dimensions (resolution) for the singular value decomposition.\nTOL=\u025b\n  specifies the maximum allowable tolerance for the singular value."},"StatementOptionType":"S","SubOptionsKeywords":"K=|MAXK=|RESOLUTION=|TOL="},{"StatementOptionName":"SYNONYMS=","StatementOptionHelp":{"#cdata":"Syntax: SYNONYMS=table-name\n\nSpecifies the name of an in-memory table that contains user-defined synonyms to use in the analysis. \nThe table specifies parent-child relationships that enable you to map child terms to a representative \nparent. The synonym relationship is indicated in the Terms result table and is also reflected in the \nterm-by-document result table known as the Termdoc or Parent table. \n\nThe specified table must have either the two variables Term and Parent, or the four variables Term, \nParent, Termrole, and Parentrole. When stemming is enabled (the default), the relationships provided \nby the SYNONYMS= table take precedence over relationships that are identified through term stemming."},"StatementOptionType":"V"},{"StatementOptionName":"TERMWGT=","StatementOptionHelp":{"#cdata":"Syntax: TERMWGT=ENTROPY | MI | NONE\n\nSpecifies how terms are weighted. TERMWGT=ENTROPY specifies that terms are weighted using the entropy \nformulation. If you specify TERMWGT=MI, then terms are weighted using the mutual information formulation. \nSpecifying TERMWGT=NONE suppresses term weighting. See the documentation for the HPTMINE procedure for the \ndetails about computing term weights. \n\nIf you specify TERMWGT=MI, then you must specify a target variables with the TARGET= option. \n\nDefault ENTROPY"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"ENTROPY","@Value2":"MI","@Value3":"NONE"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that terms are weighted using the entropy formulation.","@ToolTip2":"Specifies that terms are weighted using the mutual information formulation.","@ToolTip3":"Suppresses term weighting. "}},{"StatementOptionName":"TOPICS=|NUMTOPICS=","StatementOptionHelp":{"#cdata":"Syntax: TOPICS=n\n\nSpecifies the number of topics to generate. When you specify n, the server automatically produces \na table of topics with up to n entries. You can also request the Topics table with the SELECT= option. \nSpecifying TOPICS=n is equivalent to requesting topics based on a singular-value decomposition with n=k \nfactors. \n\nInteraction: You can use the NUMLABELS= option to control the number of terms to use in labeling the topic."},"StatementOptionType":"V"},{"StatementOptionName":"TARGET=","StatementOptionHelp":{"#cdata":"Syntax: TARGET=target-variable\n\nSpecifies a variable that contains information about the category that a document belongs to. If specified, \nthe target variable is used in computing term weights. For example, it is used with TERMWGHT=MI."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary \nvariables or a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"}]}},{"StatementName":"TOPK","StatementHelp":{"#cdata":"Syntax: TOPK <variable-list> </ options>; \n      \nThe TOPK statement calculates and selects the top-k and bottom-k distinct values of a variable \nbased on a user-specified ranking order. The distinct values can be reported as raw or formatted \nvalues. The ranking can be based on the raw value, the formatted value, the frequency count, or \nbased on a calculated score derived from the values of a weight variable. You can also specify \naggregate functions to roll up multiple weight values into a single score for a distinct value."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"AGGREGATE=|AGG=","StatementOptionHelp":{"#cdata":"Syntax: AGGREGATE=(aggregation-methods) \n\n\nspecifies the aggregation methods for which WEIGHT= variable values are rolled up into rank order score for distinct values. If no WEIGHT= variable is specified, then this option is ignored. \n\n\nThe available aggregation methods are as follows: \n\nMAX specifies to use the maximum value of the weight values  \nMEAN specifies to use the arithmetic mean of the weight values  \nMIN specifies to use the minimum value of the weight values  \nSUM specifies to use the sum of the weight values \n\nAlias AGG= \nDefault SUM"},"StatementOptionType":"V","SubOptionsKeywords":"MAX|MEAN|MIN|SUM"},{"StatementOptionName":"FORMATS=","StatementOptionHelp":{"#cdata":"Syntax: FORMATS=(\"format-specification\",...) \n\nSpecifies the formats for the variables. If you do not specify the FORMATS= option, or if you omit \nthe entry for a variable, the default format is applied for that variable. \n\nEnclose each format specification in quotation marks and separate each format specification with a comma. \n\nExample:\nproc imstat data=lasr1.table1;\n   topk x1 x2 / formats=(\"10.2\", 10.2\");\nquit;"},"StatementOptionType":"V"},{"StatementOptionName":"FREQ=","StatementOptionHelp":{"#cdata":"Syntax: FREQ=variable-name\n\nSpecifies the numeric frequency variable to use for calculating the rank order score for distinct values. \nThis option is valid when ORDER=FREQ or when AGGREGATE= is N, SUM, or MEAN only."},"StatementOptionType":"V"},{"StatementOptionName":"K1=|TOPK=","StatementOptionHelp":{"#cdata":"Syntax: K1=n\n\nSpecifies the maximum number of distinct values to include in the top-k list.\n\nDefault: 1 \nRange: 1 to 1000"},"StatementOptionType":"V"},{"StatementOptionName":"K2=|BOTTOMK=","StatementOptionHelp":{"#cdata":"Syntax: K2=n\n\n\nSpecifies the maximum number of distinct values to include in the bottom-k list. \n\nDefault: 1 \nRange: 1 to 1000"},"StatementOptionType":"V"},{"StatementOptionName":"DESCENDING|DESC","StatementOptionHelp":{"#cdata":"pecifies that the levels of the GROUPBY variables are to be arranged in descending order."},"StatementOptionType":"S"},{"StatementOptionName":"ORDER=","StatementOptionHelp":{"#cdata":"Syntax: ORDER= FREQ | VALUE | WEIGHT\n\nSpecifies the rank ordering to apply to the distinct values when no WEIGHT= variable is specified. \nThe following rank orders are valid in the TOPK request. \n\nThe available ordering methods are as follows: \n\nFREQ specifies to order by frequency count \nVALUE specifies to order by raw or formatted values of the variable  \nWEIGHT specifies to order by the aggregate values of the WEIGHT= variable  \n\nDefault FREQ \n"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"FREQ","@Value2":"VALUE","@Value3":"WEIGHT"},"StatementOptionToolTips":{"@ToolTip1":"Specifies to order by frequency count","@ToolTip2":"Specifies to order by raw or formatted values of the variable","@ToolTip3":"Specifies to order by the aggregate values of the WEIGHT= variable "}},{"StatementOptionName":"WEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT=variable-name\n\nSpecifies the numeric weight variable to use for calculating the rank order score. If you specify \nORDER= and WEIGHT=, then the WEIGHT= variable takes priority over ORDER."},"StatementOptionType":"V"},{"StatementOptionName":"SAVE=","StatementOptionHelp":{"#cdata":"Syntax: SAVE=table-name\n\nSaves the result table so that you can use it in other IMSTAT procedure statements like STORE, REPLAY, \nand FREE. The value for table-name must be unique within the scope of the procedure execution. The name \nof a table that has been freed with the FREE statement can be used again in subsequent SAVE= options."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary \nvariables or a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"}]}},{"StatementName":"TRANSFORM","StatementHelp":{"#cdata":"Syntax: TRANSFORM (request1) <(request2) ...> </ options>; \n      \nrequest\n  specifies the transform phases to perform on the input variables. If a request is not specified \n  properly, it is ignored but does not stop other requests from processing. If you do not specify \n  a request at all, the TRANSFORM statement bins the numeric variables from the active table with \n  the BUCKET(5) method.  \n  \nThe TRANSFORM statement can perform multiple transformations on a set of input variables. \nEach transformation can perform imputation, outlier detection and treatment, functional \ntransformation, binning, and output."},"StatementOptions":{"#comment":[{},{}],"StatementOption":[{"StatementOptionName":"NAME=","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"V"},{"StatementOptionName":"INPUT=|TRANSVAR=","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"V"},{"StatementOptionName":"IMPUTE=","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"V"},{"StatementOptionName":"OUTLIER","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"S|V"},{"StatementOptionName":"FUNC=","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"V","SubOptionsKeywords":"ABS|ARCSIN|BOXCOX|CENTER|LOC=|COSH|EXP|INVERSE|LOG|POWER|RANGE|MIN=|MAX=|SQRT|STANDARDIZE|SCALE=|TANH"},{"StatementOptionName":"BIN=","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"V"},{"StatementOptionName":"BUCKET","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"S"},{"StatementOptionName":"QUANTILE","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"S"},{"StatementOptionName":"CHIMERGE","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"S"},{"StatementOptionName":"DTREE","StatementOptionHelp":{"#cdata":" "},"StatementOptionType":"S"},{"StatementOptionName":"GAIN","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"S"},{"StatementOptionName":"MAX=","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"V"},{"StatementOptionName":"MIN=","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"V"},{"StatementOptionName":"MDLP","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"S"},{"StatementOptionName":"EVENT=","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"V"},{"StatementOptionName":"TARGET=|EVALVAR=","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"V"},{"StatementOptionName":"CODE","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"S"},{"StatementOptionName":"COMMENT","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"S"},{"StatementOptionName":"FILENAME=|FILE=","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"V"},{"StatementOptionName":"FORMATWIDTH=|FMTW=","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"V"},{"StatementOptionName":"LINESIZE=|LS=","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"V"},{"StatementOptionName":"DETAILS","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"S"},{"StatementOptionName":"SCORE|TEMPTABLE","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"S"},{"StatementOptionName":"ALLIDVARS","StatementOptionHelp":{"#cdata":"Requests that all variables in the input table are treated as ID variables when a scoring table \nis produced. In other words, if this option is specified, all variables from the input table, \nincluding computed columns, are transferred to the scoring table. This option has no effect \nunless you specify the SCORE option."},"StatementOptionType":"S"},{"StatementOptionName":"ALPHA=","StatementOptionHelp":{"#cdata":"Syntax: ALPHA=number\n\nSpecifies a number between 0 and 1 from which to determine the confidence level when the BIN= option \nuses the CHIMERGE= method. The default is \u03b1 = 0.05, which leads to 100 x (1- \u03b1)% = 95% confidence limits \nfor the parameter estimates. \n\nDefault: 0.05"},"StatementOptionType":"V"},{"StatementOptionName":"BININIT=","StatementOptionHelp":{"#cdata":"Syntax: BININIT=(binning-initialization) \n\nSpecifies how to initialize the bins for supervised binning methods (MDLP, CHIMERGE, or DTREE). \nThe n value for the BUCKET and QUANTILE options is the starting number of bins. The default value \nis 100. \n\nThe three options are as follows: \n\nBUCKET<(n)>\n  specifies to use equal width binning. \nEXACT\nDISTINCT\n  specifies to use the distinct levels of the input variables. This binning initialization method \n  is not compatible with outlier and functional phases. If you specify this initialization method, \n  then transformation requests that contain an outlier phase or functional phase are ignored. \nQUANTILE<(n)>\n  specifies to use equal frequency binning."},"StatementOptionType":"V","SubOptionsKeywords":"BUCKET|EXACT|DISTINCT|QUANTILE"},{"StatementOptionName":"BINMISSING","StatementOptionHelp":{"#cdata":"Specifies to place missing values in a separate bin during the binning phase."},"StatementOptionType":"S"},{"StatementOptionName":"EMPTYBINS","StatementOptionHelp":{"#cdata":"Avoids the default merging of bins with no observations (empty bins) with their left neighbors. \nThis option is applicable to the MDLP binning method. Empty bins can occur from initializing the \nnumber of bins with the BININIT= option set to BUCKET or QUANTILE."},"StatementOptionType":"S"},{"StatementOptionName":"EVALSTATS=","StatementOptionHelp":{"#cdata":"Syntax: EVALSTATS=(list-of-binning-evaluation-statistics) \n\nSpecifies to compute binning evaluation statistics. These statistics are computed from two-way \ncontingency tables between the scored variables and a target variable. The available statistics \nare as follows: \n\n  CHISQ chi-square statistic \n  FTEST F-test statistic \n  G2 G2 log-likelihood-ratio statistic  \n  GINI Gini index statistic \n  IV information value statistic \n  WOE weight of evidence statistic \n\nThe CHISQ and G2 statistics are valid for all target variables. The WOE, IV, and GINI statistics \nare valid for binary target variables, The FTEST statistic is valid for continuous target variables \nonly. If statistics are not specified, the default statistics are CHISQ and G2. Transformation requests \nthat are incompatible with the specified evaluation statistics are ignored. "},"StatementOptionType":"V"},{"StatementOptionName":"FREQ=","StatementOptionHelp":{"#cdata":"Syntax: FREQ=variable-name\n\nSpecifies a numeric variable with a value that represents the frequency of the observation. For example, \nif the FREQ= variable has the value 5 for a given observation, then that observation represents five \nobservations. The FREQ= option is not available for transform requests that require percentiles in any \nof the transformation phase. Consequently, if the FREQ= option is specified and percentiles are required, \nthen all such transformation requests are ignored."},"StatementOptionType":"V"},{"StatementOptionName":"IDVARS=|ID=","StatementOptionHelp":{"#cdata":"Syntax: IDVARS=(variable-list) \n\nIDVARS=variable-name\n\nspecifies the variables from the active table to transfer to the temporary table that is created \nby scoring the input table. This option has no effect unless the SCORE option is also specified. \n(See the SCORE option for details about which variables are added to the temporary table by default.) \nThe IDVARS= option should be used to transfer additional columns from the input table to the scoring table. \n\nTip: Instead of this option, you can specify the ALLIDVARS option to transfer all variables from the input table to the scoring table."},"StatementOptionType":"V"},{"StatementOptionName":"PERCEPSILON=","StatementOptionHelp":{"#cdata":"Syntax: PERCEPSILON=number\n\nSpecifies the convergence tolerance for the iterative algorithm that is used to compute percentiles. \nPercentiles are calculated in the outlier transformation phase and can also be calculated in the binning \ntransformation phase if quantiles are requested. \n\nDefault: 1e-5"},"StatementOptionType":"V"},{"StatementOptionName":"PERCMAXITER=","StatementOptionHelp":{"#cdata":"Syntax: PERCMAXITER=i\n\nSpecifies the maximum number of iterations in the percentile algorithm. The percentile algorithm \nis iterative and avoids the cost of copying and sorting the data with multiple passes through the \ndata. You can limit the number of iterations with the PERCMAXITER= option. You can also control the \ncomputational demand with the PERCEPSILON= option, which affects the tolerance criterion by which \nthe convergence of the iterative algorithm is judged. If the percentile computations for a particular \nvariable do not converge, the transformation that depends on those percentiles is not performed. \n\nDefault: 10"},"StatementOptionType":"V"},{"StatementOptionName":"TEMPEXPRESS=|TE=","StatementOptionHelp":{"#cdata":"Syntax: TEMPEXPRESS=\"SAS-expressions\" \n\nTEMPEXPRESS=file-reference\n\nSpecifies either a quoted string that contains the SAS expression that defines the temporary \nvariables or a file reference to an external file with the SAS statements."},"StatementOptionType":"V"},{"StatementOptionName":"TEMPNAMES=|TN=","StatementOptionHelp":{"#cdata":"Syntax: TEMPNAMES=variable-name\n\nTEMPNAMES=(variable-list) \n\nSpecifies the list of temporary variables for the request. Each temporary variable must be defined \nthrough SAS statements that you supply with the TEMPEXPRESS= option."},"StatementOptionType":"V"}]}},{"StatementName":"QUIT","StatementHelp":{"#cdata":"Syntax: QUIT; \n      \nThe QUIT statement is used to end the procedure execution. When the procedure reaches the QUIT statement, \nall resources allocated by the procedure are released. You can no longer execute procedure statements \nwithout invoking the procedure again. However, the connection to the server is not lost, because that \nconnection was made through the SAS LASR Analytic Server engine. As a result, any subsequent invocation \nof the procedure that uses the same libref executes almost instantaneously because the engine is already \nconnected to the server."},"StatementOptions":null}]}}}