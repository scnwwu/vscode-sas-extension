{"Procedure":{"Name":"MDC","#comment":{},"ProductGroup":"SAS/ETS","ProcedureHelp":{"#cdata":"Syntax: PROC MDC options ; \n    MDCDATA options ; \n    BOUNDS bound1 < , bound2 ...> ; \n    BY variables ; \n    CLASS options ;\n    ID variable ; \n    MODEL dependent variables = regressors / options ; \n    NEST LEVEL(value) = ((values)@(value),..., (values)@(value)) ; \n    NLOPTIONS options ; \n    OUTPUT options ; \n    RESTRICT restriction1 < , restriction2 ...> ; \n    TEST options ; \n    UTILITY U() = variables, ..., U() = variables ; \n\nThe MDC (multinomial discrete choice) procedure analyzes models in which the choice set consists \nof multiple alternatives. This procedure supports conditional logit, mixed logit, heteroscedastic \nextreme value, nested logit, and multinomial probit models. The MDC procedure uses the maximum \nlikelihood (ML) or simulated maximum likelihood method for model estimation.  The term multinomial \nlogit is often used in the econometrics literature to refer to the conditional logit model of \nMcFadden (1974). Here, the term conditional logit refers to McFadden\u2019s conditional logit model, \nand the term multinomial logit refers to a model that differs slightly. Schmidt and Strauss (1975) \nand Theil (1969) are early applications of the multinomial logit model in the econometrics literature. \nThe main difference between McFadden\u2019s conditional logit model and the multinomial logit model \nis that the multinomial logit model makes the choice probabilities depend on the characteristics \nof the individuals only, whereas the conditional logit model considers the effects of choice \nattributes on choice probabilities as well."},"ProcedureOptions":{"ProcedureOption":[{"ProcedureOptionName":"DATA=","ProcedureOptionHelp":{"#cdata":"[Syntax: DATA=SAS-data-set] \n      \nSpecifies the input SAS data set. If the DATA= option is not specified, PROC MDC uses \nthe most recently created SAS data set."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"OUTEST=","ProcedureOptionHelp":{"#cdata":"[Syntax: OUTEST=SAS-data-set] \n      \nNames the SAS data set that the parameter estimates are written to."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"COVOUT","ProcedureOptionHelp":{"#cdata":"Writes the covariance matrix for the parameter estimates to the OUTEST= data set. This option \nis valid only if the OUTEST= option is specified."},"ProcedureOptionType":"S"}]},"ProcedureStatements":{"ProcedureStatement":[{"StatementName":"ID","StatementHelp":{"#cdata":"Syntax: ID variable ; \n\nThe ID statement must be used with PROC MDC to specify the identification variable that \ncontrols multiple choice-specific cases. The MDC procedure requires only one ID statement \neven with multiple MODEL statements."},"StatementOptions":null},{"StatementName":"BOUNDS","StatementHelp":{"#cdata":"Syntax: BOUNDS bound1 <, bound2 ...> ; \n\nThe BOUNDS statement imposes simple boundary constraints on the parameter estimates. \nBOUNDS statement constraints refer to the parameters estimated by the MDC procedure. \nYou can specify any number of BOUNDS statements. \n\nEach bound is composed of parameters, constants, and inequality operators: \n\n  item operator item < operator item < operator item ...> > \n\nEach item is a constant, parameter, or list of parameters. Parameters associated with \na regressor variable are referred to by the name of the corresponding regressor variable. \nEach operator is \u2019<\u2019, \u2019>\u2019, \u2019\u2264\u2019, or \u2019\u2265\u2019."},"StatementOptions":null},{"StatementName":"BY","StatementHelp":{"#cdata":"Syntax: BY variables ; \n\nA BY statement can be used with PROC MDC to obtain separate analyses on observations \nin groups defined by the BY variables."},"StatementOptions":null},{"StatementName":"CLASS","StatementHelp":{"#cdata":"Syntax: CLASS variables ; \n      \nThe CLASS statement names the classification variables to be used in the analysis. \nClassification variables can be either character or numeric."},"StatementOptions":null},{"StatementName":"MODEL","StatementHelp":{"#cdata":"Syntax: MODEL dependent = regressors < / options > ; \n\nThe MODEL statement specifies the dependent variable and independent regressor variables for \nthe regression model. When the nested logit model is estimated, regressors in the UTILITY \nstatement are used for estimation."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"CHOICE=","StatementOptionHelp":{"#cdata":"[Syntax: CHOICE=(variables) | CHOICE=(variable numbers)] \n          \nSpecifies the variables that contain possible choices for each individual. Choice variables \nmust have integer values. Multiple choice variables are allowed only for nested logit models. \nIf all possible alternatives are written with the variable name, the MDC procedure checks all \nvalues of the choice variable. The CHOICE=(X 1 2 3) specification implies that the value of X \nshould be 1, 2, or 3. On the other hand, the CHOICE=(X) specification considers all distinctive \nnonmissing values of X as elements of the choice set."},"StatementOptionType":"V"},{"StatementOptionName":"CONVERGE=","StatementOptionHelp":{"#cdata":"[Syntax: CONVERGE=number] \n          \nSpecifies the convergence criterion. The CONVERGE= option is the same as the ABSGCONV= option \nin the NLOPTIONS statement. The ABSGCONV= option in the NLOPTIONS statement overrides the CONVERGE= \noption. The default value is 1E\u20135."},"StatementOptionType":"V"},{"StatementOptionName":"HALTONSTART=","StatementOptionHelp":{"#cdata":"[Syntax: HALTONSTART=number] \n          \nSpecifies the starting point of the Halton sequence. The specified number must be a positive \ninteger. The default is HALTONSTART=11."},"StatementOptionType":"V"},{"StatementOptionName":"HEV=","StatementOptionHelp":{"#cdata":"[Syntax: HEV=( option-list )] \n          \nSpecifies options that are used to estimate the HEV model. The HEV model with a unit scale \nfor the alternative 1 is estimated using the following SAS statement: \n\n   model y = x1 x2 x3 / hev=(unitscale=1);\n\nThe following options can be used in the HEV=() option. These options are listed within \nparentheses and separated by commas:\n\n  INTORDER=number\n  specifies the number of summation terms for Gaussian quadrature integration. The default \n  is INTORDER=40. The maximum order is limited to 45.\n\n  UNITSCALE=number-list\n  specifies restrictions on scale parameters of stochastic utility components. \n\n  INTEGRATE=LAGUERRE|HARDY\n  specifies the integration method. The INTEGRATE=HARDY option specifies an adaptive integration \n  method, while the INTEGRATE=LAGUERRE option specifies the Gauss-Laguerre approximation method. \n  The default is INTEGRATE=LAGUERRE."},"StatementOptionType":"V","SubOptionsKeywords":"INTORDER=|UNITSCALE=|INTEGRATE="},{"StatementOptionName":"MIXED=","StatementOptionHelp":{"#cdata":"[Syntax: MIXED=( option-list )] \n          \nSpecifies options that are used for mixed logit estimation. The following options can be used \nin the MIXED=() option. The options are listed within parentheses and separated by commas: \n\n  LOGNORMALPARM=variables\n  specifies the variables whose random coefficients are lognormally distributed. \n\n  NORMALEC=variables\n  specifies the error component variables whose coefficients have a normal distribution \n\n  NORMALPARM=variables\n  specifies the variables whose random coefficients are normally distributed.\n\n  UNIFORMEC=variables\n  specifies the error component variables whose coefficients have a uniform distribution \n\n  UNIFORMPARM=variables\n  specifies the variables whose random coefficients are uniformly distributed."},"StatementOptionType":"V","SubOptionsKeywords":"LOGNORMALPARM=|NORMALEC=|NORMALPARM=|UNIFORMEC=|UNIFORMPARM="},{"StatementOptionName":"NCHOICE=","StatementOptionHelp":{"#cdata":"[Syntax: NCHOICE=number] \n          \nSpecifies the number of choices for multinomial choice models when all individuals have \nthe same choice set."},"StatementOptionType":"V"},{"StatementOptionName":"NSIMUL=","StatementOptionHelp":{"#cdata":"[Syntax: NSIMUL=number] \n          \nSpecifies the number of simulations when the mixed logit or multinomial probit model is \nestimated. The default is NSIMUL=100."},"StatementOptionType":"V"},{"StatementOptionName":"RANDNUM=","StatementOptionHelp":{"#cdata":"Specifies the type of the random number generator used for simulation. RANDNUM=HALTON is the default."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"PSEUDO","@Value2":"HALTON"},"StatementOptionToolTips":{"@ToolTip1":"Specifies pseudo-random number generation.","@ToolTip2":"Specifies Halton sequence generation."}},{"StatementOptionName":"RANDINIT=","StatementOptionHelp":{"#cdata":"[Syntax: RANDINIT<=r>] \n          \nSpecifies that initial parameter values be perturbed by uniform pseudo-random numbers for \nnumerical optimization of the objective function. The default is U(-1,1).When the RANDINIT=r \noption is specified, U(-r,r) pseudo-random numbers are generated. The value r should be positive."},"StatementOptionType":"S|V"},{"StatementOptionName":"RANK","StatementOptionHelp":{"#cdata":"Specifies that the dependent variable contain ranks. The numbers must be positive integers \nstarting from 1. When the dependent variable has value 1, the corresponding alternative is \nchosen. This option is provided only as a convenience to the user: the extra information \ncontained in the ranks is not currently used for estimation purposes."},"StatementOptionType":"S"},{"StatementOptionName":"RESTART=","StatementOptionHelp":{"#cdata":"[Syntax: RESTART=( option-list )] \n          \nSpecifies options that are used for reiteration of the optimization problem.\n          \nThe following options can be used in the RESTART=() option. The options are listed within parentheses.\n\n  ADDMAXIT=number\n  specifies the maximum number of iterations for the second stage of the estimation. The default is ADDMAXIT=100. \n\n  ADDRANDOM | ADDRANDOM=r\n  specifies random added values to the estimates from the initial stage. With the ADDRANDOM \n  option, U(-1,1) random numbers are created and added to the estimates obtained in the initial \n  stage. When the ADDRANDOM=r option is specified, U(-r,r) random numbers are generated. The \n  restart initial value is determined based on the given number of random searches (1000 for \n  conditional or nested logit, and 500 for other models).\n\n  ADDVALUE=( value-list )\n  specifies values added to the estimates from the initial stage. A missing value in the list \n  is considered as a zero value for the corresponding estimate. When the ADDVALUE= option is \n  not specified, default values equal to (|estimate| * 1e-3) are added."},"StatementOptionType":"V","SubOptionsKeywords":"ADDMAXIT=|ADDRANDOM|ADDRANDOM=|ADDVALUE="},{"StatementOptionName":"SAMESCALE","StatementOptionHelp":{"#cdata":"Specifies that the parameters of the inclusive values be the same within a group at each \nlevel when the nested logit is estimated."},"StatementOptionType":"S"},{"StatementOptionName":"SEED=","StatementOptionHelp":{"#cdata":"[Syntax: SEED=number] \n          \nSpecifies an initial seed for pseudo-random number generation. The SEED= value must are less \nthan 2\u00b3\u00b9-1. If the SEED= value is negative or zero, the time of day from the computer\u2019s \nclock is used to obtain the initial seed. The default is SEED=0."},"StatementOptionType":"V"},{"StatementOptionName":"SPSCALE","StatementOptionHelp":{"#cdata":"Specifies that the parameters of the inclusive values be the same for any choice with only one \nnested choice within a group, for each level in a nested logit model. This option is useful in \nanalyzing stated preference data."},"StatementOptionType":"S"},{"StatementOptionName":"TYPE=","StatementOptionHelp":{"#cdata":"Specifies the type of model to be analyzed."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"CONDITIONLOGIT|CLOGIT|CL","@Value2":"HEV","@Value3":"MIXEDLOGIT|MXL","@Value4":"MULTINOMPROBIT|MPROBIT|MP","@Value5":"NESTEDLOGIT|NLOGIT|NL"},"StatementOptionToolTips":{"@ToolTip1":"Specifies a conditional logit model.","@ToolTip2":"Specifies a heteroscedastic extreme-value model.","@ToolTip3":"Specifies a mixed logit model.","@ToolTip4":"Specifies a multinomial probit model.","@ToolTip5":"Specifies a nested logit model."}},{"StatementOptionName":"UNITVARIANCE=","StatementOptionHelp":{"#cdata":"[Syntax: UNITVARIANCE=( number-list )] \n          \nSpecifies normalization restrictions on error variances of multinomial probit for the \nchoices whose numbers are given in the list."},"StatementOptionType":"V"},{"StatementOptionName":"COVEST=","StatementOptionHelp":{"#cdata":"Specifies the type of covariance matrix."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"OP","@Value2":"HESSIAN","@Value3":"QML"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the covariance from the outer product matrix.","@ToolTip2":"Specifies the covariance from the Hessian matrix.","@ToolTip3":"Specifies the covariance from the outer product and Hessian matrices."}},{"StatementOptionName":"ALL","StatementOptionHelp":{"#cdata":"Requests all printing options."},"StatementOptionType":"S"},{"StatementOptionName":"COVB","StatementOptionHelp":{"#cdata":"Displays the estimated covariances of the parameter estimates."},"StatementOptionType":"S"},{"StatementOptionName":"CORRB","StatementOptionHelp":{"#cdata":"Displays the estimated correlation matrix of the parameter estimates."},"StatementOptionType":"S"},{"StatementOptionName":"ITPPRINT","StatementOptionHelp":{"#cdata":"Displays the initial parameter estimates, convergence criteria, and constraints of the optimization."},"StatementOptionType":"S"},{"StatementOptionName":"NOPRINT","StatementOptionHelp":{"#cdata":"Suppresses all displayed output."},"StatementOptionType":"S"},{"StatementOptionName":"INITIAL=|START=","StatementOptionHelp":{"#cdata":"[Syntax: INITIAL=( initial-values )] \n          \nSpecifies initial values for some or all of the parameter estimates. The values specified \nare assigned to model parameters in the same order in which the parameter estimates are \ndisplayed in the MDC procedure output. \n\nWhen you use the INITIAL= option, the initial values in the INITIAL= option must satisfy \nthe restrictions specified for the parameter estimates. If they do not, the initial values \nyou specify are adjusted to satisfy the restrictions."},"StatementOptionType":"V"},{"StatementOptionName":"MAXITER=","StatementOptionHelp":{"#cdata":"[Syntax: MAXITER=number] \n          \nSets the maximum number of iterations allowed. The MAXITER= option overrides the \nMAXITER= option in the NLOPTIONS statement. The default is MAXITER=100."},"StatementOptionType":"V"},{"StatementOptionName":"OPTMETHOD=","StatementOptionHelp":{"#cdata":"Specifies the optimization technique when the estimation method uses nonlinear optimization."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"QN","@Value2":"NR","@Value3":"TR"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the quasi-Newton method.","@ToolTip2":"Specifies the Newton-Raphson method.","@ToolTip3":"Specifies the trust region method."}}]}},{"StatementName":"NEST","StatementHelp":{"#cdata":"Syntax: NEST LEVEL( level-number )= ( choices@choice, ...) ; \n\nThe NEST statement is used when one choice variable contains all possible alternatives and the \nTYPE=NLOGIT option is specified. The decision tree is constructed based on the NEST statement. \nWhen the choice set is specified using multiple CHOICE= variables in the MODEL statement,  \nthe NEST statement is ignored."},"StatementOptions":{"StatementOption":{"StatementOptionName":"LEVEL=","StatementOptionHelp":{"#cdata":"[Syntax: LEVEL(level-number )= ( choices@choice, ...)] \n          \nUsed to specify the tree structure to be built. For example:\n          \nnest level(1) = (1 2 3 @ 1, 4 5 6 @ 2, 7 8 @ 3), \n    level(2) = (3 @ 2, 1 2 @ 1),\n    level(3) = (1 2 @ 1);"},"StatementOptionType":"S|V"}}},{"StatementName":"NLOPTIONS","StatementHelp":{"#cdata":"Syntax: NLOPTIONS options ; \n\nPROC MDC uses the nonlinear optimization (NLO) subsystem to perform nonlinear optimization tasks. \nThe NLOPTIONS statement specifies nonlinear optimization options. The NLOPTIONS statement must \nfollow the MODEL statement."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ABSCONV=|ABSTOL=","StatementOptionHelp":{"#cdata":"[Syntax: ABSCONV= | ABSTOL=r] \n          \nSpecifies an absolute function convergence criterion. The default value of r is the negative \nsquare root of the largest double-precision value, which serves only as a protection against \noverflows. "},"StatementOptionType":"V"},{"StatementOptionName":"ABSFCONV=|ABSFTOL=","StatementOptionHelp":{"#cdata":"[Syntax: ABSFCONV=r[n] | ABSFTOL=r[n]] \n          \nSpecifies an absolute function convergence criterion. The default value is r=0. The optional \ninteger value n specifies the number of successive iterations for which the criterion must be \nsatisfied before the process can be terminated."},"StatementOptionType":"V"},{"StatementOptionName":"ABSGCONV=|ABSGTOL=","StatementOptionHelp":{"#cdata":"[Syntax: ABSGCONV=r[n] | ABSGTOL=r[n]] \n          \nSpecifies an absolute gradient convergence criterion. The default value is r=1E-5. \nThe optional integer value n specifies the number of successive iterations for which \nthe criterion must be satisfied before the process can be terminated."},"StatementOptionType":"V"},{"StatementOptionName":"ABSXCONV=|ABSXTOL=","StatementOptionHelp":{"#cdata":"[Syntax: ABSXCONV= | ABSXTOL=r[n]] \n          \nSpecifies the absolute parameter convergence criterion. The default is r=1E-8 for the \nNMSIMP technique and r=0 otherwise. The optional integer value n specifies the number of \nsuccessive iterations for which the criterion must be satisfied before the process can \nterminate."},"StatementOptionType":"V"},{"StatementOptionName":"DAMPSTEP=","StatementOptionHelp":{"#cdata":"[Syntax: DAMPSTEP<=r>] \n          \nSpecifies that the initial step length value a\u2070 for each line search (used by the QUANEW, \nHYQUAN, CONGRA, or NEWRAP technique) cannot be larger than r times the step length value used \nin the former iteration. If the DAMPSTEP option is specified but r is not specified, the default \nis r=2. The DAMPSTEP=r option can prevent the line-search algorithm from repeatedly stepping into\nregions where some objective functions are difficult to compute or where they could lead to floating \npoint overflows during the computation of objective functions and their derivatives. The DAMPSTEP=r \noption can save time-costly function calls during the line searches of objective functions that \nresult in very small steps."},"StatementOptionType":"S|V"},{"StatementOptionName":"FCONV=|FTOL=","StatementOptionHelp":{"#cdata":"[Syntax: FCONV= | FTOL=r[n]] \n          \nSpecifies a relative function convergence criterion."},"StatementOptionType":"V"},{"StatementOptionName":"FCONV2=|FTOL2=","StatementOptionHelp":{"#cdata":"[Syntax: FCONV2= | FTOL2=r[n]] \n          \nSpecifies another function convergence criterion."},"StatementOptionType":"V"},{"StatementOptionName":"FSIZE=","StatementOptionHelp":{"#cdata":"[Syntax:FSIZE=r] \n          \nSpecifies the FSIZE parameter of the relative function and relative gradient termination \ncriteria. The default value is r=0."},"StatementOptionType":"V"},{"StatementOptionName":"GCONV=|GTOL=","StatementOptionHelp":{"#cdata":"[Syntax: GCONV=r | GTOL=r] \n          \nSpecifies a relative gradient convergence criterion. The default value is r=1E-8. \nThe optional integer value n specifies the number of successive iterations for which \nthe criterion must be satisfied before the process can terminate."},"StatementOptionType":"V"},{"StatementOptionName":"HESCAL=|HS=","StatementOptionHelp":{"#cdata":"Specifies the scaling version of the Hessian matrix used in NRRIDG, TRUREG, NEWRAP, or \nDBLDOG optimization."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"0","@Value2":"1","@Value3":"2","@Value4":"3"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that no scaling is done.","@ToolTip2":"Specifies the Mor\u00e9 (1978) scaling update","@ToolTip3":"Specifies the Dennis, Gay, and Welsch (1981) scaling update","@ToolTip4":"Specifies that di is reset in each iteration"}},{"StatementOptionName":"INHESSIAN=|INHESS=","StatementOptionHelp":{"#cdata":"[Syntax: INHESSIAN[=r]] \n          \nSpecifies how the initial estimate of the approximate Hessian is defined for the \nquasi-Newton techniques QUANEW and DBLDOG."},"StatementOptionType":"S|V"},{"StatementOptionName":"INSTEP=","StatementOptionHelp":{"#cdata":"[Syntax: INSTEP=r] \n          \nReduces the length of the first trial step during the line search of the first iterations."},"StatementOptionType":"V"},{"StatementOptionName":"LINESEARCH=|LIS=","StatementOptionHelp":{"#cdata":"[Syntax: LINESEARCH= | LIS=i] \n          \n Specifies the line-search method for the CONGRA, QUANEW, and NEWRAP optimization techniques."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"1","@Value2":"2","@Value3":"3","@Value4":"4","@Value5":"5","@Value6":"6","@Value7":"7","@Value8":"8"},"StatementOptionToolTips":{"@ToolTip1":"Specifies a line-search method that needs the same number of function and gradient calls  for cubic interpolation and cubic extrapolation; this method is similar to one used by  the Harwell subroutine library.","@ToolTip2":"Specifies a line-search method that needs more function calls than gradient calls for quadratic  and cubic interpolation and cubic extrapolation; this method is implemented as shown in Fletcher  (1987) and can be modified to an exact line search by using the LSPRECISION= option.","@ToolTip3":"Specifies a line-search method that needs the same number of function and gradient calls for  cubic interpolation and cubic extrapolation; this method is implemented as shown in Fletcher  (1987) and can be modified to an exact line search by using the LSPRECISION= option.","@ToolTip4":"Specifies a line-search method that needs the same number of function and gradient calls for  stepwise extrapolation and cubic interpolation","@ToolTip5":"Specifies a line-search method that is a modified version of LIS=4.","@ToolTip6":"Specifies golden section line search (Polak 1971), which uses only function values for linear  approximation.","@ToolTip7":"Specifies bisection line search (Polak 1971), which uses only function values for linear  approximation.","@ToolTip8":"Specifies Armijo line-search technique (Polak 1971), which uses only function values for  linear approximation."}},{"StatementOptionName":"LSPRECISION=|LSP=","StatementOptionHelp":{"#cdata":"[Syntax: LSPRECISION= | LSP=r] \n          \nSpecifies the degree of accuracy that should be obtained by the line-search algorithms \nLIS=2 and LIS=3. The default LSPRECISION= values are: \n\n  o For TECH=QUANEW UPDATE=DBFGS, BFGS: r = 0.4\n  o For TECH=QUANEW UPDATE=DDFP, DFP: r = 0.06 \n  o For TECH=CONGRA UPDATE=all r = 0.1\n  o For TECH=NEWRAP NO UPDATE: r = 0.9"},"StatementOptionType":"V"},{"StatementOptionName":"MAXFUNC=|MAXFU=","StatementOptionHelp":{"#cdata":"[Syntax: MAXFUNC= | MAXFU=i] \n          \nRequires the number of function calls to be no larger than i. The default values are: \n\n  o For TECH= TRUREG, NRRIDG, NEWRAP: i=125 \n  o For TECH= DBLDOG, QUANEW: i=500 \n  o For TECH= CONGRA: i=1000\n  o For TECH= NMSIMP: i=3000 \n  \nNote that the optimization can terminate only after completing a full iteration. \nTherefore, the number of function calls that is actually performed can exceed the \nnumber that is specified by the MAXFUNC= option."},"StatementOptionType":"V"},{"StatementOptionName":"MAXITER=|MAXIT=","StatementOptionHelp":{"#cdata":"[Syntax: MAXITER= | MAXIT=i[n]] \n          \n Requires the number of iterations to be no larger than i. The default values are: \n \n  o For TECH= TRUREG, NRRIDG, NEWRAP: i=50 \n  o For TECH= QUANEW, DBLDOG: i=200 \n  o For TECH= CONGRA: i=400\n  o For TECH= NMSIMP: i=1000 \n  \nThese default values are also valid when i is specified as a missing value."},"StatementOptionType":"V"},{"StatementOptionName":"MAXSTEP=","StatementOptionHelp":{"#cdata":"[Syntax: MAXSTEP=r[n]] \n          \nSpecifies an upper bound for the step length of the line-search algorithms during \nthe first n iterations."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"[Syntax: MAXTIME=r] \n          \nRequires the CPU time to be no larger than r. The default value of the MAXTIME= option \nis the largest double floating-point number on your computer. Note that the time specified \nby the MAXTIME= option is checked only once at the end of each iteration. Therefore, the \nactual running time can be much longer than that specified by the MAXTIME= option. The \nactual running time includes the rest of the time needed to finish the iteration and the \ntime needed to generate the output of the results."},"StatementOptionType":"V"},{"StatementOptionName":"MINITER=|MINIT=","StatementOptionHelp":{"#cdata":"[Syntax: MINITER= | MINIT=i] \n          \nSpecifies the minimum number of iterations. The default value is 0. If you request more \niterations than are actually needed for convergence to a stationary point, the optimization \nalgorithms can behave strangely. For example, the effect of rounding errors can prevent the \nalgorithm from continuing for the required number of iterations."},"StatementOptionType":"V"},{"StatementOptionName":"NOPRINT","StatementOptionHelp":{"#cdata":"Suppresses the output."},"StatementOptionType":"S"},{"StatementOptionName":"PALL","StatementOptionHelp":{"#cdata":"[Displays all optional output for optimization."},"StatementOptionType":"S"},{"StatementOptionName":"PHISTORY","StatementOptionHelp":{"#cdata":"Displays the optimization history."},"StatementOptionType":"S"},{"StatementOptionName":"PHISTPARMS","StatementOptionHelp":{"#cdata":"Display parameter estimates in each iteration."},"StatementOptionType":"S"},{"StatementOptionName":"PINIT","StatementOptionHelp":{"#cdata":"Displays the initial values and derivatives (if available)."},"StatementOptionType":"S"},{"StatementOptionName":"PSHORT","StatementOptionHelp":{"#cdata":"Restricts the amount of default output."},"StatementOptionType":"S"},{"StatementOptionName":"PSUMMARY","StatementOptionHelp":{"#cdata":"Restricts the amount of default displayed output to a short form of iteration history and \nnotes, warnings, and errors."},"StatementOptionType":"S"},{"StatementOptionName":"RESTART=|REST=","StatementOptionHelp":{"#cdata":"[Syntax: RESTART= | REST=i > 0] \n          \nSpecifies that the QUANEW or CONGRA algorithm is restarted with a steepest descent/ascent \nsearch direction after, at most, i iterations, i > 0."},"StatementOptionType":"V"},{"StatementOptionName":"SOCKET=","StatementOptionHelp":{"#cdata":"Specifies the fileref that contains the information needed for remote monitoring."},"StatementOptionType":"V"},{"StatementOptionName":"TECHNIQUE=|TECH=","StatementOptionHelp":{"#cdata":"[Syntax: TECHNIQUE= | TECH=name] \n          \nSpecifies the optimization technique."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"CONGRA","@Value2":"DBLDOG","@Value3":"NMSIMP","@Value4":"NEWRAP","@Value5":"NRRIDG","@Value6":"QUANEW","@Value7":"TRUREG","@Value8":"NONE"},"StatementOptionToolTips":{"@ToolTip1":"Chooses one of four different conjugate-gradient optimization algorithms, which can be more  precisely defined with the UPDATE= option and modified with the LINESEARCH= option.","@ToolTip2":"Performs a version of double-dogleg optimization, which uses the gradient to update an approximation  of the Cholesky factor of the Hessian.","@ToolTip3":"Performs a Nelder-Mead simplex optimization.","@ToolTip4":"Performs a usually stable but, for large problems, memory- and time-consuming Newton-Raphson  optimization technique. The algorithm combines a line-search algorithm with ridging, and it  can be modified with the LINESEARCH= option.","@ToolTip5":"Performs a usually stable but, for large problems, memory- and time-consuming Newton-Raphson  optimization technique. This algorithm does not perform a line search.","@ToolTip6":"Chooses one of four different quasi-Newton optimization algorithms that can be more precisely  defined with the UPDATE= option and modified with the LINESEARCH= option.","@ToolTip7":"Performs a usually very stable but, for large problems, memory- and time-consuming trust-region  optimization technique. The algorithm is implemented similar to Gay (1983) and Mor\u00e9 and Sorensen  (1983).","@ToolTip8":"Does not perform any optimization. This option is similar to METHOD=NONE, but TECH=NONE also  computes and displays residuals and goodness of fit statistics."}},{"StatementOptionName":"UPDATE=|UPD=","StatementOptionHelp":{"#cdata":"Specifies the update method for the quasi-Newton, double-dogleg, or conjugate-gradient \noptimization technique."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"BFGS","@Value2":"DBFGS","@Value3":"DDFP","@Value4":"DFP","@Value5":"PB","@Value6":"FR","@Value7":"PR","@Value8":"CD"},"StatementOptionToolTips":{"@ToolTip1":"Performs the original Broyden, Fletcher, Goldfarb, and Shanno (BFGS) update of the inverse  Hessian matrix.","@ToolTip2":"Performs the dual BFGS update of the Cholesky factor of the Hessian matrix. This is the  default update method.","@ToolTip3":"Performs the dual Davidon, Fletcher, and Powell (DFP) update of the Cholesky factor of  the Hessian matrix.","@ToolTip4":"Performs the original DFP update of the inverse Hessian matrix.","@ToolTip5":"Performs the automatic restart update method of Powell (1977) and Beale (1972).","@ToolTip6":"Performs the Fletcher-Reeves update (Fletcher 1987).","@ToolTip7":"Performs the Polak-Ribiere update (Fletcher 1987).","@ToolTip8":"Performs a conjugate-descent update of Fletcher (1987)."}},{"StatementOptionName":"XCONV=|XTOL=","StatementOptionHelp":{"#cdata":"[Syntax: XCONV= | XTOL=r[n]] \n          \nSpecifies the relative parameter convergence criterion. For all techniques except NMSIMP, \ntermination requires a small relative parameter change in subsequent iterations. The default \nvalue is r=1E-8 for the NMSIMP technique and r=0 otherwise. The optional integer value n \nspecifies the number of successive iterations for which the criterion must be satisfied \nbefore the process can be terminated. "},"StatementOptionType":"V"},{"StatementOptionName":"XSIZE=","StatementOptionHelp":{"#cdata":"[Syntax: XSIZE=r > 0] \n          \nSpecifies the XSIZE parameter of the relative parameter termination criterion. The default \nvalue is r=0."},"StatementOptionType":"V"}]}},{"StatementName":"OUTPUT","StatementHelp":{"#cdata":"Syntax: OUTPUT options ; \n      \nThe MDC procedure supports the OUTPUT statement. The OUTPUT statement creates a new SAS data \nset that contains all the variables in the input data set and, optionally, the estimated linear \npredictors (XBETA) and predicted probabilities (P). The input data set must be sorted by the \nchoice variable(s) within each ID."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"[Syntax: OUT=SAS-data-set] \n          \nSpecifies the name of the output data set."},"StatementOptionType":"DV"},{"StatementOptionName":"PRED=|P=","StatementOptionHelp":{"#cdata":"[Syntax: PRED=variable name] \n          \nRequests the predicted probabilities by naming the variable that contains the predicted \nprobabilities in the output data set."},"StatementOptionType":"V"},{"StatementOptionName":"XBETA=","StatementOptionHelp":{"#cdata":"[Syntax: XBETA=variable name] \n          \nNames the variable that contains the linear predictor (x'\u03b2) values. However, the XBETA= \noption is not supported in the nested logit model."},"StatementOptionType":"V"}]}},{"StatementName":"RESTRICT","StatementHelp":{"#cdata":"Syntax: RESTRICT restriction1 < , restriction2 ...> ; \n\nThe RESTRICT statement is used to impose linear restrictions on the parameter estimates. \nYou can specify any number of RESTRICT statements. \n\nEach restriction is written as an expression, followed by an equality operator (=) or an \ninequality operator (<, >, \u2264,  \u2265 ), followed by a second expression: \n\n  expression operator expression\n\nThe operator can be =, <, >, \u2264, or  \u2265 . \n\nRestriction expressions can be composed of parameters; multiplication (*), summation (+), \nand substraction (-) operators; and constants. Parameters named in restriction expressions \nmust be among the parameters estimated by the model. Parameters associated with a regressor \nvariable are referred to by the name of the corresponding regressor variable. The restriction \nexpressions must be a linear function of the parameters."},"StatementOptions":null},{"StatementName":"TEST","StatementHelp":{"#cdata":"Syntax: <'label':> TEST <'string':> equation <,equation...> </ options> ; \n      \nThe TEST statement performs Wald, Lagrange multiplier, and likelihood ratio tests of \nlinear hypotheses about the regression parameters in the preceding MODEL statement. \nEach equation specifies a linear hypothesis to be tested. All hypotheses in one TEST \nstatement are tested jointly. Variable names in the equations must correspond to \nregressors in the preceding MODEL statement, and each name represents the coefficient \nof the corresponding regressor. The keyword INTERCEPT refers to the coefficient of the \nintercept."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ALL","StatementOptionHelp":{"#cdata":"Requests Wald, Lagrange multiplier, and likelihood ratio tests."},"StatementOptionType":"S"},{"StatementOptionName":"WALD","StatementOptionHelp":{"#cdata":"Requests the Wald test."},"StatementOptionType":"S"},{"StatementOptionName":"LM","StatementOptionHelp":{"#cdata":"Requests the Lagrange multiplier test."},"StatementOptionType":"S"},{"StatementOptionName":"LR","StatementOptionHelp":{"#cdata":"Requests the likelihood ratio test."},"StatementOptionType":"S"}]}},{"StatementName":"UTILITY","StatementHelp":{"#cdata":"Syntax: UTILITY U(level < , choices> )= variables ; \n\nThe UTILITY statement can be used in estimating a nested logit model. The U()= option can \nhave two arguments. The first argument contains level information, while the second argument \nis related to choice information. The second argument can be omitted for the first level when \nall the choices at the first level share the same variables and the same parameters. However, \nfor any level above the first, the second argument must be provided. The UTILITY statement \nspecifies a utility function while the NEST statement constructs the decision tree."},"StatementOptions":null}]}}}