{"Procedure":{"Name":"MODEL","#comment":{},"ProductGroup":"SAS/ETS","ProcedureHelp":{"#cdata":"Syntax: PROC MODEL options ; \n    programming Statements...   \n    PROC-MODEL-specific statements...\n    ...\n\nThe MODEL procedure analyzes models in which the relationships among the variables comprise \na system of one or more nonlinear equations. Primary uses of the MODEL procedure are estimation, \nsimulation, and forecasting of nonlinear simultaneous equation models. \n\nPROC MODEL features include the following: \n  o SAS programming statements to define simultaneous systems of nonlinear equations \n  o tools to analyze the structure of the simultaneous equation system \n  o ARIMA, PDL, and other dynamic modeling capabilities \n  o tools to specify and estimate the error covariance structure \n  o tools to estimate and solve ordinary differential equations \n  o the following methods for parameter estimation: \n    \u2013 ordinary least squares (OLS) \n    \u2013 two-stage least squares (2SLS) \n    \u2013 seemingly unrelated regression (SUR) and iterative SUR (ITSUR) \n    \u2013 three-stage least squares (3SLS) and iterative 3SLS (IT3SLS) \n    \u2013 generalized method of moments (GMM) \n    \u2013 simulated method of moments (SMM) \n    \u2013 full information maximum likelihood (FIML) \n    \u2013 general log-likelihood maximization \n  o simulation and forecasting capabilities \n  o Monte Carlo simulation \n  o goal-seeking solutions"},"ProcedureOptions":{"ProcedureOption":[{"ProcedureOptionName":"DATA=","ProcedureOptionHelp":{"#cdata":"[Syntax: DATA=SAS-data-set] \n      \nNames the input data set. Variables in the model program are looked up in the DATA= data set \nand, if found, their attributes (type, length, label, format) are set to be the same as those \nin the input data set (if not previously defined otherwise). The values for the variables in \nthe program are read from the input data set when the model is estimated or simulated by FIT \nand SOLVE statements. "},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"OUTPARMS=","ProcedureOptionHelp":{"#cdata":"[Syntax: OUTPARMS=SAS-data-set] \n      \nWrites the parameter estimates to a SAS data set."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"PARMSDATA=","ProcedureOptionHelp":{"#cdata":"[Syntax: PARMSDATA=SAS-data-set] \n      \nNames the SAS data set that contains the parameter estimates. In PROC MODEL, you have several \noptions to specify starting values for the parameters to be estimated. When more than one option \nis specified, the options are implemented in the following order of precedence (from highest to \nlowest): the START= option, the PARMS statement initialization value, the ESTDATA= option, and \nthe PARMSDATA= option. If no options are specified for the starting value, the default value of \n0.0001 is used."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"PLOTS=","ProcedureOptionHelp":{"#cdata":"Syntax: PLOTS=global-plot-options | plot-request \n      \nRequests that the MODEL procedure produce statistical graphics via the Output Delivery System, \nprovided that the ODS GRAPHICS statement has been specified. The global-plot-options apply to \nall relevant plots generated by the MODEL procedure. The global-plot-options supported by the MODEL procedure follow. \n\n  ONLY \n  suppresses the default plots. Only the plots specifically requested are produced. \n\n  UNPACKPANEL \n  breaks a graphic that is otherwise paneled into individual component plots."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"ALL","@Value2":"ACF","@Value3":"IACF","@Value4":"PACF","@Value5":"FITPLOT","@Value6":"COOKSD","@Value7":"QQ","@Value8":"RESIDUAL|RES","@Value9":"STUDENTRESIDUAL","@Value10":"RESIDUALHISTOGRAM |RESIDHISTOGRAM","@Value11":"NONE"},"ProcedureOptionToolTips":{"@ToolTip1":"Requests that all plots appropriate for the particular analysis be produced.","@ToolTip2":"Produces the autocorrelation function plot.","@ToolTip3":"Produces the inverse autocorrelation function plot of residuals.","@ToolTip4":"Produces the partial autocorrelation function plot of residuals.","@ToolTip5":"Plots the predicted and actual values.","@ToolTip6":"Produces the Cook\u2019s D plot.","@ToolTip7":"Produces a QQ plot of residuals.","@ToolTip8":"Plots the residuals.","@ToolTip9":"Plots the studentized residuals.","@ToolTip10":"Plots the histogram of residuals.","@ToolTip11":"Suppresses all plots."}},{"ProcedureOptionName":"MODEL=","ProcedureOptionHelp":{"#cdata":"[Syntax: MODEL=model-name | (model-list)] \n      \nReads the model from one or more input model files created by previous PROC MODEL executions. \nModel files are written by the OUTMODEL= option."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"NOSTORE","ProcedureOptionHelp":{"#cdata":"Suppresses the default output of the model file. This option is applicable only when FIT or SOLVE \nstatements are not used, the MODEL= option is not used, and when a model is specified."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"OUTMODEL=","ProcedureOptionHelp":{"#cdata":"[Syntax: OUTMODEL=model-name] \n      \nSpecifies the name of an output model file to which the model is to be written. \nStarting with SAS 9.2, model files are being stored as XML-based SAS data sets \ninstead of being stored as members of a SAS catalog as in earlier releases. This \nmakes MODEL files more readily extendable in the future and enables Java-based \napplications to read the MODEL files directly. To change this behavior, use the \nSAS global-CMPMODEL-options. You can choose the format in which the output model \nfile is stored and read by using the CMPMODEL=global-CMPMODEL-options in an \nPTIONS statement as follows. \n\n  OPTIONS CMPMODEL=global-CMPMODEL-option;"},"ProcedureOptionType":"V"},{"ProcedureOptionName":"BLOCK","ProcedureOptionHelp":{"#cdata":"Prints an analysis of the structure of the model given by the assignments to model variables \nappearing in the model program. This analysis includes a classification of model variables \ninto endogenous (dependent) and exogenous (independent) groups based on the presence of the \nvariable on the left-hand side of an assignment statement. The endogenous variables are \ngrouped into simultaneously determined blocks. The dependency structure of the simultaneous\nblocks and exogenous variables is also printed. The BLOCK option cannot analyze dependencies \nimplied by general form equations."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"GRAPH","ProcedureOptionHelp":{"#cdata":"Prints the graph of the dependency structure of the model. The GRAPH option also invokes \nthe BLOCK option and produces a graphical display of the information listed by the BLOCK \noption."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"LIST","ProcedureOptionHelp":{"#cdata":"Prints the model program and variable lists, including the statements added by PROC MODEL \nand macros."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"LISTALL","ProcedureOptionHelp":{"#cdata":"Selects the LIST, LISTDEP, LISTDER, and LISTCODE options."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"LISTCODE","ProcedureOptionHelp":{"#cdata":"Prints the derivative tables and compiled model program code. LISTCODE is a debugging feature \nand is not normally needed."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"LISTDEP","ProcedureOptionHelp":{"#cdata":"Prints a report that lists for each variable in the model program the variables that depend \non it and that it depends on. These lists are given separately for current-period values \nand for lagged values of the variables. \n\nThe information displayed is the same as that used to construct the BLOCK report but differs \nin that the information is listed for all variables (including parameters, control variables, \nand program variables), not just for the model variables. Classification into endogenous and \nexogenous groups and analysis of simultaneous structure is not done by the LISTDEP report."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"LISTDER","ProcedureOptionHelp":{"#cdata":"Prints a table of derivatives for FIT and SOLVE tasks. (The LISTDER option is applicable only \nfor the default NEWTON method for SOLVE tasks.) The derivatives table shows each nonzero \nderivative computed for the problem. The derivative listed can be a constant, a variable \nin the model program, or a special derivative variable created to hold the result of the \nderivative expression. This option is turned on by the LISTCODE and PRINTALL options."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"XREF","ProcedureOptionHelp":{"#cdata":"Prints a cross-reference of the variables in the model program that shows where each variable \nwas referenced or given a value. The XREF option is normally used in conjunction with the \nLIST option."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"DETAILS","ProcedureOptionHelp":{"#cdata":"Specifies the detailed printout. Parts of the printed output are expanded when the DETAILS \noption is specified. If ODS GRAPHICS ON is specified, the following additional graphs of \nthe residuals are produced: ACF, PACF, IACF, white noise, and QQ plot versus the normal."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"FLOW","ProcedureOptionHelp":{"#cdata":"Prints a message for each statement in the model program as it is executed. This debugging \noption is needed very rarely and produces voluminous output."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"MAXERRORS=","ProcedureOptionHelp":{"#cdata":"[Syntax: MAXERRORS=n] \n      \nSpecifies the maximum number of execution errors that can be printed. The default \nis MAXERRORS=50."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"NDEC=","ProcedureOptionHelp":{"#cdata":"[Syntax: NDEC=n] \n      \nSpecifies the precision of the format that PROC MODEL uses when printing various numbers. \nThe default is NDEC=3, which means that PROC MODEL attempts to print values by using the \nD format but ensures that at least three significant digits are shown. If the NDEC= value \nis greater than nine, the BEST. format is used. The smallest value allowed is NDEC=2. \n\nThe NDEC= option affects the format of most, but not all, of the floating point numbers \nthat PROC MODEL can print. For some values (such as parameter estimates), a precision \nlimit one or two digits greater than the NDEC= value is used. This option does not apply \nto the precision of the variables in the output data set."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"NOPRINT","ProcedureOptionHelp":{"#cdata":"Suppresses the normal printed output but does not suppress error listings. Using any other \nprint option turns the NOPRINT option off. The PRINT option can be used with the RESET \nstatement to turn off NOPRINT."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"PRINTALL","ProcedureOptionHelp":{"#cdata":"Turns on all the printing-control options. The options set by PRINTALL are DETAILS; the model \ninformation options LIST, LISTDEP, LISTDER, XREF, BLOCK, and GRAPH; the FIT task printing \noptions FSRSQ, COVB, CORRB, COVS, CORRS, DW, and COLLIN; and the SOLVE task printing options \nSTATS, THEIL, SOLVEPRINT, and ITPRINT."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"TRACE","ProcedureOptionHelp":{"#cdata":"Prints the result of each operation in each statement in the model program as it is executed, \nin addition to the information printed by the FLOW option. This debugging option is needed \nvery rarely and produces voluminous output."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"MEMORYUSE","ProcedureOptionHelp":{"#cdata":"Prints a report of the memory required for the various parts of the analysis."},"ProcedureOptionType":"S"}],"#comment":[{},{}]},"ProcedureStatements":{"ProcedureStatement":[{"StatementName":"BOUNDS","StatementHelp":{"#cdata":"Syntax: BOUNDS bound1 <, bound2 ...> ;\n      \nThe BOUNDS statement imposes simple boundary constraints on the parameter estimates. \nBOUNDS statement constraints refer to the parameters estimated by the associated FIT \nstatement (that is, to either the preceding FIT statement or, in the absence of a \npreceding FIT statement, to the following FIT statement). You can specify any number \nof BOUNDS statements. \n\nEach bound is composed of parameters and constants and inequality operators: \n\n  item operator item < operator item < operator item ...> > \n\nEach item is a constant, the name of an estimated parameter, or a list of parameter names. \nEach operator is <, >, <=, or >=. \n\nYou can use both the BOUNDS statement and the RESTRICT statement to impose boundary \nconstraints; however, the BOUNDS statement provides a simpler syntax for specifying \nthese kinds of constraints."},"StatementOptions":null},{"StatementName":"BY","StatementHelp":{"#cdata":"Syntax: BY variables ;\n\nA BY statement is used with the FIT statement to obtain separate estimates for observations \nin groups defined by the BY variables. Note that if an output model file is written, using \nthe OUTMODEL= option, the parameter values stored are those from the last BY group processed. \nTo save parameter estimates for each BY group, use the OUTEST= option in the FIT statement. \n\nA BY statement is used with the SOLVE statement to obtain solutions for observations in \ngroups defined by the BY variables. If the BY variables are identical in the DATA= data \nset and the ESTDATA= data set, then the two data sets are synchronized and the calculations \nare performed by using the data and parameters for each BY group. This holds for BY variables \nin the SDATA= data set as well. If the BY variables do not match, BY group processing is \nabandoned in either the ESTDATA= data set or the SDATA= data set, whichever has the missing \nBY value. If the DATA= data set does not contain BY variables and the ESTDATA= data set or \nthe SDATA= data set does, then BY processing is performed for the ESTDATA= data set and the \nSDATA= data set by reusing the data in the DATA= data set for each BY group."},"StatementOptions":null},{"StatementName":"CONTROL","StatementHelp":{"#cdata":"Syntax: CONTROL variable < value > ... ; \n\nThe CONTROL statement declares control variables and specifies their values. A control variable \nis like a parameter except that it has a fixed value and is not estimated from the data. You can \nuse control variables for constants in model equations that you might want to change in different \nsolution cases. You can use control variables to vary the program logic. Unlike the retained \nvariables, these values are fixed across iterations. "},"StatementOptions":null},{"StatementName":"ENDOGENOUS|ENDOG|ENDO","StatementHelp":{"#cdata":"Syntax: ENDOGENOUS variable < initial-values > ... ; \n\nThe ENDOGENOUS statement declares model variables and identifies them as endogenous. You \ncan declare model variables with an ENDOGENOUS statement instead of with a VAR statement \nto help document the model or to indicate the default solution variables. The variables \ndeclared endogenous are solved when a SOLVE statement does not indicate which variables \nto solve. Valid abbreviations for the ENDOGENOUS statement are ENDOG and ENDO. \n\nThe DEPENDENT statement is equivalent to the ENDOGENOUS statement and is provided for the \nconvenience of non-econometric practitioners. \n\nThe ENDOGENOUS statement optionally provides initial values for lagged dependent variables."},"StatementOptions":null},{"StatementName":"DEPENDENT","StatementHelp":{"#cdata":"Syntax: DEPENDENT variable < initial-values > ... ; \n\nThe DEPENDENT statement is equivalent to the ENDOGENOUS statement and is provided for the \nconvenience of non-econometric practitioners. \n\nThe ENDOGENOUS statement optionally provides initial values for lagged dependent variables."},"StatementOptions":null},{"StatementName":"ERRORMODEL","StatementHelp":{"#cdata":"Syntax: ERRORMODEL equation-name ~ distribution < CDF= CDF(options) > ; \n\nThe ERRORMODEL statement is the mechanism for specifying the distribution of the residuals. \nYou must specify the dependent/endogenous variables or general-form model name, a tilde (~), \nand then a distribution with its parameters."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"CAUCHY","StatementOptionHelp":{"#cdata":"Syntax: CAUCHY( <location, scale> ) \n          \nSpecifies the Cauchy distribution. This option is supported only for simulation. The arguments \ncorrespond to the arguments of the SAS CDF function which computes the cumulative distribution \nfunction (ignoring the random variable argument)."},"StatementOptionType":"S"},{"StatementOptionName":"CHISQUARED","StatementOptionHelp":{"#cdata":"Syntax: CHISQUARED ( df <, nc> ) \n\nSpecifies the \u03c7\u00b2 distribution. This option is supported only for simulation. The arguments \ncorrespond to the arguments of the SAS CDF function (ignoring the random variable argument)."},"StatementOptionType":"S"},{"StatementOptionName":"GENERAL","StatementOptionHelp":{"#cdata":"Syntax: GENERAL(Likelihood <, parm1, parm2,...parmn > ) \n          \nSpecifies the negative of a general log-likelihood function that you construct by using SAS \nprogramming statements. The procedure minimizes the negative log-likelihood function specified.  \nparm1, parm2,...parmn are optional parameters for this distribution and are used for documentation \npurposes only."},"StatementOptionType":"S"},{"StatementOptionName":"F","StatementOptionHelp":{"#cdata":"Syntax: F( ndf, ddf <, nc> ) \n          \nSpecifies the F distribution. This option is supported only for simulation. The arguments \ncorrespond to the arguments of the SAS CDF function (ignoring the random variable argument)."},"StatementOptionType":"S"},{"StatementOptionName":"NORMAL","StatementOptionHelp":{"#cdata":"Syntax: NORMAL( \u03bd1 \u03bd2 ... \u03bdn ) \n          \nSpecifies a multivariate normal (Gaussian) distribution with mean 0 and variances \u03bd1 through \u03bdn."},"StatementOptionType":"S"},{"StatementOptionName":"POISSON","StatementOptionHelp":{"#cdata":"Syntax: POISSON( mean ) \n          \nSpecifies the Poisson distribution. This option is supported only for simulation. The arguments \ncorrespond to the arguments of the SAS CDF function (ignoring the random variable argument)."},"StatementOptionType":"S"},{"StatementOptionName":"T","StatementOptionHelp":{"#cdata":"Syntax: T( \u03bd1 \u03bd2 ... \u03bdn, df ) \n          \nSpecifies a multivariate t distribution with noncentrality 0, variance \u03bd1 through \u03bdn, \nand common degrees of freedom df."},"StatementOptionType":"S"},{"StatementOptionName":"UNIFORM","StatementOptionHelp":{"#cdata":"Syntax: UNIFORM( <left, right> ) \n          \nSpecifies the uniform distribution. This option is supported only for simulation. \nThe arguments correspond to the arguments of the SAS CDF function (ignoring the \nrandom variable argument)."},"StatementOptionType":"S"},{"StatementOptionName":"CDF=","StatementOptionHelp":{"#cdata":"Syntax: CDF=( CDF(options) ) \n          \nSpecifies the univariate distribution that is used for simulation so that the estimation \ncan be done for one set of distributional assumptions and the simulation for another. The \nCDF can be any of the distributions from the previous section with the exception of the \ngeneral likelihood. In addition, you can specify the empirical distribution of the residuals. \n\n  EMPIRICAL= ( <TAILS=(options)> ) \n  uses the sorted residual data to create an empirical CDF. \n\n  TAILS=( tail-options ) \n\n  specifies how to handle the tails in computing the inverse CDF from an empirical distribution, \n  where tail-options are: \n\n    NORMAL \n    specifies the normal distribution to extrapolate the tails. \n\n    T( df ) \n    specifies the t distribution to extrapolate the tails. \n\n    PERCENT= p \n    specifies the percentage of the observations to use in constructing each tail. The default \n    for the PERCENT= option is 10. A normal distribution or a t distribution is used to extrapolate \n    the tails to infinity. The variance for the tail distribution is obtained from the data so \n    that the empirical CDF is continuous."},"StatementOptionType":"V","SubOptionsKeywords":"EMPIRICAL=|TAILS=|NORMAL|T|PERCENT="}]}},{"StatementName":"FIT","StatementHelp":{"#cdata":"Syntax: FIT < equations > < PARMS=( parameter <values> ...) > < START=( parameter values ...) > \n  < DROP=( parameter ...) > < INITIAL=( variable <= parameter | constant > ...) > < / options > ; \n  \n The FIT statement estimates model parameters by fitting the model equations to input data \n and optionally selects the equations to be fit. If the list of equations is omitted, all \n model equations that contain parameters are fitted.\n \n [Not all FIT statement options are supported for autocompletion at present.]"},"StatementOptions":{"StatementOption":[{"StatementOptionName":"DROP=","StatementOptionHelp":{"#cdata":"[Syntax: DROP= ( parameters ...) ] \n          \nSpecifies that the named parameters not be estimated. All the parameters in the equations \nfit are estimated except those listed in the DROP= option. The dropped parameters retain \ntheir previous values and are not changed by the estimation. "},"StatementOptionType":"RV"},{"StatementOptionName":"INITIAL=","StatementOptionHelp":{"#cdata":"[Syntax: INITIAL= ( variable = < parameter | constant > ...) ] \n          \nAssociates a variable with an initial value as a parameter or a constant. This option applies \nonly to ordinary differential equations."},"StatementOptionType":"RV"},{"StatementOptionName":"PARMS=","StatementOptionHelp":{"#cdata":"[Syntax: PARMS= ( parameters [values] ...)] \n          \nSelects a subset of the parameters for estimation. When the PARMS= option is used, only the \nnamed parameters are estimated. Any parameters not specified in the PARMS= list retain their \nprevious values and are not changed by the estimation. \n\nIn PROC MODEL, you have several options to specify starting values for the parameters to be \nestimated. When more than one option is specified, the options are implemented in the following \norder of precedence (from highest to lowest): the START= option, the PARMS statement initialization \nvalue, the ESTDATA= option, and the PARMSDATA= option. If no options are specified for the starting \nvalue, the default value of 0.0001 is used."},"StatementOptionType":"RV"},{"StatementOptionName":"PRL=","StatementOptionHelp":{"#cdata":"Requests confidence intervals on estimated parameters. By default, the PRL option produces \n95% likelihood ratio confidence limits. The coverage of the confidence interval is controlled \nby the ALPHA= option in the FIT statement."},"StatementOptionType":"RV","StatementOptionValues":{"@Value1":"WALD","@Value2":"LR","@Value3":"BOTH"},"StatementOptionToolTips":{"@ToolTip1":"Requests likelihood ratio confidence limits.","@ToolTip2":"Requests Wald confidence limits.","@ToolTip3":"Requests both Wald and likelihood ratio confidence limits."}},{"StatementOptionName":"START=","StatementOptionHelp":{"#cdata":"[Syntax: START= ( parameter values ...) ] \n          \nSupplies starting values for the parameter estimates. In PROC MODEL, you have several \noptions to specify starting values for the parameters to be estimated. When more than \none option is specified, the options are implemented in the following order of precedence \n(from highest to lowest): the START= option, the PARMS statement initialization value, \nthe ESTDATA= option, and the PARMSDATA= option. If no options are specified for the \nstarting value, the default value of 0.0001 is used. If the START= option specifies \nmore than one starting value for one or more parameters, a grid search is performed \nover all combinations of the values, and the best combination is used to start the \niterations."},"StatementOptionType":"RV"},{"StatementOptionName":"ADJSMMV","StatementOptionHelp":{"#cdata":"Specifies adding the variance adjustment from simulating the moments to the variance-covariance \nmatrix of the parameter estimators. By default, no adjustment is made."},"StatementOptionType":"S"},{"StatementOptionName":"COVBEST=","StatementOptionHelp":{"#cdata":"Specifies the variance-covariance estimator used for FIML. \n          \nThe default is COVBEST=CROSS."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"GLS","@Value2":"CROSS","@Value3":"FDA"},"StatementOptionToolTips":{"@ToolTip1":"Selects the generalized least squares estimator.","@ToolTip2":"Selects the crossproducts estimator.","@ToolTip3":"Selects the inverse of the finite difference approximation to the Hessian."}},{"StatementOptionName":"DYNAMIC","StatementOptionHelp":{"#cdata":"Specifies dynamic estimation of ordinary differential equations."},"StatementOptionType":"S"},{"StatementOptionName":"FIML","StatementOptionHelp":{"#cdata":"Specifies full information maximum likelihood estimation."},"StatementOptionType":"S"},{"StatementOptionName":"GINV=","StatementOptionHelp":{"#cdata":"Specifies the type of generalized inverse to be used when computing the covariance matrix. \n          \nThe default is GINV=G2."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"G2","@Value2":"G4"},"StatementOptionToolTips":{"@ToolTip1":"A G2 inverse is calculated by satisfying the first two properties of the Moore-Penrose generalized inverse.","@ToolTip2":"Selects the Moore-Penrose generalized inverse."}},{"StatementOptionName":"GENGMMV","StatementOptionHelp":{"#cdata":"Specify GMM variance under arbitrary weighting matrix. This is the default method \nfor GMM estimation."},"StatementOptionType":"S"},{"StatementOptionName":"GMM","StatementOptionHelp":{"#cdata":"Specifies generalized method of moments estimation."},"StatementOptionType":"S"},{"StatementOptionName":"HCCME=","StatementOptionHelp":{"#cdata":"Specifies the type of heteroscedasticity-consistent covariance matrix estimator to use \nfor OLS, 2SLS, 3SLS, SUR, and the iterated versions of these estimation methods. \n\nThe default is NO."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"0","@Value2":"1","@Value3":"2","@Value4":"3","@Value5":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Corresponds to the type of covariance matrix estimator to use: HCO","@ToolTip2":"Corresponds to the type of covariance matrix estimator to use: HC1","@ToolTip3":"Corresponds to the type of covariance matrix estimator to use: HC2","@ToolTip4":"Corresponds to the type of covariance matrix estimator to use: HC3","@ToolTip5":"Specifies not to use any covariance matrix estimator."}},{"StatementOptionName":"ITGMM","StatementOptionHelp":{"#cdata":"Specifies iterated generalized method of moments estimation."},"StatementOptionType":"S"},{"StatementOptionName":"ITOLS","StatementOptionHelp":{"#cdata":"Specifies iterated ordinary least squares estimation. This is the same as OLS unless \nthere are cross-equation parameter restrictions."},"StatementOptionType":"S"},{"StatementOptionName":"ITSUR","StatementOptionHelp":{"#cdata":"Specifies iterated seemingly unrelated regression estimation."},"StatementOptionType":"S"},{"StatementOptionName":"IT2SLS","StatementOptionHelp":{"#cdata":"Specifies iterated two-stage least squares estimation. This is the same as 2SLS \nunless there are cross-equation parameter restrictions."},"StatementOptionType":"S"},{"StatementOptionName":"KERNEL=","StatementOptionHelp":{"#cdata":"Syntax: KERNEL=(PARZEN | BART | QS, <c> , <e> ) | KERNEL=PARZEN | BART | QS \n\nSpecifies the kernel to be used for GMM and ITGMM. The default is KERNEL=(PARZEN, 1, 0.2)."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"PARZEN","@Value2":"BART","@Value3":"QS"},"StatementOptionToolTips":{"@ToolTip1":"Selects the Parzen kernel.","@ToolTip2":"Selects the Bartlett kernel.","@ToolTip3":"Selects the quadratic spectral kernel. e \u2265 0 and c \u2265 0 are used to compute  the bandwidth parameter."}},{"StatementOptionName":"IT3SLS","StatementOptionHelp":{"#cdata":"Specifies iterated three-stage least squares estimation."},"StatementOptionType":"S"},{"StatementOptionName":"NDRAW=","StatementOptionHelp":{"#cdata":"[Syntax: NDRAW <=number of draws>] \n          \nRequests the simulation method for estimation. H is the number of draws. If number \nof draws is not specified, the default H is set to 10."},"StatementOptionType":"S|V"},{"StatementOptionName":"NOOLS|NO2SLS","StatementOptionHelp":{"#cdata":"Specifies bypassing OLS or 2SLS to get initial parameter estimates for GMM, ITGMM, \nor FIML. This is important for certain models that are poorly defined in OLS or \n2SLS, or if good initial parameter values are already provided. Note that for \nGMM, the V matrix is created by using the initial values specified and this \nmight not be consistently estimated."},"StatementOptionType":"S"},{"StatementOptionName":"NO3SLS","StatementOptionHelp":{"#cdata":"Specifies not to use 3SLS automatically for FIML initial parameter starting values."},"StatementOptionType":"S"},{"StatementOptionName":"NOGENGMMV","StatementOptionHelp":{"#cdata":"Specifies not to use GMM variance under arbitrary weighting matrix. Use GMM variance \nunder optimal weighting matrix instead."},"StatementOptionType":"S"},{"StatementOptionName":"NPREOBS=","StatementOptionHelp":{"#cdata":"[Syntax: NPREOBS =number of obs to initialize] \n          \nSpecifies the initial number of observations to run the simulation before the simulated \nvalues are compared to observed variables. This option is most useful in cases where the \nprogram statements involve lag operations. Use this option to avoid the effect of the \nstarting point on the simulation."},"StatementOptionType":"V"},{"StatementOptionName":"NVDRAW=","StatementOptionHelp":{"#cdata":"[Syntax: NVDRAW =number of draws for V matrix] \n          \nSpecifies H', the number of draws for V matrix. If this option is not specified, \nthe default H' is set to 20."},"StatementOptionType":"V"},{"StatementOptionName":"OLS","StatementOptionHelp":{"#cdata":"Specifies ordinary least squares estimation. This is the default."},"StatementOptionType":"S"},{"StatementOptionName":"SUR","StatementOptionHelp":{"#cdata":"Specifies seemingly unrelated regression estimation."},"StatementOptionType":"S"},{"StatementOptionName":"VARDEF=","StatementOptionHelp":{"#cdata":"Specifies the denominator to be used in computing variances and covariances, MSE, \nroot MSE measures, and so on. The default is VARDEF=DF."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"N","@Value2":"WGT","@Value3":"DF","@Value4":"WDF"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that the number of nonmissing observations be used.","@ToolTip2":"Specifies that the sum of the weights be used.","@ToolTip3":"Specifies that the number of nonmissing observations minus the model degrees of freedom  (number of parameters) be used.","@ToolTip4":"Specifies that the sum of the weights minus the model degrees of freedom be used."}},{"StatementOptionName":"DATA=","StatementOptionHelp":{"#cdata":"[Syntax: DATA=SAS-data-set] \n          \nSpecifies the input data set. Values for the variables in the program are read from \nthis data set. If the DATA= option is not specified on the FIT statement, the data \nset specified by the DATA= option on the PROC MODEL statement is used."},"StatementOptionType":"DV"},{"StatementOptionName":"ESTDATA=","StatementOptionHelp":{"#cdata":"[Syntax: ESTDATA=SAS-data-set] \n          \nSpecifies a data set whose first observation provides initial values for some \nor all of the parameters."},"StatementOptionType":"DV"},{"StatementOptionName":"MISSING=","StatementOptionHelp":{"#cdata":"Specifies how missing values are handled. The default is MISSING=DELETE."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"PAIRWISE","@Value2":"DELETE"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that missing values are tracked on an equation-by-equation basis.","@ToolTip2":"Specifies that the entire observation is omitted from the analysis when any equation  has a missing predicted or actual value for the equation."}},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"[Syntax: OUT=SAS-data-set] \n          \nNames the SAS data set to contain the residuals, predicted values, or actual values \nfrom each estimation."},"StatementOptionType":"DV"},{"StatementOptionName":"OUTACTUAL","StatementOptionHelp":{"#cdata":"Writes the actual values of the endogenous variables of the estimation to the OUT= \ndata set. This option is applicable only if the OUT= option is specified."},"StatementOptionType":"S"},{"StatementOptionName":"OUTALL","StatementOptionHelp":{"#cdata":"Selects the OUTACTUAL, OUTERRORS, OUTLAGS, OUTPREDICT, and OUTRESID options."},"StatementOptionType":"S"},{"StatementOptionName":"OUTCOV|COVOUT","StatementOptionHelp":{"#cdata":"Writes the covariance matrix of the estimates to the OUTEST= data set in addition to \nthe parameter estimates. The OUTCOV option is applicable only if the OUTEST= option \nis also specified."},"StatementOptionType":"S"},{"StatementOptionName":"OUTEST=","StatementOptionHelp":{"#cdata":"[Syntax: OUTEST=SAS-data-set] \n          \nNames the SAS data set to contain the parameter estimates and optionally the \ncovariance of the estimates."},"StatementOptionType":"V"},{"StatementOptionName":"OUTLAGS","StatementOptionHelp":{"#cdata":"Writes the observations used to start the lags to the OUT= data set. This option \nis applicable only if the OUT= option is specified."},"StatementOptionType":"S"},{"StatementOptionName":"OUTPREDICT","StatementOptionHelp":{"#cdata":"Writes the predicted values to the OUT= data set. This option is applicable only if OUT= is specified."},"StatementOptionType":"S"},{"StatementOptionName":"OUTRESID","StatementOptionHelp":{"#cdata":"Writes the residual values computed from the parameter estimates to the OUT= data set. \nThe OUTRESID option is the default if neither OUTPREDICT nor OUTACTUAL is specified. \nThis option is applicable only if the OUT= option is specified."},"StatementOptionType":"S"},{"StatementOptionName":"OUTS=","StatementOptionHelp":{"#cdata":"[Syntax: OUTS=SAS-data-set] \n          \nNames the SAS data set to contain the estimated covariance matrix of the equation errors. \nThis is the covariance of the residuals computed from the parameter estimates."},"StatementOptionType":"DV"},{"StatementOptionName":"OUTSN=","StatementOptionHelp":{"#cdata":"[Syntax: OUTSN=SAS-data-set] \n          \nNames the SAS data set to contain the estimated normalized covariance matrix of the \nequation errors. This is valid for multivariate t distribution estimation."},"StatementOptionType":"DV"},{"StatementOptionName":"OUTSUSED=","StatementOptionHelp":{"#cdata":"[Syntax: OUTSUSED=SAS-data-set] \n          \nNames the SAS data set to contain the S matrix used in the objective function definition. \nThe OUTSUSED= data set is the same as the OUTS= data set for the methods that iterate the \nS matrix."},"StatementOptionType":"DV"},{"StatementOptionName":"OUTUNWGTRESID","StatementOptionHelp":{"#cdata":"Writes the unweighted residual values computed from the parameter estimates to the \nOUT= data set. These are residuals computed as actual-predicted with no accounting \nfor the WEIGHT statement, the _WEIGHT_ variable, or any variance expressions. This \noption is applicable only if the OUT= option is specified."},"StatementOptionType":"S"},{"StatementOptionName":"OUTV=","StatementOptionHelp":{"#cdata":"[Syntax: OUTV=SAS-data-set] \n          \nNames the SAS data set to contain the estimate of the variance matrix for GMM and ITGMM."},"StatementOptionType":"DV"},{"StatementOptionName":"SDATA=","StatementOptionHelp":{"#cdata":"[Syntax: SDATA=SAS-data-set] \n          \nSpecifies a data set that provides the covariance matrix of the equation errors. \nThe matrix read from the SDATA= data set is used for the equation covariance matrix \n(S matrix) in the estimation. (The SDATA= S matrix is used to provide only the initial \nestimate of S for the methods that iterate the S matrix.)"},"StatementOptionType":"DV"},{"StatementOptionName":"TIME=","StatementOptionHelp":{"#cdata":"[Syntax: TIME=name] \n          \nSpecifies the name of the time variable. This variable must be in the data set."},"StatementOptionType":"V"},{"StatementOptionName":"TYPE=","StatementOptionHelp":{"#cdata":"[Syntax: TYPE=name] \n          \nSpecifies the estimation type to read from the SDATA= and ESTDATA= data sets. \nThe name specified in the TYPE= option is compared to the _TYPE_ variable in \nthe ESTDATA= and SDATA= data sets to select observations to use in constructing \nthe covariance matrices. When the TYPE= option is omitted, the last estimation \ntype in the data set is used. Valid values are the estimation methods used in \nPROC MODEL."},"StatementOptionType":"V"},{"StatementOptionName":"VDATA=","StatementOptionHelp":{"#cdata":"[Syntax: VDATA=SAS-data-set] \n          \nSpecifies a data set that contains a variance matrix for GMM and ITGMM estimation."},"StatementOptionType":"V"},{"StatementOptionName":"CHOW=","StatementOptionHelp":{"#cdata":"[Syntax: CHOW=obs | CHOW=(obs1 obs2 ...obsn)] \n          \nPrints the Chow test for break points or structural changes in a model. The argument is \nthe number of observations in the first sample or a parenthesized list of first sample \nsizes. If the size of the one of the two groups in which the sample is partitioned is \nless than the number of parameters, then a predictive Chow test is automatically used."},"StatementOptionType":"V"},{"StatementOptionName":"COLLIN","StatementOptionHelp":{"#cdata":"Prints collinearity diagnostics for the Jacobian crossproducts matrix (XPX) after the \nparameters have converged. Collinearity diagnostics are also automatically printed if \nthe estimation fails to converge."},"StatementOptionType":"S"},{"StatementOptionName":"CORR","StatementOptionHelp":{"#cdata":"Prints the correlation matrices of the residuals and parameters. Using CORR is the \nsame as using both CORRB and CORRS."},"StatementOptionType":"S"},{"StatementOptionName":"CORRB","StatementOptionHelp":{"#cdata":"Prints the correlation matrix of the parameter estimates."},"StatementOptionType":"S"},{"StatementOptionName":"CORRS","StatementOptionHelp":{"#cdata":"Prints the correlation matrix of the residuals."},"StatementOptionType":"S"},{"StatementOptionName":"COV","StatementOptionHelp":{"#cdata":"Prints the covariance matrices of the residuals and parameters. Specifying COV \nis the same as specifying both COVB and COVS."},"StatementOptionType":"S"},{"StatementOptionName":"COVB","StatementOptionHelp":{"#cdata":"Prints the covariance matrix of the parameter estimates."},"StatementOptionType":"S"},{"StatementOptionName":"COVS","StatementOptionHelp":{"#cdata":"Prints the covariance matrix of the residuals."},"StatementOptionType":"S"},{"StatementOptionName":"DW=","StatementOptionHelp":{"#cdata":"[Syntax: DW <=>] \n          \nPrints Durbin-Watson d statistics, which measure autocorrelation of the residuals. \nWhen the residual series is interrupted by missing observations, the Durbin-Watson \nstatistic calculated is d' as suggested by Savin and White (1978). This is the usual \nDurbin-Watson computed by ignoring the gaps. Savin and White show that it has the \nsame null distribution as the DW with no gaps in the series and can be used to test \nfor autocorrelation using the standard tables. The Durbin-Watson statistic is not \nvalid for models that contain lagged endogenous variables. \n\nYou can use the DW= option to request higher-order Durbin-Watson statistics. Since \nthe ordinary Durbin-Watson statistic tests only for first-order autocorrelation, the \nDurbin-Watson statistics for higher-order autocorrelation are called generalized \nDurbin-Watson statistics."},"StatementOptionType":"S|V"},{"StatementOptionName":"DWPROB","StatementOptionHelp":{"#cdata":"Prints the significance level (p-values) for the Durbin-Watson tests. Since the \nDurbin-Watson p-values are computationally expensive, they are not reported  \nby default. In the Durbin-Watson test, the null hypothesis is that there is \nautocorrelation at a specific lag."},"StatementOptionType":"S"},{"StatementOptionName":"FSRSQ","StatementOptionHelp":{"#cdata":"Prints the first-stage R\u00b2 statistics for instrumental estimation methods. These R\u00b2 \nstatistics measure the proportion of the variance retained when the Jacobian columns \nassociated with the parameters are projected through the instruments space."},"StatementOptionType":"S"},{"StatementOptionName":"GODFREY=","StatementOptionHelp":{"#cdata":"[Syntax: GODFREY=n] \n          \nPerforms Godfrey\u2019s tests for autocorrelated residuals for each equation, where n is the \nmaximum autoregressive order, and specifies that Godfrey\u2019s tests be computed for lags 1 \nthrough n. The default number of lags is one."},"StatementOptionType":"S|V"},{"StatementOptionName":"HAUSMAN","StatementOptionHelp":{"#cdata":"Performs Hausman\u2019s specification test, or m-statistics."},"StatementOptionType":"S"},{"StatementOptionName":"NORMAL","StatementOptionHelp":{"#cdata":"Performs tests of normality of the model residuals."},"StatementOptionType":"S"},{"StatementOptionName":"PCHOW=","StatementOptionHelp":{"#cdata":"[Syntax: PCHOW=obs | PCHOW=(obs1 obs2 ...obsn) ] \n          \nPrints the predictive Chow test for break points or structural changes in a model. \nThe argument is the number of observations in the first sample or a parenthesized \nlist of first sample sizes."},"StatementOptionType":"V"},{"StatementOptionName":"WHITE","StatementOptionHelp":{"#cdata":"Specifies White\u2019s test."},"StatementOptionType":"S"},{"StatementOptionName":"I","StatementOptionHelp":{"#cdata":"Prints the inverse of the crossproducts Jacobian matrix at each iteration."},"StatementOptionType":"S"},{"StatementOptionName":"ITALL","StatementOptionHelp":{"#cdata":"Specifies all iteration printing-control options (I, ITDETAILS, ITPRINT, and XPX). \nITALL also prints the crossproducts matrix (labeled CROSS), the parameter change \nvector, and the estimate of the cross-equation covariance of residuals matrix at \neach iteration."},"StatementOptionType":"S"},{"StatementOptionName":"ITDETAILS","StatementOptionHelp":{"#cdata":"Prints a detailed iteration listing. This includes the ITPRINT information and additional statistics."},"StatementOptionType":"S"},{"StatementOptionName":"ITPRINT","StatementOptionHelp":{"#cdata":"Prints the parameter estimates, objective function value, and convergence criteria at each iteration."},"StatementOptionType":"S"},{"StatementOptionName":"XPX","StatementOptionHelp":{"#cdata":"Prints the crossproducts Jacobian matrix at each iteration."},"StatementOptionType":"S"},{"StatementOptionName":"CONVERGE=","StatementOptionHelp":{"#cdata":"[Syntax: CONVERGE=value1 | CONVERGE=(value1, value2)] \n          \nSpecifies the convergence criteria. The convergence measure must be less than value1 \nbefore convergence is assumed. value2 is the convergence criterion for the S and V \nmatrices for S and V iterated methods. value2 defaults to value1."},"StatementOptionType":"V"},{"StatementOptionName":"HESSIAN=","StatementOptionHelp":{"#cdata":"Specifies the Hessian approximation used for FIML. HESSIAN=GLS is the default."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"CROSS","@Value2":"GLS","@Value3":"FDA"},"StatementOptionToolTips":{"@ToolTip1":"Selects the crossproducts approximation to the Hessian.","@ToolTip2":"Selects the generalized least squares approximation to the Hessian.","@ToolTip3":"Selects the finite difference approximation to the Hessian."}},{"StatementOptionName":"LTEBOUND=","StatementOptionHelp":{"#cdata":"[Syntax: LTEBOUND=n] \n          \nSpecifies the local truncation error bound for the integration. This option is ignored \nif no ordinary differential equations (ODEs) are specified."},"StatementOptionType":"V"},{"StatementOptionName":"EPSILON=","StatementOptionHelp":{"#cdata":"[Syntax: EPSILON =value] \n          \nSpecifies the tolerance value used to transform strict inequalities into inequalities \nwhen restrictions on parameters are imposed. By default, EPSILON=1E\u20138."},"StatementOptionType":"V"},{"StatementOptionName":"MAXITER=","StatementOptionHelp":{"#cdata":"[Syntax: MAXITER=n] \n          \nSpecifies the maximum number of iterations allowed. The default is MAXITER=100."},"StatementOptionType":"V"},{"StatementOptionName":"MAXSUBITER=","StatementOptionHelp":{"#cdata":"[Syntax: MAXSUBITER=n] \n          \nSpecifies the maximum number of subiterations allowed for an iteration. For the GAUSS \nmethod, the MAXSUBITER= option limits the number of step halvings. For the MARQUARDT \nmethod, the MAXSUBITER= option limits the number of times n can be increased. The default \nis MAXSUBITER=30."},"StatementOptionType":"V"},{"StatementOptionName":"METHOD=","StatementOptionHelp":{"#cdata":"Specifies the iterative minimization method to use. \n          \nThe default is METHOD=GAUSS. If the default GAUSS method fails to converge, \nthe procedure switches to the MARQUARDT method."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"GAUSS","@Value2":"MARQUARDT"},"StatementOptionToolTips":{"@ToolTip1":"Specifies the Gauss-Newton method.","@ToolTip2":"Specifies the Marquardt-Levenberg method."}},{"StatementOptionName":"MINTIMESTEP=","StatementOptionHelp":{"#cdata":"[Syntax: MINTIMESTEP=n] \n          \nSpecifies the smallest allowed time step to be used in the integration. This option \nis ignored if no ODEs are specified."},"StatementOptionType":"V"},{"StatementOptionName":"NESTIT","StatementOptionHelp":{"#cdata":"Changes the way the iterations are performed for estimation methods that iterate \nthe estimate of the equation covariance (S matrix). The NESTIT option is relevant \nonly for the methods that iterate the estimate of the covariance matrix (ITGMM, \nITOLS, ITSUR, IT2SLS, and IT3SLS)."},"StatementOptionType":"S"},{"StatementOptionName":"SINGULAR=","StatementOptionHelp":{"#cdata":"[Syntax: SINGULAR=value] \n          \nSpecifies the smallest pivot value allowed. The default 1.0E\u201312."},"StatementOptionType":"V"},{"StatementOptionName":"STARTITER=","StatementOptionHelp":{"#cdata":"[Syntax: STARTITER=n] \n          \nSpecifies the number of minimization iterations to perform at each grid point. \nThe default is STARTITER=0, which implies that no minimization is performed at \nthe grid points."},"StatementOptionType":"V"},{"StatementOptionName":"BLOCK","StatementOptionHelp":{"#cdata":"Prints an analysis of the structure of the model given by the assignments to model variables \nappearing in the model program. This analysis includes a classification of model variables \ninto endogenous (dependent) and exogenous (independent) groups based on the presence of the \nvariable on the left-hand side of an assignment statement. The endogenous variables are \ngrouped into simultaneously determined blocks. The dependency structure of the simultaneous\nblocks and exogenous variables is also printed. The BLOCK option cannot analyze dependencies \nimplied by general form equations."},"StatementOptionType":"S"},{"StatementOptionName":"GRAPH","StatementOptionHelp":{"#cdata":"Prints the graph of the dependency structure of the model. The GRAPH option also invokes \nthe BLOCK option and produces a graphical display of the information listed by the BLOCK \noption."},"StatementOptionType":"S"},{"StatementOptionName":"LIST","StatementOptionHelp":{"#cdata":"Prints the model program and variable lists, including the statements added by PROC MODEL \nand macros."},"StatementOptionType":"S"},{"StatementOptionName":"LISTCODE","StatementOptionHelp":{"#cdata":"Prints the derivative tables and compiled model program code. LISTCODE is a debugging feature \nand is not normally needed."},"StatementOptionType":"S"},{"StatementOptionName":"LISTDEP","StatementOptionHelp":{"#cdata":"Prints a report that lists for each variable in the model program the variables that depend \non it and that it depends on. These lists are given separately for current-period values \nand for lagged values of the variables. \n\nThe information displayed is the same as that used to construct the BLOCK report but differs \nin that the information is listed for all variables (including parameters, control variables, \nand program variables), not just for the model variables. Classification into endogenous and \nexogenous groups and analysis of simultaneous structure is not done by the LISTDEP report."},"StatementOptionType":"S"},{"StatementOptionName":"LISTDER","StatementOptionHelp":{"#cdata":"Prints a table of derivatives for FIT and SOLVE tasks. (The LISTDER option is applicable only \nfor the default NEWTON method for SOLVE tasks.) The derivatives table shows each nonzero \nderivative computed for the problem. The derivative listed can be a constant, a variable \nin the model program, or a special derivative variable created to hold the result of the \nderivative expression. This option is turned on by the LISTCODE and PRINTALL options."},"StatementOptionType":"S"},{"StatementOptionName":"XREF","StatementOptionHelp":{"#cdata":"Prints a cross-reference of the variables in the model program that shows where each variable \nwas referenced or given a value. The XREF option is normally used in conjunction with the \nLIST option."},"StatementOptionType":"S"},{"StatementOptionName":"DETAILS","StatementOptionHelp":{"#cdata":"Specifies the detailed printout. Parts of the printed output are expanded when the DETAILS \noption is specified. If ODS GRAPHICS ON is specified, the following additional graphs of \nthe residuals are produced: ACF, PACF, IACF, white noise, and QQ plot versus the normal."},"StatementOptionType":"S"},{"StatementOptionName":"FLOW","StatementOptionHelp":{"#cdata":"Prints a message for each statement in the model program as it is executed. This debugging \noption is needed very rarely and produces voluminous output."},"StatementOptionType":"S"},{"StatementOptionName":"MAXERRORS=","StatementOptionHelp":{"#cdata":"[Syntax: MAXERRORS=n] \n      \nSpecifies the maximum number of execution errors that can be printed. The default \nis MAXERRORS=50."},"StatementOptionType":"V"},{"StatementOptionName":"NOPRINT","StatementOptionHelp":{"#cdata":"Suppresses the normal printed output but does not suppress error listings. Using any other \nprint option turns the NOPRINT option off. The PRINT option can be used with the RESET \nstatement to turn off NOPRINT."},"StatementOptionType":"S"},{"StatementOptionName":"PRINTALL","StatementOptionHelp":{"#cdata":"Turns on all the printing-control options. The options set by PRINTALL are DETAILS; the model \ninformation options LIST, LISTDEP, LISTDER, XREF, BLOCK, and GRAPH; the FIT task printing \noptions FSRSQ, COVB, CORRB, COVS, CORRS, DW, and COLLIN; and the SOLVE task printing options \nSTATS, THEIL, SOLVEPRINT, and ITPRINT."},"StatementOptionType":"S"},{"StatementOptionName":"TRACE","StatementOptionHelp":{"#cdata":"Prints the result of each operation in each statement in the model program as it is executed, \nin addition to the information printed by the FLOW option. This debugging option is needed \nvery rarely and produces voluminous output."},"StatementOptionType":"S"}],"#comment":[{},{},{},{},{},{}]}},{"StatementName":"ESTIMATE","StatementHelp":{"#cdata":"Syntax: ESTIMATE item < , item ...> < ,/ options > ; \n      \nThe ESTIMATE statement computes estimates of functions of the parameters. \n\nThe ESTIMATE statement refers to the parameters estimated by the associated FIT statement \n(that is, to either the preceding FIT statement or, in the absence of a preceding FIT statement, \nto the following FIT statement). You can use any number of ESTIMATE statements."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"OUTEST=","StatementOptionHelp":{"#cdata":"Specifies the name of the data set in which the estimate of the functions of the parameters \nare to be written. The format for this data set is identical to the OUTEST= data set for \nthe FIT statement. \n\nIf you specify a name in the ESTIMATE statement, that name is used as the parameter name \nfor the estimate in the OUTEST= data set. If no name is provided and the expression is \njust a symbol, the symbol name is used; otherwise, the string \"_Estimate #\" is used, \nwhere \"#\" is the variable number in the OUTEST= data set."},"StatementOptionType":"V"},{"StatementOptionName":"OUTCOV","StatementOptionHelp":{"#cdata":"Writes the covariance matrix of the functions of the parameters to the OUTEST= data set \nin addition to the parameter estimates."},"StatementOptionType":"S"},{"StatementOptionName":"COVB","StatementOptionHelp":{"#cdata":"Prints the covariance matrix of the functions of the parameters."},"StatementOptionType":"S"},{"StatementOptionName":"CORRB","StatementOptionHelp":{"#cdata":"Prints the correlation matrix of the functions of the parameters."},"StatementOptionType":"S"}]}},{"StatementName":"EXOGENOUS|EXOG|EXO","StatementHelp":{"#cdata":"Syntax: EXOGENOUS variable < initial-values > ... ; \n\nThe EXOGENOUS statement declares model variables and identifies them as exogenous. \nYou can declare model variables with an EXOGENOUS statement instead of with a VAR \nstatement to help document the model or to indicate the default instrumental variables.\nThe variables declared exogenous are used as instruments when an instrumental variables \nestimation method is requested (such as N2SLS or N3SLS) and an INSTRUMENTS statement \nis not used. Valid abbreviations for the EXOGENOUS statement are EXOG and EXO. \n\nThe INDEPENDENT statement is equivalent to the EXOGENOUS statement and is provided \nfor the convenience of non-econometric practitioners. \n\nThe EXOGENOUS statement optionally provides initial values for lagged exogenous variables."},"StatementOptions":null},{"StatementName":"INDEPENDENT","StatementHelp":{"#cdata":"Syntax: INDEPENDENT variable < initial-values > ... ; \n\nThe INDEPENDENT statement is equivalent to the EXOGENOUS statement and is provided \nfor the convenience of non-econometric practitioners. \n\nThe EXOGENOUS statement optionally provides initial values for lagged exogenous variables."},"StatementOptions":null},{"StatementName":"ID","StatementHelp":{"#cdata":"Syntax: ID variables ;\n\nThe ID statement specifies variables to identify observations in error messages \nor other listings and in the OUT= data set. The ID variables are normally SAS date \nor datetime variables. If more than one ID variable is used, the first variable is \nused to identify the observations; the remaining variables are added to the OUT= \ndata set."},"StatementOptions":null},{"StatementName":"INCLUDE","StatementHelp":{"#cdata":"Syntax: INCLUDE model-names ... ; \n\nThe INCLUDE statement reads model files and inserts their contents into the current model. \nHowever, instead of replacing the current model as the RESET MODEL= option does, the contents \nof included model files are inserted into the model program at the position that the INCLUDE \nstatement appears."},"StatementOptions":null},{"StatementName":"INSTRUMENTS","StatementHelp":{"#cdata":"Syntax: INSTRUMENTS <variables-list> < _EXOG_ > < EXCLUDE =( parameters ) > < / options > ; \n  INSTRUMENTS variables < _EXOG_ > ;  \n  INSTRUMENTS (equation, variables) (equation, variables) ... ; \n\nThe INSTRUMENTS statement specifies the instrumental variables to be used in the N2SLS, N3SLS,   \nIT2SLS, IT3SLS, GMM, and ITGMM estimation methods. There are three ways of specifying the INSTRUMENTS \nstatement. \n\nThe first form of the INSTRUMENTS statement is used only after the FIT statement and before the \nnext RUN statement. The items specified as instruments for the second form can be variables, names \nof parameters to be estimated, or the special keyword _EXOG_.  The keyword _EXOG_ indicates that all \nthe model variables declared EXOGENOUS are to be added to the instruments list. \n\nThe second form of the INSTRUMENTS statement is declared before a FIT statement and defines \nthe default instruments list. The items specified as instruments can be variables or the special \nkeyword _EXOG_. If a single INSTRUMENTS statement of the second form is declared before multiple \nFIT statements, then it serves as the default instruments list for each of the FIT statements. \nHowever, if any of these FIT statements are followed by separate INSTRUMENTS statement, then the \nlatter take precedence over the default list. Hence, in the case of multiple FIT statements, the \nINSTRUMENTS statement for a particular FIT statement is written below the FIT statement if instruments \nother than the default are required. For a single FIT statement, you can declare the INSTRUMENTS \nstatement of the second form either preceding or following the FIT statement. \n\nA third form of the INSTRUMENTS statement is used to specify instruments for each equation. No \nexplicit intercept is added, parameters cannot be specified to represent instruments, and the \n_EXOG_ keyword is not allowed. Equations not explicitly assigned instruments use all the instruments \nspecified for the other equations as well as instruments not assigned specific equations."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"_EXOG_","StatementOptionHelp":{"#cdata":"The keyword _EXOG_ indicates that all the model variables declared EXOGENOUS are to be added \nto the instruments list."},"StatementOptionType":"RS"},{"StatementOptionName":"EXCLUDE=","StatementOptionHelp":{"#cdata":"[Syntax: EXCLUDE=(parameters)] \n          \nSpecifies that the derivatives of the equations with respect to all of the parameters to \nbe estimated (except the parameters listed in the EXCLUDE list) be used as instruments, in  \naddition to the other instruments specified. If you use the EXCLUDE= option, you should be \nsure that the derivatives with respect to the nonexcluded parameters in the estimation are \nindependent of the endogenous variables and not functions of the parameters estimated."},"StatementOptionType":"RV"},{"StatementOptionName":"NOINTERCEPT|NOINT","StatementOptionHelp":{"#cdata":"Excludes the constant of 1.0 (intercept) from the instruments list. An intercept is included \nas an instrument while using the first or second form of the INSTRUMENTS statement unless \nNOINTERCEPT is specified. \n\nWhen a FIT statement specifies an instrumental variables estimation method and no \nINSTRUMENTS statement accompanies the FIT statement, the default instruments are \nused. If no default instruments list has been specified, all the model variables \ndeclared EXOGENOUS are used as instruments."},"StatementOptionType":"S"},{"StatementOptionName":"INTONLY","StatementOptionHelp":{"#cdata":"Specifies that only the intercept be used as an instrument. This option is used for GMM \nestimation where the moments have been specified explicitly."},"StatementOptionType":"S"}]}},{"StatementName":"MOMENT","StatementHelp":{"#cdata":"Syntax: MOMENT variables = moment specification ; \n\nIn many scenarios, endogenous variables are observed from data. From the models, you can \nsimulate these endogenous variables based on a fixed set of parameters. The goal of simulated \nmethod of moments (SMM) is to find a set of parameters such that the moments of the simulated \ndata match the moments of the observed variables. If there are many moments to match, the code \nmight be tedious. The following MOMENT statement provides a way to generate some commonly used \nmoments automatically. Multiple MOMENT statements can be used. \nvariables can be one or more endogenous variables. \n\nmoment specification can have the following four types: \n\n  o ( number list ) specifies that the endogenous variable is raised to the power specified by \n    each number in number list. \n\n  o ABS( number list ) specifies that the absolute value of the endogenous variable is raised to \n    the power specified by each number in number list. \n\n  o LAGnum ( number list ) specifies that the endogenous variable is multiplied by the num th lag \n    of the endogenous variable, and this product is raised to the power specified by each number in \n    number list. \n  o ABS_LAGnum ( number list ) specifies that the endogenous variable is multiplied by the num th \n    lag of the endogenous variable, and the absolute value of this product is raised to the power \n    specified by each number in number list."},"StatementOptions":null},{"StatementName":"OUTVARS|OUTVAR","StatementHelp":{"#cdata":"Syntax: OUTVARS variables ; \n\nThe OUTVARS statement specifies additional variables defined in the model program to be \noutput to the OUT= data sets. The OUTVARS statement is not needed unless the variables \nto be added to the output data set are not referred to by the model, or unless you want \nto include parameters or other special variables in the OUT= data set. The OUTVARS \nstatement includes additional variables, whereas the KEEP statement excludes variables."},"StatementOptions":null},{"StatementName":"PARAMETERS|PARMS|PARM","StatementHelp":{"#cdata":"Syntax: PARAMETERS variable <value> <variable <value>> ... ; \n      \nThe PARAMETERS statement declares the parameters of a model and optionally sets their initial \nvalues. Valid abbreviations are PARMS and PARM. \n\nEach parameter has a single value associated with it, which is the same for all observations. \nLagging is not relevant for parameters. If a value is not specified in the PARMS statement \n(or by the PARMS= option of a FIT statement), the value defaults to 0.0001 for FIT tasks and \nto a missing value for SOLVE tasks."},"StatementOptions":null},{"StatementName":"RANGE","StatementHelp":{"#cdata":"Syntax: RANGE variable < = first > < TO last > ; \n\nThe RANGE statement specifies the range of observations to be read from the DATA= data set. \nFor FIT tasks, the RANGE statement controls the period of fit for the estimation. For SOLVE \ntasks, the RANGE statement controls the simulation period or forecast horizon. \n\nThe RANGE variable must be a numeric variable in the DATA= data set that identifies the \nobservations, and the data set must be sorted by the RANGE variable. The first observation \nin the range is identified by first, and the last observation is identified by last."},"StatementOptions":{"StatementOption":{"StatementOptionName":"TO","StatementOptionHelp":{"#cdata":"Syntax: RANGE variable < = first > < TO last > ;  \n          \nSeparates the first and last observations in the range."},"StatementOptionType":"S"}}},{"StatementName":"RESET","StatementHelp":{"#cdata":"Syntax: RESET options ; \n\nAll of the options of the PROC MODEL statement can be reset by the RESET statement. \nIn addition, the RESET statement supports one additional option: \n\nPURGE \ndeletes the current model so that a new model can be defined."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"PURGE","StatementOptionHelp":{"#cdata":"Deletes the current model so that a new model can be defined."},"StatementOptionType":"S"},{"StatementOptionName":"DATA=","StatementOptionHelp":{"#cdata":"[Syntax: DATA=SAS-data-set] \n      \nNames the input data set. Variables in the model program are looked up in the DATA= data set \nand, if found, their attributes (type, length, label, format) are set to be the same as those \nin the input data set (if not previously defined otherwise). The values for the variables in \nthe program are read from the input data set when the model is estimated or simulated by FIT \nand SOLVE statements. "},"StatementOptionType":"DV"},{"StatementOptionName":"OUTPARMS=","StatementOptionHelp":{"#cdata":"[Syntax: OUTPARMS=SAS-data-set] \n      \nWrites the parameter estimates to a SAS data set."},"StatementOptionType":"DV"},{"StatementOptionName":"PARMSDATA=","StatementOptionHelp":{"#cdata":"[Syntax: PARMSDATA=SAS-data-set] \n      \nNames the SAS data set that contains the parameter estimates. In PROC MODEL, you have several \noptions to specify starting values for the parameters to be estimated. When more than one option \nis specified, the options are implemented in the following order of precedence (from highest to \nlowest): the START= option, the PARMS statement initialization value, the ESTDATA= option, and \nthe PARMSDATA= option. If no options are specified for the starting value, the default value of \n0.0001 is used."},"StatementOptionType":"DV"},{"StatementOptionName":"PLOTS=","StatementOptionHelp":{"#cdata":"Syntax: PLOTS=global-plot-options | plot-request \n      \nRequests that the MODEL procedure produce statistical graphics via the Output Delivery System, \nprovided that the ODS GRAPHICS statement has been specified. The global-plot-options apply to \nall relevant plots generated by the MODEL procedure. The global-plot-options supported by the MODEL procedure follow. \n\n  ONLY \n  suppresses the default plots. Only the plots specifically requested are produced. \n\n  UNPACKPANEL \n  breaks a graphic that is otherwise paneled into individual component plots."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"ALL","@Value2":"ACF","@Value3":"IACF","@Value4":"PACF","@Value5":"FITPLOT","@Value6":"COOKSD","@Value7":"QQ","@Value8":"RESIDUAL|RES","@Value9":"STUDENTRESIDUAL","@Value10":"RESIDUALHISTOGRAM |RESIDHISTOGRAM","@Value11":"NONE"},"StatementOptionToolTips":{"@ToolTip1":"Requests that all plots appropriate for the particular analysis be produced.","@ToolTip2":"Produces the autocorrelation function plot.","@ToolTip3":"Produces the inverse autocorrelation function plot of residuals.","@ToolTip4":"Produces the partial autocorrelation function plot of residuals.","@ToolTip5":"Plots the predicted and actual values.","@ToolTip6":"Produces the Cook\u2019s D plot.","@ToolTip7":"Produces a QQ plot of residuals.","@ToolTip8":"Plots the residuals.","@ToolTip9":"Plots the studentized residuals.","@ToolTip10":"Plots the histogram of residuals.","@ToolTip11":"Suppresses all plots."}},{"StatementOptionName":"MODEL=","StatementOptionHelp":{"#cdata":"[Syntax: MODEL=model-name | (model-list)] \n      \nReads the model from one or more input model files created by previous PROC MODEL executions. \nModel files are written by the OUTMODEL= option."},"StatementOptionType":"V"},{"StatementOptionName":"NOSTORE","StatementOptionHelp":{"#cdata":"Suppresses the default output of the model file. This option is applicable only when FIT or SOLVE \nstatements are not used, the MODEL= option is not used, and when a model is specified."},"StatementOptionType":"S"},{"StatementOptionName":"OUTMODEL=","StatementOptionHelp":{"#cdata":"[Syntax: OUTMODEL=model-name] \n      \nSpecifies the name of an output model file to which the model is to be written. \nStarting with SAS 9.2, model files are being stored as XML-based SAS data sets \ninstead of being stored as members of a SAS catalog as in earlier releases. This \nmakes MODEL files more readily extendable in the future and enables Java-based \napplications to read the MODEL files directly. To change this behavior, use the \nSAS global-CMPMODEL-options. You can choose the format in which the output model \nfile is stored and read by using the CMPMODEL=global-CMPMODEL-options in an \nPTIONS statement as follows. \n\n  OPTIONS CMPMODEL=global-CMPMODEL-option;"},"StatementOptionType":"V"},{"StatementOptionName":"BLOCK","StatementOptionHelp":{"#cdata":"Prints an analysis of the structure of the model given by the assignments to model variables \nappearing in the model program. This analysis includes a classification of model variables \ninto endogenous (dependent) and exogenous (independent) groups based on the presence of the \nvariable on the left-hand side of an assignment statement. The endogenous variables are \ngrouped into simultaneously determined blocks. The dependency structure of the simultaneous\nblocks and exogenous variables is also printed. The BLOCK option cannot analyze dependencies \nimplied by general form equations."},"StatementOptionType":"S"},{"StatementOptionName":"GRAPH","StatementOptionHelp":{"#cdata":"Prints the graph of the dependency structure of the model. The GRAPH option also invokes \nthe BLOCK option and produces a graphical display of the information listed by the BLOCK \noption."},"StatementOptionType":"S"},{"StatementOptionName":"LIST","StatementOptionHelp":{"#cdata":"prints the model program and variable lists, including the statements added by PROC MODEL \nand macros."},"StatementOptionType":"S"},{"StatementOptionName":"LISTALL","StatementOptionHelp":{"#cdata":"Selects the LIST, LISTDEP, LISTDER, and LISTCODE options."},"StatementOptionType":"S"},{"StatementOptionName":"LISTCODE","StatementOptionHelp":{"#cdata":"Prints the derivative tables and compiled model program code. LISTCODE is a debugging feature \nand is not normally needed."},"StatementOptionType":"S"},{"StatementOptionName":"LISTDEP","StatementOptionHelp":{"#cdata":"Prints a report that lists for each variable in the model program the variables that depend \non it and that it depends on. These lists are given separately for current-period values \nand for lagged values of the variables. \n\nThe information displayed is the same as that used to construct the BLOCK report but differs \nin that the information is listed for all variables (including parameters, control variables, \nand program variables), not just for the model variables. Classification into endogenous and \nexogenous groups and analysis of simultaneous structure is not done by the LISTDEP report."},"StatementOptionType":"S"},{"StatementOptionName":"LISTDER","StatementOptionHelp":{"#cdata":"Prints a table of derivatives for FIT and SOLVE tasks. (The LISTDER option is applicable only \nfor the default NEWTON method for SOLVE tasks.) The derivatives table shows each nonzero \nderivative computed for the problem. The derivative listed can be a constant, a variable \nin the model program, or a special derivative variable created to hold the result of the \nderivative expression. This option is turned on by the LISTCODE and PRINTALL options."},"StatementOptionType":"S"},{"StatementOptionName":"XREF","StatementOptionHelp":{"#cdata":"Prints a cross-reference of the variables in the model program that shows where each variable \nwas referenced or given a value. The XREF option is normally used in conjunction with the \nLIST option."},"StatementOptionType":"S"},{"StatementOptionName":"DETAILS","StatementOptionHelp":{"#cdata":"Specifies the detailed printout. Parts of the printed output are expanded when the DETAILS \noption is specified. If ODS GRAPHICS ON is specified, the following additional graphs of \nthe residuals are produced: ACF, PACF, IACF, white noise, and QQ plot versus the normal."},"StatementOptionType":"S"},{"StatementOptionName":"FLOW","StatementOptionHelp":{"#cdata":"Prints a message for each statement in the model program as it is executed. This debugging \noption is needed very rarely and produces voluminous output."},"StatementOptionType":"S"},{"StatementOptionName":"MAXERRORS=","StatementOptionHelp":{"#cdata":"[Syntax: MAXERRORS=n] \n      \nSpecifies the maximum number of execution errors that can be printed. The default \nis MAXERRORS=50."},"StatementOptionType":"V"},{"StatementOptionName":"NDEC=","StatementOptionHelp":{"#cdata":"[Syntax: NDEC=n] \n      \nSpecifies the precision of the format that PROC MODEL uses when printing various numbers. \nThe default is NDEC=3, which means that PROC MODEL attempts to print values by using the \nD format but ensures that at least three significant digits are shown. If the NDEC= value \nis greater than nine, the BEST. format is used. The smallest value allowed is NDEC=2. \n\nThe NDEC= option affects the format of most, but not all, of the floating point numbers \nthat PROC MODEL can print. For some values (such as parameter estimates), a precision \nlimit one or two digits greater than the NDEC= value is used. This option does not apply \nto the precision of the variables in the output data set."},"StatementOptionType":"V"},{"StatementOptionName":"NOPRINT","StatementOptionHelp":{"#cdata":"Suppresses the normal printed output but does not suppress error listings. Using any other \nprint option turns the NOPRINT option off. The PRINT option can be used with the RESET \nstatement to turn off NOPRINT."},"StatementOptionType":"S"},{"StatementOptionName":"PRINTALL","StatementOptionHelp":{"#cdata":"Turns on all the printing-control options. The options set by PRINTALL are DETAILS; the model \ninformation options LIST, LISTDEP, LISTDER, XREF, BLOCK, and GRAPH; the FIT task printing \noptions FSRSQ, COVB, CORRB, COVS, CORRS, DW, and COLLIN; and the SOLVE task printing options \nSTATS, THEIL, SOLVEPRINT, and ITPRINT."},"StatementOptionType":"S"},{"StatementOptionName":"TRACE","StatementOptionHelp":{"#cdata":"Prints the result of each operation in each statement in the model program as it is executed, \nin addition to the information printed by the FLOW option. This debugging option is needed \nvery rarely and produces voluminous output."},"StatementOptionType":"S"},{"StatementOptionName":"MEMORYUSE","StatementOptionHelp":{"#cdata":"Prints a report of the memory required for the various parts of the analysis."},"StatementOptionType":"S"}]}},{"StatementName":"RESTRICT","StatementHelp":{"#cdata":"Syntax: RESTRICT restriction1 < , restriction2 ...> ; \n\nThe RESTRICT statement is used to impose linear and nonlinear restrictions on the \nparameter estimates. \n\nRESTRICT statements refer to the parameters estimated by the associated FIT statement \n(that is, to either the preceding FIT statement or, in the absence of a preceding FIT \nstatement, to the following FIT statement). You can specify any number of RESTRICT \nstatements. \n\nEach restriction is written as an optional name, followed by an expression, followed \nby an equality operator (=) or an inequality operator (<, >, <=, >=), followed by a \nsecond expression: \n\n< \"name\" > expression operator expression \n\nThe optional \"name\" is a string used to identify the restriction in the printed output \nand in the OUTEST= data set. The operator can be =, <, >, <= , or >=. The operator and \nsecond expression are optional."},"StatementOptions":null},{"StatementName":"SOLVE","StatementHelp":{"#cdata":"Syntax: SOLVE variables <SATISFY= equations> </options> ; \n\nThe SOLVE statement specifies that the model be simulated or forecast for input data \nvalues and, optionally, selects the variables to be solved. If the list of variables \nis omitted, all of the model variables declared ENDOGENOUS are solved. If no model \nvariables are declared ENDOGENOUS, then all model variables are solved. \n\n(SOLVE statement options are not currently supported for autocompletion.)"},"StatementOptions":{"StatementOption":{"StatementOptionName":"SATISFY=","StatementOptionHelp":{"#cdata":"Syntax: SATISFY=equation | SATISFY=( equations ) \n          \nSpecifies a subset of the model equations that the solution values are to satisfy. \nIf the SATISFY= option is not used, the solution is computed to satisfy all the model \nequations. Note that the number of equations must equal the number of variables solved."},"StatementOptionType":"RV"}}},{"StatementName":"NUMBER","StatementHelp":{"#cdata":"Syntax: NUMBER parameter-decl [, ...parameter-decl] ;\n\nDeclaration of parameters that have a NUMBER type."},"StatementOptions":{"StatementOption":{"StatementOptionName":"INIT","StatementOptionHelp":{"#cdata":"[Syntax: INIT expression] \n          \nSpecifies a default value that is used when a parameter value is required but no other value \nhas been supplied."},"StatementOptionType":"S"}}},{"StatementName":"TEST","StatementHelp":{"#cdata":"Syntax: TEST <\"name\"> test1 <, test2 ...> <,/ options > ; \n      \nThe TEST statement performs tests of nonlinear hypotheses on the model parameters. \n\nThe TEST statement applies to the parameters estimated by the associated FIT statement \n(that is, either the preceding FIT statement or, in the absence of a preceding FIT statement, \nthe following FIT statement). You can specify any number of TEST statements."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"WALD","StatementOptionHelp":{"#cdata":"Specifies that a Wald test be computed. WALD is the default."},"StatementOptionType":"S"},{"StatementOptionName":"LM|RAO|LGRANGE","StatementOptionHelp":{"#cdata":"Specifies that a Lagrange multiplier test be computed."},"StatementOptionType":"S"},{"StatementOptionName":"LR|LIKE","StatementOptionHelp":{"#cdata":"Specifies that a likelihood ratio test be computed."},"StatementOptionType":"S"},{"StatementOptionName":"ALL","StatementOptionHelp":{"#cdata":"Requests all three types of tests."},"StatementOptionType":"S"},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"[Syntax: OUT=SAS-data-set] \n          \nSpecifies the name of an output SAS data set that contains the test results. The format of the \nOUT= data set produced by the TEST statement is similar to that of the OUTEST= data set produced \nby the FIT statement."},"StatementOptionType":"V"}]}},{"StatementName":"VAR|VARS","StatementHelp":{"#cdata":"Syntax: VAR variables <initial-values> ... ; \n      \nThe VAR statement declares model variables and optionally provides initial values \nfor the lags of the variables."},"StatementOptions":null},{"StatementName":"WEIGHT|WGT","StatementHelp":{"#cdata":"Syntax: WEIGHT variable ; \n      \nThe WEIGHT statement specifies a variable to supply weighting values to use for each \nobservation in estimating parameters. \n\nIf the weight of an observation is nonpositive, that observation is not used for the \nestimation. variable must be a numeric variable in the input data set. \n\nAn alternative weighting method is to use an assignment statement to give values to the \nspecial variable _WEIGHT_. The _WEIGHT_ variable must not depend on the parameters being \nestimated. If both weighting specifications are given, the weights are multiplied together."},"StatementOptions":null},{"StatementName":"CALL","StatementHelp":{"#cdata":"Syntax: CALL name ( argument-1 [, ...argument-n] );\n\nThe CALL statement invokes the named library subroutine. The values that are determined for \neach argument expression are passed to the subroutine when the subroutine is invoked. The \nsubroutine can update the values of PROC OPTMODEL parameters and variables when an argument \nis an identifier-expression."},"StatementOptions":null},{"StatementName":"DROP","StatementHelp":{"#cdata":"Syntax: DROP variable ... ; \n      \nExcludes variables from output SAS data sets."},"StatementOptions":null},{"StatementName":"PUT","StatementHelp":{"#cdata":"Syntax: PUT print-item ...< @ > < @@ > ;\n\nThe PUT statement writes text data to the current output file."},"StatementOptions":{"StatementOption":{"StatementOptionName":"_PAGE_","StatementOptionHelp":{"#cdata":"Outputs any pending line data and moves to the top of the next page."},"StatementOptionType":"S"}}},{"StatementName":"KEEP","StatementHelp":{"#cdata":"Syntax: KEEP variable-list ; \n\nThe KEEP statement specifies which variables are to be included in the analysis and/or output."},"StatementOptions":null},{"StatementName":"STOP","StatementHelp":{"#cdata":"Syntax: STOP ;\n\nThe STOP statement halts the execution of all statements that contain it, including \nDO statements and other control or looping statements. Execution continues with the \nnext top-level source statement."},"StatementOptions":null},{"StatementName":"ABORT","StatementHelp":{"#cdata":"Syntax: ABORT <ABEND | CANCEL <FILE> | RETURN | > <n> <NOLIST>; \n      \nStops executing the current DATA step, SAS job, or SAS session."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ABEND","StatementOptionHelp":{"#cdata":"Causes abnormal termination of the current SAS job or session. Results depend on the method \nof operation: \n\no batch mode and noninteractive mode \n\n  o stops processing immediately\n  o sends an error message to the SAS log that states that execution was terminated by the ABEND option \n    of the ABORT macro statement\n  o does not execute any subsequent statements or check syntax\n  o returns control to the operating environment; further action is based on how your operating environment \n    and your site treat jobs that end abnormally.\n\no windowing environment and interactive line mode \n\n  o causes your windowing environment and interactive line mode to stop processing immediately \n    and return you to your operating environment."},"StatementOptionType":"S"},{"StatementOptionName":"CANCEL","StatementOptionHelp":{"#cdata":"Causes the cancellation of the current submitted statements. The results depend on the method \nof operation:\n\no batch mode and noninteractive mode\n\n  o The entire SAS program and SAS system are terminated.\n  o The error message is written to the SAS log.\n\no windowing environment and interactive line mode \n\n  o It only clears the current submitted program.\n  o Other subsequent submitted programs are not affected.\n  o The error message is written to the SAS log.\n\no workspace server and stored process server \n\n  o It only clears currently submitted program.\n  o Other subsequent submit calls are not affected.\n  o The error message is written to the SAS log.\n\no SAS IntrNet application server \n\n  o A separate execution is created for each request. The execution submits the request code. A CANCEL \n    argument in the request code clears the current submitted code but does not terminate the execution \n    of the SAS session."},"StatementOptionType":"S"},{"StatementOptionName":"CANCEL FILE","StatementOptionHelp":{"#cdata":"Causes only the contents of the autoexec file or %INCLUDE file to be cleared by the %ABORT statement. \nOther submitted source statements will be executed after the autoexec or %INCLUDE file."},"StatementOptionType":"S"},{"StatementOptionName":"RETURN","StatementOptionHelp":{"#cdata":"Causes abnormal termination of the current SAS job or session. Results depend on the method \nof operation: \n\no batch mode and noninteractive mode \n\n  o stops processing immediately\n  o sends an error message to the SAS log that states that execution was terminated by the RETURN option \n    in the ABORT macro statement\n  o does not execute any subsequent statements or check syntax\n  o returns control to the operating environment with a condition code indicating an error.\n\no windowing environment and interactive line mode \n\n  o causes your windowing environment and interactive line mode to stop processing immediately \n    and return you to your operating environment."},"StatementOptionType":"S"},{"StatementOptionName":"NOLIST","StatementOptionHelp":{"#cdata":"suppresses the output of all variables to the SAS log."},"StatementOptionType":"S"}]}},{"StatementName":"ARRAY","StatementHelp":{"#cdata":"Syntax: ARRAY array-name { subscript } <$><length> \n  <array-elements> <(initial-value-list)>; \n  \nDefines the elements of an array."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"_ALL_","StatementOptionHelp":{"#cdata":"Specifies all variables."},"StatementOptionType":"S"},{"StatementOptionName":"_TEMPORARY_","StatementOptionHelp":{"#cdata":"Creates a list of temporary data elements."},"StatementOptionType":"S"},{"StatementOptionName":"_NUMERIC_","StatementOptionHelp":{"#cdata":"Specifies all numeric variables."},"StatementOptionType":"S"},{"StatementOptionName":"_CHARACTER_","StatementOptionHelp":{"#cdata":"Specifies all character variables."},"StatementOptionType":"S"}]}},{"StatementName":"ATTRIB","StatementHelp":{"#cdata":"Syntax: ATTRIB variable-list(s) attribute-list(s) ; \n      \nAssociates a format, informat, label, and length with one or more variables."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"FORMAT=","StatementOptionHelp":{"#cdata":"[Syntax: FORMAT=format] \n          \nAssociates a format with variables in a variable-list."},"StatementOptionType":"V"},{"StatementOptionName":"INFORMAT=","StatementOptionHelp":{"#cdata":"[Syntax: INFORMAT=informat] \n          \nAssociates an informat with variables in a variable-list."},"StatementOptionType":"V"},{"StatementOptionName":"LABEL=","StatementOptionHelp":{"#cdata":"[Syntax: LABEL='label'] \n          \nAssociates a label with variables in a variable-list."},"StatementOptionType":"V"},{"StatementOptionName":"LENGTH=","StatementOptionHelp":{"#cdata":"[Syntax: LENGTH=<$>length] \n          \nSpecifies the length of variables in a variable-list."},"StatementOptionType":"V"},{"StatementOptionName":"TRANSCODE=","StatementOptionHelp":{"#cdata":"Specifies whether character variables can be transcoded."},"StatementOptionType":"V","StatementeOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that character variables can be transcoded.","@ToolTip2":"Suppresses transcoding."}}]}},{"StatementName":"DELETE","StatementHelp":{"#cdata":"Syntax: DELETE; \n      \nStops processing the current observation."},"StatementOptions":null},{"StatementName":"DO","StatementHelp":{"#cdata":"Specifies a group of statements to be executed as a unit.\n      \nSyntax: \n(1) DO; \n...more SAS statements...  \nEND;  \n\n(2) DO index-variable=specification-1 <, ... specification-n>; \n... more SAS statements ...  \nEND;  \n\n(3) DO UNTIL (expression); \n...more SAS statements...  \nEND \n\n(4) DO WHILE (expression); \n...more SAS statements...  \nEND;"},"StatementOptions":{"StatementOption":[{"StatementOptionName":"UNTIL","StatementOptionHelp":{"#cdata":"Executes statements in a DO loop repetitively until a condition is true.\n          \nSyntax: \nDO UNTIL (expression); \n...more SAS statements...  \nEND"},"StatementOptionType":"S"},{"StatementOptionName":"WHILE","StatementOptionHelp":{"#cdata":"Executes statements in a DO-loop repetitively while a condition is true. \n          \nSyntax: \nDO WHILE (expression); \n...more SAS statements...  \nEND;"},"StatementOptionType":"S"},{"StatementOptionName":"OVER","StatementOptionType":"S"},{"StatementOptionName":"TO","StatementOptionHelp":{"#cdata":"Separates the start and stop integers or expressions that control the number of times the \nportion of the DATA step between the iterative DO and END statements is processed."},"StatementOptionType":"S"},{"StatementOptionName":"BY","StatementOptionHelp":{"#cdata":"Precedes an increment integer (other than 0) or an expression that generates an integer to be \nadded to the value of the index variable in each iteration of the DO loop."},"StatementOptionType":"S"}]}},{"StatementName":"END","StatementHelp":{"#cdata":"Syntax: END; \n      \nEnds a DO group or SELECT group processing."},"StatementOptions":null},{"StatementName":"GOTO","StatementHelp":{"#cdata":"Syntax: GOTO label;\n      \nJumps to a new statement."},"StatementOptions":null},{"StatementName":"IF","StatementHelp":{"#cdata":"Executes a SAS statement for observations that meet specific conditions. \n\nSyntax: \n(1) IF expression THEN statement; \n    <ELSE statement;> \n(2) IF condition;"},"StatementOptions":{"StatementOption":[{"StatementOptionName":"THEN","StatementOptionHelp":{"#cdata":"If the conditions that are specified in the IF clause are met, the IF-THEN statement executes a SAS \nstatement for observations that are read from a SAS data set, for records in an external file, or \nfor computed values."},"StatementOptionType":"S"},{"StatementOptionName":"DO","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct."},"StatementOptionType":"S"},{"StatementOptionName":"WHEN","StatementOptionHelp":{"#cdata":"WHEN statement in an IF-THEN-WHEN construct."},"StatementOptionType":"S"},{"StatementOptionName":"OUTPUT","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct."},"StatementOptionType":"S"},{"StatementOptionName":"GO TO|GOTO","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct. \n          \nSyntax: ... GO TO label; | ... GOTO label;\n      \nJumps to a new statement."},"StatementOptionType":"S"},{"StatementOptionName":"PUT","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct."},"StatementOptionType":"S"},{"StatementOptionName":"STOP","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct. \n          \nStops execution of the current DATA step."},"StatementOptionType":"S"},{"StatementOptionName":"SET","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct.\n          \nSyntax: SET <SAS-data-set(s) <(data-set-options(s) )>>; \n      \nReads an observation from one or more SAS data sets."},"StatementOptionType":"S"},{"StatementOptionName":"NOT","StatementOptionType":"S"},{"StatementOptionName":"OR","StatementOptionType":"S"},{"StatementOptionName":"AND","StatementOptionType":"S"}],"#comment":{}}},{"StatementName":"ELSE","StatementHelp":{"#cdata":"If the condition in an IF-THEN statement is false and an ELSE statement is present, \nthen the ELSE action is carried out."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"THEN","StatementOptionHelp":{"#cdata":"If the conditions that are specified in the IF clause are met, the IF-THEN statement executes a SAS \nstatement for observations that are read from a SAS data set, for records in an external file, or \nfor computed values."},"StatementOptionType":"S"},{"StatementOptionName":"IF","StatementOptionHelp":{"#cdata":"Executes a SAS statement for observations that meet specific conditions."},"StatementOptionType":"S"},{"StatementOptionName":"DO","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN-ELSE construct."},"StatementOptionType":"S"},{"StatementOptionName":"OUTPUT","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN-ELSE construct."},"StatementOptionType":"S"},{"StatementOptionName":"NOT","StatementOptionType":"S"},{"StatementOptionName":"OR","StatementOptionType":"S"},{"StatementOptionName":"AND","StatementOptionType":"S"}],"#comment":{}}},{"StatementName":"LABEL","StatementHelp":{"#cdata":"Assigns descriptive labels to variables.\n      \nSyntax: \n(1) LABEL variable-1=label-1 ... <variable-n=label-n>;  \n\n(2) LABEL variable-1=' ' ... <variable-n=' '>;"},"StatementOptions":null},{"StatementName":"LENGTH","StatementHelp":{"#cdata":"Syntax: LENGTH variable-list <$> length ...<DEFAULT=length > ;\n      \nSpecifies the number of bytes for storing variables."},"StatementOptions":{"StatementOption":{"StatementOptionName":"DEFAULT=","StatementOptionHelp":{"#cdata":"[Syntax: DEFAULT=n] \n          \nChanges the default number of bytes that SAS uses to store the values of any newly created \nnumeric variables."},"StatementOptionType":"V"}}},{"StatementName":"LINK","StatementHelp":{"#cdata":"Syntax: LINK statement-label; \n      \nDirects program execution immediately to the statement label that is specified and, if followed \nby a RETURN statement, returns execution to the statement that follows the LINK statement."},"StatementOptions":null},{"StatementName":"RENAME","StatementHelp":{"#cdata":"Syntax: RENAME old-name-1=new-name-1 ... <old-name-n=new-name-n>; \n      \nSpecifies new names for variables in output SAS data sets. "},"StatementOptions":null},{"StatementName":"RETAIN","StatementHelp":{"#cdata":"Syntax: RETAIN variable-list1 value1 < variable-list2 value2 ...> ;\n      \nCauses a variable that is created by an INPUT or assignment statement to retain its value from \none iteration to the next."},"StatementOptions":null},{"StatementName":"RETURN","StatementHelp":{"#cdata":"Syntax: RETURN; \n      \nStops executing statements at the current point in the DATA step and returns to a predetermined \npoint in the step."},"StatementOptions":null},{"StatementName":"SELECT","StatementHelp":{"#cdata":"Executes one of several statements or groups of statements.\n      \nSyntax: \nSELECT <(select-expression)>;  \n  WHEN-1 (when-expression-1 <..., when-expression-n>) statement;  \n    <... WHEN-n (when-expression-1 <..., when-expression-n>) statement;>  \n      <OTHERWISE statement;> \nEND;"},"StatementOptions":null},{"StatementName":"WHEN","StatementHelp":{"#cdata":"SELECT groups contain WHEN statements that identify SAS statements that are executed when a particular \ncondition is true. Use at least one WHEN statement in a SELECT group.\n      \nSyntax: WHEN-1 (when-expression-1 <..., when-expression-n>) statement; "},"StatementOptions":{"StatementOption":{"StatementOptionName":"DO","StatementOptionType":"S"}}},{"StatementName":"OTHERWISE","StatementHelp":{"#cdata":"An optional OTHERWISE statement specifies a statement to be executed if no WHEN condition is met. \nAn END statement ends a SELECT group.\n\n      \nSyntax: \n  <... WHEN-n (when-expression-1 <..., when-expression-n>) statement;>  \n    <OTHERWISE statement;>"},"StatementOptions":null}]}}}