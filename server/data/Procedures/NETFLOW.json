{"Procedure":{"Name":"NETFLOW","ProductGroup":"SAS/OR","ProcedureHelp":{"#cdata":"Syntax: PROC NETFLOW options ; \n    CAPACITY variable ; \n    COEF variables ; \n    COLUMN variable ; \n    CONOPT; \n    COST variable ; \n    DEMAND variable ; \n    HEADNODE variable ; \n    ID variables ; \n    LO variable ; \n    NAME variable ; \n    NODE variable ; \n    PIVOT; \n    PRINT options ; \n    QUIT; \n    RESET options ; \n    RHS variables ; \n    ROW variables ; \n    RUN; \n    SAVE options ; \n    SHOW options ; \n    SUPDEM variable ; \n    SUPPLY variable ; \n    TAILNODE variable ; \n    TYPE variable ; \n    VAR variables ; \n\nConstrained network models can be used to describe a wide variety of real-world applications \nranging from production, inventory, and distribution problems to financial applications. These \nproblems can be solved with the NETFLOW procedure. \n\nThese models are conceptually easy since they are based on network diagrams that represent \nthe problem pictorially. PROC NETFLOW accepts the network specification in a format that is \nparticularly suited to networks. This not only simplifies problem description but also aids \nin the interpretation of the solution."},"ProcedureOptions":{"ProcedureOption":[{"ProcedureOptionName":"ARCDATA=","ProcedureOptionHelp":{"#cdata":"[Syntax: ARCDATA=SAS-data-set] \n      \nNames the data set that contains arc and, optionally, nonarc variable information and nodal \nsupply/demand data. The ARCDATA= data set must be specified in all PROC NETFLOW statements."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"ARCOUT=|AOUT=","ProcedureOptionHelp":{"#cdata":"[Syntax: ARCOUT=SAS-data-set] \n      \nNames the output data set that receives all arc and nonarc variable data, including flows or \nvalues, and other information concerning the unconstrained optimal solution."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"CONDATA=","ProcedureOptionHelp":{"#cdata":"[Syntax: CONDATA=SAS-data-set] \n      \nNames the data set that contains the side constraint data. The data set can also contain other \ndata such as arc costs, capacities, lower flow bounds, nonarc variable upper and lower bounds, \nand objective function coefficients."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"CONOUT=|COUT=","ProcedureOptionHelp":{"#cdata":"[Syntax: CONOUT=SAS-data-set] \n      \nNames the output data set that receives an optimal primal solution to the problem obtained by \nperforming optimization that considers the side constraints."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"COUT=","ProcedureOptionHelp":{"#cdata":"[Syntax: COUT=SAS-data-set] \n      \nNames the output data set that receives an optimal primal solution to the problem obtained by \nperforming optimization that considers the side constraints."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"DUALOUT=|DOUT=","ProcedureOptionHelp":{"#cdata":"[Syntax: DUALOUT=SAS-data-set] \n      \nNames the output data set that receives an optimal dual solution to the problem obtained by \nperforming optimization that considers the side constraints."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"NODEDATA=|DUALIN=","ProcedureOptionHelp":{"#cdata":"[Syntax: NODEDATA=SAS-data-set] \n      \nNames the data set that contains the node supply and demand specifications."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"NODEOUT=","ProcedureOptionHelp":{"#cdata":"[Syntax: NODEOUT=SAS-data-set] \n      \nNames the output data set that receives all information about nodes (supply and demand and \nnodal dual variable values) and other information concerning the optimal solution found by \nthe optimizer when neglecting side constraints."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"MPSOUT=","ProcedureOptionHelp":{"#cdata":"[Syntax: MPSOUT=SAS-data-set] \n      \nNames the SAS data set that contains converted sparse or dense format input data in MPS format."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"ALLART","ProcedureOptionHelp":{"#cdata":"Indicates that PROC NETFLOW uses an all artificial initial solution instead of the default good \npath method for determining an initial solution."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"ARCS_ONLY_ARCDATA","ProcedureOptionHelp":{"#cdata":"Indicates that data for only arcs are in the ARCDATA= data set."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"ARC_SINGLE_OBS","ProcedureOptionHelp":{"#cdata":"Indicates that for all arcs and nonarc variables, data for each arc or nonarc variable is found \nin only one observation of the ARCDATA= data set."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"BYPASSDIVIDE=|BYPASSDIV=|BPD=","ProcedureOptionHelp":{"#cdata":"[Syntax: BYPASSDIVIDE=b] \n      \nShould be used only when the MAXFLOW option has been specified; that is, PROC NETFLOW is solving \na maximal flow problem."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"BYTES=","ProcedureOptionHelp":{"#cdata":"[Syntax: BYTES=b] \n      \nIndicates the size of the main working memory (in bytes) that PROC NETFLOW will allocate."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"CON_SINGLE_OBS","ProcedureOptionHelp":{"#cdata":"Improves how the CONDATA= data set is read. How it works depends on whether the CONDATA has \na dense or sparse format."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"COREFACTOR=|CF=","ProcedureOptionHelp":{"#cdata":"[Syntax: COREFACTOR=c] \n      \nEnables you to specify the maximum proportion of memory to be used by the arrays frequently \naccessed by PROC NETFLOW. PROC NETFLOW strives to maintain all information required during \noptimization in core."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"DEFCAPACITY=|DC=","ProcedureOptionHelp":{"#cdata":"[Syntax: DEFCAPACITY=c] \n      \nRequests that the default arc capacity and the default nonarc variable value upper bound be c. \nIf this option is not specified, then DEFCAPACITY= INFINITY."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"DEFCONTYPE=|DEFTYPE=|DCT=","ProcedureOptionHelp":{"#cdata":"Specifies the default constraint type. This default constraint type is either less than or equal \nto or is the type indicated by DEFCONTYPE=c."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"LE","@Value2":"EQ","@Value3":"GE"},"ProcedureOptionToolTips":{"@ToolTip1":"For less than or equal to","@ToolTip2":"For equal to","@ToolTip3":"For greater than or equal to"}},{"ProcedureOptionName":"DEFCOST=","ProcedureOptionHelp":{"#cdata":"[Syntax: DEFCOST=c] \n      \nRequests that the default arc cost and the default nonarc variable objective function coefficient \nbe c. If this option is not specified, then DEFCOST=0.0."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"DEFMINFLOW=|DMF=","ProcedureOptionHelp":{"#cdata":"[Syntax: DEFMINFLOW=m] \n      \nRequests that the default lower flow bound through arcs and the default lower value bound of \nnonarc variables be m. If a value is not specified, then DEFMINFLOW=0.0."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"DEMAND=","ProcedureOptionHelp":{"#cdata":"[Syntax: DEMAND=d] \n      \nSpecifies the demand at the SINK node specified by the SINK= option."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"DWIA=","ProcedureOptionHelp":{"#cdata":"[Syntax: DWIA=i] \n      \nControls the initial amount of memory to be allocated to store the LU factors of the working \nbasis matrix. DWIA stands for Dw initial allocation and i is the number of nonzeros and matrix \nrow operations in the LU factors that can be stored in this memory."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"EXCESS=","ProcedureOptionHelp":{"#cdata":"Enables you to specify how to handle excess supply or demand in a network, if it exists."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"ARCS","@Value2":"SLACKS","@Value3":"DEMAND","@Value4":"SUPPLY"},"ProcedureOptionToolTips":{"@ToolTip1":"[For pure networks]--An extra node, referred to as _EXCESS_, is added to the network and  is connected to the actual network by \"excess\" arcs.","@ToolTip2":"[For pure networks]--Slack variables are created for some flow conservation constraints  instead of having the node _EXCESS_ and \"excess\" arcs. The interior point  solver is used and you need to specify the output data set using the CONOUT= data set.","@ToolTip3":"[For generalized networks]--The network has excess demand.","@ToolTip4":"[For generalized networks]--The network has excess supply."}},{"ProcedureOptionName":"GENNET","ProcedureOptionHelp":{"#cdata":"This option is necessary if you need to solve a generalized network flow problem and there are no \narc multipliers specified in the ARCDATA= data set."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"GROUPED=","ProcedureOptionHelp":{"#cdata":"PROC NETFLOW can take a much shorter time to read data if the data have been grouped prior to the \nPROC NETFLOW call."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"ARCDATA","@Value2":"CONDATA","@Value3":"BOTH","@Value4":"NONE"},"ProcedureOptionToolTips":{"@ToolTip1":"Indicates that the ARCDATA= data set has been grouped by values of the NAME list variable.","@ToolTip2":"Indicates that the CONDATA= data set has been grouped.","@ToolTip3":"Indicates that both GROUPED=ARCDATA and GROUPED=CONDATA are TRUE.","@ToolTip4":"Indicates that the data sets have not been grouped."}},{"ProcedureOptionName":"INFINITY=|INF=","ProcedureOptionHelp":{"#cdata":"[Syntax: INFINITY=i] \n      \nIs the largest number used by PROC NETFLOW in computations."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"INF=","ProcedureOptionHelp":{"#cdata":"[Syntax: INF=i] \n      \nIs the largest number used by PROC NETFLOW in computations."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"INTPOINT","ProcedureOptionHelp":{"#cdata":"Indicates that the interior point algorithm is to be used."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"INVD_2D","ProcedureOptionHelp":{"#cdata":"Controls the way in which the inverse of the working basis matrix is stored."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"MAXARRAYBYTES=","ProcedureOptionHelp":{"#cdata":"[Syntax: MAXARRAYBYTES=m] \n      \nSpecifies the maximum number of bytes an individual array can occupy."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"MAXFLOW|MF","ProcedureOptionHelp":{"#cdata":"Specifies that PROC NETFLOW solve a maximum flow problem. In this case, the PROC NETFLOW procedure \nfinds the maximum flow from the node specified by the SOURCE= option to the node specified by the \nSINK= option. PROC NETFLOW automatically assigns an INFINITY= option supply to the SOURCE= option \nnode and the SINK= option is assigned the INFINITY= option demand. In this way, the MAXFLOW option \nsets up a maximum flow problem as an equivalent minimum cost problem."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"MAXIMIZE|MAX","ProcedureOptionHelp":{"#cdata":"Specifies that PROC NETFLOW find the maximum cost flow through the network."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"MEMREP","ProcedureOptionHelp":{"#cdata":"Indicates that information on the memory usage and paging schemes (if necessary) is reported by \nPROC NETFLOW on the SAS log. As optimization proceeds, you are informed of any changes in the \nmemory requirements and schemes used by PROC NETFLOW."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"NAMECTRL=","ProcedureOptionHelp":{"#cdata":"Is used to interpret arc and nonarc variable names in the CONDATA= data set. The NAMECTRL= option \nis used when a name of an arc or nonarc variable in the CONDATA= data set (either a VAR list SAS \nvariable name or value of the COLUMN list SAS variable) is in the form tail_head and there exists \nan arc with these end nodes. If tail_head has not already been tagged as belonging to an arc or \nnonarc variable in the ARCDATA= data set, PROC NETFLOW needs to know whether tail_head is the name \nof the arc or the name of a nonarc variable."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"1","@Value2":"2","@Value3":"3"},"ProcedureOptionToolTips":{"@ToolTip1":"A name that is not defined in the ARCDATA= data set is assumed to be the name of a nonarc variable.","@ToolTip2":"Treats tail_head as the name of the arc with these endnodes, provided no other name is used to  associate data in the CONDATA= data set with this arc. If the arc does have other names that  appear in the CONDATA= data set, tail_head is assumed to be the name of a nonarc variable.","@ToolTip3":"Tail_head is assumed to be a name of the arc with these end nodes, whether the arc has other names  or not. This is the default."}},{"ProcedureOptionName":"NARCS=","ProcedureOptionHelp":{"#cdata":"[Syntax: NARCS=n] \n      \nSpecifies the approximate number of arcs."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"NCOEFS=","ProcedureOptionHelp":{"#cdata":"[Syntax: NCOEFS=n] \n      \nSpecifies the approximate number of constraint coefficients."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"NCONS=","ProcedureOptionHelp":{"#cdata":"[Syntax: NCONS=n] \n      Specifies the approximate number of constraints."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"NNAS=","ProcedureOptionHelp":{"#cdata":"[Syntax: NNAS=n] \n      \nSpecifies the approximate number of nonarc variables."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"NNODES=","ProcedureOptionHelp":{"#cdata":"[Syntax: NNODES=n] \n      \nSpecifies the approximate number of nodes."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"NON_REPLIC=","ProcedureOptionHelp":{"#cdata":"Prevents PROC NETFLOW from doing unnecessary checks of data previously read."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"COEFS","@Value2":"NONE"},"ProcedureOptionToolTips":{"@ToolTip1":"Indicates that each constraint coefficient is specified once in the CONDATA= data set.","@ToolTip2":"Indicates that constraint coefficients can be specified more than once in the CONDATA= data set.  This is the default."}},{"ProcedureOptionName":"RHSOBS=","ProcedureOptionHelp":{"#cdata":"[Syntax: RHSOBS=charstr] \n      \nSpecifies the keyword that identifies a right-hand-side observation when using the sparse format \nfor data in the CONDATA= data set."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"SAME_NONARC_DATA|SND","ProcedureOptionHelp":{"#cdata":"Indicates that any nonconstraint nonarc variable data in the CONDATA= data set is to be ignored."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"SCALE=","ProcedureOptionHelp":{"#cdata":"Indicates that the side constraints are to be scaled. Scaling is useful when some coefficients of \na constraint or nonarc variable are either much larger or much smaller than other coefficients."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"ROW","@Value2":"COL","@Value3":"BOTH","@Value4":"NONE"},"ProcedureOptionToolTips":{"@ToolTip1":"Specify this if the largest absolute value of coefficients in each constraint is about 1.0","@ToolTip2":"Specify this if nonarc variable columns are scaled so that the absolute value of the largest  constraint coefficient of a nonarc variable is near to 1.","@ToolTip3":"Specify this if the largest absolute value of coefficients in each constraint, and the absolute value  of the largest constraint coefficient of a nonarc variable is near to 1. This is the default.","@ToolTip4":"Specify this if no scaling should be done."}},{"ProcedureOptionName":"SHORTPATH|SP","ProcedureOptionHelp":{"#cdata":"Specifies that PROC NETFLOW solve a shortest path problem."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"SINK=|SINKNODE=","ProcedureOptionHelp":{"#cdata":"[Syntax: SINK=sinkname] \n      \nIdentifies the demand node. The SINK= option is useful when you specify the MAXFLOW option or the \nSHORTPATH option and need to specify toward which node the shortest path or maximum flow is directed."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"SOURCE=|SOURCENODE=","ProcedureOptionHelp":{"#cdata":"[Syntax: SOURCE=sourcename] \n      \nIdentifies a supply node. The SOURCE= option is useful when you specify the MAXFLOW or the SHORTPATH \noption and need to specify from which node the shortest path or maximum flow originates."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"SPARSECONDATA|SCDATA","ProcedureOptionHelp":{"#cdata":"Indicates that the CONDATA= data set has data in the sparse data format. Otherwise, it is assumed \nthat the data are in the dense format."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"SPARSEP2|SP2","ProcedureOptionHelp":{"#cdata":"Indicates that the new column of the working basis matrix that replaces another column be held \nin a linked list."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"SUPPLY=","ProcedureOptionHelp":{"#cdata":"[Syntax: SUPPLY=s] \n      \nSpecifies the supply at the source node specified by the SOURCE= option. The SUPPLY= option should \nbe used only if the SOURCE= option is given in the PROC NETFLOW statement and neither the SHORTPATH \noption nor the MAXFLOW option is specified."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"THRUNET","ProcedureOptionHelp":{"#cdata":"Tells PROC NETFLOW to force through the network any excess supply (the amount by which total supply \nexceeds total demand) or any excess demand (the amount by which total demand exceeds total supply) \nas is required."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"TYPEOBS=","ProcedureOptionHelp":{"#cdata":"[Syntax: TYPEOBS=charstr] \n      \nSpecifies the keyword that identifies a type observation when using the sparse format for data \nin the CONDATA= data set."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"WARM","ProcedureOptionHelp":{"#cdata":"Indicates that the NODEDATA= data set or the DUALIN= data set and the ARCDATA= data set contain \nextra information of a warm start to be used by PROC NETFLOW."},"ProcedureOptionType":"S"}]},"ProcedureStatements":{"ProcedureStatement":[{"StatementName":"RESET|SET","StatementHelp":{"#cdata":"Syntax: RESET options ; | SET options ;\n\nThe RESET statement is used to change options after PROC NETFLOW has started execution. \nAnother name for the RESET statement is SET. You can use RESET when you are resetting \noptions and SET when you are setting options for the first time."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ARCOUT=|AOUT=","StatementOptionHelp":{"#cdata":"[Syntax: ARCOUT=SAS-data-set] \n          \nNames the output data set that receives all arc and nonarc variable data, including flows or values, \nand other information concerning the unconstrained optimal solution."},"StatementOptionType":"DV"},{"StatementOptionName":"CONOUT=|COUT=","StatementOptionHelp":{"#cdata":"[Syntax: CONOUT=SAS-data-set] \n          \nNames the output data set that receives an optimal primal solution to the problem obtained by \nperforming optimization that considers the side constraints."},"StatementOptionType":"DV"},{"StatementOptionName":"DUALOUT=|DOUT=","StatementOptionHelp":{"#cdata":"[Syntax: DUALOUT=SAS-data-set] \n          \nNames the output data set that receives an optimal dual solution to the problem obtained by \nperforming optimization that considers the side constraints."},"StatementOptionType":"DV"},{"StatementOptionName":"NODEOUT=|NOUT=","StatementOptionHelp":{"#cdata":"[Syntax: NODEOUT=SAS-data-set] \n          \nNames the output data set that receives all information about nodes (supply and demand and \nnodal dual variable values) and other information concerning the optimal solution found by \nthe optimizer when neglecting side constraints."},"StatementOptionType":"DV"},{"StatementOptionName":"ENDPAUSE1","StatementOptionHelp":{"#cdata":"Indicates that PROC NETFLOW will pause after the unconstrained optimal solution has been obtained \nand information about this solution has been output to the current ARCOUT= data set, NODEOUT= \ndata set, or both. The procedure then executes the next statement, or waits if no subsequent \nstatement has been specified."},"StatementOptionType":"S"},{"StatementOptionName":"FEASIBLEPAUSE1|FP1","StatementOptionHelp":{"#cdata":"Indicates that unconstrained optimization should stop once a feasible solution is reached. PROC NETFLOW \nchecks for feasibility every 10 iterations. A solution is feasible if there are no artificial arcs \nhaving nonzero flow assigned to be conveyed through them. The presence of artificial arcs with nonzero \nflows means that the current solution does not satisfy all the nodal flow conservation constraints \nimplicit in network problems."},"StatementOptionType":"S"},{"StatementOptionName":"MAXIT1=","StatementOptionHelp":{"#cdata":"[Syntax: MAXIT1=m] \n          \nSpecifies the maximum number of primal simplex iterations PROC NETFLOW is to perform in stage 1. \nThe default value for the MAXIT1= option is 1000. If MAXIT1=m iterations are performed and you \nwant to continue unconstrained optimization, reset MAXIT1= to a number larger than the number of \niterations already performed and issue another RUN statement."},"StatementOptionType":"V"},{"StatementOptionName":"NOENDPAUSE1|NOEP1","StatementOptionHelp":{"#cdata":"Negates the ENDPAUSE1 option."},"StatementOptionType":"S"},{"StatementOptionName":"NOFEASIBLEPAUSE1|NOFP1","StatementOptionHelp":{"#cdata":"Negates the FEASIBLEPAUSE1 option."},"StatementOptionType":"S"},{"StatementOptionName":"PAUSE1=","StatementOptionHelp":{"#cdata":"[Syntax: PAUSE1=p] \n          \nIndicates that PROC NETFLOW will halt unconstrained optimization and pause when the remainder \nof the number of stage 1 iterations divided by the value of the PAUSE1= option is zero. If present, \nthe next statement is executed; if not, the procedure waits for the next statement to be specified. \nThe default value for PAUSE1= is 999999."},"StatementOptionType":"V"},{"StatementOptionName":"MAXIT2=","StatementOptionHelp":{"#cdata":"[Syntax: MAXIT2=m] \n          \nStage 2 constrained optimization counterpart of the MAXIT1= option."},"StatementOptionType":"V"},{"StatementOptionName":"NOENDPAUSE2|NOEP2","StatementOptionHelp":{"#cdata":"Negates the ENDPAUSE2 option."},"StatementOptionType":"S"},{"StatementOptionName":"NOFEASIBLEPAUSE2|NOFP2","StatementOptionHelp":{"#cdata":"Negates the FEASIBLEPAUSE2 option."},"StatementOptionType":"S"},{"StatementOptionName":"PAUSE2=","StatementOptionHelp":{"#cdata":"[Syntax: PAUSE2=p] \n          \nStage 2 constrained optimization counterpart of the PAUSE1= option."},"StatementOptionType":"V"},{"StatementOptionName":"BIGM1","StatementOptionHelp":{"#cdata":"Indicates that the \"big-M\" approach to optimization is used. Artificial variables are treated like \nreal arcs, slacks, surpluses and nonarc variables. Artificials have very expensive costs. BIGM1 is \nthe default."},"StatementOptionType":"S"},{"StatementOptionName":"TWOPHASE1","StatementOptionHelp":{"#cdata":"Indicates that the two-phase approach is used instead of the big-M approach. At first, artificial \nvariables are the only variables to have nonzero objective function coefficients. An artificial \nvariable's objective function coefficient is temporarily set to 1 and PROC NETFLOW minimizes. \nWhen all artificial variables have zero value, PROC NETFLOW has found a feasible solution, and \nphase 2 commences. Arcs and nonarc variables have their real costs and objective function coefficients."},"StatementOptionType":"S"},{"StatementOptionName":"NOBIGM1","StatementOptionHelp":{"#cdata":"Is synonymous with THE TWOPHASE1 option."},"StatementOptionType":"S"},{"StatementOptionName":"NOTWOPHASE1","StatementOptionHelp":{"#cdata":"Is synonymous with the BIGM1 option."},"StatementOptionType":"S"},{"StatementOptionName":"CYCLEMULT1=","StatementOptionHelp":{"#cdata":"[Syntax: CYCLEMULT1=c] \n          \nIf the number of consecutive degenerate pivots (those with no progress toward the optimum) \nperformed equals the value of the CYCLEMULT1= option times the number of nodes, the arcs \nthat were \"blocking\" (can leave the basis) are added to a list. In subsequent iterations, \nof the arcs that now can leave the basis, the one chosen to leave is an arc on the list of \narcs that could have left in the previous iteration. In other words, perference is given to \narcs that \"block\" many iterations. After several iterations, the list is cleared."},"StatementOptionType":"V"},{"StatementOptionName":"MINBLOCK1=","StatementOptionHelp":{"#cdata":"[Syntax: MINBLOCK1=m] \n          \nIf the number of blocking arcs is less than the value of the MINBLOCK1= option, a list of arcs \nthat were \"blocking\" (can leave the basis) is not kept."},"StatementOptionType":"V"},{"StatementOptionName":"PERTURB1","StatementOptionHelp":{"#cdata":"The arc flows are perturbed by a random quantity, so that arcs on the list that block subsequent \niterations are chosen to leave the basis randomly. Although perturbation often pays off, it is \ncomputationally expensive. Periodically, PROC NETFLOW has to clear out the lists and un-perturb \nthe solution."},"StatementOptionType":"S"},{"StatementOptionName":"NOPERTURB1","StatementOptionHelp":{"#cdata":"Prevents perturbation of arc flows."},"StatementOptionType":"S"},{"StatementOptionName":"LRATIO1","StatementOptionHelp":{"#cdata":"Specifies the type of ratio test to use in determining which arc leaves the basis in stage 1. \nIn some iterations, more than one arc is eligible to leave the basis. Of those arcs that can \nleave the basis, the leaving arc is the first encountered by the algorithm if the LRATIO1 option \nis specified. Specifying the LRATIO1 option can decrease the chance of cycling but can increase \nsolution times. The alternative to the LRATIO1 option is the NOLRATIO1 option, which is the default."},"StatementOptionType":"S"},{"StatementOptionName":"LRATIO2","StatementOptionHelp":{"#cdata":"Specifies the type of ratio test to use in determining what leaves the basis in stage 2. In some \niterations, more than one arc, constraint slack, surplus, or nonarc variable is eligible to leave \nthe basis. If the LRATIO2 option is specified, the leaving arc, constraint slack, surplus, or nonarc \nvariable is the one that is eligible to leave the basis first encountered by the algorithm. Specifying \nthe LRATIO2 option can decrease the chance of cycling but can increase solution times. The alternative \nto the LRATIO2 option is the NOLRATIO2 option, which is the default."},"StatementOptionType":"S"},{"StatementOptionName":"NOLRATIO1","StatementOptionHelp":{"#cdata":"Specifies the type of ratio test to use in determining which arc leaves the basis in stage 1. If the \nNOLRATIO1 option is specified, of those arcs that can leave the basis, the leaving arc has the minimum \n(maximum) cost if the leaving arc is to be nonbasic with flow capacity equal to its capacity (lower \nflow bound). If more than one possible leaving arc has the minimum (maximum) cost, the first such arc \nencountered is chosen. Specifying the NOLRATIO1 option can decrease solution times, but can increase \nthe chance of cycling. The alternative to the NOLRATIO1 option is the LRATIO1 option. The NOLRATIO1 \noption is the default."},"StatementOptionType":"S"},{"StatementOptionName":"NOLRATIO2","StatementOptionHelp":{"#cdata":"Specifies the type of ratio test to use in determining which arc leaves the basis in stage 2. If the \nNOLRATIO2 option is specified, the leaving arc, constraint slack, surplus, or nonarc variable is the \none eligible to leave the basis with the minimum (maximum) cost or objective function coefficient if \nthe leaving arc, constraint slack or nonarc variable is to be nonbasic with flow or value equal to its \ncapacity or upper value bound (lower flow or value bound), respectively. If several possible leaving \narcs, constraint slacks, surpluses, or nonarc variables have the minimum (maximum) cost or objective \nfunction coefficient, then the first encountered is chosen. Specifying the NOLRATIO2 option can decrease \nsolution times, but can increase the chance of cycling. The alternative to the NOLRATIO2 option is the \nLRATIO2 option. The NOLRATIO2 option is the default."},"StatementOptionType":"S"},{"StatementOptionName":"BIGM2","StatementOptionHelp":{"#cdata":"Are the stage 2 constrained optimization counterparts of the options BIGM1."},"StatementOptionType":"S"},{"StatementOptionName":"TWOPHASE2","StatementOptionHelp":{"#cdata":"Are the stage 2 constrained optimization counterparts of the option TWOPHASE1."},"StatementOptionType":"S"},{"StatementOptionName":"NOBIGM2","StatementOptionHelp":{"#cdata":"Is synonymous with THE TWOPHASE2 option."},"StatementOptionType":"S"},{"StatementOptionName":"NOTWOPHASE2","StatementOptionHelp":{"#cdata":"Is synonymous with the BIGM2 option."},"StatementOptionType":"S"},{"StatementOptionName":"INVFREQ=","StatementOptionHelp":{"#cdata":"[Syntax: INVFREQ=n] \n          \nRecalculates the working basis matrix inverse whenever n iterations have been performed where \nn is the value of the INVFREQ= option. Although a relatively expensive task, it is prudent to \ndo as roundoff errors accumulate, especially affecting the elements of this matrix inverse. The \ndefault is INVFREQ=50. The INVFREQ= option should be used only if the INVD_2D option is specified \nin the PROC NETFLOW statement."},"StatementOptionType":"V"},{"StatementOptionName":"INTFIRST","StatementOptionHelp":{"#cdata":"In some iterations, it is found that what must leave the basis is an arc that is part of the \nspanning tree representation of the network part of the basis (called a key arc). It is necessary \nto interchange another basic arc not part of the tree (called a nonkey arc) with the tree arc that \nleaves to permit the basis update to be performed efficiently. Specifying the INTFIRST option \nindicates that of the nonkey arcs eligible to be swapped with the leaving key arc, the one chosen \nto do so is the first encountered by the algorithm. If the INTFIRST option is not specified, all \nsuch arcs are examined and the one with the best cost is chosen."},"StatementOptionType":"S"},{"StatementOptionName":"MAXL=","StatementOptionHelp":{"#cdata":"[Syntax: MAXL=m] \n          \nIf the working basis matrix is LU factored, U is an upper triangular matrix and L is a lower \ntriangular matrix corresponding to a sequence of elementary matrix row operations required to \nchange the working basis matrix into U. L and U enable substitution techniques to be used to \nsolve the linear systems of the simplex algorithm. Among other things, the LU processing strives \nto keep the number of L elementary matrix row operation matrices small. A buildup in the number of \nthese could indicate that fill-in is becoming excessive and the computations involving L and U will \nbe hampered. Refactorization should be performed to restore U sparsity and reduce L information. \nWhen the number of L matrix row operations exceeds the value of the MAXL= option, a refactorization \nis done rather than one or more updates. The default value for MAXL= is 10 times the number of side \nconstraints. The MAXL= option should not be used if INVD_2D is specified in the PROC NETFLOW statement."},"StatementOptionType":"V"},{"StatementOptionName":"MAXLUUPDATES=|MLUU=","StatementOptionHelp":{"#cdata":"[Syntax: MAXLUUPDATES=m] \n          \nIn some iterations, PROC NETFLOW must either perform a series of single column updates or a complete \nrefactorization of the working basis matrix. More than one column of the working basis matrix must \nchange before the next simplex iteration can begin. The single column updates can often be done \nfaster than a complete refactorization, especially if few updates are necessary, the working basis \nmatrix is sparse, or a refactorization has been performed recently. If the number of columns that \nmust change is less than the value specified in the MAXLUUPDATES= option, the updates are attempted; \notherwise, a refactorization is done. Refactorization also occurs if the sum of the number of columns \nthat must be changed and the number of LU updates done since the last refactorization exceeds the value \nof the REFACTFREQ= option. The MAXLUUPDATES= option should not be used if the INVD_2D option is specified \nin the PROC NETFLOW statement. \n\nIn some iterations, a series of single column updates are not able to complete the changes required \nfor a working basis matrix because, ideally, all columns should change at once. If the update cannot \nbe completed, PROC NETFLOW performs a refactorization. The default value is 5. "},"StatementOptionType":"V"},{"StatementOptionName":"NOINTFIRST","StatementOptionHelp":{"#cdata":"Indicates that of the arcs eligible to be swapped with the leaving arc, the one chosen to do so has \nthe best cost. See the INTFIRST option."},"StatementOptionType":"S"},{"StatementOptionName":"REFACTFREQ=|RFF=","StatementOptionHelp":{"#cdata":"[Syntax: REFACTFREQ=r] \n          \nSpecifies the maximum number of L and U updates between refactorization of the working \nbasis matrix to reinitialize LU factors. In most iterations, one or several Bartels-Golub \nupdates can be performed. An update is performed more quickly than a complete refactorization. \nHowever, after a series of updates, the sparsity of the U factor is degraded. A refactorization \nis necessary to regain sparsity and to make subsequent computations and updates more efficient. \nThe default value is 50. The REFACTFREQ= option should not be used if INVD_2D is specified in the \nPROC NETFLOW statement. "},"StatementOptionType":"V"},{"StatementOptionName":"U=","StatementOptionHelp":{"#cdata":"[Syntax: U=u] \n          \nControls the choice of pivot during LU decomposition or Bartels-Golub update. When searching \nfor a pivot, any element less than the value of the U= option times the largest element in its \nmatrix row is excluded, or matrix rows are interchanged to improve numerical stability. The U= \noption should have values on or between ZERO2 and 1.0. Decreasing the value of the U= option \nbiases the algorithm toward maintaining sparsity at the expense of numerical stability and \nvice-versa. Reid (1975) suggests that the value of 0.01 is acceptable and this is the default \nfor the U= option. This option should not be used if INVD_2D is specified in the PROC NETFLOW \nstatement."},"StatementOptionType":"V"},{"StatementOptionName":"PRICETYPE1=","StatementOptionHelp":{"#cdata":"Pricing strategies for optimizing an unconstrained problem (or when constraints are temporarily ignored)."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NOQ","@Value2":"BLAND","@Value3":"Q"},"StatementOptionToolTips":{"@ToolTip1":"Is the least complex pricing strategy, but it is nevertheless quite efficient. In contrast to the  specification of PRICETYPE=Q, a candidate queue is not set up.","@ToolTip2":"Is equivalent to specifying in the PROC NETFLOW or RESET statement all three options PRICETYPE=NOQ,  PxSCAN=FIRST, and LRATIOx, and the scans are not wraparound.  Bland (1977) proved that this pivot  rule prevents the simplex algorithm from cycling. However, because the pivots concentrate on the  lower indexed arcs, constraint slack, surplus, and nonarc variables, optimization with PRICETYPE=BLAND  can make the optimization execute slowly.","@ToolTip3":"A queue is set up. Candidates currently on the queue are tested at each iteration and either enter  the basis or are removed from the queue. The size of the queue can be specified by using the QSIZE=  option. The default value for QSIZE1= is        QSIZE1=number of arcs/200     if (QSIZE1<24) QSIZE1=24     else if (QSIZE1>100) QSIZE1=100    The default value for QSIZE2= is         QSIZE2=(number of arcs+number of nonarc variables)/200     if (QSIZE2<24) QSIZE2=24     else if (QSIZE2>100) QSIZE2=100   controls the amount of additional candidate selection work done to find a better candidate after an  eligible candidate has been found in the queue."}},{"StatementOptionName":"PRICETYPE2=","StatementOptionHelp":{"#cdata":"Pricing strategies for optimizing a problem considering constraints."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NOQ","@Value2":"BLAND","@Value3":"Q"},"StatementOptionToolTips":{"@ToolTip1":"Is the least complex pricing strategy, but it is nevertheless quite efficient. In contrast to the  specification of PRICETYPE=Q, a candidate queue is not set up.","@ToolTip2":"Is equivalent to specifying in the PROC NETFLOW or RESET statement all three options PRICETYPE=NOQ,  PxSCAN=FIRST, and LRATIOx, and the scans are not wraparound.  Bland (1977) proved that this pivot  rule prevents the simplex algorithm from cycling. However, because the pivots concentrate on the  lower indexed arcs, constraint slack, surplus, and nonarc variables, optimization with PRICETYPE=BLAND  can make the optimization execute slowly.","@ToolTip3":"A queue is set up. Candidates currently on the queue are tested at each iteration and either enter  the basis or are removed from the queue. The size of the queue can be specified by using the QSIZE=  option. The default value for QSIZE1= is        QSIZE1=number of arcs/200     if (QSIZE1<24) QSIZE1=24     else if (QSIZE1>100) QSIZE1=100    The default value for QSIZE2= is         QSIZE2=(number of arcs+number of nonarc variables)/200     if (QSIZE2<24) QSIZE2=24     else if (QSIZE2>100) QSIZE2=100   controls the amount of additional candidate selection work done to find a better candidate after an  eligible candidate has been found in the queue."}},{"StatementOptionName":"FUTURE1","StatementOptionHelp":{"#cdata":"Signals that PROC NETFLOW must output extra observations to the NODEOUT= and ARCOUT= data sets. \nThese observations contain information about the solution found by doing optimization neglecting \nany side constraints. These two data sets then can be used as the NODEDATA= and ARCDATA= data sets, \nrespectively, in subsequent PROC NETFLOW runs with the WARM option specified."},"StatementOptionType":"S"},{"StatementOptionName":"FUTURE2","StatementOptionHelp":{"#cdata":"Signals that PROC NETFLOW must output extra observations to the DUALOUT= and CONOUT= data sets. \nThese observations contain information about the solution found by optimization that considers \nside constraints. These two data sets can then be used as the NODEDATA= data set (also called \nthe DUALIN= data set) and the ARCDATA= data sets, respectively, in subsequent PROC NETFLOW runs \nwith the WARM option specified."},"StatementOptionType":"S"},{"StatementOptionName":"MOREOPT","StatementOptionHelp":{"#cdata":"The MOREOPT option turns off all optimality and infeasibility flags that may have been raised. \nUnless this is done, PROC NETFLOW will not do any optimization when a RUN statement is specified."},"StatementOptionType":"S"},{"StatementOptionName":"NOFUTURE1","StatementOptionHelp":{"#cdata":"Negates the FUTURE1 option."},"StatementOptionType":"S"},{"StatementOptionName":"NOFUTURE2","StatementOptionHelp":{"#cdata":"Negates the FUTURE2 option."},"StatementOptionType":"S"},{"StatementOptionName":"NOZTOL1","StatementOptionHelp":{"#cdata":"Indicates that the majority of tests for roundoff error should not be done. Specifying the NOZTOL1 \noption and obtaining the same optimal solution as when the NOZTOL1 option is not specified in the \nPROC NETFLOW statement (or the ZTOL1 option is specified), verifies that the zero tolerances were \nnot too high. Roundoff error checks that are critical to the successful functioning of PROC NETFLOW \nand any related readjustments are always done."},"StatementOptionType":"S"},{"StatementOptionName":"NOZTOL2","StatementOptionHelp":{"#cdata":"Indicates that the majority of tests for roundoff error are not to be done during an optimization \nthat considers side constraints. The reasons for specifying the NOZTOL2 option are the same as \nthose for specifying the NOZTOL1 option for stage 1 optimization (see the NOZTOL1 option)."},"StatementOptionType":"S"},{"StatementOptionName":"OPTIM_TIMER","StatementOptionHelp":{"#cdata":"Indicates that the procedure is to issue a message to the SAS log giving the CPU time spent doing \noptimization. This includes the time spent preprocessing, performing optimization, and postprocessing. \nNot counted in that time is the rest of the procedure execution, which includes reading the data and \ncreating output SAS data sets."},"StatementOptionType":"S"},{"StatementOptionName":"SCRATCH","StatementOptionHelp":{"#cdata":"Specifies that you do not want PROC NETFLOW to enter or continue stage 1 of the algorithm. \nRather than specify RESET SCRATCH, you can use the CONOPT statement."},"StatementOptionType":"S"},{"StatementOptionName":"VERBOSE=","StatementOptionHelp":{"#cdata":"[Syntax: VERBOSE=v] \n      \nLimits the number of similar messages that are displayed on the SAS log."},"StatementOptionType":"V"},{"StatementOptionName":"ZERO2=|Z2=","StatementOptionHelp":{"#cdata":"[Syntax: ZERO2=z] \n      \nSpecifies the zero tolerance level used when determining whether the final solution has \nbeen reached."},"StatementOptionType":"V"},{"StatementOptionName":"ZEROTOL=","StatementOptionHelp":{"#cdata":"[Syntax: ZEROTOL=z] \n \nSpecifies the zero tolerance used when PROC NETFLOW must compare any real number with another \nreal number, or zero."},"StatementOptionType":"V"},{"StatementOptionName":"FACT_METHOD=","StatementOptionHelp":{"#cdata":"[Syntax: FACT_METHOD=f] \n      \nEnables you to choose the type of algorithm used to factorize and solve the main linear systems \nat each iteration of the interior point algorithm."},"StatementOptionType":"V"},{"StatementOptionName":"TOLDINF=|RTOLDINF=","StatementOptionHelp":{"#cdata":"[Syntax: TOLDINF=t] \n      \nSpecifies the allowed amount of dual infeasibility."},"StatementOptionType":"V"},{"StatementOptionName":"TOLPINF=|RTOLPINF=","StatementOptionHelp":{"#cdata":"[Syntax: TOLPINF=t] \n      \nSpecifies the allowed amount of primal infeasibility."},"StatementOptionType":"V"},{"StatementOptionName":"TOLTOTDINF=|TOLTOTDINF=","StatementOptionHelp":{"#cdata":"[Syntax: TOLTOTDINF=t] \n      \nSpecifies the allowed total amount of dual infeasibility."},"StatementOptionType":"V"},{"StatementOptionName":"TOLTOTPINF=|RTOLTOTPINF=","StatementOptionHelp":{"#cdata":"[Syntax: TOLTOTPINF=t] \n      \nSpecifies the allowed total amount of primal infeasibility."},"StatementOptionType":"V"},{"StatementOptionName":"CHOLTINYTOL=|RCHOLTINYTOL=","StatementOptionHelp":{"#cdata":"[Syntax: CHOLTINYTOL=c] \n      \nSpecifies the cut-off tolerance for Cholesky factorization."},"StatementOptionType":"V"},{"StatementOptionName":"DENSETHR=|RDENSETHR=","StatementOptionHelp":{"#cdata":"[Syntax: DENSETHR=d] \n      \nSpecifies the density threshold for Cholesky factorization."},"StatementOptionType":"V"},{"StatementOptionName":"PDSTEPMULT=|RPDSTEPMULT=","StatementOptionHelp":{"#cdata":"[Syntax: PDSTEPMULT=p] \n      \nSpecifies the step-length multiplier."},"StatementOptionType":"V"},{"StatementOptionName":"PRSLTYPE=|IPRSLTYPE=","StatementOptionHelp":{"#cdata":"Controls how much preprocessing to do."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"-1","@Value2":"0","@Value3":"1","@Value4":"2","@Value5":"3"},"StatementOptionToolTips":{"@ToolTip1":"Specifies not to perform preprocessing.","@ToolTip2":"Given upper and lower bounds on each variable, the greatest and least contribution to the row activity  of each variable is computed. If these are within the limits set by the upper and lower bounds on the  row activity, then the row is redundant and can be discarded. Otherwise, whenever possible, the bounds  on any of the variables are tightened.","@ToolTip3":"When there are exactly two unfixed variables with coefficients in an equality constraint, one variable  is solved in terms of the other. The problem will have one less variable.","@ToolTip4":"It may be possible to determine that an equality constraint is not constraining a variable.","@ToolTip5":"All possible reductions are performed. PRSLTYPE=3 is the default."}},{"StatementOptionName":"PRINTLEVEL2=","StatementOptionHelp":{"#cdata":"[Syntax: PRINTLEVEL2=p] \n      \nIs used when you want to see PROC NETFLOW's progress to the optimum."},"StatementOptionType":"V"},{"StatementOptionName":"RTTOL=","StatementOptionHelp":{"#cdata":"[Syntax: RTTOL=r] \n      \nSpecifies the zero tolerance used during the ratio test of the interior point algorithm."},"StatementOptionType":"V"},{"StatementOptionName":"MAXITERB=|IMAXITERB=","StatementOptionHelp":{"#cdata":"[Syntax: MAXITERB=m] \n      \nSpecifies the maximum number of iterations that the interior point algorithm can perform. \nThe default value for m is 100."},"StatementOptionType":"V"},{"StatementOptionName":"PDGAPTOL=|RPDGAPTOL=","StatementOptionHelp":{"#cdata":"[Syntax: PDGAPTOL=p] \n      \nSpecifies the primal-dual gap or duality gap tolerance."},"StatementOptionType":"V"},{"StatementOptionName":"STOP_C=","StatementOptionHelp":{"#cdata":"[Syntax: STOP_C=s] \n      \nIs used to determine whether optimization should stop. At the beginning of each iteration, \nif complementarity is less than of equal to s, optimization will stop."},"StatementOptionType":"V"},{"StatementOptionName":"STOP_DG=","StatementOptionHelp":{"#cdata":"[Syntax: STOP_DG=s] \n      \nIs used to determine whether optimization should stop. At the beginning of each iteration, if the \nduality gap is less than of equal to s, optimization will stop."},"StatementOptionType":"V"},{"StatementOptionName":"STOP_IB=","StatementOptionHelp":{"#cdata":"[Syntax: STOP_IB=s] \n      \nIs used to determine whether optimization should stop. At the beginning of each iteration, if total \nbound infeasibility is less than of equal to s, optimization will stop."},"StatementOptionType":"V"},{"StatementOptionName":"STOP_IC=","StatementOptionHelp":{"#cdata":"[Syntax: STOP_IC=s] \n      \nIs used to determine whether optimization should stop. At the beginning of each iteration, if total \nconstraint infeasibility is less than of equal to s, optimization will stop."},"StatementOptionType":"V"},{"StatementOptionName":"STOP_ID=","StatementOptionHelp":{"#cdata":"[Syntax: STOP_ID=s] \n      \nIs used to determine whether optimization should stop. At the beginning of each iteration, if total \ndual infeasibility is less than of equal to s, optimization will stop."},"StatementOptionType":"V"},{"StatementOptionName":"AND_STOP_C=","StatementOptionHelp":{"#cdata":"[Syntax: AND_STOP_C=s] \n      \nIs used to determine whether optimization should stop. At the beginning of each iteration, \nif complementarity (the value of the Complem-ity column in the table produced when you specify \nPRINTLEVEL2=1 or PRINTLEVEL2=2) is <= s, and the other conditions related to other AND_STOP \nparameters are also satisfied, optimization will stop."},"StatementOptionType":"V"},{"StatementOptionName":"AND_STOP_DG=","StatementOptionHelp":{"#cdata":"[Syntax: AND_STOP_DG=s] \n      \nIs used to determine whether optimization should stop. At the beginning of each iteration, if the \nduality gap (the value of the Duality_gap column in the table produced when you specify PRINTLEVEL2=1 \nor PRINTLEVEL2=2) is <= s, and the other conditions related to other AND_STOP parameters are also satisfied, \noptimization will stop."},"StatementOptionType":"V"},{"StatementOptionName":"AND_STOP_IB=","StatementOptionHelp":{"#cdata":"[Syntax: AND_STOP_IB=s] \n      \nIs used to determine whether optimization should stop. At the beginning of each iteration, if total \nbound infeasibility is <= s, and the other conditions related to other AND_STOP parameters are also \nsatisfied, optimization will stop."},"StatementOptionType":"V"},{"StatementOptionName":"AND_STOP_IC=","StatementOptionHelp":{"#cdata":"[Syntax: AND_STOP_IC=s] \n      \nIs used to determine whether optimization should stop. At the beginning of each iteration, if total \nconstraint infeasibility is <= s, and the other conditions related to other AND_STOP parameters are \nalso satisfied, optimization will stop."},"StatementOptionType":"V"},{"StatementOptionName":"AND_STOP_ID=","StatementOptionHelp":{"#cdata":"[Syntax: AND_STOP_ID=s] \n      \nIs used to determine whether optimization should stop. At the beginning of each iteration, if total \ndual infeasibility is <= s, and the other conditions related to other AND_STOP parameters are also \nsatisfied, optimization will stop."},"StatementOptionType":"V"},{"StatementOptionName":"KEEPGOING_C=","StatementOptionHelp":{"#cdata":"[Syntax: KEEPGOING_C=s] \n      \nIs used to determine whether optimization should stop. When a stopping condition is met, if \ncomplementarity (the value of the Complem-ity column in the table produced when you specify \nPRINTLEVEL2=1 or PRINTLEVEL2=2) is > s, optimization will continue."},"StatementOptionType":"V"},{"StatementOptionName":"KEEPGOING_DG=","StatementOptionHelp":{"#cdata":"[Syntax: KEEPGOING_DG=s] \n      \nIs used to determine whether optimization should stop. When a stopping condition is met, if the \nduality gap (the value of the Duality_gap column in the table produced when you specify PRINTLEVEL2=1 \nor PRINTLEVEL2=2) is > s, optimization will continue."},"StatementOptionType":"V"},{"StatementOptionName":"KEEPGOING_IC=","StatementOptionHelp":{"#cdata":"[Syntax: KEEPGOING_IC=s] \n      \nIs used to determine whether optimization should stop. When a stopping condition is met, \nif total constraint infeasibility is > s, optimization will continue."},"StatementOptionType":"V"},{"StatementOptionName":"KEEPGOING_ID=","StatementOptionHelp":{"#cdata":"[Syntax: KEEPGOING_ID=s] \n      \nIs used to determine whether optimization should stop. When a stopping condition is met, \nif total dual infeasibility is > s, optimization will continue. "},"StatementOptionType":"V"},{"StatementOptionName":"AND_KEEPGOING_C=","StatementOptionHelp":{"#cdata":"[Syntax: AND_KEEPGOING_C=s] \n      \nIs used to determine whether optimization should stop. When a stopping condition is met, \nif complementarity (the value of the Complem-ity column in the table produced when you \nspecify PRINTLEVEL2=1 or PRINTLEVEL2=2) is > s, and the other conditions related to other \nAND_KEEPGOING parameters are also satisfied, optimization will continue."},"StatementOptionType":"V"},{"StatementOptionName":"AND_KEEPGOING_DG=","StatementOptionHelp":{"#cdata":"[Syntax: AND_KEEPGOING_DG=s] \n      \nIs used to determine whether optimization should stop. When a stopping condition is met, \nif the duality gap (the value of the Duality_gap column in the table produced when you \nspecify PRINTLEVEL2=1 or PRINTLEVEL2=2) is > s, and the other conditions related to other \nAND_KEEPGOING parameters are also satisfied, optimization will continue."},"StatementOptionType":"V"},{"StatementOptionName":"AND_KEEPGOING_IB=","StatementOptionHelp":{"#cdata":"[Syntax: AND_KEEPGOING_IB=s] \n      \nIs used to determine whether optimization should stop. When a stopping condition is met, \nif total bound infeasibility is > s, and the other conditions related to other AND_KEEPGOING \nparameters are also satisfied, optimization will continue."},"StatementOptionType":"V"},{"StatementOptionName":"AND_KEEPGOING_IC=","StatementOptionHelp":{"#cdata":"[Syntax: AND_KEEPGOING_IC=s] \n      \nIs used to determine whether optimization should stop. When a stopping condition is met, if \ntotal constraint infeasibility is > s, and the other conditions related to other AND_KEEPGOING \nparameters are also satisfied, optimization will continue."},"StatementOptionType":"V"},{"StatementOptionName":"AND_KEEPGOING_ID=","StatementOptionHelp":{"#cdata":"[Syntax: AND_KEEPGOING_ID=s] \n      \nIs used to determine whether optimization should stop. When a stopping condition is met, \nif total dual infeasibility is > s, and the other conditions related to other AND_KEEPGOING \nparameters are also satisfied, optimization will continue."},"StatementOptionType":"V"}]}},{"StatementName":"CAPACITY|CAPAC|UPPERBD","StatementHelp":{"#cdata":"Syntax: CAPACITY variable ; | CAPAC variable ; | UPPERBD variable ;\n\nThe CAPACITY statement identifies the SAS variable in the ARCDATA= data set that contains the \nmaximum feasible flow or capacity of the network arcs."},"StatementOptions":null},{"StatementName":"COEF","StatementHelp":{"#cdata":"Syntax: COEF variables ;\n\nThe COEF list is used with the sparse input format of the CONDATA= data set. The COEF list can \ncontain more than one SAS variable, each of which must have numeric values."},"StatementOptions":null},{"StatementName":"COLUMN","StatementHelp":{"#cdata":"Syntax: COLUMN variable ;\n\nThe COLUMN list is used with the sparse input format of side constraints. This list consists \nof one SAS variable in the CONDATA= data set that has as values the names of arc variables, \nnonarc variables, or missing values."},"StatementOptions":null},{"StatementName":"CONOPT","StatementHelp":{"#cdata":"Syntax: CONOPT ;\n\nThe CONOPT statement has no options. It is equivalent to specifying RESET SCRATCH;. The CONOPT \nstatement should be used before stage 2 optimization commences. It indicates that the optimization \nperformed next should consider the side constraints."},"StatementOptions":null},{"StatementName":"COST|OBJFN","StatementHelp":{"#cdata":"Syntax: COST variable ; | OBJFN variable ;\n\nThe COST statement identifies the SAS variable in the ARCDATA= data set that contains the\nper unit flow cost through an arc."},"StatementOptions":null},{"StatementName":"DEMAND","StatementHelp":{"#cdata":"Syntax: DEMAND variable ;\n\nThe DEMAND statement identifies the SAS variable in the ARCDATA= data set that contains the \ndemand at the node named in the corresponding HEADNODE list variable. The DEMAND list variable \nmust have numeric values. It is not necessary to have a DEMAND statement if the name of this SAS \nvariable is _DEMAND_."},"StatementOptions":null},{"StatementName":"HEADNODE|HEAD|TONOODE|TO","StatementHelp":{"#cdata":"Syntax: HEADNODE | HEAD | TONOODE | TO variable ;\n    | HEAD variable ;\n    | TONODE variable ;\n    | TO variable ;\n\nThe HEADNODE statement specifies the SAS variable that must be present in the ARCDATA= data set \nthat contains the names of nodes toward which arcs are directed. It is not necessary to have a \nHEADNODE statement if the name of the SAS variable is _HEAD_ or _TO_. The HEADNODE variable must \nhave character values."},"StatementOptions":null},{"StatementName":"ID","StatementHelp":{"#cdata":"Syntax: ID variables ;\n\nThe ID statement specifies SAS variables containing values for pre- and post-optimal processing \nand analysis. These variables are not processed by PROC NETFLOW but are read by the procedure \nand written in the ARCOUT= and CONOUT= data sets and the output of PRINT statements."},"StatementOptions":null},{"StatementName":"LO|LOWERBD|MINFLOW","StatementHelp":{"#cdata":"Syntax: LO variable ; | LOWERBD variable ; | MINFLOW variable ;\n\nThe LO statement identifies the SAS variable in the ARCDATA= data set that contains the minimum \nfeasible flow or lower flow bound for arcs in the network."},"StatementOptions":null},{"StatementName":"MULT|MULTIPLIER","StatementHelp":{"#cdata":"Syntax: MULT | MULTIPLIER variable ;\n\nThe MULT statement identifies the SAS variable in the ARCDATA= data set associated with the \nvalues of arc multipliers in the network. These values must be positive real numbers. It is \nnot necessary to have a MULT statement if the name of this SAS variable is _MULT_. "},"StatementOptions":null},{"StatementName":"NAME|ARCNAME|VARNAME|","StatementHelp":{"#cdata":"Syntax: NAME variable ; | ARCNAME variable ; | VARNAME variable ;\n\nEach arc and nonarc variable that has data in the CONDATA= data set must have a unique name. \nThis variable is identified in the ARCDATA= data set. The NAME list variable must have character \nvalues (see the NAMECTRL= option in the PROC NETFLOW statement for more information). It is not \nnecessary to have a NAME statement if the name of this SAS variable is _NAME_."},"StatementOptions":null},{"StatementName":"NODE","StatementHelp":{"#cdata":"Syntax: NODE variable ;\n\nThe NODE list variable, which must be present in the NODEDATA= data set, has names of nodes as values. \nThese values must also be values of the TAILNODE list variable, the HEADNODE list variable, or both. \nIf this list is not explicitly specified, the NODEDATA= data set is searched for a SAS variable with \nthe name _NODE_. The NODE list variable must have character values."},"StatementOptions":null},{"StatementName":"PIVOT","StatementHelp":{"#cdata":"Syntax: PIVOT ;\n\nThe PIVOT statement has no options. It indicates that one simplex iteration is to be performed. \nThe PIVOT statement forces a simplex iteration to be performed in spite of the continued presence \nof any reasons or solution conditions that caused optimization to be halted."},"StatementOptions":null},{"StatementName":"PRINT","StatementHelp":{"#cdata":"Syntax: PRINT options / qualifiers ;\n\nThe PRINT statement enables you to examine part or all of the problem. You can limit the amount \nof information displayed when a PRINT statement is processed by specifying PRINT statement options. \nThe name of the PRINT option indicates what part of the problem is to be examined."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ARCS","StatementOptionHelp":{"#cdata":"Indicates that you want to have displayed information about all arcs."},"StatementOptionType":"RS"},{"StatementOptionName":"SOME_ARCS","StatementOptionHelp":{"#cdata":"[Syntax: SOME_ARCS (taillist,headlist)] \n          \nIs similar to the statement PRINT ARCS except that, instead of displaying information about all \narcs, only arcs directed from nodes in a specified set of tail nodes to nodes in a specified set \nof head nodes are included. The nodes or node constructs belonging to the taillist list are separated \nby blanks. The nodes or node constructs belonging to the headlist list are also separated by blanks. \nThe lists are separated by a comma."},"StatementOptionType":"RS"},{"StatementOptionName":"NONARCS|VARIABLES","StatementOptionHelp":{"#cdata":"Indicates that information is to be displayed about all nonarc variables."},"StatementOptionType":"RS"},{"StatementOptionName":"SOME_NONARCS|SOME_VARIABLES","StatementOptionHelp":{"#cdata":"[Syntax: SOME_NONARCS(nonarclist) | SOME_VARIABLES(variablelist)]\n          \nIs similar to the PRINT NONARCS statement except that, instead of displaying information about all \nnonarc variables, only those belonging to a specified set of nonarc variables have information displayed. \nThe nonarc variables or nonarc variable constructs belonging to the nonarclist list are separated by blanks."},"StatementOptionType":"RS"},{"StatementOptionName":"CONSTRAINTS","StatementOptionHelp":{"#cdata":"Indicates that you want to have displayed information about all constraint coefficients."},"StatementOptionType":"RS"},{"StatementOptionName":"SOME_CONS","StatementOptionHelp":{"#cdata":"[Syntax: SOME_CONS(conlist) \n          \nDisplays information for coefficients in a specified set of constraints. The constraints or \nconstraint constructs belonging to the conlist list are separated by blanks."},"StatementOptionType":"RS"},{"StatementOptionName":"CON_ARCS|CON_VARIABLES","StatementOptionHelp":{"#cdata":"[Syntax: >CON_ARCS(taillist, headlist) | CON_VARIABLES(conlist, variablelist)]\n          \nIs similar to the PRINT SOME_CONS (conlist) statement except that, instead of displaying information \nabout all coefficients in specified constraints, information about only those coefficients that are \nassociated with arcs directed from a set of specified tail nodes toward a set of specified head nodes \nis displayed."},"StatementOptionType":"RS"},{"StatementOptionName":"PROBLEM","StatementOptionHelp":{"#cdata":"Is equivalent to the statement PRINT ARCS NONARCS CONSTRAINTS."},"StatementOptionType":"RS"},{"StatementOptionName":"BASIC","StatementOptionHelp":{"#cdata":"[Qualifier, following a slash /] \n          \nOnly rows that are associated with arcs or nonarc variables that are basic are displayed."},"StatementOptionType":"S"},{"StatementOptionName":"LONG","StatementOptionHelp":{"#cdata":"[Qualifier, following a slash /] \n          \nAll table columns are displayed (the default when no qualifier is used)."},"StatementOptionType":"S"},{"StatementOptionName":"NONBASIC","StatementOptionHelp":{"#cdata":"[Qualifier, following a slash /] \n          \nOnly rows that are associated with arcs or nonarc variables that are nonbasic are displayed."},"StatementOptionType":"S"},{"StatementOptionName":"NONZERO","StatementOptionHelp":{"#cdata":"[Qualifier, following a slash /] \n          \nOnly rows that have nonzero _FLOW_ column values (nonzero arc flows, nonzero nonarc variable values) \nare displayed."},"StatementOptionType":"S"},{"StatementOptionName":"SHORT","StatementOptionHelp":{"#cdata":"[Qualifier, following a slash /] \n          \nThe table columns are _N_, _FROM_, _TO_, _COST_, _CAPAC_, _LO_, _NAME_, and _FLOW_, or the names \nof the SAS variables specified in the corresponding variable lists (TAILNODE, HEADNODE, COST, CAPACITY, \nLO, and NAME lists). _COEF_ or the name of the SAS variable in the COEF list specification will head a \ncolumn when the SHORT qualifier is used in PRINT CONSTRAINTS, SOME_CONS, CON_ARCS, or CON_NONARCS."},"StatementOptionType":"S"},{"StatementOptionName":"ZERO","StatementOptionHelp":{"#cdata":"[Qualifier, following a slash /] \n          \nOnly rows that have zero _FLOW_ column values (zero arc flows, zero nonarc variable values) \nare displayed."},"StatementOptionType":"S"}]}},{"StatementName":"QUIT","StatementHelp":{"#cdata":"Syntax: QUIT ;\n\nThe QUIT statement indicates that PROC NETFLOW is to be terminated immediately. The solution \nis not saved in the current output data sets. The QUIT statement has no options."},"StatementOptions":null},{"StatementName":"RHS","StatementHelp":{"#cdata":"Syntax: RHS variable ;\n\nThe RHS variable list is used when the dense format of the CONDATA= data set is used. The values \nof the SAS variable specified in the RHS list are constraint right-hand-side values."},"StatementOptions":null},{"StatementName":"ROW","StatementHelp":{"#cdata":"Syntax: ROW variables ;\n\nThe ROW list is used when either the sparse or the dense format of side constraints is being used. \nSAS variables in the ROW list have values that are constraint or special row names. The SAS variables \nin the ROW list must have character values."},"StatementOptions":null},{"StatementName":"SAVE","StatementHelp":{"#cdata":"Syntax: SAVE options ; \n      \nThe SAVE statement can be used to specify output data sets and create observations in these data sets. \nUse the SAVE statement if no optimization is to be performed before these output data sets are created."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ARCOUT=|AOUT=","StatementOptionHelp":{"#cdata":"[Syntax: ARCOUT=SAS-data-set] \n          \nNames the output data set that receives all arc and nonarc variable data, including flows \nor values, and other information concerning the unconstrained optimal solution."},"StatementOptionType":"DV"},{"StatementOptionName":"CONOUT=|COUT=","StatementOptionHelp":{"#cdata":"[Syntax: CONOUT=SAS-data-set] \n          \nNames the output data set that receives an optimal primal solution to the problem obtained by \nperforming optimization that considers the side constraints."},"StatementOptionType":"DV"},{"StatementOptionName":"DUALOUT=|DOUT=","StatementOptionHelp":{"#cdata":"[Syntax: DUALOUT=SAS-data-set] \n          \nNames the output data set that receives an optimal dual solution to the problem obtained by \nperforming optimization that considers the side constraints."},"StatementOptionType":"DV"},{"StatementOptionName":"NODEOUT=|NOUT=","StatementOptionHelp":{"#cdata":"[Syntax: NODEOUT=SAS-data-set] \n          \nNames the output data set that receives all information about nodes (supply and demand and nodal \ndual variable values) and other information concerning the optimal solution found by the optimizer \nwhen neglecting side constraints."},"StatementOptionType":"DV"}]}},{"StatementName":"SHOW","StatementHelp":{"#cdata":"Syntax: SHOW options / qualifiers ;\n\nThe SHOW statement enables you to examine the status of the problem and values of the RESET \nstatement options. All output of the SHOW statement appears on the SAS log. The amount of \ninformation displayed when a SHOW statement is processed can be limited if some of the options \nof the SHOW statement are specified. "},"StatementOptions":{"StatementOption":[{"StatementOptionName":"STATUS","StatementOptionHelp":{"#cdata":"Produces optimization status reports. The warning messages are issued only if the network or entire \nproblem is infeasible."},"StatementOptionType":"RS"},{"StatementOptionName":"DATASETS","StatementOptionHelp":{"#cdata":"Produces a report on output data sets."},"StatementOptionType":"RS"},{"StatementOptionName":"PAUSE","StatementOptionHelp":{"#cdata":"Produces a report on the current settings of options used to make optimization pause."},"StatementOptionType":"RS"},{"StatementOptionName":"SIMPLEX","StatementOptionHelp":{"#cdata":"Produces the following: \n  \n   NOTE: Options and parameters that control the primal simplex \n         network algorithm (excluding those that affect the \n         pricing strategies) (SHOW SIMPLEX) \n         LRATIO1=FALSE \n         BIGM1=NOTWOPHASE1=TRUE, TWOPHASE1=NOBIGM1=FALSE \n         CYCLEMULT1=0.15 \n         PERTURB1=FALSE \n         MINBLOCK1=2 \n         INTFIRST=TRUE \n         LRATIO2=FALSE \n         BIGM2=NOTWOPHASE2=TRUE, TWOPHASE2=NOBIGM2=FALSE \n         REFACTFREQ=50 \n         U=0.1 \n         MAXLUUPDATES=6 \n         MAXL=40"},"StatementOptionType":"RS"},{"StatementOptionName":"PRICING","StatementOptionHelp":{"#cdata":"Produces the following: \n  \n   NOTE: Options and parameters that control the primal simplex \n         network algorithm pricing strategies (SHOW PRICING) \n         PRICETYPE1=Q \n         P1SCAN=FIRST \n         P1NPARTIAL=10 \n         Q1FILLSCAN=FIRST \n         QSIZE1=24 \n         REFRESHQ1=0.75 \n         REDUCEQSIZE1=1 \n         Q1FILLNPARTIAL=10 \n         PRICETYPE2=Q \n         P2SCAN=FIRST \n         P2NPARTIAL=10 \n         DUALFREQ=4 \n         Q2FILLSCAN=FIRST \n         QSIZE2=24 \n         REFRESHQ2=0.75 \n         REDUCEQSIZE2=1 \n         Q2FILLNPARTIAL=10"},"StatementOptionType":"RS"},{"StatementOptionName":"MISC","StatementOptionHelp":{"#cdata":"Produces the following: \n  \n   NOTE: Miscellaneous options and parameters (SHOW MISC) \n         VERBOSE=12 \n         ZTOL1=TRUE \n         ZERO1=1E-6 \n         FUTURE1=FALSE \n         ZTOL2=TRUE \n         ZERO2=1E-6 \n         FUTURE2=FALSE\n\n"},"StatementOptionType":"RS"},{"StatementOptionName":"RELEVANT","StatementOptionHelp":{"#cdata":"[Qualifier, following a slash /] \n          \nIndicates that you want information only on relevant options of the RESET statement."},"StatementOptionType":"S"},{"StatementOptionName":"STAGE","StatementOptionHelp":{"#cdata":"[Qualifier, following a slash /] \n          \nIndicates that you want to examine only the options that affect the optimization that is performed \nif a RUN statement is executed next."},"StatementOptionType":"S"}]}},{"StatementName":"SUPDEM","StatementHelp":{"#cdata":"Syntax: SUPDEM variable ;\n\nThe SAS variable in this list, which must be present in the NODEDATA= data set, contains supply \nand demand information for the nodes in the NODE list."},"StatementOptions":null},{"StatementName":"SUPPLY","StatementHelp":{"#cdata":"Syntax: SUPPLY variable ;\n\nThe SUPPLY statement identifies the SAS variable in the ARCDATA= data set that contains the supply \nat the node named in that observation's TAILNODE list variable."},"StatementOptions":null},{"StatementName":"TAILNODE|TAIL|FROMNODE|FROM","StatementHelp":{"#cdata":"Syntax: TAILNODE | TAIL | FROMNODE | FROM variable ;\n    | TAIL variable ;\n    | FROMNODE variable ;\n    | FROM variable ;\n\nThe TAILNODE statement specifies the SAS variable that must be present in the ARCDATA= data set that \nhas as values the names of tail nodes of arcs. The TAILNODE variable must have character values. It \nis not necessary to have a TAILNODE statement if the name of the SAS variable is _TAIL_ or _FROM_."},"StatementOptions":null},{"StatementName":"TYPE|CONTYPE","StatementHelp":{"#cdata":"Syntax: TYPE variable ; | CONTYPE variable ;\n\nThe TYPE list, which is optional, names the variable that has as values keywords that indicate either the \nconstraint type for each constraint or the type of special rows in the CONDATA= data set. The values of  \nthe TYPE list variable also indicate, in each observation of the CONDATA= data set, how values of the  \nVAR or COEF list variables are to be interpreted and how the type of each constraint or special row \nname is determined."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"CAPAC","StatementOptionHelp":{"#cdata":"Capacity"},"StatementOptionType":"S"},{"StatementOptionName":"COST","StatementOptionHelp":{"#cdata":"Cost"},"StatementOptionType":"S"},{"StatementOptionName":"EQ","StatementOptionHelp":{"#cdata":"Equal to"},"StatementOptionType":"S"},{"StatementOptionName":"FREE","StatementOptionHelp":{"#cdata":"Free row (used only for linear programs solved by interior point)"},"StatementOptionType":"S"},{"StatementOptionName":"GAIN","StatementOptionHelp":{"#cdata":"Gain in arc flow (generalized networks)"},"StatementOptionType":"S"},{"StatementOptionName":"GE","StatementOptionHelp":{"#cdata":"Greater than or equal to"},"StatementOptionType":"S"},{"StatementOptionName":"LE","StatementOptionHelp":{"#cdata":"Less than or equal to"},"StatementOptionType":"S"},{"StatementOptionName":"LOSS","StatementOptionHelp":{"#cdata":"Loss in arc flow (generalized networks)"},"StatementOptionType":"S"},{"StatementOptionName":"LOWERBD","StatementOptionHelp":{"#cdata":"Lower flow or value bound"},"StatementOptionType":"S"},{"StatementOptionName":"LOW","StatementOptionHelp":{"#cdata":"Lower flow or value bound"},"StatementOptionType":"S"},{"StatementOptionName":"MAXIMIZE","StatementOptionHelp":{"#cdata":"Maximize (opposite of cost)"},"StatementOptionType":"S"},{"StatementOptionName":"MINIMIZE","StatementOptionHelp":{"#cdata":"Minimize (same as cost)"},"StatementOptionType":"S"},{"StatementOptionName":"MULT","StatementOptionHelp":{"#cdata":"Value of arc multiplier (generalized networks)"},"StatementOptionType":"S"},{"StatementOptionName":"OBJECTIVE","StatementOptionHelp":{"#cdata":"Objective function (same as cost)"},"StatementOptionType":"S"},{"StatementOptionName":"RHS","StatementOptionHelp":{"#cdata":"Rhs of constraint"},"StatementOptionType":"S"},{"StatementOptionName":"TYPE","StatementOptionHelp":{"#cdata":"Type of constraint"},"StatementOptionType":"S"},{"StatementOptionName":"UPPCOST","StatementOptionHelp":{"#cdata":"Reserved for future use"},"StatementOptionType":"S"},{"StatementOptionName":"UNREST","StatementOptionHelp":{"#cdata":"Unrestricted variable (used only for linear programs solved by interior point)"},"StatementOptionType":"S"},{"StatementOptionName":"UPPER","StatementOptionHelp":{"#cdata":"Upper value bound or capacity; second letter must not be N"},"StatementOptionType":"S"}]}},{"StatementName":"VAR","StatementHelp":{"#cdata":"Syntax: VAR variables ;\n\nThe VAR variable list is used when the dense data format is used. The names of these SAS variables\nare also names of the arc and nonarc variables that have data in the CONDATA= data set."},"StatementOptions":null}]}}}