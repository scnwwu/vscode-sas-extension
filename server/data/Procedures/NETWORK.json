{"Procedure":{"Name":"NETWORK","#comment":{},"ProductGroup":"CAS|VIYA|DATA MINING AND MACHINE LEARNING","ProcedureHelp":{"#cdata":"Syntax: PROC NETWORK <options>;   \n    BY variables;\n    DISPLAY <table-list> </ options>;\n    DISPLAYOUT table-spec-list </ options>;\n    LINKSVAR <options>; \n    NODESVAR <options>; \n    NODESSUBSETVAR <options>;\n    BICONNECTEDCOMPONENTS;\n    CENTRALITY < options >;\n    CLIQUE <options>; \n    CONNECTEDCOMPONENTS <options>;\n    CORE < options >;\n    CYCLE <options>; \n    REACH < options >;\n    SHORTESTPATH <options>; \n    SUMMARY <options>; \n    TRANSITIVECLOSURE <options>;\n    \nThe NETWORK procedure includes a number of graph theory and network analysis algorithms that can \naugment data mining and machine learning approaches. In many practical applications of data mining \nand machine learning models, pairwise interaction between the entities of interest in the model often \nplays an important role. For example, when you are modeling churn in a telecommunications network to \nsupport a retention campaign, the influence of individual customers on the other customers\u2014such as \nfriends and acquaintances that they regularly interact with\u2014might contribute to the propensity of other \ncustomers to churn. You could likewise imagine a customer being able to influence the propensity of his \nor her acquaintances to acquire new products. Social networks such as Facebook and Twitter are obvious \nexamples of networks that represent such interactions between individuals."},"ProcedureOptions":{"ProcedureOption":[{"ProcedureOptionName":"DIRECTION=","ProcedureOptionHelp":{"#cdata":"Syntax: DIRECTION=DIRECTED | UNDIRECTED \n\nSpecifies whether the input graph should be considered directed or undirected."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"DIRECTED","@Value2":"UNDIRECTED"},"ProcedureOptionToolTips":{"@ToolTip1":"Specifies the graph as directed.","@ToolTip2":"Specifies the graph as undirected."}},{"ProcedureOptionName":"INCLUDESELFLINK","ProcedureOptionHelp":{"#cdata":"Includes self-links, such as (i,i), when an input graph is read. By default, when PROC NETWORK \nreads the LINKS= data table, it removes all self-links."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"INDEXOFFSET=","ProcedureOptionHelp":{"#cdata":"Syntax: INDEXOFFSET=number \n      \nSpecifies the index offset for identifiers in the log and results output data tables. For example, \nif three cycles are found in cycle enumeration, they are labeled cycles 1, 2, and 3 by default. \nIf INDEXOFFSET=4, they are labeled cycles 4, 5, and 6. The value of number must be an integer \ngreater than or equal to 0. By default, INDEXOFFSET=1."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"LINKS=","ProcedureOptionHelp":{"#cdata":"Syntax: LINKS=CAS-libref.data-table \n      \nSpecifies the input data table that contains the graph link information. CAS-libref.data-table \nis a two-level name, where CAS-libref refers to the caslib and session identifier, and data-table \nspecifies the name of the input data table."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"LOGFREQUENCYTIME=|LOGFREQTIME=","ProcedureOptionHelp":{"#cdata":"Syntax: LOGFREQTIME=number | LOGFREQUENCYTIME=number \n      \nControls the frequency, in number of seconds, for displaying iteration logs for some algorithms. \nThis option is useful for computationally intensive algorithms. Setting this value too low can \nhurt algorithm performance. The value of number can be any integer greater than or equal to 1. \n\nBy default, LOGFREQTIME=5."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"LOGLEVEL=","ProcedureOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE \n      \nControls the amount of information that is displayed in the SAS log. \n\nBy default, LOGLEVEL=BASIC."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"NONE","@Value2":"BASIC","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Turns off all procedure-related messages in the SAS log. ","@ToolTip2":"Displays a brief summary of the algorithmic processing. ","@ToolTip3":"Displays a moderately detailed summary of the input, output, and algorithmic processing.","@ToolTip4":"Displays a more detailed summary of the input, output, and algorithmic processing."}},{"ProcedureOptionName":"NODES=","ProcedureOptionHelp":{"#cdata":"Syntax: NODES=CAS-libref.data-table \n      \nSpecifies the input data table that contains the graph node information. \n\nCAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session \nidentifier, and data-table specifies the name of the input data table."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"NODESSUBSET=","ProcedureOptionHelp":{"#cdata":"Syntax: NODESSUBSET=CAS-libref.data-table \n      \nSpecifies the input data table that contains the graph node subset information. \n\nCAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session \nidentifier, and data-table specifies the name of the input data table."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"NTHREADS=","ProcedureOptionHelp":{"#cdata":"Syntax: NTHREADS=number \n      \nSpecifies the maximum number of threads to use for multithreaded processing. Some of the algorithms \ncan take advantage of multicore machines and can run faster when number is greater than 1. Algorithms \nthat cannot take advantage of this option use only one thread even if number is greater than 1. For \ndistributed execution, number specifies the maximum number of threads to use on each machine. The \nvalue of number can be any integer between 1 and 256, inclusive. The default is the number of cores \non the machine that executes the process or the number of cores permissible based on your installation \n(whichever is less). The number of simultaneously active CPUs is limited by your installation and \nlicense configuration."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"OUTLINKS=","ProcedureOptionHelp":{"#cdata":"Syntax: OUTLINKS=CAS-libref.data-table \n      \nSpecifies the output data table to contain the graph link information along with any results from the \nalgorithms that calculate metrics on links. CAS-libref.data-table is a two-level name, where CAS-libref \nrefers to the caslib and session identifier, and data-table specifies the name of the output data table."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"OUTNODES=","ProcedureOptionHelp":{"#cdata":"Syntax: OUTNODES=CAS-libref.data-table \n      \nSpecifies the output data table to contain the graph node information along with any results from \nthe algorithms that calculate metrics on nodes. CAS-libref.data-table is a two-level name, where \nCAS-libref refers to the caslib and session identifier, and data-table specifies the name of the\noutput data table."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"STANDARDIZEDLABELS","ProcedureOptionHelp":{"#cdata":"Specifies that the input graph data are in a standardized format."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"TIMETYPE=","ProcedureOptionHelp":{"#cdata":"Syntax: TIMETYPE=CPU | REAL \n      \nSpecifies whether CPU time or real time is used for each algorithm\u2019s MAXTIME= option (where applicable).\n\nBy default, TIMETYPE=REAL."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"CPU","@Value2":"REAL"},"ProcedureOptionToolTips":{"@ToolTip1":"Specifies units of CPU time. The time restriction is applied per processing machine (not across all machines).","@ToolTip2":"Specifies units of real time."}}]},"ProcedureStatements":{"ProcedureStatement":[{"StatementName":"BICONNECTEDCOMPONENTS","StatementHelp":{"#cdata":"Syntax: BICONNECTEDCOMPONENTS ;\n      \nThe BICONNECTEDCOMPONENTS statement requests that PROC NETWORK find biconnected components and \narticulation points of an undirected input graph."},"StatementOptions":null},{"StatementName":"BY","StatementHelp":{"#cdata":"Syntax: BY variables;\n\nYou can specify a BY statement in PROC NETWORK to obtain separate analyses of observations in groups \nthat are defined by the values of the BY variables. If you specify more than one BY statement, only the \nlast one specified is used.\n\nThe BY statement in PROC NETWORK is not supported when either a nodes or nodes subset data table is \nused. The BY variable must come from the LINKS= data table."},"StatementOptions":null},{"StatementName":"CENTRALITY","StatementHelp":{"#cdata":"Syntax: CENTRALITY < options > ; \n\nThe CENTRALITY statement enables you to select which centrality metrics to calculate \nfor the given input graph. It also enables you to specify options for particular metrics. \nThe resulting metrics are included in the node output data set (specified by the OUT_NODES= option) \nor the link output data set (specified by the OUT_LINKS= option)."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"AUTH=","StatementOptionHelp":{"#cdata":"Syntax: AUTH=WEIGHT | UNWEIGHT | BOTH \n          \nSpecifies which type of authority centrality to calculate.\n\nIf the input graph does not contain weights, then WEIGHT and UNWEIGHT both give the same \nresults (using 1.0 for each link weight). This centrality metric can be used only for \ndirected graphs."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"WEIGHT","@Value2":"UNWEIGHT","@Value3":"BOTH"},"StatementOptionToolTips":{"@ToolTip1":"Calculates authority centrality based on the weighted graph.","@ToolTip2":"Calculates authority centrality based on the unweighted graph.","@ToolTip3":"Calculates authority centrality based on both weighted and unweighted graphs."}},{"StatementOptionName":"BETWEEN=","StatementOptionHelp":{"#cdata":"Syntax: BETWEEN=WEIGHT | UNWEIGHT | BOTH \n          \nSpecifies which type of betweenness centrality to calculate.\n\nIf the input graph does not contain weights, then WEIGHT and UNWEIGHT both give the same \nresults (using 1.0 for each link weight). If the OUT_NODES= option is specified in the \nPROC OPTGRAPH statement, the node betweenness metric is produced; if the OUT_LINKS= option \nis specified, the link betweenness metric is produced."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"WEIGHT","@Value2":"UNWEIGHT","@Value3":"BOTH"},"StatementOptionToolTips":{"@ToolTip1":"Calculates betweenness centrality based on the weighted graph.","@ToolTip2":"Calculates betweenness centrality based on the unweighted graph.","@ToolTip3":"Calculates betweenness centrality based on both weighted and unweighted graphs."}},{"StatementOptionName":"BETWEENNORM=","StatementOptionHelp":{"#cdata":"Syntax: BETWEENNORM=TRUE | FALSE\n          \nSpecifies whether to normalize the betweenness centrality metrics."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"TRUE","@Value2":"FALSE"},"StatementOptionToolTips":{"@ToolTip1":"Normalizes the betweenness metrics. This is the default.","@ToolTip2":"Does not normalize the betweenness metrics."}},{"StatementOptionName":"CLOSE=","StatementOptionHelp":{"#cdata":"Syntax: CLOSE=WEIGHT | UNWEIGHT | BOTH \n          \nSpecifies which type of closeness centrality to calculate.\n\nIf the input graph does not contain weights, then WEIGHT and UNWEIGHT both give the \nsame results (using 1.0 for each link weight). "},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"WEIGHT","@Value2":"UNWEIGHT","@Value3":"BOTH"},"StatementOptionToolTips":{"@ToolTip1":"Calculates closeness centrality based on the weighted graph.","@ToolTip2":"Calculates closeness centrality based on the unweighted graph.","@ToolTip3":"Calculates closeness centrality based on both weighted and unweighted graphs."}},{"StatementOptionName":"CLOSENOPATH=","StatementOptionHelp":{"#cdata":"Syntax: CLOSENOPATH=DIAMETER | HARMONIC | NNODES | ZERO \n          \nSpecifies a method for accounting for a shortest path between two nodes when a path does not \nexist (disconnected nodes).\n\nBy default, CLOSENOPATH=DIAMETER."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"DIAMETER","@Value2":"HARMONIC","@Value3":"NNODES","@Value4":"ZERO"},"StatementOptionToolTips":{"@ToolTip1":"Uses the graph diameter as a shortest path between disconnected nodes.","@ToolTip2":"Uses the harmonic formula for calculating closeness centrality.","@ToolTip3":"Uses the number of nodes as a shortest path between disconnected nodes.","@ToolTip4":"Uses zero as a shortest path between disconnected nodes."}},{"StatementOptionName":"CLUSTERINGCOEF","StatementOptionHelp":{"#cdata":"Calculates the node clustering coefficient."},"StatementOptionType":"S"},{"StatementOptionName":"DEGREE","StatementOptionHelp":{"#cdata":"Calculates the degree centrality."},"StatementOptionType":"S"},{"StatementOptionName":"EIGEN=","StatementOptionHelp":{"#cdata":"Syntax: EIGEN=WEIGHT | UNWEIGHT | BOTH \n          \nSpecifies which type of eigenvector centrality to calculate."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"WEIGHT","@Value2":"UNWEIGHT","@Value3":"BOTH"},"StatementOptionToolTips":{"@ToolTip1":"Calculates eigenvector centrality based on the weighted graph.","@ToolTip2":"Calculates centrality based on the unweighted graph.","@ToolTip3":"Calculates centrality based on both weighted and unweighted graphs."}},{"StatementOptionName":"EIGENALGORITHM=","StatementOptionHelp":{"#cdata":"Syntax: EIGENALGORITHM=AUTOMATIC | JACOBIDAVIDSON | POWER \n          \nSpecifies the algorithm to use in calculating centrality metrics that require solving eigensystems\u2014\nthat is, when the EIGEN, HUB, or AUTH option (or some combination) is specified.\n\nBy default, EIGENALGORITHM=AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"JACOBIDAVIDSON","@Value3":"POWER"},"StatementOptionToolTips":{"@ToolTip1":"Automatically determines the eigensolver to use.","@ToolTip2":"Uses a variant of the Jacobi-Davidson algorithm for solving eigensystems.","@ToolTip3":"Uses the power method to calculate eigenvectors. "}},{"StatementOptionName":"EIGENMAXITER=","StatementOptionHelp":{"#cdata":"Syntax: EIGENMAXITER=num \n          \nSpecifies the maximum number of iterations to use for eigenvector calculations to limit \nthe amount of computation time spent when convergence is slow. By default, EIGENMAXITERS=10,000."},"StatementOptionType":"V"},{"StatementOptionName":"HUB=","StatementOptionHelp":{"#cdata":"Syntax: HUB=WEIGHT | UNWEIGHT | BOTH \n          \nSpecifies which type of hub centrality to calculate."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"WEIGHT","@Value2":"UNWEIGHT","@Value3":"BOTH"},"StatementOptionToolTips":{"@ToolTip1":"Calculates hub centrality based on the weighted graph.","@ToolTip2":"Calculates hub centrality based on the unweighted graph.","@ToolTip3":"Calculates hub centrality based on both weighted and unweighted graphs."}},{"StatementOptionName":"INFLUENCE=","StatementOptionHelp":{"#cdata":"Syntax: INFLUENCE=WEIGHT | UNWEIGHT | BOTH \n          \nSpecifies which type of influence centrality to calculate."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"WEIGHT","@Value2":"UNWEIGHT","@Value3":"BOTH"},"StatementOptionToolTips":{"@ToolTip1":"Calculates influence centrality based on the weighted graph.","@ToolTip2":"Calculates influence centrality based on the unweighted graph.","@ToolTip3":"Calculates influence centrality based on both weighted and unweighted graphs."}}]}},{"StatementName":"CLIQUE","StatementHelp":{"#cdata":"Syntax: CLIQUE < options >;\n      \nThe CLIQUE statement invokes an algorithm that finds maximal cliques in the input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"MAXCLIQUES=","StatementOptionHelp":{"#cdata":"Syntax: MAXCLIQUES=number | ALL \n          \nSpecifies the maximum number of cliques to return during clique enumeration. You can specify either \na number (which can be any 32-bit integer greater than or equal to 1) or ALL (which represents the \nmaximum that can be represented by a 32-bit integer). By default, MAXCLIQUES=1."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=number \n          \nSpecifies the maximum amount of time to spend finding cliques. The type of time (either CPU time \nor real time) is determined by the value of the TIMETYPE= option in the PROC NETWORK statement. \nThe default is the largest number that can be represented by a double."},"StatementOptionType":"V"},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=CAS-libref.data-table \n          \nSpecifies the output data table to contain the maximal cliques. CAS-libref.data-table is a two-level \nname, where CAS-libref refers to the caslib and session identifier, and data-table specifies the name \nof the output data table."},"StatementOptionType":"V"}]}},{"StatementName":"COMMUNITY","StatementHelp":{"#cdata":"Syntax: COMMUNITY < options > ; \n\nThe COMMUNITY statement invokes an algorithm that detects communities of the input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ALGORITHM=","StatementOptionHelp":{"#cdata":"Syntax: ALGORITHM=LOUVAIN | LABELPROP | PARALLELLABELPROP\n          \nSpecifies the algorithm to use for community detection.\n\nBy default, ALGORITHM=LOUVAIN."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"LOUVAIN","@Value2":"LABELPROP","@Value3":"PARALLELLABELPROP"},"StatementOptionToolTips":{"@ToolTip1":"Uses the Louvain algorithm proposed in Blondel et al. (2008).","@ToolTip2":"Uses the label propagation algorithm proposed in Raghavan, Albert, and Kumara (2007).","@ToolTip3":"Uses the parallel (distributed and threaded) label propagation algorithm developed by SAS."}},{"StatementOptionName":"INTERNALFORMAT=","StatementOptionHelp":{"#cdata":"Syntax: INTERNALFORMAT=FULL | THIN \n          \nSpecifies which internal graph format for the community detection algorithm to use.\n\nBy default, INTERNALFORMAT=THIN."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"FULL","@Value2":"THIN"},"StatementOptionToolTips":{"@ToolTip1":"Stores the graph in standard (adjacency-list-based) format.","@ToolTip2":"Stores the graph in thin (simple list of links) format."}},{"StatementOptionName":"LINKREMOVALRATIO=","StatementOptionHelp":{"#cdata":"Syntax: LINKREMOVALRATIO=number\n          \nSpecifies the percentage of small-weight links to be removed around each node neighborhood. A link \nis usually removed if its weight is relatively smaller than the weights of the neighboring links."},"StatementOptionType":"V"},{"StatementOptionName":"MAXITER=","StatementOptionHelp":{"#cdata":"Syntax: MAXITER=num \n          \nSpecifies the maximum number of iterations allowed in the algorithm. The default is 20 when \nALGORITHM=LOUVAIN and 100 when ALGORITHM=LABEL_PROP or ALGORITHM=PARALLEL_LABEL_PROP."},"StatementOptionType":"V"},{"StatementOptionName":"OUTCOMMLINKS=","StatementOptionHelp":{"#cdata":"Syntax: OUTCOMMLINKS=CAS-libref.data-table \n          \nSpecifies the output data set that describes the links between communities. CAS-libref.data-table \nis a two-level name, where CAS-libref refers to the caslib and session identifier, and data-table \nspecifies the name of the output data table. "},"StatementOptionType":"V"},{"StatementOptionName":"OUTCOMMUNITY=","StatementOptionHelp":{"#cdata":"Syntax: OUTCOMMUNITY=CAS-libref.data-table\n          \nSpecifies the output data table that contains the number of nodes in each community. CAS-libref.data-table \nis a two-level name, where CAS-libref refers to the caslib and session identifier, and data-table specifies \nthe name of the output data table."},"StatementOptionType":"V"},{"StatementOptionName":"OUTLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: OUTLEVEL=CAS-libref.data-table\n          \nSpecifies the output data table that contains community information at different resolution levels. \nCAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session identifier, \nand data-table specifies the name of the output data table."},"StatementOptionType":"V"},{"StatementOptionName":"OUTOVERLAP=","StatementOptionHelp":{"#cdata":"Syntax: OUTOVERLAP=CAS-libref.data-table\n          \nSpecifies the output data table that describes the intensity of each node. CAS-libref.data-table \nis a two-level name, where CAS-libref refers to the caslib and session identifier, and data-table \nspecifies the name of the output data table."},"StatementOptionType":"V"},{"StatementOptionName":"RANDOMFACTOR=","StatementOptionHelp":{"#cdata":"Syntax: RANDOMFACTOR=number\n          \nSpecifies the random factor for the parallel label propagation algorithm. At each iteration, \nnumber x 100% of the nodes are randomly selected to skip the label propagation step. Specify \na number between 0 and 1. The default is 0.15, which means that 15% of nodes skip the label \npropagation step at each iteration."},"StatementOptionType":"V"},{"StatementOptionName":"RANDOMSEED=","StatementOptionHelp":{"#cdata":"Syntax: RANDOMSEED=number \n          \nSpecifies the random seed for the parallel label propagation algorithm. At each iteration, some \nnodes are randomly selected to skip the label propagation step, based on the value that you specify \nin the RANDOMFACTOR= option. To choose a different set of random samples, specify a number in the \nRANDOMSEED= option. By default, RANDOMSEED=1234."},"StatementOptionType":"V"},{"StatementOptionName":"RECURSIVE","StatementOptionHelp":{"#cdata":"Syntax: RECURSIVE (options)\n          \nBreaks down large communities into smaller ones until the specified conditions are satisfied. \nThis option starts with the keyword RECURSIVE followed by any combination of three suboptions \nenclosed in parentheses\u2014for example, RECURSIVE (MAXCOMMSIZE=500) or RECURSIVE (MAXCOMMSIZE=1000 \nMAXDIAMETER=3 RELATION=AND)."},"StatementOptionType":"S","SubOptionsKeywords":"MAXCOMMSIZE=|MAXDIAMETER=|RELATION="},{"StatementOptionName":"RESOLUTIONLIST","StatementOptionHelp":{"#cdata":"Syntax: RESOLUTIONLIST=num_list \n          \nSpecifies a list of resolution values (positive numbers) that are separated by spaces \n(for example, 4.3 2.1 1.0 0.6 0.2)."},"StatementOptionType":"V"},{"StatementOptionName":"TOLERANCE=|MODULARITY=","StatementOptionHelp":{"#cdata":"Syntax: TOLERANCE=|MODULARITY=number \n          \nSpecifies the tolerance value for when to stop iterations."},"StatementOptionType":"V"}]}},{"StatementName":"CONNECTEDCOMPONENTS","StatementHelp":{"#cdata":"Syntax: CONNECTEDCOMPONENTS < options >;\n      \nThe CONNECTEDCOMPONENTS statement invokes an algorithm that finds the connected components of the \ninput graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ALGORITHM=","StatementOptionHelp":{"#cdata":"Syntax: ALGORITHM=AUTOMATIC | DFS | PARALLEL | UNIONFIND \n          \nSpecifies the algorithm to use for calculating connected components. \n\nBy default, ALGORITHM=UNIONFIND for undirected graphs, and ALGORITHM=DFS for directed graphs."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"DFS","@Value3":"PARALLEL","@Value4":"UNIONFIND"},"StatementOptionToolTips":{"@ToolTip1":"Automatically determines the algorithm for connected components.","@ToolTip2":"Uses the depth-first search algorithm for connected components.","@ToolTip3":"Uses the distributed parallel union-find algorithm for connected components. You can specify this  value when the number of machines in your session is greater than 1. You can use this algorithm  only with undirected graphs.","@ToolTip4":"Uses the union-find algorithm for connected components. You can use this algorithm only with  undirected graphs."}},{"StatementOptionName":"INTERNALFORMAT=","StatementOptionHelp":{"#cdata":"Syntax: INTERNALFORMAT=FULL | THIN \n          \nSpecifies the internal graph format for the connected components algorithm to use.\n\nBy default, INTERNALFORMAT=FULL when ALGORITHM=DFS and INTERNALFORMAT=THIN for any other value \nof the ALGORITHM= option."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"FULL","@Value2":"THIN"},"StatementOptionToolTips":{"@ToolTip1":"Stores the graph in standard (adjacency-list-based) format. ","@ToolTip2":"Stores the graph in thin (simple list of links) format."}}]}},{"StatementName":"CORE","StatementHelp":{"#cdata":"Syntax: CORE < option > ; \n\nThe CORE statement invokes an algorithm that finds the core decomposition of the input graph."},"StatementOptions":{"StatementOption":{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=number\n          \nSpecifies the maximum amount of time to spend calculating the core decomposition. The type of time \n(either CPU time or real time) is determined by the value of the TIMETYPE= option in the PROC NETWORK \nstatement."},"StatementOptionType":"V"}}},{"StatementName":"CYCLE","StatementHelp":{"#cdata":"Syntax: CYCLE < options > ; \n\nThe CYCLE statement invokes an algorithm that finds the cycles (or the existence of a cycle) \nin the input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ALGORITHM=","StatementOptionHelp":{"#cdata":"Syntax: ALGORITHM=BACKTRACK | BUILD \n          \nSpecifies which algorithm to use in enumerating cycles.\n\nBy default, ALGORITHM=BACKTRACK for MAXLENGTH greater than 20; otherwise, ALGORITHM=BUILD."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"BACKTRACK","@Value2":"BUILD"},"StatementOptionToolTips":{"@ToolTip1":"Uses a backtracking algorithm based on Johnson (1975).","@ToolTip2":"Uses a building algorithm based on Liu and Wang (2006). "}},{"StatementOptionName":"MAXCYCLES=","StatementOptionHelp":{"#cdata":"Syntax: MAXCYCLES=number | ALL \n          \nSpecifies the maximum number of cycles to return during cycle enumeration. You can specify either \na number (which can be any 32-bit integer greater than or equal to 1) or ALL (which represents the \nmaximum that can be represented by a 32-bit integer). By default, MAXCYCLES=1."},"StatementOptionType":"V"},{"StatementOptionName":"MAXLENGTH=","StatementOptionHelp":{"#cdata":"Syntax: MAXLENGTH=number \n          \nSpecifies the maximum number of links in a cycle. Any cycle whose length is greater than number \nis removed from the results. The default is the largest number that can be represented by a 32-bit \ninteger, which causes no cycles to be removed from the results."},"StatementOptionType":"V"},{"StatementOptionName":"MAXLINKWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MAXLINKWEIGHT=number \n          \nSpecifies the maximum sum of link weights in a cycle. Any cycle whose sum of link weights is greater \nthan number is removed from the results. The default is the largest number that can be represented by \na double, which causes no cycles to be removed from the results."},"StatementOptionType":"V"},{"StatementOptionName":"MAXNODEWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MAXNODEWEIGHT=number \n          \nSpecifies the maximum sum of node weights in a cycle. Any cycle whose sum of node weights is greater \nthan number is removed from the results. The default is the largest number that can be represented by \na double, which causes no cycles to be removed from the results."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=number \n          \nSpecifies the maximum amount of time to spend finding cycles. The type of time (either CPU time \nor real time) is determined by the value of the TIMETYPE= option in the PROC NETWORK statement. \nThe default is the largest number that can be represented by a double."},"StatementOptionType":"V"},{"StatementOptionName":"MINLENGTH=","StatementOptionHelp":{"#cdata":"Syntax: MINLENGTH=number \n          \nSpecifies the minimum number of links in a cycle. Any cycle that has fewer links than number \nis removed from the results. By default, MINLENGTH=1 and no cycles are removed from the results."},"StatementOptionType":"V"},{"StatementOptionName":"MINLINKWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MINLINKWEIGHT=number \n          \nSpecifies the minimum sum of link weights in a cycle. Any cycle whose sum of link weights is less \nthan number is removed from the results. The default is the largest (in magnitude) negative number \nthat can be represented by a double, which causes no cycles to be removed from the results."},"StatementOptionType":"V"},{"StatementOptionName":"MINNODEWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MINNODEWEIGHT=number \n          \nSpecifies the minimum sum of node weights in a cycle. Any cycle whose sum of node weights is less \nthan number is removed from the results. The default is the largest (in magnitude) negative number \nthat can be represented by a double, which causes no cycles to be removed from the results."},"StatementOptionType":"V"},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=CAS-libref.data-table \n          \nSpecifies the output data table to contain the cycles found. \n\nCAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session identifier, \nand data-table specifies the name of the output data table."},"StatementOptionType":"V"}]}},{"StatementName":"DISPLAY","StatementHelp":{"#cdata":"Syntax: DISPLAY <table-list> </ options>;\n      \nThe DISPLAY statement enables you to specify a list of display tables to display or exclude. This statement \nis similar to the ODS SELECT, ODS EXCLUDE, and ODS TRACE statements. However, the DISPLAY statement can improve \nperformance when a large number of tables could be generated (such as in BY-group processing). The procedure \nprocesses the DISPLAY statement on a CAS server and thus sends only a subset of ODS tables to the SAS client. \nBecause ODS statements are processed on a SAS client, first all the generated display tables are sent to the \nclient, and then the client creates a subset. \n\nIf you use both DISPLAY and ODS statements together, the DISPLAY statement takes precedence over the ODS \nstatements."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"CASESENSITIVE","StatementOptionHelp":{"#cdata":"Performs a case-sensitive comparison of table names in the table-list to display table names when \ntables are subsetted for display. To preserve case, you must enclose table names in the table-list \nin quotation marks."},"StatementOptionType":"S"},{"StatementOptionName":"EXCLUDE","StatementOptionHelp":{"#cdata":"Displays all display tables except those specified in the table-list."},"StatementOptionType":"S"},{"StatementOptionName":"EXCLUDEALL","StatementOptionHelp":{"#cdata":"Suppresses display of all tables. This option takes precedence over the other options."},"StatementOptionType":"S"},{"StatementOptionName":"TRACE","StatementOptionHelp":{"#cdata":"Displays the display table names, labels, and paths."},"StatementOptionType":"S"}]}},{"StatementName":"DISPLAYOUT","StatementHelp":{"#cdata":"Syntax: DISPLAYOUT table-spec-list < / options > ;\n      \nThe DISPLAYOUT statement enables you to create CAS output tables from your displayed output. This\nstatement is similar to the ODS OUTPUT statement.\n\nThe table-spec-list specifies a list of CAS output tables to create. Each entry in the list has either a key or a\nkey=value format:\n\n  key=value specifies key as the ODS table name, path, or partial pathname, and specifies value as the\n    CAS output table name.\n  key specifies key as the ODS table name and also as the CAS output table name.\n  \nTable names and partial pathnames are discussed under the DISPLAY statement. The DISPLAYOUT\nstatement does not support regular expressions."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"NOREPLACE","StatementOptionHelp":{"#cdata":"Does not replace an existing CAS output table of the same name."},"StatementOptionType":"S"},{"StatementOptionName":"REPEATED","StatementOptionHelp":{"#cdata":"Replicates the CAS output tables on all nodes."},"StatementOptionType":"S"}]}},{"StatementName":"LINKSVAR","StatementHelp":{"#cdata":"Syntax: LINKSVAR < options >;\n      \nThe LINKSVAR statement enables you to explicitly specify the data variable names for PROC NETWORK \nto use when it reads the data table that you specify in the LINKS= option in the PROC NETWORK \nstatement."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"AUXWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: AUXWEIGHT=column \n          \nSpecifies the name of the data variable for the auxiliary link weights. The value of the column \nvariable must be numeric."},"StatementOptionType":"V"},{"StatementOptionName":"FROM=","StatementOptionHelp":{"#cdata":"Syntax: FROM=column \n          \nSpecifies the name of the data variable for the from nodes. The value of the column variable can \nbe numeric or character."},"StatementOptionType":"V"},{"StatementOptionName":"TO=","StatementOptionHelp":{"#cdata":"Syntax: TO=column \n          \nSpecifies the name of the data variable for the to nodes. The value of the column variable can be \nnumeric or character."},"StatementOptionType":"V"},{"StatementOptionName":"WEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT=column \n      \nSpecifies the name of the data variable for the link weights. The value of the column variable \nmust be numeric."},"StatementOptionType":"V"}]}},{"StatementName":"NODESSUBSETVAR","StatementHelp":{"#cdata":"Syntax: NODESSUBSETVAR < options >;\n          \nThe NODESSUBSETVAR statement enables you to explicitly specify the data variable names for \nPROC NETWORK to use when it reads the data table that you specify in the NODESSUBSET= \noption in the PROC NETWORK statement."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"NODE=","StatementOptionHelp":{"#cdata":"Syntax: NODE=column \n          \nSpecifies the name of the data variable for the nodes. The value of the column variable can \nbe numeric or character."},"StatementOptionType":"V"},{"StatementOptionName":"REACH=","StatementOptionHelp":{"#cdata":"Syntax: REACH=column\n          \nSpecifies the name of the data variable for the reach identifier. The value of the column variable \nmust be numeric."},"StatementOptionType":"V"},{"StatementOptionName":"SINK=","StatementOptionHelp":{"#cdata":"Syntax: SINK=column \n          \nSpecifies the name of the data variable for the sink indicator. The value of the column variable \nmust be numeric."},"StatementOptionType":"V"},{"StatementOptionName":"SOURCE=","StatementOptionHelp":{"#cdata":"Syntax: SOURCE=column \n          \nSpecifies the name of the data variable for the source indicator. The value of the column variable \nmust be numeric."},"StatementOptionType":"V"}]}},{"StatementName":"NODESVAR","StatementHelp":{"#cdata":"Syntax: NODESVAR < options >;\n      \nThe NODESVAR statement enables you to explicitly specify the data variable names for PROC NETWORK \nto use when it reads the data table that you specify in the NODES= option in the PROC NETWORK \nstatement."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"NODE=","StatementOptionHelp":{"#cdata":"Syntax: NODE=column \n          \nSpecifies the name of the data variable for the nodes. The value of the column variable can \nbe numeric or character."},"StatementOptionType":"V"},{"StatementOptionName":"WEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT=column \n          \nSpecifies the name of the data variable for the node weights. The value of the column variable must \nbe numeric."},"StatementOptionType":"V"}]}},{"StatementName":"REACH","StatementHelp":{"#cdata":"Syntax: REACH < options > ; \n\nThe REACH statement invokes an algorithm that calculates the reach (ego) network on an \ninput graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"DIGRAPH","StatementOptionHelp":{"#cdata":"Calculates the directed reach counts when computing the reach networks and includes the \ndirected counts in the resulting output data set that is specified in the OUT_COUNTS= \noption. This option is ignored unless you specify MAXREACH=1 in the REACH statement."},"StatementOptionType":"S"},{"StatementOptionName":"EACHSOURCE","StatementOptionHelp":{"#cdata":"Treats each node as a source and calculates a reach network from each one."},"StatementOptionType":"S"},{"StatementOptionName":"MAXREACH=","StatementOptionHelp":{"#cdata":"Syntax: MAXREACH=number\n          \nSpecifies the maximum number of links to allow from each source node in a reach network. \n\nBy default, MAXREACH=1."},"StatementOptionType":"V"},{"StatementOptionName":"OUTCOUNTS=","StatementOptionHelp":{"#cdata":"Syntax: OUTCOUNTS=CAS-libref.data-table\n          \nSpecifies the output data table to contain the node counts in each reach network. CAS-libref.data-table \nis a two-level name, where CAS-libref refers to the caslib and session identifier, and data-table specifies \nthe name of the output data table."},"StatementOptionType":"V"},{"StatementOptionName":"OUTREACHLINKS=","StatementOptionHelp":{"#cdata":"Syntax: OUTREACHLINKS=CAS-libref.data-table\n          \nSpecifies the output data table to contain the links in each reach network. CAS-libref.data-table \nis a two-level name, where CAS-libref refers to the caslib and session identifier, and data-table \nspecifies the name of the output data table. "},"StatementOptionType":"V"},{"StatementOptionName":"OUTREACHNODES=","StatementOptionHelp":{"#cdata":"Syntax: OUTREACHNODES=CAS-libref.data-table\n          \nSpecifies the output data table to contain the nodes in each reach network. CAS-libref.data-table \nis a two-level name, where CAS-libref refers to the caslib and session identifier, and data-table \nspecifies the name of the output data table."},"StatementOptionType":"V"}]}},{"StatementName":"SHORTESTPATH","StatementHelp":{"#cdata":"Syntax: SHORTESTPATH < options >; \n      \nThe SHORTESTPATH statement invokes an algorithm that calculates shortest paths between pairs of \nnodes in the input graph. By default, PROC NETWORK finds a shortest path for each possible \ncombination of source and sink nodes."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"MAXPATHWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MAXPATHWEIGHT=number \n          \nSpecifies the maximum path weight. Any shortest path whose sum of link weights is greater than \nnumber is removed from the results. The default is the largest number that can be represented \nby a double, which causes no paths to be removed from the results."},"StatementOptionType":"V"},{"StatementOptionName":"OUTPATHS=|OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUTPATHS=CAS-libref.data-table | OUT=CAS-libref.data-table \n          \nSpecifies the output data table to contain the shortest paths. \n\nCAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session identifier, \nand data-table specifies the name of the output data table."},"StatementOptionType":"V"},{"StatementOptionName":"OUTWEIGHTS=","StatementOptionHelp":{"#cdata":"Syntax: OUTWEIGHTS=CAS-libref.data-table \n          \nSpecifies the output data table to contain the shortest path summaries. \n\nCAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session identifier, \nand data-table specifies the name of the output data table."},"StatementOptionType":"V"},{"StatementOptionName":"SINK=","StatementOptionHelp":{"#cdata":"Syntax: SINK=sink-node \n          \nSpecifies the sink node for shortest path calculations. This setting overrides the use of the variable sink \nin the data table that you specify in the NODESSUBSET= option in the PROC NETWORK statement."},"StatementOptionType":"V"},{"StatementOptionName":"SOURCE=","StatementOptionHelp":{"#cdata":"Syntax: SOURCE=source-node \n          \nSpecifies the source node for shortest path calculations. This setting overrides the use of the variable source \nin the data table that you specify in the NODESSUBSET= option in the PROC NETWORK statement."},"StatementOptionType":"V"}]}},{"StatementName":"SUMMARY","StatementHelp":{"#cdata":"Syntax: SUMMARY < options >;\n      \nThe SUMMARY statement invokes an algorithm that calculates various summary metrics for an input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"BICONNECTEDCOMPONENTS","StatementOptionHelp":{"#cdata":"Calculates information about biconnected components. You can use this option only for an undirected graph."},"StatementOptionType":"S"},{"StatementOptionName":"CONNECTEDCOMPONENTS","StatementOptionHelp":{"#cdata":"Calculates information about connected components."},"StatementOptionType":"S"},{"StatementOptionName":"DIAMETERAPPROX=","StatementOptionHelp":{"#cdata":"Syntax: DIAMETERAPPROX=WEIGHT | UNWEIGHT | BOTH \n          \nCalculates information about the approximate diameter and specifies which type of calculation \nto perform. Use this option when calculating the exact diameter (by calculating all shortest \npaths) is too computationally expensive."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"WEIGHT","@Value2":"UNWEIGHT","@Value3":"BOTH"},"StatementOptionToolTips":{"@ToolTip1":"Calculates the approximate diameter by using the weighted graph.","@ToolTip2":"Calculates the approximate diameter by using the unweighted graph.","@ToolTip3":"Calculates the approximate diameter by using both the weighted and unweighted graphs."}},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=CAS-libref.data-table \n          \nSpecifies the output data table to contain the summary results. \n\nCAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session \nidentifier, and data-table specifies the name of the output data table."},"StatementOptionType":"V"},{"StatementOptionName":"SHORTESTPATH=","StatementOptionHelp":{"#cdata":"Syntax: SHORTESTPATH=WEIGHT | UNWEIGHT | BOTH \n          \nCalculates information about shortest paths and specifies which type of calculation to perform."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"WEIGHT","@Value2":"UNWEIGHT","@Value3":"BOTH"},"StatementOptionToolTips":{"@ToolTip1":"Calculates shortest paths by using the weighted graph.","@ToolTip2":"Calculates shortest paths by using the unweighted graph.","@ToolTip3":"Calculates shortest paths by using both the weighted and unweighted graphs."}}]}},{"StatementName":"TRANSITIVECLOSURE","StatementHelp":{"#cdata":"Syntax: TRANSITIVECLOSURE < option >;\n      \nThe TRANSITIVECLOSURE statement invokes an algorithm that calculates the transitive closure of an input graph."},"StatementOptions":{"StatementOption":{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=CAS-libref.data-table \n          \nSpecifies the output data table to contain the transitive closure results. \n\nCAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session identifier, \nand data-table specifies the name of the output data table."},"StatementOptionType":"V"}}}]}}}