{"Procedure":{"Name":"OPTGRAPH","ProductGroup":"Graph Algorithms and Network Analysis","#comment":{},"ProcedureHelp":{"#cdata":"Syntax: PROC OPTGRAPH options ; \n    DATA_ADJ_MATRIX_VAR column1 <,column2,...> ; \n    DATA_LINKS_VAR < options > ; \n    DATA_MATRIX_VAR column1 <,column2,...> ; \n    DATA_NODES_VAR < options > ; \n    BICONCOMP < options > ; \n    CENTRALITY < options > ; \n    CLIQUE < options > ; \n    COMMUNITY < options > ; \n    CONCOMP < options > ; \n    CORE < options > ; \n    CYCLE < options > ; \n    EIGENVECTOR < options > ; \n    LINEAR_ASSIGNMENT < options > ; \n    MINCUT < options > ; \n    MINSPANTREE < options > ; \n    NETFLOW_MINCOST < options > ; \n    REACH < options > ; \n    SHORTPATH < options > ; \n    SUMMARY < options > ; \n    TRANSITIVE_CLOSURE < options > ; \n    TSP < options > ; \n    PERFORMANCE < options > ; \n\nThe OPTGRAPH procedure can be used to analyze relationships between entities. These relationships \nare typically defined by using a graph. A graph, G = (N,A), is defined over a set N of nodes and \na set A of arcs. A node is an abstract representation of some entity (or object), and an arc defines \nsome relationship (or connection) between two nodes. The terms node and vertex are often interchanged \nwhen describing an entity. The term arc is often interchanged with the term edge or link when describing \na connection. \n\nThe OPTGRAPH procedure in SAS High-Performance Network Algorithms enables you to perform community\ndetection and centrality computations on large graphs in a high-performance environment. It uses an\nappliance that houses a massively parallel database management system (Teradata or EMC Greenplum) to\nmanage data in distributed form and to perform computations in parallel on an x64 Linux platform. A computing\nappliance is a dedicated hardware and software environment that acts as a server to provide computing\nresources in a client/server model. You connect indirectly to the appliance through the network connection\nbetween the client machine and the appliance. Software instructions on the client machine are translated into\ncommands that are run on the appliance."},"ProcedureOptions":{"ProcedureOption":[{"ProcedureOptionName":"DATA_ADJ_MATRIX=|ADJ_MATRIX=","ProcedureOptionHelp":{"#cdata":"Syntax: DATA_ADJ_MATRIX=SAS-data-set | ADJ_MATRIX=SAS-data-set \n      \nSpecifies the input data set that contains the graph link information, where the links \nare defined as an adjacency matrix."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"DATA_LINKS=|LINKS=","ProcedureOptionHelp":{"#cdata":"Syntax: DATA_LINKS=SAS-data-set | LINKS=SAS-data-set \n      \nSpecifies the input data set that contains the graph link information, where the links \nare defined as a list."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"DATA_MATRIX=|MATRIX=","ProcedureOptionHelp":{"#cdata":"Syntax: DATA_MATRIX=SAS-data-set | MATRIX=SAS-data-set \n      \nSpecifies the input data set that contains the matrix to be processed. This is a generic \nmatrix (as opposed to an adjacency matrix which defines an underlying graph)."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"DATA_NODES=|NODES=","ProcedureOptionHelp":{"#cdata":"Syntax: DATA_NODES=SAS-data-set | NODES=SAS-data-set \n      \nSpecifies the input data set that contains the graph node information."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"DATA_NODES_SUB=|NODES_SUB=","ProcedureOptionHelp":{"#cdata":"Syntax: DATA_NODES_SUB=SAS-data-set | NODES_SUB=SAS-data-set \n      \nSpecifies the input data set that contains the graph node subset information."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"FILTER_SUBGRAPH=","ProcedureOptionHelp":{"#cdata":"Syntax: FILTER_SUBGRAPH=num  \n      \nSpecifies the minimum number of nodes allowed in a subgraph when processing is decomposed \nby cluster. When the BY_CLUSTER option is also specified in another statement, any subgraph \nwhose number of nodes is less than or equal to num is skipped. The default setting is 0, \nso nothing is filtered by default."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"GRAPH_DIRECTION=|DIRECTION=","ProcedureOptionHelp":{"#cdata":"Syntax: GRAPH_DIRECTION=DIRECTED | UNDIRECTED \n  DIRECTION=DIRECTED | UNDIRECTED \n\nSpecifies whether the input graph should be considered directed or undirected."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"DIRECTED","@Value2":"UNDIRECTED"},"ProcedureOptionToolTips":{"@ToolTip1":"Specifies the graph as directed.","@ToolTip2":"Specifies the graph as undirected."}},{"ProcedureOptionName":"GRAPH_INTERNAL_FORMAT=|INTERNAL_FORMAT=","ProcedureOptionHelp":{"#cdata":"Syntax: GRAPH_INTERNAL_FORMAT=THIN | FULL \nINTERNAL_FORMAT=THIN | FULL\n\n"},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"THIN","@Value2":"FULL"},"ProcedureOptionToolTips":{"@ToolTip1":"Stores the graph in thin format. This option can improve performance in some cases both by  reducing memory and by simplifying the construction of the internal data structures. The  thin format causes PROC OPTGRAPH to skip the removal of duplicate links when it reads in  the graph. So this option should be used with caution. For some algorithms, the thin format  is not allowed and this option is ignored. The THIN option can often be helpful when you do  calculations that are decomposed by subgraph.","@ToolTip2":"Stores the graph in standard (full) format. This is the default."}},{"ProcedureOptionName":"INCLUDE_SELFLINK","ProcedureOptionHelp":{"#cdata":"Includes self links\u2014for example, \u2014when an input graph is read. By default, when PROC OPTGRAPH \nreads the DATA_LINKS= data set, it removes all self links."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"LOGLEVEL=","ProcedureOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE | 0 | 1 | 2 | 3\n      \nControls the amount of information that is displayed in the SAS log. Each algorithm has \nits own specific log level. This setting sets the log level for all algorithms except \nthose for which you specify the LOGLEVEL= option in the algorithm statement. \n\nThe default is BASIC."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"NONE|0","@Value2":"BASIC|1","@Value3":"MODERATE|2","@Value4":"AGGRESSIVE|3"},"ProcedureOptionToolTips":{"@ToolTip1":"Turns off all procedure-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the input, output, and algorithmic processing","@ToolTip3":"Displays a summary of the input, output, and algorithmic processing","@ToolTip4":"Displays a detailed summary of the input, output, and algorithmic processing"}},{"ProcedureOptionName":"TIMETYPE=","ProcedureOptionHelp":{"#cdata":"Syntax: TIMETYPE=CPU | REAL | 0 | 1 \n      \nSpecifies whether CPU time or real time is used for the MAXTIME= option for each applicable \nalgorithm."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"CPU","@Value2":"REAL"},"ProcedureOptionToolTips":{"@ToolTip1":"Specifies units of CPU time","@ToolTip2":"Specifies units of real time"}},{"ProcedureOptionName":"OUT_LINKS=","ProcedureOptionHelp":{"#cdata":"Syntax: OUT_LINKS=SAS-data-set \n      \nSpecifies the output data set to contain the graph link information along with any results \nfrom the various algorithms that calculate metrics on links."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"OUT_NODES=","ProcedureOptionHelp":{"#cdata":"Syntax: OUT_NODES=SAS-data-set \n      \nSpecifies the output data set to contain the graph node information along with any results \nfrom the various algorithms that calculate metrics on nodes."},"ProcedureOptionType":"V"}]},"ProcedureStatements":{"ProcedureStatement":[{"StatementName":"DATA_ADJ_MATRIX_VAR|ADJ_MATRIX_VAR","StatementHelp":{"#cdata":"Syntax: DATA_ADJ_MATRIX_VAR column1 <,column2,...> ; \n\n  ADJ_MATRIX_VAR column1 <,column2,...> ; \n\nThe DATA_ADJ_MATRIX_VAR statement enables you to explicitly define the data set variable names \nfor PROC OPTGRAPH to use when it reads the data set that is specified in the DATA_ADJ_MATRIX= \noption in the PROC OPTGRAPH statement. The format of the adjacency matrix input data set is \ndefined in the section Adjacency Matrix Input Data. The value of each column variable must \nbe numeric."},"StatementOptions":null},{"StatementName":"DATA_LINKS_VAR|LINKS_VAR","StatementHelp":{"#cdata":"Syntax: DATA_LINKS_VAR < options > ; \n\n  LINKS_VAR < options > ; \n\nThe DATA_LINKS_VAR statement enables you to explicitly define the data set variable names \nfor PROC OPTGRAPH to use when it reads the data set that is specified in the DATA_LINKS= \noption in the PROC OPTGRAPH statement."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"FROM=","StatementOptionHelp":{"#cdata":"Syntax: FROM=column \n          \nSpecifies the data set variable name for from nodes. The value of column can be numeric or character."},"StatementOptionType":"V"},{"StatementOptionName":"LOWER=","StatementOptionHelp":{"#cdata":"Syntax: LOWER=column \n          \nSpecifies the data set variable name for link flow lower bounds. The value of column must be numeric."},"StatementOptionType":"V"},{"StatementOptionName":"TO=","StatementOptionHelp":{"#cdata":"Syntax: TO=column \n          \nSpecifies the data set variable name for to node. The value of column can be numeric or character."},"StatementOptionType":"V"},{"StatementOptionName":"UPPER=","StatementOptionHelp":{"#cdata":"Syntax: UPPER=column \n          \nSpecifies the data set variable name for link flow upper bounds. The value of column must be numeric."},"StatementOptionType":"V"},{"StatementOptionName":"WEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT=column \n          \nSpecifies the data set variable name for link weights. The value of column must be numeric."},"StatementOptionType":"V"}]}},{"StatementName":"DATA_MATRIX_VAR|MATRIX_VAR","StatementHelp":{"#cdata":"Syntax: DATA_MATRIX_VAR column1 <,column2,...> ; \n\n  MATRIX_VAR column1 <,column2,...> ; \n\nThe DATA_MATRIX_VAR statement enables you to explicitly define the data set variable names for \nPROC OPTGRAPH to use when it reads the data set that is specified in the DATA_MATRIX= option in \nthe PROC OPTGRAPH statement. The format of the matrix input data set is defined in the section \nMatrix Input Data. The value of each column variable must be numeric."},"StatementOptions":null},{"StatementName":"DATA_NODES_VAR|NODES_VAR","StatementHelp":{"#cdata":"Syntax: DATA_NODES_VAR < options > ; \n\n  NODES_VAR < options > ; \n\nThe DATA_NODES_VAR statement enables you to explicitly define the data set variable names \nfor PROC OPTGRAPH to use when it reads the data set that is specified in the DATA_NODES= \noption in the PROC OPTGRAPH statement."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"CLUSTER=","StatementOptionHelp":{"#cdata":"Syntax: CLUSTER=column \n          \nSpecifies the data set variable name for clusters identifiers. The value of column must be numeric."},"StatementOptionType":"V"},{"StatementOptionName":"NODE=","StatementOptionHelp":{"#cdata":"Syntax: NODE=column \n          \nSpecifies the data set variable name for the nodes. The value of column can be numeric or character."},"StatementOptionType":"V"},{"StatementOptionName":"WEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT=column \n          \nSpecifies the data set variable name for node weights. The value of column must be numeric."},"StatementOptionType":"V"},{"StatementOptionName":"WEIGHT2=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT2=column \n          \nSpecifies the data set variable name for auxiliary node weights. The value of column \nmust be numeric."},"StatementOptionType":"V"}]}},{"StatementName":"BICONCOMP","StatementHelp":{"#cdata":"Syntax: BICONCOMP < options > ; \n\nThe BICONCOMP statement requests that PROC OPTGRAPH find biconnected components and \narticulation points of an undirected input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE|0","@Value2":"BASIC|1","@Value3":"MODERATE|2","@Value4":"AGGRESSIVE|3"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing","@ToolTip4":"Displays a detailed summary of the algorithmic processing"}},{"StatementOptionName":"NODE=","StatementOptionHelp":{"#cdata":"Syntax: NODE=column \n          \nSpecifies the data set variable name for the nodes. The value of column can be numeric or character."},"StatementOptionType":"V"},{"StatementOptionName":"WEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT=column \n          \nSpecifies the data set variable name for node weights. The value of column must be numeric."},"StatementOptionType":"V"},{"StatementOptionName":"WEIGHT2=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT2=column \n          \nSpecifies the data set variable name for auxiliary node weights. The value of column \nmust be numeric."},"StatementOptionType":"V"}]}},{"StatementName":"CENTRALITY","StatementHelp":{"#cdata":"Syntax: CENTRALITY < options > ; \n\nThe CENTRALITY statement enables you to select which centrality metrics to calculate \nfor the given input graph. It also enables you to specify options for particular metrics. \nThe resulting metrics are included in the node output data set (specified by the OUT_NODES= option) \nor the link output data set (specified by the OUT_LINKS= option)."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"AUTH=","StatementOptionHelp":{"#cdata":"Syntax: AUTH=WEIGHT | UNWEIGHT | BOTH \n          \nSpecifies which type of authority centrality to calculate.\n\nIf the input graph does not contain weights, then WEIGHT and UNWEIGHT both give the same \nresults (using 1.0 for each link weight). This centrality metric can be used only for \ndirected graphs."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"WEIGHT","@Value2":"UNWEIGHT","@Value3":"BOTH"},"StatementOptionToolTips":{"@ToolTip1":"Calculates authority centrality based on the weighted graph.","@ToolTip2":"Calculates authority centrality based on the unweighted graph.","@ToolTip3":"Calculates authority centrality based on both weighted and unweighted graphs."}},{"StatementOptionName":"BETWEEN=","StatementOptionHelp":{"#cdata":"Syntax: BETWEEN=WEIGHT | UNWEIGHT | BOTH \n          \nSpecifies which type of betweenness centrality to calculate.\n\nIf the input graph does not contain weights, then WEIGHT and UNWEIGHT both give the same \nresults (using 1.0 for each link weight). If the OUT_NODES= option is specified in the \nPROC OPTGRAPH statement, the node betweenness metric is produced; if the OUT_LINKS= option \nis specified, the link betweenness metric is produced."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"WEIGHT","@Value2":"UNWEIGHT","@Value3":"BOTH"},"StatementOptionToolTips":{"@ToolTip1":"Calculates betweenness centrality based on the weighted graph.","@ToolTip2":"Calculates betweenness centrality based on the unweighted graph.","@ToolTip3":"Calculates betweenness centrality based on both weighted and unweighted graphs."}},{"StatementOptionName":"BETWEEN_NORM=","StatementOptionHelp":{"#cdata":"Syntax: BETWEEN_NORM=YES | NO \n          \nSpecifies whether to normalize the betweenness centrality metrics."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Normalizes the betweenness metrics. This is the default.","@ToolTip2":"Does not normalize the betweenness metrics."}},{"StatementOptionName":"BY_CLUSTER","StatementOptionHelp":{"#cdata":"Decomposes the calculations by cluster (or subgraph). If this option is specified, \nPROC OPTGRAPH looks for a definition of the clusters in the input data set specified \nby the DATA_NODES= option in the PROC OPTGRAPH statement. The use of the BY_CLUSTER \noption is described in the section Processing by Cluster."},"StatementOptionType":"S"},{"StatementOptionName":"CLOSE=","StatementOptionHelp":{"#cdata":"Syntax: CLOSE=WEIGHT | UNWEIGHT | BOTH \n          \nSpecifies which type of closeness centrality to calculate.\n\nIf the input graph does not contain weights, then WEIGHT and UNWEIGHT both give the \nsame results (using 1.0 for each link weight). "},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"WEIGHT","@Value2":"UNWEIGHT","@Value3":"BOTH"},"StatementOptionToolTips":{"@ToolTip1":"Calculates closeness centrality based on the weighted graph.","@ToolTip2":"Calculates closeness centrality based on the unweighted graph.","@ToolTip3":"Calculates closeness centrality based on both weighted and unweighted graphs."}},{"StatementOptionName":"CLOSE_NOPATH=","StatementOptionHelp":{"#cdata":"Syntax: CLOSE_NOPATH=NNODES | DIAMETER | ZERO \n          \nSpecifies a method for accounting for a shortest path between two nodes when a path does not \nexist (disconnected nodes)."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NNODES","@Value2":"DIAMETER","@Value3":"ZERO"},"StatementOptionToolTips":{"@ToolTip1":"Uses the number of nodes as a shortest path between disconnected nodes. This is the default.","@ToolTip2":"Uses the graph diameter as a shortest path between disconnected nodes.","@ToolTip3":"Uses zero as a shortest path between disconnected nodes."}},{"StatementOptionName":"CLUSTERING_COEF","StatementOptionHelp":{"#cdata":"Calculates the node clustering coefficient."},"StatementOptionType":"S"},{"StatementOptionName":"DEGREE=","StatementOptionHelp":{"#cdata":"Syntax: DEGREE=IN | OUT | BOTH \n          \nSpecifies which type of degree centrality to calculate for the input graph.\n\nFor an undirected graph, option values IN and BOTH are ignored, since there is only \none notion of degree, which corresponds to the degree of out-links."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"IN","@Value2":"OUT","@Value3":"BOTH"},"StatementOptionToolTips":{"@ToolTip1":"Calculates degree based on in-links.","@ToolTip2":"Calculates degree based on out-links.","@ToolTip3":"Calculates degree based on in-links and out-links."}},{"StatementOptionName":"EIGEN=","StatementOptionHelp":{"#cdata":"Syntax: EIGEN=WEIGHT | UNWEIGHT | BOTH \n          \nSpecifies which type of eigenvector centrality to calculate."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"WEIGHT","@Value2":"UNWEIGHT","@Value3":"BOTH"},"StatementOptionToolTips":{"@ToolTip1":"Calculates eigenvector centrality based on the weighted graph.","@ToolTip2":"Calculates centrality based on the unweighted graph.","@ToolTip3":"Calculates centrality based on both weighted and unweighted graphs."}},{"StatementOptionName":"EIGEN_ALGORITHM=","StatementOptionHelp":{"#cdata":"Syntax: EIGEN_ALGORITHM=ARPACK | POWER \n          \nSpecifies the algorithm to use in calculating the eigenvector centrality."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"ARPACK","@Value2":"POWER"},"StatementOptionToolTips":{"@ToolTip1":"Uses ARPACK to calculate eigenvector centrality. This is the default.","@ToolTip2":"Uses the power method to calculate eigenvector centrality."}},{"StatementOptionName":"EIGEN_MAXITER=","StatementOptionHelp":{"#cdata":"Syntax: EIGEN_MAXITER=num \n          \nSpecifies the maximum number of iterations to use for eigenvector calculations to limit \nthe amount of computation time spent when convergence is slow. The default is 5,000."},"StatementOptionType":"V"},{"StatementOptionName":"HUB=","StatementOptionHelp":{"#cdata":"Syntax: HUB=WEIGHT | UNWEIGHT | BOTH \n          \nSpecifies which type of hub centrality to calculate."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"WEIGHT","@Value2":"UNWEIGHT","@Value3":"BOTH"},"StatementOptionToolTips":{"@ToolTip1":"Calculates hub centrality based on the weighted graph.","@ToolTip2":"Calculates hub centrality based on the unweighted graph.","@ToolTip3":"Calculates hub centrality based on both weighted and unweighted graphs."}},{"StatementOptionName":"INFLUENCE=","StatementOptionHelp":{"#cdata":"Syntax: INFLUENCE=WEIGHT | UNWEIGHT | BOTH \n          \nSpecifies which type of influence centrality to calculate."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"WEIGHT","@Value2":"UNWEIGHT","@Value3":"BOTH"},"StatementOptionToolTips":{"@ToolTip1":"Calculates influence centrality based on the weighted graph.","@ToolTip2":"Calculates influence centrality based on the unweighted graph.","@ToolTip3":"Calculates influence centrality based on both weighted and unweighted graphs."}},{"StatementOptionName":"LOGFREQNODE=","StatementOptionHelp":{"#cdata":"Syntax: LOGFREQNODE=num \n          \nControls the frequency for displaying iteration logs for some of the centrality metrics. \nFor computationally intensive algorithms such as betweenness and closeness centrality, \nthis option displays progress every num nodes. If you also specify the BY_CLUSTER option \nin this statement or a value greater than 1 for the NTHREADS= option in the PERFORMANCE \nstatement, this option is ignored and the display frequency is determined by using the \nLOGFREQTIME= option instead. The value of num can be any integer greater than or equal \nto 1; the default is determined automatically based on the size of the graph. Setting \nthis value too low can hurt performance on large-scale graphs."},"StatementOptionType":"V"},{"StatementOptionName":"LOGFREQTIME=","StatementOptionHelp":{"#cdata":"Syntax: LOGFREQTIME=num \n\nControls the frequency for displaying iteration logs for some of the centrality metrics. \nFor computationally intensive algorithms such as betweenness and closeness centrality, \nthis option displays progress every num seconds. If you specify a value greater than 1 \nfor the NTHREADS= option in the PERFORMANCE statement, PROC OPTGRAPH displays the number \nof nodes that have completed. If you specify the BY_CLUSTER option, PROC OPTGRAPH displays \nthe number of subgraphs that have completed. The value of num can be any integer greater \nthan or equal to 1; the default is 5. Setting this value too low can hurt performance on \nlarge-scale graphs."},"StatementOptionType":"V"},{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"BASIC","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log.","@ToolTip2":"Displays a basic summary of the algorithmic processing.","@ToolTip3":"Displays a summary of the algorithmic processing including a progress log using the interval  dictated by the LOGFREQNODE= or LOGFREQTIME= option.","@ToolTip4":"Displays a detailed summary of the algorithmic processing including a progress log using the  interval dictated by the LOGFREQNODE= or LOGFREQTIME= option "}},{"StatementOptionName":"PAGERANK=","StatementOptionHelp":{"#cdata":"Syntax: PAGERANK=WEIGHT | UNWEIGHT | BOTH \n          \nSpecifies which type of graph to base PageRank calculation on."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"WEIGHT","@Value2":"UNWEIGHT","@Value3":"BOTH"},"StatementOptionToolTips":{"@ToolTip1":"Calculates PageRank based on the weighted graph.","@ToolTip2":"Calculates PageRank based on the unweighted graph.","@ToolTip3":"Calculates PageRank based on both weighted and unweighted graphs."}},{"StatementOptionName":"PAGERANK_ALPHA=","StatementOptionHelp":{"#cdata":"Syntax: PAGERANK_ALPHA=num \n          \nSpecifies the damping factor to be used in the PageRank algorithm. The value must be between \n0 and 1 (inclusive). The default is 0.85, which means a random Web surfer has a 15% chance of \njumping to any other node in the network at any time. The algorithm usually takes more iterations \nto converge (or does not converge at all) as the damping factor is set closer to 1."},"StatementOptionType":"V"},{"StatementOptionName":"PAGERANK_TOL=","StatementOptionHelp":{"#cdata":"Syntax: PAGERANK_TOL=num \n          \nSpecifies the convergence tolerance value for the PageRank algorithm. The value must be \na positive number; the default value is 1E\u20139. The algorithm stops power iterations when \nthe gap between the PageRank scores of the current iteration and the previous iteration \nis less than or equal to num."},"StatementOptionType":"V"},{"StatementOptionName":"SUBSIZESWITCH=","StatementOptionHelp":{"#cdata":"Syntax: SUBSIZESWITCH=num \n          \nSpecifies how many subgraph nodes to run separately when you also specify the BY_CLUSTER \noption in this statement and a value greater than 1 for the NTHREADS= option in the PERFORMANCE \nstatement. When PROC OPTGRAPH processes centrality by subgraphs, it uses thread logic to \nsimultaneously process a number of subgraphs, with that number as specified in the NTHREADS= \noption in the PERFORMANCE statement. For a larger graph with a number of nodes greater than \nnum, each subgraph is processed sequentially, allowing the threading to be done at the \ncentrality metric level. The default value is 10,000."},"StatementOptionType":"V"},{"StatementOptionName":"WEIGHT2=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT2=column \n          \nSpecifies the data set variable name for a second link weight. The value of column must be numeric."},"StatementOptionType":"V"}]}},{"StatementName":"CLIQUE","StatementHelp":{"#cdata":"Syntax: CLIQUE < options > ; \n\nThe CLIQUE statement invokes an algorithm that finds maximal cliques on the input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE|0","@Value2":"BASIC|1","@Value3":"MODERATE|2","@Value4":"AGGRESSIVE|3"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing","@ToolTip4":"Displays a detailed summary of the algorithmic processing"}},{"StatementOptionName":"MAXCLIQUES=","StatementOptionHelp":{"#cdata":"Syntax: MAXCLIQUES=num \n          \nSpecifies the maximum number of cliques to return during clique calculations. The default \nis the positive number that has the largest absolute value that can be represented in your \noperating environment."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=num \n          \nSpecifies the maximum amount of time to spend calculating cliques. The type of time (either \nCPU time or real time) is determined by the value of the TIMETYPE= option. The value of num \ncan be any positive number; the default value is the positive number that has the largest \nabsolute value that can be represented in your operating environment."},"StatementOptionType":"V"},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=SAS-data-set \n          \nSpecifies the output data set to contain the maximal cliques."},"StatementOptionType":"V"}]}},{"StatementName":"COMMUNITY","StatementHelp":{"#cdata":"Syntax: COMMUNITY < options > ; \n\nThe COMMUNITY statement invokes an algorithm that detects communities of the input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ALGORITHM=","StatementOptionHelp":{"#cdata":"Syntax: ALGORITHM=PARALLEL_LABEL_PROP \n          \nSpecifies which algorithm to use. Currently, only the parallel label propagation algorithm (PARALLEL_\nLABEL_PROP) is supported in MPP mode.."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"PARALLEL_LABEL_PROP"},"StatementOptionToolTips":{"@ToolTip1":"Specifies to use the parallel label propagation algorithm."}},{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE|0","@Value2":"BASIC|1","@Value3":"MODERATE|2","@Value4":"AGGRESSIVE|3"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing","@ToolTip4":"Displays a detailed summary of the algorithmic processing"}},{"StatementOptionName":"MAXITER=","StatementOptionHelp":{"#cdata":"Syntax: MAXITER=num \n          \nSpecifies the maximum number of iterations allowed in the algorithm. The default is 20 when \nALGORITHM=LOUVAIN and 100 when ALGORITHM=LABEL_PROP or ALGORITHM=PARALLEL_LABEL_PROP."},"StatementOptionType":"V"},{"StatementOptionName":"OUT_COMM_LINKS=","StatementOptionHelp":{"#cdata":"Syntax: OUT_COMM_LINKS=SAS-data-set \n          \nSpecifies the output data set that describes the links between communities. This data \nset is not created when you specify ALGORITHM=PARALLEL_LABEL_PROP and you are running \nPROC OPTGRAPH in a distributed computing environment."},"StatementOptionType":"V"},{"StatementOptionName":"OUT_COMMUNITY=","StatementOptionHelp":{"#cdata":"Syntax: OUT_COMMUNITY=SAS-data-set \n          \nSpecifies the output data set to contain the number of nodes in each community."},"StatementOptionType":"V"},{"StatementOptionName":"OUT_INTRA_COMM_LINKS=","StatementOptionHelp":{"#cdata":"Syntax: OUT_INTRA_COMM_LINKS=SAS-data-set \n          \nSpecifies the output data set that describes the links within each community."},"StatementOptionType":"V"},{"StatementOptionName":"OUT_LEVEL=","StatementOptionHelp":{"#cdata":"Syntax: OUT_LEVEL=SAS-data-set \n          \nSpecifies the output data set to contain community information at different resolution levels."},"StatementOptionType":"V"},{"StatementOptionName":"OUT_OVERLAP=","StatementOptionHelp":{"#cdata":"Syntax: OUT_OVERLAP=SAS-data-set \n          \nSpecifies the output data set that describes the intensity of each node that belongs to multiple \ncommunities. This data set is not created when you specify ALGORITHM=PARALLEL_LABEL_PROP and you \nare running PROC OPTGRAPH in a distributed computing environment."},"StatementOptionType":"V"},{"StatementOptionName":"RANDOM_FACTOR=","StatementOptionHelp":{"#cdata":"Syntax: RANDOM_FACTOR=num \n          \nSpecifies the random factor for the parallel label propagation algorithm. At each iteration, \nsome nodes are randomly selected to skip the label propagation step based on the specified \nRANDOM_FACTOR value. The default is 0.15, meaning 15% of nodes will skip the label propagation \nstep at each iteration."},"StatementOptionType":"V"},{"StatementOptionName":"RANDOM_SEED=","StatementOptionHelp":{"#cdata":"Syntax: RANDOM_SEED=number \n          \nSpecifies the initial seed for random number generation used in the parallel label propagation algorithm.\nAt each iteration, some nodes are randomly selected to skip the label propagation step based on\nthe value that you specify in the RANDOM_FACTOR= option. To change the sequence of random\nnumbers generated by changing the initial seed, specify a number in the RANDOM_SEED= option.\nThe default is 1234."},"StatementOptionType":"V"},{"StatementOptionName":"RECURSIVE","StatementOptionHelp":{"#cdata":"Syntax: RECURSIVE(MAX_COMM_SIZE=number) \n          \nRequests that the algorithm recursively break down large communities into smaller ones until all\ncommunities have a size that is less than or equal to number. This option starts with the keyword\nRECURSIVE, followed by the MAX_COMM_SIZE= suboption enclosed in parentheses\u2014for example,\nRECURSIVE (MAX_COMM_SIZE=200). MAX_COMM_SIZE= specifies the maximum number of\nnodes to be contained in any community."},"StatementOptionType":"S","SubOptionsKeywords":"MAX_COMM_SIZE="},{"StatementOptionName":"RESOLUTION_LIST","StatementOptionHelp":{"#cdata":"Syntax: RESOLUTION_LIST=num_list \n          \nSpecifies a list of resolution parameters that are separated by spaces (for example, \n4.3 2.1 1.0 0.6 0.2). The OPTGRAPH procedure interprets the RESOLUTION_LIST= option \ndifferently depending on the value of the ALGORITHM= option."},"StatementOptionType":"V"},{"StatementOptionName":"TOLERANCE=","StatementOptionHelp":{"#cdata":"Syntax: TOLERANCE=num \n          \nStops iterations when the percentage of label changes for all nodes in the graph falls within the tolerance\nspecified by number. The valid range is between 0 and 1. The default is 0.01."},"StatementOptionType":"V"}]}},{"StatementName":"CONCOMP","StatementHelp":{"#cdata":"Syntax: CONCOMP < options > ; \n\nThe CONCOMP statement invokes an algorithm that finds the connected components of the input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ALGORITHM=","StatementOptionHelp":{"#cdata":"Syntax: ALGORITHM=DFS | UNION_FIND \n          \nSpecifies the algorithm to use for calculating connected components."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"DFS","@Value2":"UNION_FIND"},"StatementOptionToolTips":{"@ToolTip1":"Uses the depth-first search algorithm for connected components. This value cannot be used  when you specify GRAPH_INTERNAL_FORMAT=THIN in the PROC OPTGRAPH statement.","@ToolTip2":"Uses the union-find algorithm for connected components. You can specify this value with  either the THIN or FULL value for the GRAPH_INTERNAL_FORMAT option in the PROC OPTGRAPH  statement. This value can be faster than DFS when used with GRAPH_INTERNAL_FORMAT=THIN;  however, you can use it only with undirected graphs."}},{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE|0","@Value2":"BASIC|1","@Value3":"MODERATE|2","@Value4":"AGGRESSIVE|3"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing","@ToolTip4":"Displays a detailed summary of the algorithmic processing"}}]}},{"StatementName":"CORE","StatementHelp":{"#cdata":"Syntax: CORE < options > ; \n\nThe CORE statement invokes an algorithm that finds the core decomposition of the input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"LINKS=","StatementOptionHelp":{"#cdata":"Syntax: LINKS=IN | OUT | BOTH \n          \nSpecifies which type of cores to calculate for a directed graph. You can choose to calculate \nthe cores based on in-links (IN), out-links (OUT), or both (BOTH). For an undirected graph, \ncore applies only to out-links."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"IN","@Value2":"OUT","@Value3":"BOTH"},"StatementOptionToolTips":{"@ToolTip1":"Specifies to calculate the cores based on in-links.","@ToolTip2":"Specifies to calculate the cores based on out-links.","@ToolTip3":"Specifies to calculate the cores based on both in-links and out-links."}},{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE|0","@Value2":"BASIC|1","@Value3":"MODERATE|2","@Value4":"AGGRESSIVE|3"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing","@ToolTip4":"Displays a detailed summary of the algorithmic processing"}}]}},{"StatementName":"CYCLE","StatementHelp":{"#cdata":"Syntax: CYCLE < options > ; \n\nThe CYCLE statement invokes an algorithm that finds the cycles (or the existence of a cycle) \nin the input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE|0","@Value2":"BASIC|1","@Value3":"MODERATE|2","@Value4":"AGGRESSIVE|3"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing","@ToolTip4":"Displays a detailed summary of the algorithmic processing"}},{"StatementOptionName":"MAXCYCLES=","StatementOptionHelp":{"#cdata":"Syntax: MAXCYCLES=num \n          \nSpecifies the maximum number of cycles to return. The default is the positive number \nthat has the largest absolute value representable in your operating environment. This \noption works only when you also specify MODE=ALL_CYCLES."},"StatementOptionType":"V"},{"StatementOptionName":"MAXLENGTH=","StatementOptionHelp":{"#cdata":"Syntax: MAXLENGTH=num \n          \nSpecifies the maximum number of links to allow in a cycle. If a cycle is found whose length \nis greater than num, that cycle is removed from the results. The default is the positive number \nthat has the largest absolute value representable in your operating environment. By default, \nnothing is filtered. This option works only when you also specify MODE=ALL_CYCLES."},"StatementOptionType":"V"},{"StatementOptionName":"MAXLINKWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MAXLINKWEIGHT=num \n          \nSpecifies the maximum sum of link weights to allow in a cycle. If a cycle is found whose sum \nof link weights is greater than num, that cycle is removed from the results. The default is \nthe positive number that has the largest absolute value representable in your operating \nenvironment. By default, nothing is filtered. This option works only when you also specify \nMODE=ALL_CYCLES."},"StatementOptionType":"V"},{"StatementOptionName":"MAXNODEWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MAXNODEWEIGHT=num \n          \nSpecifies the maximum sum of node weights to allow in a cycle. If a cycle is found whose \nsum of node weights is greater than num, that cycle is removed from the results. The default \nis the positive number that has the largest absolute value representable in your operating \nenvironment. By default, nothing is filtered. This option works only when you also specify \nMODE=ALL_CYCLES."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=num \n          \nSpecifies the maximum amount of time to spend finding cycles. The type of time (either CPU \ntime or real time) is determined by the value of the TIMETYPE= option. The value of num can \nbe any positive number; the default value is the positive number that has the largest absolute \nvalue that can be represented in your operating environment. This option works only when you \nalso specify MODE=ALL_CYCLES."},"StatementOptionType":"V"},{"StatementOptionName":"MINLENGTH=","StatementOptionHelp":{"#cdata":"Syntax: MINLENGTH=num \n          \nSpecifies the minimum number of links to allow in a cycle. If a cycle is found that has fewer \nlinks than num, that cycle is removed from the results. The default is 1. By default, nothing \nis filtered. This option works only when you also specify MODE=ALL_CYCLES."},"StatementOptionType":"V"},{"StatementOptionName":"MINLINKWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MINLINKWEIGHT=num \n          \nSpecifies the minimum sum of link weights to allow in a cycle. If a cycle is found whose \nsum of link weights is less than num, that cycle is removed from the results. The default \nis the negative number that has the largest absolute value representable in your operating \nenvironment. By default, nothing is filtered. This option works only when you also specify \nMODE=ALL_CYCLES."},"StatementOptionType":"V"},{"StatementOptionName":"MINNODEWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MINNODEWEIGHT=num \n          \nSpecifies the minimum sum of node weights to allow in a cycle. If a cycle is found whose \nsum of node weights is less than num, that cycle is removed from the results. The default \nis the negative number that has the largest absolute value representable in your operating \nenvironment. By default, nothing is filtered. This option works only when you also specify \nMODE=ALL_CYCLES."},"StatementOptionType":"V"},{"StatementOptionName":"MODE=","StatementOptionHelp":{"#cdata":"Syntax: MODE=option \n          \nSpecifies the mode for processing cycles."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"ALL_CYCLES","@Value2":"FIRST_CYCLE"},"StatementOptionToolTips":{"@ToolTip1":"Returns all (unique, elementary) cycles found.","@ToolTip2":"Returns the first cycle found."}},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=SAS-data-set \n          \nSpecifies the output data set to contain the cycles found."},"StatementOptionType":"V"}]}},{"StatementName":"EIGENVECTOR","StatementHelp":{"#cdata":"Syntax: EIGENVECTOR < options > ; \n\nThe EIGENVECTOR statement invokes an algorithm that finds eigenvectors (and eigenvalues) \nfor symmetric matrices. The matrix is typically defined in the input data set that is \nspecified by the DATA_MATRIX= option in the PROC OPTGRAPH statement. The matrix can also \nbe input as a graph by using the DATA_LINKS= option in the PROC OPTGRAPH statement. \n\nInternally, the graph is converted into a (sparse) adjacency matrix."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ALGORITHM=","StatementOptionHelp":{"#cdata":"Syntax: ALGORITHM=ARPACK | POWER \n          \nSpecifies the algorithm to use when calculating eigenvectors."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"ARPACK","@Value2":"POWER"},"StatementOptionToolTips":{"@ToolTip1":"Uses ARPACK to calculate eigenvectors. This is the default.","@ToolTip2":"Uses the power method to calculate eigenvectors. This option can be used only when  EIGENVALUES=LM and NEIGEN=1."}},{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE|0","@Value2":"BASIC|1","@Value3":"MODERATE|2","@Value4":"AGGRESSIVE|3"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing","@ToolTip4":"Displays a detailed summary of the algorithmic processing"}},{"StatementOptionName":"MAXITER=","StatementOptionHelp":{"#cdata":"Syntax: MAXITER=num \n          \nSpecifies the maximum number of iterations used in the algorithm to calculate eigenvectors. \nWhen ALGORITHM=ARPACK is also specified, the resulting solution is invalid when the number \nof iterations reaches num. When ALGORITHM=POWER is also specified, the resulting solution \nmight be valid but is not guaranteed. The default is 5,000."},"StatementOptionType":"V"},{"StatementOptionName":"NEIGEN=","StatementOptionHelp":{"#cdata":"Syntax: NEIGEN=num \n          \nSpecifies the number of eigenvectors to generate. When ALGORITHM=ARPACK is specified, \nthis value must be less than the dimension of the matrix. The default is 1."},"StatementOptionType":"V"},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=SAS-data-set \n          \nSpecifies the output data set to contain the eigenvectors (and eigenvalues) found."},"StatementOptionType":"V"},{"StatementOptionName":"EIGENVALUES=","StatementOptionHelp":{"#cdata":"Syntax: EIGENVALUES=LA | SA | LM | SM | BE \n          \nSpecifies the type of eigenvector to calculate."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"LA","@Value2":"SA","@Value3":"LM","@Value4":"SM","@Value5":"BE"},"StatementOptionToolTips":{"@ToolTip1":"Computes NEIGEN largest (algebraic) eigenvalues.","@ToolTip2":"Computes NEIGEN smallest (algebraic) eigenvalues.","@ToolTip3":"Computes NEIGEN largest (in magnitude) eigenvalues. This is the default","@ToolTip4":"Computes NEIGEN smallest (in magnitude) eigenvalues.","@ToolTip5":"Computes NEIGEN eigenvalues, half from each end of the spectrum. When NEIGEN is odd,  compute one more from the high end than from the low end."}}]}},{"StatementName":"LINEAR_ASSIGNMENT|LAP","StatementHelp":{"#cdata":"Syntax: LINEAR_ASSIGNMENT | LAP < options > ; \n\nThe LINEAR_ASSIGNMENT statement invokes an algorithm that solves the minimal-cost linear \nassignment problem. In graph terms, this problem is also known as the minimum link-weighted \nmatching problem on a bipartite graph. The input data (the cost matrix) is typically defined \nin the input data set that is specified in the DATA_MATRIX= option in the PROC OPTGRAPH \nstatement. The data can also be defined as a directed graph by specifying the DATA_LINKS= \noption in the PROC OPTGRAPH statement, where the costs are defined as link weights. \n\nInternally, the graph is treated as a bipartite graph in which the from nodes define one \npart and the to nodes define the other part."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ID=","StatementOptionHelp":{"#cdata":"Syntax: ID=(column1 <,column2,...>) \n          \nSpecifies the data set variable names that identify the matrix rows (from nodes). The \ninformation in these columns is carried to the output data set that is specified in the \nOUT= option. The value of each column variable can be numeric or character."},"StatementOptionType":"V"},{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE|0","@Value2":"BASIC|1","@Value3":"MODERATE|2","@Value4":"AGGRESSIVE|3"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing","@ToolTip4":"Displays a detailed summary of the algorithmic processing"}},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=num \n          \nSpecifies the maximum amount of time to spend calculating cliques. The type of time (either \nCPU time or real time) is determined by the value of the TIMETYPE= option. The value of num \ncan be any positive number; the default value is the positive number that has the largest \nabsolute value that can be represented in your operating environment."},"StatementOptionType":"V"},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=SAS-data-set \n          \nSpecifies the output data set to contain the solution to the linear assignment problem."},"StatementOptionType":"V"},{"StatementOptionName":"WEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT=(column1 <,column2,...>) \n          \nSpecifies the data set variable names for the cost matrix. The value of each column \nvariable must be numeric. If this option is not specified, the matrix is assumed to \nbe defined by all of the numeric variables in the data set (excluding those specified \nin the ID= option)."},"StatementOptionType":"V"}]}},{"StatementName":"MINCUT","StatementHelp":{"#cdata":"Syntax: MINCUT < options > ; \n\nThe MINCUT statement invokes an algorithm that finds the minimum link-weighted cut of an input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE|0","@Value2":"BASIC|1","@Value3":"MODERATE|2","@Value4":"AGGRESSIVE|3"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing","@ToolTip4":"Displays a detailed summary of the algorithmic processing"}},{"StatementOptionName":"MAXNUMCUTS=","StatementOptionHelp":{"#cdata":"Syntax: MAXNUMCUTS=num \n          \nSpecifies the maximum number of cuts to return from the algorithm. The minimal cut and \nany others found during the search, up to num, are returned. The default is 1."},"StatementOptionType":"V"},{"StatementOptionName":"MAXWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MAXWEIGHT=num \n          \nSpecifies the maximum weight of the cuts to return from the algorithm. Only cuts that \nhave weight less than or equal to num are returned. The default is the positive number \nthat has the largest absolute value representable in your operating environment."},"StatementOptionType":"V"},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=SAS-data-set \n          \nSpecifies the output data set to contain the solution to the minimum cut problem."},"StatementOptionType":"V"}]}},{"StatementName":"MINSPANTREE","StatementHelp":{"#cdata":"Syntax: MINSPANTREE < options > ; \n\nThe MINSPANTREE statement invokes an algorithm that solves the minimum link-weighted \nspanning tree problem on an input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE|0","@Value2":"BASIC|1","@Value3":"MODERATE|2","@Value4":"AGGRESSIVE|3"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing","@ToolTip4":"Displays a detailed summary of the algorithmic processing"}},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=SAS-data-set \n          \nSpecifies the output data set to contain the solution to the minimum link-weighted \nspanning tree problem."},"StatementOptionType":"V"}]}},{"StatementName":"NETFLOW_MINCOST|MCF","StatementHelp":{"#cdata":"Syntax: NETFLOW_MINCOST | MCF < options > ; \n\nThe NETFLOW_MINCOST statement invokes an algorithm that solves the minimum-cost network flow \nproblem on an input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"LOGFREQ=","StatementOptionHelp":{"#cdata":"Syntax: LOGFREQ=num \n          \nControls the frequency for displaying iteration logs for minimum-cost network flow calculations \nthat use the network simplex algorithm. For graphs that contain one component, this option displays \nprogress every num simplex iterations, and the default is 10,000. For graphs that contain multiple \ncomponents, when you also specify LOGLEVEL=MODERATE, this option displays progress after processing \nevery num components, and the default is based on the number of components. When you also specify \nLOGLEVEL=AGGRESSIVE, the simplex iteration log for each component is displayed with frequency num. \n\nThe value of num can be any integer greater than or equal to 1. Setting this value too low can hurt \nperformance on large-scale graphs."},"StatementOptionType":"V"},{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log. \n\nThe default is the value that is specified by the LOGLEVEL= option in the PROC OPTGRAPH \nstatement (or BASIC if that option is not specified)."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE|0","@Value2":"BASIC|1","@Value3":"MODERATE|2","@Value4":"AGGRESSIVE|3"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing including a progress log using the  interval dictated by the LOGFREQ option","@ToolTip4":"Displays a detailed summary of the algorithmic processing including a progress log using  the interval dictated by the LOGFREQ option"}},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=option \n          \nSpecifies the maximum amount of time to spend calculating minimum-cost network flows. The \ntype of time (either CPU time or real time) is determined by the value of the TIMETYPE= \noption. The value of num can be any positive number; the default value is the positive \nnumber that has the largest absolute value that can be represented in your operating \nenvironment."},"StatementOptionType":"V"}]}},{"StatementName":"PERFORMANCE","StatementHelp":{"#cdata":"Syntax: PERFORMANCE <options> ; \n\nThe PERFORMANCE statement specifies performance options for multithreaded and distributed \ncomputing, passes variables about the distributed computing environment, and requests detailed \nresults about the performance characteristics of the OPTGRAPH procedure. \n\nWith the PERFORMANCE statement, you can also control whether the OPTGRAPH procedure executes \nin symmetric multiprocessing (SMP) or massively parallel processing (MPP) mode. \n\nThe OPTGRAPH procedure supports the deterministic mode of the PARALLELMODE= option in the \nPERFORMANCE statement. \n\nNote:MPP mode requires SAS\u00aeHigh-Performance Analytics software."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"COMMIT=","StatementOptionHelp":{"#cdata":"Syntax: COMMIT=n\n          \nThis option specifies the minimum number of observations transferred from the client to the \nappliance necessary to update the SAS Log. For instance, if you specify COMMIT=5000, then \nevery time the number of observations sent exceeds an integer multiple of 5000 a log message \nis produced. This message indicates the actual number of observations distributed, not the \nCOMMIT= value that triggered the message. "},"StatementOptionType":"V"},{"StatementOptionName":"CPUCOUNT=","StatementOptionHelp":{"#cdata":"Syntax: CPUCOUNT=ACTUAL | num\n          \nThis argument specifies how many processors PROC OPTGRAPH assumes are available on each host \nin the computing environment. Valid values for number are integers between 1 and 256, \ninclusive. Setting CPUCOUNT= to a value greater than the actual number of available CPUs \nmight results in reduced performance. Specify CPUCOUNT=ACTUAL to set CPUCOUNT= to the \nnumber of processors physically available. This number can be less than the physical \nnumber of CPUs if the SAS process has been restricted by system administration tools. \nThis option overrides the CPUCOUNT= SAS system option. If PROC OPTGRAPH executes in SMP \nmode, then this option referes to the client machine of the SAS session. If PROC OPTGRAPH \nexecutes in MPP mode, then this option applies the nodes on the appliance."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"ACTUAL","@Value2":"<num>"},"StatementOptionToolTips":{"@ToolTip1":"Sets CPUCOUNT to the number of processors physically available. This number can be less than the physical number of CPUs if the SAS process has been restricted by system administration tools.","@ToolTip2":"Replace <num> with an actual number. Setting CPUCOUNT= to a number  greater than the actual number of available CPUs might result in reduced performance. This  option overrides the CPUCOUNT= SAS system option."}},{"StatementOptionName":"DATASERVER=","StatementOptionHelp":{"#cdata":"Syntax: DATASERVER=\u201cname\u201d\n          \nSpecifies the name of the server on Teradata systems as defined through the hosts file \nand as used in the LIBNAME statement for Teradata. For example, if the hosts file defines\n\n    myservercop1 33.44.55.66\n    \nas the server for Teradata, then a LIBNAME specification would be as follows:\n\n    libname TDLib teradata server=myserver user= password= database= ;\n    \nA PERFORMANCE statement to induce running alongside the Teradata server would specify the\nfollowing:\n\n    performance dataserver=\"myserver\";\n    \nIf the DATASERVER= option is specified, it overrides the GRIDDATASERVER environment \nvariable."},"StatementOptionType":"V"},{"StatementOptionName":"DETAILS","StatementOptionHelp":{"#cdata":"Specify this option to request a table that shows a timing breakdown of the procedure steps."},"StatementOptionType":"S"},{"StatementOptionName":"HOST=|GRIDHOST=","StatementOptionHelp":{"#cdata":"Syntax: HOST=name | GRIDHOST=name\n          \nThis option specifies the name of the appliance host. The HOST= option overrides the value \nof the GRIDHOST environment variable."},"StatementOptionType":"V"},{"StatementOptionName":"INSTALL=|INSTALLLOC=","StatementOptionHelp":{"#cdata":"Syntax: INSTALL=\u201cname\u201d | INSTALLLOC=\u201cname\u201d \n          \nThis option specifies the directory where the High-Performance Analytics shared libraries \nare installed on the appliance. Specifying the INSTALL= option overrides the GRIDINSTALLLOC \nenvironment variable."},"StatementOptionType":"V"},{"StatementOptionName":"NTHREADS=","StatementOptionHelp":{"#cdata":"Syntax: NTHREADS=n \n          \nThis option specifies the number of threads used for analytic computations and overrides the \nSAS system option THREADS | NOTHREADS. If you do not specify the NTHREADS= option, then the \nnumber of threads is determined based on the number of CPUs on the host machine where the \nanalytic computations execute. By default, High-Performance Analytics procedures execute in \nmultiple concurrent threads, unless you disable this behavior with the NOTHREADS system option \nor you specify NTHREADS=1 to force single-threaded execution. The value specified here must \nnot exceed 256.\n\nNote:The SAS system option THREADS | NOTHREADS applies to the current machine where the SAS \nHigh-Performance Analytics procedures execute. This option does not apply to the compute nodes \nin a distributed environment."},"StatementOptionType":"V"},{"StatementOptionName":"TIMEOUT=","StatementOptionHelp":{"#cdata":"Syntax: TIMEOUT=s\n          \nSpecifies the time-out in seconds for the procedure to wait for a connection to the appliance and\nestablish a connection back to the client. The default is 120 seconds. If jobs are submitted to the\nappliance through workload management tools that might suspend access to the appliance for a longer\nperiod, you might want to increase the time-out value."},"StatementOptionType":"V"}]}},{"StatementName":"REACH","StatementHelp":{"#cdata":"Syntax: REACH < options > ; \n\nThe REACH statement invokes an algorithm that calculates the reach (ego) network on an \ninput graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"BY_CLUSTER","StatementOptionHelp":{"#cdata":"Decomposes the calculations by cluster (subgraph). If this option is specified, PROC OPTGRAPH \nlooks for a definition of the clusters in the input data set specified by the DATA_NODES= option \nin the PROC OPTGRAPH statement. If BY_CLUSTER is specified, the reach network links output \n(specified by the OUT_LINKS= option) cannot be generated."},"StatementOptionType":"S"},{"StatementOptionName":"DIGRAPH","StatementOptionHelp":{"#cdata":"Calculates the directed reach counts when computing the reach networks and includes the \ndirected counts in the resulting output data set that is specified in the OUT_COUNTS= \noption. This option is ignored unless you specify MAXREACH=1 in the REACH statement."},"StatementOptionType":"S"},{"StatementOptionName":"EACH_SOURCE","StatementOptionHelp":{"#cdata":"Treats each node as a source and calculates a reach network from each one."},"StatementOptionType":"S"},{"StatementOptionName":"IGNORE_SELF","StatementOptionHelp":{"#cdata":"Ignores the source nodes in the reach network node counts."},"StatementOptionType":"S"},{"StatementOptionName":"MAXREACH=","StatementOptionHelp":{"#cdata":"Syntax: MAXREACH=num \n          \nSpecifies the maximum number of links to allow from each source node in a reach network. \n\nThe default is 1."},"StatementOptionType":"V"},{"StatementOptionName":"LOGFREQTIME=","StatementOptionHelp":{"#cdata":"Syntax: LOGFREQTIME=num \n          \nDisplays iteration logs for the reach algorithm every num seconds. When PROC OPTGRAPH runs \nthe reach algorithm, it displays the number of source networks that have completed. When you \nalso specify the BY_CLUSTER option in the REACH statement, PROC OPTGRAPH displays the number \nof subgraphs that have completed. The value of num can be any integer greater than or equal \nto 1; the default is 5. Setting this value too low can hurt performance on large-scale graphs."},"StatementOptionType":"V"},{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log. \n\nThe default is the value that is specified by the LOGLEVEL= option in the PROC OPTGRAPH \nstatement (or BASIC if that option is not specified)."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE|0","@Value2":"BASIC|1","@Value3":"MODERATE|2","@Value4":"AGGRESSIVE|3"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing","@ToolTip4":"Displays a detailed summary of the algorithmic processing"}},{"StatementOptionName":"OUT_COUNTS=","StatementOptionHelp":{"#cdata":"Syntax: OUT_COUNTS=SAS-data-set \n          \nSpecifies the output data set to contain the node counts in each reach network."},"StatementOptionType":"V"},{"StatementOptionName":"OUT_COUNTS1=","StatementOptionHelp":{"#cdata":"Syntax: OUT_COUNTS1=SAS-data-set \n          \nSpecifies the output data set to contain the node counts in each reach network for the \nspecial case of calculating only counts that have limit 1 and 2. This data set holds the \ncounts with MAXREACH=1. This option works only when the EACH_SOURCE and BY_CLUSTER options \nare specified."},"StatementOptionType":"V"},{"StatementOptionName":"OUT_COUNTS2=","StatementOptionHelp":{"#cdata":"Syntax: OUT_COUNTS2=SAS-data-set \n          \nSpecifies the output data set to contain the node counts in each reach network for the \nspecial case of calculating only counts that have limit 1 and 2. This data set holds the \ncounts with MAXREACH=2. This option works only when the EACH_SOURCE and BY_CLUSTER options \nare specified."},"StatementOptionType":"V"},{"StatementOptionName":"OUT_LINKS=","StatementOptionHelp":{"#cdata":"Syntax: OUT_LINKS=SAS-data-set \n          \nSpecifies the output data set to contain the links in each reach network."},"StatementOptionType":"V"},{"StatementOptionName":"OUT_NODES=","StatementOptionHelp":{"#cdata":"Syntax: OUT_NODES=SAS-data-set \n          \nSpecifies the output data set to contain the nodes in each reach network."},"StatementOptionType":"V"}]}},{"StatementName":"SHORTPATH","StatementHelp":{"#cdata":"Syntax: SHORTPATH < options > ; \n\nThe SHORTPATH statement invokes an algorithm that calculates shortest paths between sets \nof nodes on the input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"LOGFREQNODE=","StatementOptionHelp":{"#cdata":"Syntax: LOGFREQNODE=num \n          \nDisplays iteration logs for shortest path calculations every num nodes. The value of num can \nbe any integer greater than or equal to 1. The default is determined automatically based on \nthe size of the graph. Setting this value too low can hurt performance on large-scale graphs."},"StatementOptionType":"V"},{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log. \n\nThe default is the value that is specified by the LOGLEVEL= option in the PROC OPTGRAPH \nstatement (or BASIC if that option is not specified)."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE|0","@Value2":"BASIC|1","@Value3":"MODERATE|2","@Value4":"AGGRESSIVE|3"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing including a progress log using the  interval dictated by the LOGFREQ option","@ToolTip4":"Displays a detailed summary of the algorithmic processing including a progress log using  the interval dictated by the LOGFREQ option"}},{"StatementOptionName":"OUT_PATHS=|OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT_PATHS | OUT==SAS-data-set \n          \nSpecifies the output data set to contain the shortest paths."},"StatementOptionType":"V"},{"StatementOptionName":"OUT_WEIGHTS=","StatementOptionHelp":{"#cdata":"Syntax: OUT_WEIGHTS=SAS-data-set \n          \nSpecifies the output data set to contain the shortest path summaries."},"StatementOptionType":"V"},{"StatementOptionName":"PATHS=","StatementOptionHelp":{"#cdata":"Syntax: PATHS=ALL | SHORTEST | LONGEST \n          \nSpecifies the type of output to produce in the output data set that is specified in the OUT_PATHS= option."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"ALL","@Value2":"SHORTEST","@Value3":"LONGEST"},"StatementOptionToolTips":{"@ToolTip1":"Outputs shortest paths for all pairs of source-sinks. This is the default.","@ToolTip2":"Outputs shortest paths for the source-sink pair with the longest (finite) length. If other  source-sink pairs (up to 100) have equally long length, they are also output.","@ToolTip3":"Outputs shortest paths for the source-sink pair with the shortest length. If other  source-sink pairs (up to 100) have equally short length, they are also output."}},{"StatementOptionName":"SINK=","StatementOptionHelp":{"#cdata":"Syntax: SINK=sink-node \n          \nSpecifies the sink node for shortest paths calculations. This setting overrides the use \nof the variable sink in the data set that is specified by the DATA_NODES_SUB= option in \nthe PROC OPTGRAPH statement."},"StatementOptionType":"V"},{"StatementOptionName":"SOURCE=","StatementOptionHelp":{"#cdata":"Syntax: SOURCE=source-node \n          \nSpecifies the source node for shortest paths calculations. This setting overrides the use \nof the variable source in the data set that is specified by the DATA_NODES_SUB= option in \nthe PROC OPTGRAPH statement."},"StatementOptionType":"V"},{"StatementOptionName":"USEWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: USEWEIGHT=YES | NO \n          \nSpecifies whether to use link weights (if they exist) in calculating shortest paths."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Uses weights (if they exist) in shortest path calculations. This is the default.","@ToolTip2":"Does not use weights in shortest path calculations."}},{"StatementOptionName":"WEIGHT2=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT2=column \n          \nSpecifies the data set variable name for the auxiliary link weights. The value of column \nmust be numeric."},"StatementOptionType":"V"}]}},{"StatementName":"SUMMARY","StatementHelp":{"#cdata":"Syntax: SUMMARY < options > ; \n\nThe SUMMARY statement invokes an algorithm that calculates various summary metrics on an input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"BICONCOMP","StatementOptionHelp":{"#cdata":"Specifies whether to calculate information about biconnected components. The graph must be undirected."},"StatementOptionType":"S"},{"StatementOptionName":"BY_CLUSTER","StatementOptionHelp":{"#cdata":"Specifies whether to decompose the calculations by cluster (or subgraph). If this option \nis specified, PROC OPTGRAPH looks for a definition of the clusters in the input data set \nspecified by the DATA_NODES= option."},"StatementOptionType":"S"},{"StatementOptionName":"CONCOMP","StatementOptionHelp":{"#cdata":"Specifies whether to calculate information about connected components."},"StatementOptionType":"S"},{"StatementOptionName":"DIAMETER_APPROX=","StatementOptionHelp":{"#cdata":"Syntax: DIAMETER_APPROX=WEIGHT | UNWEIGHT | BOTH  \n          \nSpecifies whether to calculate information about the approximate diameter and what type \nof calculations to perform. Use this option when calculating the exact diameter (by \ncalculating all shortest paths) is too expensive."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"WEIGHT","@Value2":"UNWEIGHT","@Value3":"BOTH"},"StatementOptionToolTips":{"@ToolTip1":"Calculates approximate diameter based on the weighted graph.","@ToolTip2":"Calculates approximate diameter based on the unweighted graph.","@ToolTip3":"Calculates approximate diameter based on both weighted and unweighted graphs."}},{"StatementOptionName":"LOGFREQNODE=","StatementOptionHelp":{"#cdata":"Syntax: LOGFREQNODE=num \n          \nControls the frequency for displaying iteration logs for some of the summary metrics. For \ncomputationally intensive summary metrics such as shortest path, this option displays progress \nevery num nodes. If you also specify the BY_CLUSTER option in this statement or a value greater \nthan 1 for the NTHREADS= option in the PERFORMANCE statement, this option is ignored and the \ndisplay frequency is determined by using the LOGFREQTIME= option instead. The value of num can \nbe any integer greater than or equal to 1. The default is determined automatically based on the \nsize of the graph. Setting this value too low can hurt performance on large-scale graphs."},"StatementOptionType":"V"},{"StatementOptionName":"LOGFREQTIME=","StatementOptionHelp":{"#cdata":"Syntax: LOGFREQTIME=num \n          \nControls the frequency for displaying iteration logs for some of the summary metrics. For \ncomputationally intensive summary metrics such as shortest path, this option displays progress \nevery num seconds. When you specify a value greater than 1 for the NTHREADS= option in the \nPERFORMANCE statement, PROC OPTGRAPH displays the number of nodes that have completed. When \nyou specify the BY_CLUSTER option, PROC OPTGRAPH displays the number of subgraphs that have \ncompleted. The value of num can be any integer greater than or equal to 1; the default is 5. \nSetting this value too low can hurt performance on large-scale graphs."},"StatementOptionType":"V"},{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log. \n\nThe default is the value that is specified by the LOGLEVEL= option in the PROC OPTGRAPH \nstatement (or BASIC if that option is not specified)."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE|0","@Value2":"BASIC|1","@Value3":"MODERATE|2","@Value4":"AGGRESSIVE|3"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing","@ToolTip4":"Displays a detailed summary of the algorithmic processing"}},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=SAS-data-set \n          \nSpecifies the output data set to contain the summary results."},"StatementOptionType":"V"},{"StatementOptionName":"SHORTPATH=","StatementOptionHelp":{"#cdata":"Syntax: SHORTPATH=WEIGHT | UNWEIGHT | BOTH  \n          \nSpecifies whether to calculate information about shortest paths and what type of calculations to perform."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"WEIGHT","@Value2":"UNWEIGHT","@Value3":"BOTH"},"StatementOptionToolTips":{"@ToolTip1":"Calculates shortest paths based on the weighted graph.","@ToolTip2":"Calculates shortest paths based on the unweighted graph.","@ToolTip3":"Calculates shortest paths based on both weighted and unweighted graphs."}},{"StatementOptionName":"SUBSIZESWITCH=","StatementOptionHelp":{"#cdata":"Syntax: SUBSIZESWITCH=num \n          \nSpecifies how many subgraph nodes to run separately when you also specify the BY_CLUSTER option \nin this statement and a value greater than 1 for the NTHREADS= option in the PERFORMANCE statement. \nWhen PROC OPTGRAPH processes summary by subgraphs, it uses thread logic to simultaneously process \na number of subgraphs, with that number as specified in the NTHREADS= option in the PERFORMANCE \nstatement. For a larger graph with a number of nodes greater than num, each subgraph is processed \nsequentially, allowing the threading to be done at the summary metric level. \n\nThe default value is 10,000."},"StatementOptionType":"V"}]}},{"StatementName":"TRANSITIVE_CLOSURE|TRANSC","StatementHelp":{"#cdata":"Syntax: TRANSITIVE_CLOSURE | TRANSC < options > ; \n\nThe TRANSITIVE_CLOSURE statement invokes an algorithm that calculates the transitive \nclosure of an input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log. \n\nThe default is the value that is specified by the LOGLEVEL= option in the PROC OPTGRAPH \nstatement (or BASIC if that option is not specified)."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE|0","@Value2":"BASIC|1","@Value3":"MODERATE|2","@Value4":"AGGRESSIVE|3"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing","@ToolTip4":"Displays a detailed summary of the algorithmic processing"}},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=SAS-data-set \n          \nSpecifies the output data set to contain the transitive closure results."},"StatementOptionType":"V"}]}},{"StatementName":"TSP","StatementHelp":{"#cdata":"Syntax: TSP < options > ; \n\nThe TSP statement invokes an algorithm that solves the traveling salesman problem. \n\nThe traveling salesman problem is described in the section Traveling Salesman Problem. \nThe algorithm that is used to solve this problem is built around the same method as is \nused in PROC OPTMILP: a branch-and-cut algorithm."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ABSOBJGAP=","StatementOptionHelp":{"#cdata":"Syntax: ABSOBJGAP=num  \n          \nSpecifies a stopping criterion. When the absolute difference between the best integer \nobjective and the objective of the best remaining branch-and-bound node becomes less \nthan the value of num, the procedure stops. The value of num can be any nonnegative \nnumber; the default value is 1E\u20136."},"StatementOptionType":"V"},{"StatementOptionName":"CUTOFF=","StatementOptionHelp":{"#cdata":"Syntax: CUTOFF=num \n          \nCuts off any branch-and-bound nodes in a minimization problem with an objective value \nthat is greater than num. The value of num can be any number; the default value is the \npositive number that has the largest absolute value that can be represented in your \noperating environment."},"StatementOptionType":"V"},{"StatementOptionName":"CUTSTRATEGY=","StatementOptionHelp":{"#cdata":"Syntax: CUTSTRATEGY=option \n          \nSpecifies the level of cuts to be generated by PROC OPTGRAPH.\n\nThe default is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC|-1","@Value2":"NONE|0","@Value3":"MODERATE|1","@Value4":"AGGRESSIVE|2"},"StatementOptionToolTips":{"@ToolTip1":"Disables most of the generic mixed-integer programming cuts and focuses on the generation  of TSP-specific cuts","@ToolTip2":"Disables generation of cutting planes","@ToolTip3":"Uses a moderate cut strategy","@ToolTip4":"Uses an aggressive cut strategy"}},{"StatementOptionName":"EMPHASIS=","StatementOptionHelp":{"#cdata":"Syntax: EMPHASIS=option | num \n          \nSpecifies a search emphasis option or its corresponding value num."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"BALANCE|0","@Value2":"OPTIMAL|1","@Value3":"FEASIBLE|2"},"StatementOptionToolTips":{"@ToolTip1":"Performs a balanced search","@ToolTip2":"Emphasizes optimality over feasibility","@ToolTip3":"Emphasizes feasibility over optimality"}},{"StatementOptionName":"HEURISTICS=","StatementOptionHelp":{"#cdata":"Syntax: HEURISTICS=option | num \n          \nControls the level of initial and primal heuristics that are applied by PROC OPTGRAPH. This level \ndetermines how frequently primal heuristics are applied during the branch-and-bound tree search. \nIt also affects the maximum number of iterations that are allowed in iterative heuristics. Some \ncomputationally expensive heuristics might be disabled by the solver at less aggressive levels."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC|-1","@Value2":"NONE|0","@Value3":"BASIC|1","@Value4":"MODERATE|2","@Value5":"AGGRESSIVE|3"},"StatementOptionToolTips":{"@ToolTip1":"Applies the default level of heuristics","@ToolTip2":"Disables all initial and primal heuristics","@ToolTip3":"Applies basic intial and primal heuristics at low frequency","@ToolTip4":"Applies most intial and primal heuristics at moderate frequency","@ToolTip5":"Applies all intitial primal heuristics at high frequency"}},{"StatementOptionName":"INTTOL=","StatementOptionHelp":{"#cdata":"Syntax: INTTOL=num \n          \nSpecifies the amount by which an integer variable value can differ from an integer and \nstill be considered integer feasible. The value of num can be any number between 0.0 and \n1.0; the default value is 1E\u20135. PROC OPTGRAPH attempts to find an optimal solution with \ninteger infeasibility less than num. If you assign a value that is less than 1E\u201310 to num \nand the best solution found by PROC OPTGRAPH has integer infeasibility between num and \n1E\u201310, then PROC OPTGRAPH ends with a solution status of OPTIMAL_COND."},"StatementOptionType":"V"},{"StatementOptionName":"LOGFREQ=","StatementOptionHelp":{"#cdata":"Syntax: LOGFREQ=num \n          \nSpecifies how often to print information in the branch-and-bound node log. The value of num \ncan be any nonnegative integer up to the largest four-byte signed integer, which is 2\u00b3\u00b9 - 1. \nThe default value is 100. If num is set to 0, then the node log is disabled. If num is positive, \nthen an entry is made in the node log at the first node, at the last node, and at intervals that \nare dictated by the value of num. An entry is also made each time a better integer solution is found."},"StatementOptionType":"V"},{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information displayed in the SAS log by the solver, from a short \ndescription of presolve information and summary to details at each branch-and-bound node. \n\nThe default value is MODERATE."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE|0","@Value2":"BASIC|1","@Value3":"MODERATE|2","@Value4":"AGGRESSIVE|3"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all solver-related messages in the SAS log","@ToolTip2":"Displays a solver summary after stopping","@ToolTip3":"Prints a solver summary and a node log by using the interval dictated by the LOGFREQ= option","@ToolTip4":"Prints a detailed solver summary and a node log by using the interval dictated by the  LOGFREQ= option"}},{"StatementOptionName":"MAXNODES=","StatementOptionHelp":{"#cdata":"Syntax: MAXNODES=num \n          \nSpecifies the maximum number of branch-and-bound nodes to be processed. The value of num \ncan be any nonnegative integer up to the largest four-byte signed integer, which is 2\u00b3\u00b9 - 1. \n\nThe default value is 2\u00b3\u00b9 - 1."},"StatementOptionType":"V"},{"StatementOptionName":"MAXSOLS=","StatementOptionHelp":{"#cdata":"Syntax: MAXSOLS=num \n          \nSpecifies a stopping criterion. If num solutions have been found, then the procedure stops. \nThe value of num can be any positive integer up to the largest four-byte signed integer, which \nis 2\u00b3\u00b9 - 1. The default value is 2\u00b3\u00b9 - 1."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=num \n          \nSpecifies the maximum amount of time to spend solving the traveling salesman problem. The \ntype of time (either CPU time or real time) is determined by the value of the TIMETYPE= \noption. The value of num can be any positive number; the default value is the positive \nnumber that has the largest absolute value that can be represented in your operating \nenvironment."},"StatementOptionType":"V"},{"StatementOptionName":"MILP=","StatementOptionHelp":{"#cdata":"Syntax: MILP=option | num \n          \nSpecifies whether to use a mixed-integer linear programming (MILP) solver for solving the \ntraveling salesman problem. The MILP solver attempts to find the overall best TSP tour by \nusing a branch-and-bound based algorithm. This algorithm can be expensive for large-scale \nproblems. If MILP=OFF, then PROC OPTGRAPH uses its initial heuristics to find a feasible, \nbut not necessarily optimal, tour as quickly as possible."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"ON","@Value2":"OFF"},"StatementOptionToolTips":{"@ToolTip1":"Uses a mixed-integer linear programming","@ToolTip2":"Does not use a mixed-integer linear programming solver"}},{"StatementOptionName":"NODESEL=","StatementOptionHelp":{"#cdata":"Syntax: NODESEL=option | num \n          \nSpecifies the branch-and-bound node selection strategy option or its corresponding value num."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC|-1","@Value2":"BESTBOUND|0","@Value3":"BESTESTIMATE|1","@Value4":"DEPTH|2"},"StatementOptionToolTips":{"@ToolTip1":"Uses automatic node select","@ToolTip2":"Chooses the node with the best relaxed objective (best-bound-first strategy)","@ToolTip3":"Chooses the node with the best estimate of the integer objective value (best-estimate-first strategy)","@ToolTip4":"Chooses the most recently created node (depth-first strategy)"}},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=SAS-data-set  \n          \nSpecifies the output data set to contain the solution to the traveling salesman problem."},"StatementOptionType":"V"},{"StatementOptionName":"PROBE=","StatementOptionHelp":{"#cdata":"Syntax: PROBE=option | num         \n       \nSpecifies a probing option or its corresponding value num: \n\n-1  AUTOMATIC\n 0  NONE\n 1  MODERATE\n 2  AGGRESSIVE"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC|-1","@Value2":"NONE|0","@Value3":"MODERATE|1","@Value4":"AGGRESSIVE|2"},"StatementOptionToolTips":{"@ToolTip1":"Uses an automatic probing strategy","@ToolTip2":"Disables probing","@ToolTip3":"Uses the probing moderately","@ToolTip4":"Uses the probing aggressively"}},{"StatementOptionName":"RELOBJGAP=","StatementOptionHelp":{"#cdata":"Syntax: RELOBJGAP=num \n          \nSpecifies a stopping criterion that is based on the best integer objective (BestInteger) \nand the objective of the best remaining node (BestBound)."},"StatementOptionType":"V"},{"StatementOptionName":"STRONGITER=","StatementOptionHelp":{"#cdata":"Syntax: STRONGITER=num \n          \nSpecifies the number of simplex iterations to be performed for each variable in the candidate \nlist when using the strong branching variable selection strategy. The value of num can be any \npositive number; the default value is automatically calculated by PROC OPTGRAPH."},"StatementOptionType":"V"},{"StatementOptionName":"STRONGLEN=","StatementOptionHelp":{"#cdata":"Syntax: STRONGLEN=num \n          \nSpecifies the number of candidates to be used when performing the strong branching variable \nselection strategy. The value of num can be any positive integer up to the largest four-byte \nsigned integer, which is 2\u00b3\u00b9 - 1. The default value is 10.\n"},"StatementOptionType":"V"},{"StatementOptionName":"TARGET=","StatementOptionHelp":{"#cdata":"Syntax: TARGET=num \n          \nSpecifies a stopping criterion for minimization (maximization) problems. If the best integer \nobjective is better than or equal to num, the procedure stops. The value of num can be any \nnumber; the default is the negative (positive) number that has the largest absolute value \nthat can be represented in your operating environment."},"StatementOptionType":"V"},{"StatementOptionName":"VARSEL=","StatementOptionHelp":{"#cdata":"Syntax: VARSEL= AUTOMATIC | -1 | MAXINFEAS | 0 | MININFEAS | 1 | PESUDO | 2 | STRONG | 3\n          \nSpecifies the rule for selecting the branching variable."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC|-1","@Value2":" MAXINFEAS|0","@Value3":"MININFEAS|1","@Value4":"PESUDO|2","@Value5":"STRONG|3"},"StatementOptionToolTips":{"@ToolTip1":"Uses automatic branching variable selection","@ToolTip2":"Chooses the variable with maximum infeasibility","@ToolTip3":"Chooses the variable with minimum infeasibility","@ToolTip4":"Chooses a branching variable based on pseudocost","@ToolTip5":"Uses strong branching variable selection strategy"}}]}}]}}}