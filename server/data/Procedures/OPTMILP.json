{"Procedure":{"Name":"OPTMILP","#comment":{},"ProductGroup":"SAS/OR","ProcedureHelp":{"#cdata":"Syntax: PROC OPTMILP < options > ;\n    DECOMP < options > ;\n    DECOMPMASTER < options > ;\n    DECOMPMASTERIP < options > ;\n    DECOMPSUBPROB < options > ;\n    PERFORMANCE < performance-options > ;\n    TUNER < tuner-options > ; \n\nThe OPTMILP procedure is a solver for general mixed integer linear programs (MILPs). \n\nThe OPTMILP procedure implements an LP-based branch-and-bound algorithm. This divide-and-conquer \napproach attempts to solve the original problem by solving linear programming relaxations of a \nsequence of smaller subproblems. The OPTMILP procedure also implements advanced techniques such \nas presolving, generating cutting planes, and applying primal heuristics to improve the efficiency \nof the overall algorithm."},"ProcedureOptions":{"ProcedureOption":[{"ProcedureOptionName":"ABSOBJGAP=|ABSOLUTEOBJECTIVEGAP=","ProcedureOptionHelp":{"#cdata":"[Syntax: ABSOBJGAP=number | ABSOLUTEOBJECTIVEGAP=number] \n      \nSpecifies a stopping criterion. When the absolute difference between the best integer objective and the\nobjective of the best remaining node becomes smaller than the value of number, the procedure stops.\nThe value of number can be any nonnegative number; the default value is 1E\u20136."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"BASIS=","ProcedureOptionHelp":{"#cdata":"Specifies one of three available options for generating an initial basis."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"CRASH","@Value2":"SLACK","@Value3":"WARMSTART"},"ProcedureOptionToolTips":{"@ToolTip1":"Generate an initial basis by using crash techniques (Maros 2003). The procedure creates a triangular  basic matrix consisting of both decision variables and slack variables. This is the default setting.","@ToolTip2":"Generate an initial basis by using all slack variables.","@ToolTip3":"Start the simplex solvers with a user-specified initial basis. The PRIMALIN= and DUALIN= data sets  are required to specify an initial basis."}},{"ProcedureOptionName":"DATA=|TABLE=|INSTANCE=","ProcedureOptionHelp":{"#cdata":"[Syntax: DATA=SAS-data-set] \n      \nSpecifies the input data set corresponding to the MILP model. If this option is not specified, PROC\nOPTMILP uses the most recently created SAS data set."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"DUALOUT=|DOUT=","ProcedureOptionHelp":{"#cdata":"[Syntax: DUALOUT=SAS-data-set | DOUT=SAS-data-set \n      \nSpecifies the output data set to contain the constraint activities."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"ALLCUTS=","ProcedureOptionHelp":{"#cdata":"Provides a shorthand way of setting all the cuts-related options in one setting. In other words, ALLCUTS=num is equivalent to setting each\nof the individual cuts parameters to the same value num."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"ProcedureOptionName":"CONFLICTSEARCH=","ProcedureOptionHelp":{"#cdata":"Syntax: CONFLICTSEARCH=AUTOMATIC | NONE | MODERATE | AGGRESSIVE \n      \nSpecifies the level of conflict search performed by PROC OPTMILP. Conflict search is used to find\nclauses resulting from infeasible subproblems that arise in the search tree."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Performs conflict search based on a strategy determined by PROC OPTMILP","@ToolTip2":"Disables conflict search","@ToolTip3":"Performs a moderate conflict search","@ToolTip4":"Performs an aggressive conflict search"}},{"ProcedureOptionName":"CUTCLIQUE=","ProcedureOptionHelp":{"#cdata":"Specifies the level of clique cuts generated by PROC OPTMILP. \n      \nThe CUTCLIQUE= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"ProcedureOptionName":"CUTFLOWCOVER=","ProcedureOptionHelp":{"#cdata":"Specifies the level of flow cover cuts generated by PROC OPTMILP. \n      \nThe CUTFLOWCOVER= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"ProcedureOptionName":"CUTFLOWPATH=","ProcedureOptionHelp":{"#cdata":"Specifies the level of flow path cuts generated by PROC OPTMILP. \n      \nThe CUTFLOWPATH= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"ProcedureOptionName":"CUTGOMORY=","ProcedureOptionHelp":{"#cdata":"Specifies the level of Gomory cuts generated by PROC OPTMILP. \n      \nThe CUTGOMORY= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"ProcedureOptionName":"CUTGUB=","ProcedureOptionHelp":{"#cdata":"Specifies the level of generalized upper bound (GUB) cover cuts generated by PROC OPTMILP. \n      \nThe CUTGUB= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"ProcedureOptionName":"CUTIMPLIED=","ProcedureOptionHelp":{"#cdata":"Specifies the level of implied bound cuts generated by PROC OPTMILP. \n      \nThe CUTIMPLIED= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"ProcedureOptionName":"CUTKNAPSACK=","ProcedureOptionHelp":{"#cdata":"Specifies the level of knapsack cover cuts generated by PROC OPTMILP. \n      \nThe CUTKNAPSACK= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"ProcedureOptionName":"CUTLAP=","ProcedureOptionHelp":{"#cdata":"Specifies the level of lift-and-project (LAP) cuts generated by PROC OPTMILP."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"ProcedureOptionName":"CUTMILIFTED=","ProcedureOptionHelp":{"#cdata":"Specifies the level of mixed lifted 0-1 cuts that are generated by PROC OPTMILP. \\\n      \nThe CUTMILIFTED= option overrides the ALLCUTS=option. The default value is AUTOMATIC."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"ProcedureOptionName":"CUTMIR=","ProcedureOptionHelp":{"#cdata":"Specifies the level of mixed integer rounding (MIR) cuts generated by PROC OPTMILP. \n      \nThe CUTMIR= option overrides the\nALLCUTS= option. The default value is AUTOMATIC."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"ProcedureOptionName":"CUTMULTICOMMODITY=","ProcedureOptionHelp":{"#cdata":"Specifies the level of multicommodity network flow cuts generated by PROC OPTMILP. This option \noverrides the ALLCUTS= option. By default, CUTMULTICOMMODITY=AUTOMATIC."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"ProcedureOptionName":"CUTSFACTOR=","ProcedureOptionHelp":{"#cdata":"[Syntax: CUTSFACTOR=m] \n      \nSpecifies a row multiplier factor for cuts. The number of cuts added is limited to num times the \noriginal number of rows. The value of num can be any nonnegative number less than or equal to 100; \nthe default value is 3.0."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"ProcedureOptionName":"CUTSTRATEGY=|CUTS=","ProcedureOptionHelp":{"#cdata":"[Syntax: CUTSTRATEGY=number | string ] \n      \nSpecifies the overall aggressiveness of the cut generation in the solver. Setting a nondefault value\nadjusts a number of cut parameters such that the cut generation is basic, moderate, or aggressive\ncompared to the default value."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"ProcedureOptionName":"CUTZEROHALF=","ProcedureOptionHelp":{"#cdata":"[Syntax: CUTZEROHALF=number | string] \n      \nSpecifies the level of zero-half cuts that are generated by PROC OPTMILP. \n\nThe CUTZEROHALF= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"ProcedureOptionName":"CUTOFF=","ProcedureOptionHelp":{"#cdata":"[Syntax: CUTOFF=number] \n      \nCuts off any nodes in a minimization (maximization) problem with an objective value above (below) \nnum. The value of num can be any number; the default value is the positive (negative) number that \nhas the largest absolute value representable in your operating environment."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"EMPHASIS=","ProcedureOptionHelp":{"#cdata":"Specifies a search emphasis option."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"BALANCE","@Value2":"OPTIMAL","@Value3":"FEASIBLE"},"ProcedureOptionToolTips":{"@ToolTip1":"Perform a balanced search.","@ToolTip2":"Emphasize optimality over feasibility.","@ToolTip3":"Emphasize feasibility over optimality."}},{"ProcedureOptionName":"HEURISTICS=","ProcedureOptionHelp":{"#cdata":"Syntax: HEURISTICS=AUTOMATIC | NONE | BASIC | MODERATE | AGGRESSIVE \n      \nEnables the user to control the level of primal heuristics applied by PROC OPTMILP."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"BASIC","@Value4":"MODERATE","@Value5":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Apply default level of heuristics, similar to MODERATE.","@ToolTip2":"Disable all primal heuristics.","@ToolTip3":"Apply basic primal heuristics at low frequency.","@ToolTip4":"Apply most primal heuristics at moderate frequency.","@ToolTip5":"Apply all primal heuristics at high frequency."}},{"ProcedureOptionName":"INTTOL=","ProcedureOptionHelp":{"#cdata":"[Syntax: INTTOL=number] \n      \nSpecifies the amount by which an integer variable value can differ from an integer and still be \nconsidered integer feasible. The value of num can be any number between 0.0 and 1.0; the default \nvalue is 1E-5."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"MAXNODES=","ProcedureOptionHelp":{"#cdata":"[Syntax: MAXNODES=number] \n      \nSpecifies the maximum number of branch-and-bound nodes to be processed. The value of num can be \nany nonnegative integer up to the largest four-byte signed integer, which is 2\u00b3\u00b9-1. The default \nvalue is 2\u00b3\u00b9-1."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"MAXSOLS=","ProcedureOptionHelp":{"#cdata":"[Syntax: MAXSOLS=number] \n      \nSpecifies a stopping criterion. If num solutions have been found, then the procedure stops. \nThe value of num can be any positive integer up to the largest four-byte signed integer, which \nis 2\u00b3\u00b9-1. The default value is 2\u00b3\u00b9-1."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"MAXTIME=","ProcedureOptionHelp":{"#cdata":"[Syntax: MAXTIME=k] \n      \nSpecifies the maximum time allowed for PROC OPTMILP to read in the data and find a solution."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"NODESEL=","ProcedureOptionHelp":{"#cdata":"Syntax: NODESEL=AUTOMATIC | BESTBOUND | BESTESTIMATE | DEPTH \n      \nSpecifies the node selection strategy option."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"AUTOMATIC","@Value2":"BESTBOUND","@Value3":"BESTESTIMATE","@Value4":"DEPTH"},"ProcedureOptionToolTips":{"@ToolTip1":"Use automatic node selection.","@ToolTip2":"Choose the node with the best relaxed objective (best-bound-first strategy).","@ToolTip3":"Choose the node with the best estimate of the integer objective value (best-estimate-first strategy).","@ToolTip4":"Choose the most recently created node (depth-first strategy)."}},{"ProcedureOptionName":"OBJSENSE=","ProcedureOptionHelp":{"#cdata":"Syntax: OBJSENSE=MIN | MAX \n      \nSpecifies whether the MILP model is a minimization or a maximization problem."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"MIN","@Value2":"MAX"},"ProcedureOptionToolTips":{"@ToolTip1":"For a minimization problem.","@ToolTip2":"For a maximization problem."}},{"ProcedureOptionName":"PRESOLVER=","ProcedureOptionHelp":{"#cdata":"Syntax: PRESOLVER=AUTOMATIC | NONE | BASIC | MODERATE | AGGRESSIVE \n      \nSpecifies a presolve option."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"NONE","@Value2":"AUTOMATIC","@Value3":"BASIC","@Value4":"MODERATE","@Value5":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Disable presolver.","@ToolTip2":"Applies the default level of presolve processing.","@ToolTip3":"Performs minimal presolve processing.","@ToolTip4":"Applies a higher level of presolve processing.","@ToolTip5":"Applies the highest level of presolve processing."}},{"ProcedureOptionName":"PRICETYPE=","ProcedureOptionHelp":{"#cdata":"Specifies one of 5 available pricing strategies for the simplex solvers."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"HYBRID","@Value2":"PARTIAL","@Value3":"FULL","@Value4":"DEVEX","@Value5":"STEEPESTEDGE"},"ProcedureOptionToolTips":{"@ToolTip1":"Use a hybrid of Devex and steepest-edge pricing strategies. Available for the primal simplex solver only.","@ToolTip2":"Use the Dantzig's rule on a queue of decision variables. Optionally, you can specify QUEUESIZE=. Available for the primal simplex solver only.","@ToolTip3":"Use the Dantzig's rule on all decision variables.","@ToolTip4":"Use Devex pricing strategy.","@ToolTip5":"Use steepest-edge pricing strategy."}},{"ProcedureOptionName":"PRIMALIN=","ProcedureOptionHelp":{"#cdata":"[Syntax: PRIMALIN=SAS-data-set] \n      \nEnables you to input an integer feasible solution in a SAS data set. PROC OPTMILP validates both \nthe data set and the solution stored in the data set. If both are valid, then the input solution \nprovides an incumbent solution and a bound for the branch-and-bound algorithm. If either the data \nset or the solution is not valid, then the PRIMALIN= data are ignored."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"PRIMALOUT=|POUT=","ProcedureOptionHelp":{"#cdata":"[Syntax: PRIMALOUT=SAS-data-set] \n      \nSpecifies the output data set for the primal solution."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"PRINTFREQ=","ProcedureOptionHelp":{"#cdata":"[Syntax: PRINTFREQ=k] \n      \nSpecifies how often information is printed in the node log. The value of num can be any \nnonnegative integer up to the largest four-byte signed integer, which is 2\u00b3\u00b9-1."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"PRINTLEVEL=","ProcedureOptionHelp":{"#cdata":"Specifies whether a summary of the problem and solution should be printed."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"0","@Value2":"1","@Value3":"2"},"ProcedureOptionToolTips":{"@ToolTip1":"No ODS tables are produced or printed.","@ToolTip2":"Two ODS (Output Delivery System) tables named \"ProblemSummary\" and \"SolutionSummary\"  are produced and printed. This is the default.","@ToolTip3":"The \"ProblemSummary\" and \"SolutionSummary\" tables are produced and printed along with  a third table called \"ProblemStatistics.\""}},{"ProcedureOptionName":"PRINTLEVEL2=","ProcedureOptionHelp":{"#cdata":"Controls the amount of information displayed in the SAS log by the solver, from a short description \nof presolve information and summary to details at each node."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"NONE","@Value2":"BASIC","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Turn off all solver-related messages in SAS log.","@ToolTip2":"Display a solver summary after stopping.","@ToolTip3":"Print a solver summary and a node log by using the interval dictated by the  PRINTFREQ= option.","@ToolTip4":"Print a detailed solver summary and a node log by using the interval dictated  by the PRINTFREQ= option."}},{"ProcedureOptionName":"PRIORITY=","ProcedureOptionHelp":{"#cdata":"Syntax: PRIORITY=TRUE | FALSE \n      \nIndicates whether or not to use specified branching priorities for integer variables."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"TRUE","@Value2":"FALSE"},"ProcedureOptionToolTips":{"@ToolTip1":"Uses priorities when they exist.","@ToolTip2":"Ignores variable priorities"}},{"ProcedureOptionName":"RESTARTS=","ProcedureOptionHelp":{"#cdata":"Syntax: RESTARTS=AUTOMATIC | NONE | BASIC | MODERATE | AGGRESSIVE \n      \nSpecifies the strategy for restarting the processing of the root node.\n\nBy default, RESTARTS=AUTOMATIC."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"BASIC","@Value4":"MODERATE","@Value5":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Uses a restarting strategy determined by PROC OPTMILP.","@ToolTip2":"Disables restarting.","@ToolTip3":"Uses a basic restarting strategy.","@ToolTip4":"Uses a moderate restarting strategy.","@ToolTip5":"Uses an aggressive restarting strategy."}},{"ProcedureOptionName":"PROBE=","ProcedureOptionHelp":{"#cdata":"Specifies a probing option."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Probing strategy determined by PROC OPTMILP.","@ToolTip2":"Disable probing.","@ToolTip3":"Use probing moderately.","@ToolTip4":"Use probing aggressively."}},{"ProcedureOptionName":"RELOBJGAP=","ProcedureOptionHelp":{"#cdata":"[Syntax: RELOBJGAP=number] \n      \nSpecifies a stopping criterion based on the best integer objective (BestInteger) and the \nobjective of the best remaining node (BestBound)."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"SCALE=","ProcedureOptionHelp":{"#cdata":"Indicates whether or not to scale the problem matrix."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"NONE","@Value2":"AUTOMATIC"},"ProcedureOptionToolTips":{"@ToolTip1":"Disables scaling.","@ToolTip2":"Scales the matrix as determined by PROC OPTMILP. This is the default."}},{"ProcedureOptionName":"STRONGITER=","ProcedureOptionHelp":{"#cdata":"[Syntax: STRONGITER=STRONGITER=number | AUTOMATIC] \n      \nSpecifies the number of simplex iterations performed for each variable in the candidate list \nwhen using the strong branching variable selection strategy. If you specify the keyword \nAUTOMATIC, PROC OPTMILP uses the default value; this value is calculated automatically."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"STRONGLEN=","ProcedureOptionHelp":{"#cdata":"[Syntax: STRONGLEN=number | AUTOMATIC] \n      \nSpecifies the number of candidates used when performing the strong branching variable selection \nstrategy. The value of num can be any positive integer up to the largest four-byte signed integer, \nwhich is 2\u00b3\u00b9-1. If you specify the keyword AUTOMATIC, PROC OPTMILP uses the default value; this \nvalue is calculated automatically."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"SEED=","ProcedureOptionHelp":{"#cdata":"[Syntax: SEED=number]\n      \nSpecifies the initial seed for the random number generator. Because the seed affects the \nperturbation in the simplex algorithms, the result might be a different optimal solution \nand a different solver path, but the effect is usually negligible."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"SYMMETRY=","ProcedureOptionHelp":{"#cdata":"Syntax: SYMMETRY=AUTOMATIC | NONE | BASIC | MODERATE | AGGRESSIVE \n      \nSpecifies the level of symmetry detection. Symmetry detection identifies groups of equivalent \ndecision variables and uses this information to solve the problem more efficiently.\n\nBy default, SYMMETRY=AUTOMATIC."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"BASIC","@Value4":"MODERATE","@Value5":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"performs symmetry detection based on a strategy that is determined by PROC OPTMILP.","@ToolTip2":"disables symmetry detection.","@ToolTip3":"performs a basic symmetry detection.","@ToolTip4":"performs a moderate symmetry detection.","@ToolTip5":"performs an aggressive symmetry detection."}},{"ProcedureOptionName":"TARGET=","ProcedureOptionHelp":{"#cdata":"[Syntax: TARGET=number] \n      \nSpecifies a stopping criterion for minimization (maximization) problems. If the best integer \nobjective is better than or equal to num, the procedure stops. The value of num can be any \nnumber; the default value is the negative (positive) number that has the largest absolute \nvalue representable in your operating environment."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"TIMETYPE=","ProcedureOptionHelp":{"#cdata":"Specifies whether CPU time or real time is used for the MAXTIME= option and the _OROPTMILP_ macro variable in a PROC OPTMILP call."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"CPU","@Value2":"REAL"},"ProcedureOptionToolTips":{"@ToolTip1":"Specifies that units are in CPU time.","@ToolTip2":"Specifies that units are in real time."}},{"ProcedureOptionName":"VARSEL=","ProcedureOptionHelp":{"#cdata":"Syntax: VARSEL=AUTOMATIC | MAXINFEAS | MININFEAS | PSEUDO | STRONG \n      \nSpecifies the rule for selecting the branching variable."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"AUTOMATIC","@Value2":"MAXINFEAS","@Value3":"MININFEAS","@Value4":"PSEUDO","@Value5":"STRONG"},"ProcedureOptionToolTips":{"@ToolTip1":"Uses automatic branching variable selection.","@ToolTip2":"Chooses the variable with maximum infeasibility.","@ToolTip3":"Chooses the variable with minimum infeasibility.","@ToolTip4":"Chooses a branching variable based on pseudocost.","@ToolTip5":"Uses strong branching variable selection strategy."}},{"ProcedureOptionName":"NTHREADS=","ProcedureOptionHelp":{"#cdata":"Syntax: NTHREADS=number \n      \nSpecifies the maximum number of threads to use for multithreaded processing. The branch-and-cut \nalgorithm can take advantage of multicore machines and can potentially run faster when number is \ngreater than 1. The value of number can be any integer between 1 and 256, inclusive. The default \nis the number of cores on the machine that executes the process or the number of cores permissible \nbased on your installation (whichever is less). The number of simultaneously active CPUs is limited \nby your installation and license configuration."},"ProcedureOptionType":"V"}]},"ProcedureStatements":{"ProcedureStatement":[{"StatementName":"PERFORMANCE","StatementHelp":{"#cdata":"Syntax: PERFORMANCE < performance-options > ;\n      \nThe PERFORMANCE statement defines performance parameters for multithreaded and distributed \ncomputing, passes variables about the distributed computing environment, and requests detailed \nresults about the performance characteristics of a High-Performance Analytics procedure.\n\nWith the PERFORMANCE statement, you can also control whether the HPNLIN procedure executes \nin SMP or MPP mode."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"DETAILS","StatementOptionHelp":{"#cdata":"Requests that the procedure produce the Timing ODS table. This table shows a breakdown of the time\nused in each step of the procedure."},"StatementOptionType":"S"},{"StatementOptionName":"NTHREADS=","StatementOptionHelp":{"#cdata":"Syntax: NTHREADS=number | CPUCOUNT\n          \nSpecifies the number of threads that a procedure can use. It overrides the SAS system option THREADS\n| NOTHREADS. The value of number can be any integer between 1 and 256 inclusive. The default\nvalue is CPUCOUNT, which sets the thread count to the number that is determined by the SAS system\noption CPUCOUNT=.\n\nSetting the NTHREADS= option to a number greater than the actual number of available cores might\nresult in reduced performance. Specifying a high NTHREADS= value does not guarantee shorter\nsolution time; the actual change in solution time depends on the computing hardware and the scalability\nof the underlying algorithms in the specified procedure. In some circumstances, a procedure might use\nfewer threads than the specified value of the NTHREADS= option because the procedure\u2019s internal\nalgorithms have determined that a smaller number is preferable."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"<num>","@Value2":"CPUCOUNT"},"StatementOptionToolTips":{"@ToolTip1":"Replace <num> with an actual number. The value of number can be any integer between 1 and 256  inclusive. The default value is CPUCOUNT, which sets the thread count to the number that is determined  by the SAS system option CPUCOUNT=.","@ToolTip2":"The default value is CPUCOUNT, which sets the thread count to the number that is determined by the  SAS system option CPUCOUNT="}},{"StatementOptionName":"PARALLELMODE=","StatementOptionHelp":{"#cdata":"Syntax: PARALLELMODE=number | string \n          \nSpecifies the parallel processing mode. This mode determines the solution results that are obtained\nfrom running the same model with the same option values on the same platform multiple times."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"DETERMINISTIC|0","@Value2":"NONDETERMINISTIC|1"},"StatementOptionToolTips":{"@ToolTip1":"Requires algorithms to produce the same results every time.","@ToolTip2":"Permits algorithms to produce different solution results. This mode requires less synchronization and might attain better performance than DETERMINISTIC mode."}}]}},{"StatementName":"DECOMP|DECOMPOSITION","StatementHelp":{"#cdata":"Syntax: DECOMP|DECOMPOSITION < options > ; \n      \nThe DECOMP|DECOMPOSITION statement controls the overall decomposition algorithm."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ABSOBJGAP=","StatementOptionHelp":{"#cdata":"Syntax: ABSOBJGAP=number \n          \nSpecifies a stopping criterion for the continuous bound of the decomposition. When the absolute\ndifference between the master objective and the best dual bound falls below the value of number, the\ndecomposition algorithm stops adding columns. The value of number can be any nonnegative number.\nThe default value is the value of the OPTTOL= main solver option."},"StatementOptionType":"V"},{"StatementOptionName":"BLOCKS=","StatementOptionHelp":{"#cdata":"Syntax: BLOCKS=SAS-data-set \n          \nSpecifies (for OPTLP and OPTMILP procedures only) the input data set that contains block definitions\nto be used by the decomposition algorithm if METHOD=USER. To specify blocks in PROC OPTMODEL, use the \n.block constraint suffix instead."},"StatementOptionType":"V"},{"StatementOptionName":"COMPRESSFREQ=","StatementOptionHelp":{"#cdata":"Syntax: COMPRESSFREQ=number \n          \nRemoves ineffective columns from the master LP after every number of iterations. The frequency,\nnumber, is an integer between 0 and the largest four-byte signed integer, which is 2\u00b3\u00b9 - 1. The default\nvalue is 0."},"StatementOptionType":"V"},{"StatementOptionName":"INITVARS=","StatementOptionHelp":{"#cdata":"Syntax: INITVARS=number | string \n          \nSpecifies whether to initialize the columns by using the original cost vector to solve each block."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"OFF","@Value2":"ON"},"StatementOptionToolTips":{"@ToolTip1":"Disables initializing the columns by using the original cost vector to solve each block.","@ToolTip2":"Enables initializing the columns by using the original cost vector to solve each block."}},{"StatementOptionName":"LOGFREQ=","StatementOptionHelp":{"#cdata":"Syntax: LOGFREQ=number \n          \nSpecifies (for MILP problems only) how often to print information in the continuous iteration log. The\nvalue of number can be any nonnegative number up to the largest four-byte signed integer, which is\n2\u00b3\u00b9 - 1. The default value of number is 10. If number is set to 0, then the iteration log is disabled. If\nnumber is positive, then an entry is made in the log at the first iteration, at the last iteration, and at\nintervals that are dictated by the value of number. An entry is also made each time a better integer\nsolution or improved bound is found."},"StatementOptionType":"V"},{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=number | string \n          \nControls the amount of information that is displayed in the SAS log by the decomposition algorithm. \n\nThe default is AUTOMATIC for both LPs and MILPs."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC|-1","@Value2":"NONE|0","@Value3":"BASIC|1","@Value4":"MODERATE|2","@Value5":"AGGRESSIVE|3"},"StatementOptionToolTips":{"@ToolTip1":"Prints the continuous iteration log for the root node at the interval dictated by the LOGFREQ= option  in the DECOMP statement. Prints the branch-and-bound node log at the interval dictated by the LOGFREQ=  main solver option.","@ToolTip2":"Turns off printing of all of the decomposition algorithm messages to the SAS log.","@ToolTip3":"Prints the continuous iteration log for each branch-andbound node at the interval dictated by the LOGFREQ= option in the DECOMP statement.","@ToolTip4":"Prints the continuous iteration log and summary information for each iteration of each branch-and-bound  node at the interval dictated by the LOGFREQ= option in the DECOMP statement.","@ToolTip5":"Prints the continuous iteration log and detailed information for each iteration of each branch-and-bound  node at the interval dictated by the LOGFREQ= option in the DECOMP statement."}},{"StatementOptionName":"MASTER_IP_BEG=","StatementOptionHelp":{"#cdata":"Syntax: MASTER_IP_BEG=number | string \n          \nSpecifies (for MILP problems only) whether the master problem is solved as a MILP with the current\nset of columns at the beginning of phase II."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"OFF|0","@Value2":"ON|1"},"StatementOptionToolTips":{"@ToolTip1":"Disables solving the master as a MILP at the beginning of phase II.","@ToolTip2":"Enables solving the master as a MILP at the beginning of phase II."}},{"StatementOptionName":"MASTER_IP_END=","StatementOptionHelp":{"#cdata":"Syntax: MASTER_IP_END=number | string \n          \nSpecifies (for MILP problems only) whether the master problem is solved as a MILP with the current\nset of columns at the end of phase II. \n\nThe default is ON in the root node and 0 elsewhere."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"OFF|0","@Value2":"ON|1"},"StatementOptionToolTips":{"@ToolTip1":"Disables solving the master as a MILP at the end of phase II.","@ToolTip2":"Enables solving the master as a MILP at the end of phase II."}},{"StatementOptionName":"MASTER_IP_FREQ=","StatementOptionHelp":{"#cdata":"Syntax: MASTER_IP_FREQ=number \n          \nSolves the master problem (for MILP problems only) as a MILP with the current set of columns after\nevery number iterations. The frequency, number, is an integer between 0 and the largest four-byte\nsigned integer, which is 2\u00b3\u00b9 - 1. The default is 10 in the root node and 0 elsewhere."},"StatementOptionType":"V"},{"StatementOptionName":"MAXBLOCKS=","StatementOptionHelp":{"#cdata":"Syntax: MAXBLOCKS=number \n          \nSpecifies the maximum number of blocks to allow. If the defined number of blocks exceeds number,\nthe algorithm creates superblocks using a very simple round-robin scheme. The value of number can\nbe any positive number; the default value is the positive number that has the largest absolute value that\ncan be represented in your operating environment."},"StatementOptionType":"V"},{"StatementOptionName":"MAXCOLSPASS=","StatementOptionHelp":{"#cdata":"Syntax: MAXCOLSPASS=number \n          \nSpecifies the maximum number of new columns to allow into the master at each pass. This option is\ndisabled on the initial pass if INITVARS=1. The default is 100."},"StatementOptionType":"V"},{"StatementOptionName":"MAXITER=","StatementOptionHelp":{"#cdata":"Syntax: MAXITER=number \n          \nSpecifies (for MILP problems only) the maximum number of outer iterations for the decomposition\nalgorithm. The value number can be any integer between 1 and the largest four-byte signed integer,\nwhich is 2\u00b3\u00b9 - 1. If you do not specify this option, the procedure does not stop based on the number of\niterations performed."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=number \n          \nSpecifies an upper limit of number seconds of time for the decomposition algorithm. The value of the\nTIMETYPE= main solver option determines the type of units used. If you do not specify this option,\nthe procedure does not stop based on the amount of time elapsed. The value of number can be any\npositive number; the default value is the positive number that has the largest absolute value that can be\nrepresented in your operating environment."},"StatementOptionType":"V"},{"StatementOptionName":"METHOD=","StatementOptionHelp":{"#cdata":"Specifies the decomposition algorithm method. \n          \nThe default is USER if blocks are defined and NETWORK otherwise."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"USER","@Value2":"NETWORK","@Value3":"AUTO"},"StatementOptionToolTips":{"@ToolTip1":"The user defines which rows belong to which blocks (subproblems). In PROC OPTMODEL, use the .block  constraint suffix. In PROC OPTLP and PROC OPTMILP, use the BLOCKS= data set instead.","@ToolTip2":"The algorithm attempts to find an embedded network similar to what is described in \u201cThe Network  Simplex Algorithm\u201d. The weakly connected components of this network are used as the blocks.","@ToolTip3":"The algorithm attempts to find a block structure in the constraint matrix. For the current release,  METHOD=AUTO finds block-diagonal structure only (not block-angular structures); unless your problem  separates into completely independent problems with no linking constraints, this method finds only  one block and hence is equivalent to calling the MILP solver directly."}},{"StatementOptionName":"RELOBJGAP=","StatementOptionHelp":{"#cdata":"Syntax: RELOBJGAP=number \n          \nSpecifies the relative objective gap as a stopping criterion. The relative objective gap is based on the\nmaster objective (MasterObjective) and the best dual bound (BestBound); it is equal to \n\n  | MasterObjective - BestBound | / (1E-10 + | BestBound |)\n\nWhen this value becomes smaller than the specified gap size number, the decomposition algorithm\nstops adding columns. The value of number can be any nonnegative number. For LP, the default value\nis 0; for MILP, the default value is 1e-4."},"StatementOptionType":"V"}]}},{"StatementName":"DECOMPMASTER|DECOMPOSITIONMASTER|MASTER","StatementHelp":{"#cdata":"Syntax: DECOMPMASTER|DECOMPOSITIONMASTER|MASTER < options > ; \n      \nThe DECOMPMASTER|DECOMPOSITIONMASTER|MASTER statement controls the master problem. \n\nThe default is AUTOMATIC."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"INITPRESOLVER=|INITPRESOL=","StatementOptionHelp":{"#cdata":"Syntax: INITPRESOLVER=number | string\nINITPRESOL=number | string\n\nSpecifies, for the first master solve only, presolve conditions."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC|-1","@Value2":"NONE|0","@Value3":"BASIC|1","@Value4":"MODERATE|2","@Value5":"AGGRESSIVE|3"},"StatementOptionToolTips":{"@ToolTip1":"Applies the default level of presolve processing.","@ToolTip2":"Disables presolver.","@ToolTip3":"Performs minimal presolve processing.","@ToolTip4":"Applies a higher level of presolve processing.","@ToolTip5":"Applies the highest level of presolve processing."}},{"StatementOptionName":"ALGORITHM=|SOLVER=|SOL=","StatementOptionHelp":{"#cdata":"Syntax: ALGORITHM=option | SOLVER=option | SOL=option \n          \nSpecifies an LP solver."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"PRIMAL","@Value2":"DUAL","@Value3":"NETWORK","@Value4":"INTERIORPOINT","@Value5":"CONCURRENT"},"StatementOptionToolTips":{"@ToolTip1":"Uses primal simplex solver.","@ToolTip2":"Uses dual simplex solver.","@ToolTip3":"Uses network simplex solver.","@ToolTip4":"Uses interior point solver.","@ToolTip5":"Uses several different algorithms in parallel."}},{"StatementOptionName":"FEASTOL=","StatementOptionHelp":{"#cdata":"Syntax: FEASTOL=\u03f5 \n          \nSpecifies the feasibility tolerance \u03f5 \u0404[1E\u20139, 1E\u20134] for determining the feasibility of a variable value.\nThe default value is 1E\u20136."},"StatementOptionType":"V"},{"StatementOptionName":"LOGLEVEL=|PRINTLEVEL2=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=number | string \nPRINTLEVEL2=number | string\n          \nControls the amount of information that is displayed in the SAS log by the LP solver, from a short \ndescription of presolve information and summary to details at each iteration. \n\nThe default value is MODERATE."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE|0","@Value2":"BASIC|1","@Value3":"MODERATE|2","@Value4":"AGGRESSIVE|3"},"StatementOptionToolTips":{"@ToolTip1":"Turn off all solver-related messages in SAS log.","@ToolTip2":"Display a solver summary after stopping.","@ToolTip3":"Print a solver summary and an iteration log by using the interval dictated by the LOGFREQ= option.","@ToolTip4":"Print a detailed solver summary and an iteration log by using the interval dictated by the LOGFREQ= option."}},{"StatementOptionName":"MAXITER=","StatementOptionHelp":{"#cdata":"Syntax: MAXITER=k \n          \nSpecifies the maximum number of iterations. The value k can be any integer between one and the\nlargest four-byte signed integer, which is 2\u00b3\u00b9 - 1. If you do not specify this option, the procedure\ndoes not stop based on the number of iterations performed. For network simplex, this iteration limit\ncorresponds to the solver called after network simplex (either primal or dual simplex)."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=t \n          \nSpecifies an upper limit of t seconds of time for reading in the data and performing the optimization\nprocess. The value of the TIMETYPE= option determines the type of units used. If you do not specify\nthis option, the procedure does not stop based on the amount of time elapsed. The value of t can be\nany positive number; the default value is the positive number that has the largest absolute value that\ncan be represented in your operating environment."},"StatementOptionType":"V"},{"StatementOptionName":"OPTTOL=","StatementOptionHelp":{"#cdata":"Syntax: OPTTOL=\u03f5 \n          \nSpecifies the optimality tolerance \u03f5 \u0404[1E\u20139, 1E\u20134] for declaring optimality. The default value is 1E\u20136."},"StatementOptionType":"V"},{"StatementOptionName":"PRINTLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: PRINTLEVEL=0 | 1 | 2 \n          \nSpecifies whether a summary of the problem and solution should be printed. If PRINTLEVEL=1, then\nthe ODS (Output Delivery System) tables ProblemSummary, SolutionSummary, and PerformanceInfo\nare produced and printed. If PRINTLEVEL=2, then these tables are produced and printed along with\nan additional table called ProblemStatistics. If PRINTLEVEL=0, then no ODS tables are produced or\nprinted. The default value is 1."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"0","@Value2":"1","@Value3":"2"},"StatementOptionToolTips":{"@ToolTip1":"If PRINTLEVEL=0, then no ODS tables are produced or printed.","@ToolTip2":"If PRINTLEVEL=1, then the ODS (Output Delivery System) tables ProblemSummary, SolutionSummary,  and PerformanceInfo are produced and printed.","@ToolTip3":"If PRINTLEVEL=2, then these tables are produced and printed along with an additional table  called ProblemStatistics."}},{"StatementOptionName":"TIMETYPE=","StatementOptionHelp":{"#cdata":"Syntax: TIMETYPE=number | string \n          \nSpecifies whether CPU time or real time is used for the MAXTIME= option and the _OROPTLP_\nmacro variable in a PROC OPTLP call."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"CPU","@Value2":"REAL"},"StatementOptionToolTips":{"@ToolTip1":"Specifies units of CPU time.","@ToolTip2":"Specifies units of real time."}},{"StatementOptionName":"PRICETYPE=","StatementOptionHelp":{"#cdata":"Syntax: PRICETYPE=number | string \n          \nSpecifies a pricing strategy for the primal and dual simplex solvers. \n\nThe default pricing strategy for the primal simplex solver is HYBRID (0) and for the dual simplex\nsolver is STEEPESTEDGE (4). For the network simplex solver, this option applies only to the solver\nspecified by the ALGORITHM2= option."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"HYBRID","@Value2":"PARTIAL","@Value3":"FULL","@Value4":"DEVEX","@Value5":"STEEPESTEDGE"},"StatementOptionToolTips":{"@ToolTip1":"Use a hybrid of Devex and steepest-edge pricing strategies. Available for the primal simplex solver only.","@ToolTip2":"Use Dantzig\u2019s rule on a queue of decision variables. Optionally, you can specify QUEUESIZE=. Available for the primal simplex solver only.","@ToolTip3":"Use Dantzig\u2019s rule on all decision variables.","@ToolTip4":"Use Devex pricing strategy.","@ToolTip5":"Use steepest-edge pricing strategy."}},{"StatementOptionName":"QUEUESIZE=","StatementOptionHelp":{"#cdata":"Syntax: QUEUESIZE=k \n          \nSpecifies the queue size k \u0404 [\u008c1, n]\u008d, where n is the number of decision variables. This queue is used for\nfinding an entering variable in the simplex iteration. The default value is chosen adaptively based on\nthe number of decision variables. This option is used only when PRICETYPE=PARTIAL."},"StatementOptionType":"V"},{"StatementOptionName":"SCALE=","StatementOptionHelp":{"#cdata":"Syntax: SCALE=number | string \n          \nSpecifies one of the following scaling options: NONE(0), AUTOMATIC(-1). \n\nThe default option is AUTOMATIC (\u20131)."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"AUTOMATIC"},"StatementOptionToolTips":{"@ToolTip1":"Disable scaling.","@ToolTip2":"Automatically apply scaling procedure if necessary."}},{"StatementOptionName":"CROSSOVER=","StatementOptionHelp":{"#cdata":"Syntax: CROSSOVER=number | string \n          \nSpecifies whether to convert the interior point solution to a basic simplex solution. If the interior point\nalgorithm terminates with a solution, the crossover algorithm uses the interior point solution to create\nan initial basic solution. After performing primal fixing and dual fixing, the crossover algorithm calls a\nsimplex algorithm to locate an optimal basic solution."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"OFF","@Value2":"ON"},"StatementOptionToolTips":{"@ToolTip1":"Do not convert the interior point solution to a basic simplex solution.","@ToolTip2":"Convert the interior point solution to a basic simplex solution."}},{"StatementOptionName":"STOP_DG=","StatementOptionHelp":{"#cdata":"Syntax: STOP_DG=\u03b4 \n          \nSpecifies the desired relative duality gap \u03b4 \u0404[1E\u20139, 1E\u20134]. This is the relative difference between the\nprimal and dual objective function values and is the primary solution quality parameter. The default\nvalue is 1E\u20136."},"StatementOptionType":"V"},{"StatementOptionName":"STOP_DI=","StatementOptionHelp":{"#cdata":"Syntax: STOP_DI= \u03b2\n          \nSpecifies the maximum allowed relative dual constraints violation \u03b2 \u0404[1E\u20139, 1E\u20134]. The default value\nis 1E\u20136."},"StatementOptionType":"V"},{"StatementOptionName":"STOP_PI=","StatementOptionHelp":{"#cdata":"Syntax: STOP_PI= \u03b1\n          \nSpecifies the maximum allowed relative bound and primal constraints violation \u03b1 \u0404[1E\u20139, 1E\u20134]. The\ndefault value is 1E\u20136."},"StatementOptionType":"V"}]}},{"StatementName":"DECOMPMASTERIP|DECOMPOSITIONMASTERIP|MASTERIP","StatementHelp":{"#cdata":"Syntax: DECOMPMASTERIP|DECOMPOSITIONMASTERIP|MASTERIP < options > ; \n      \nFor mixed integer linear programming problems, the DECOMPMASTERIP|DECOMPOSITIONMASTERIP|MASTERIP statement \ncontrols the (restricted) master problem, which is solved as a MILP with the current set of columns in an \neffort to obtain an integer-feasible solution."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"PRESOLVER=","StatementOptionHelp":{"#cdata":"Syntax: PRESOLVER=number | string\n\nSpecifies a presolve string or its corresponding value number. \n\n\u20131  AUTOMATIC -- Applies the default level of presolve processing\n0   NONE -- Disables presolver\n1   BASIC -- Performs minimal presolve processing\n2   MODERATE -- Applies a higher level of presolve processing\n3   AGGRESSIVE -- Applies the highest level of presolve processing \n\nThe default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC|-1","@Value2":"NONE|0","@Value3":"BASIC|1","@Value4":"MODERATE|2","@Value5":"AGGRESSIVE|3"},"StatementOptionToolTips":{"@ToolTip1":"Applies the default level of presolve processing.","@ToolTip2":"Disables presolver.","@ToolTip3":"Performs minimal presolve processing.","@ToolTip4":"Applies a higher level of presolve processing.","@ToolTip5":"Applies the highest level of presolve processing."}},{"StatementOptionName":"ABSOBJGAP=","StatementOptionHelp":{"#cdata":"Syntax: ABSOBJGAP=number \n          \nSpecifies a stopping criterion. When the absolute difference between the best integer objective and the\nobjective of the best remaining node becomes smaller than the value of number, the procedure stops.\nThe value of number can be any nonnegative number; the default value is 1E\u20136."},"StatementOptionType":"V"},{"StatementOptionName":"CUTOFF=","StatementOptionHelp":{"#cdata":"Syntax: CUTOFF=number \n          \nCuts off any nodes in a minimization (maximization) problem with an objective value above (below)\nnumber. The value of number can be any number; the default value is the positive (negative) number\nthat has the largest absolute value that can be represented in your operating environment."},"StatementOptionType":"V"},{"StatementOptionName":"EMPHASIS=","StatementOptionHelp":{"#cdata":"Syntax: BALANCE | OPTIMAL | FEASIBLE\n          \nspecifies the type of search emphasis.\n\nBy default, EMPHASIS=BALANCE."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"BALANCE","@Value2":"OPTIMAL","@Value3":"FEASIBLE"},"StatementOptionToolTips":{"@ToolTip1":"Performs a balanced search","@ToolTip2":"Emphasizes optimality over feasibility","@ToolTip3":"Emphasizes feasibility over optimality"}},{"StatementOptionName":"FEASTOL=","StatementOptionHelp":{"#cdata":"Syntax: FEASTOL=number \n          \nspecifies the tolerance used to check the feasibility of a solution. This tolerance applies both to the\nmaximum violation of bounds on variables and to the difference between the right-hand sides and\nleft-hand sides of constraints. The value of number can be any value between (and including) 1E\u20134\nand 1E\u20139. The default value is 1E\u20136."},"StatementOptionType":"V"},{"StatementOptionName":"INTTOL=|INTEGERTOLERANCE=","StatementOptionHelp":{"#cdata":"Syntax: INTTOL=number | INTEGERTOLERANCE=number\n          \nSpecifies the amount by which an integer variable value can differ from an integer and still be considered\ninteger feasible. The value of number can be any number between 0.0 and 1.0; the default value is\n1E\u20135. PROC OPTMILP attempts to find an optimal solution with integer infeasibility less than number.\nIf you assign a value smaller than 1E\u201310 to number and the best solution found by PROC OPTMILP\nhas integer infeasibility between number and 1E\u201310, then PROC OPTMILP ends with a solution status\nof OPTIMAL_COND."},"StatementOptionType":"V"},{"StatementOptionName":"LOGFREQ=|PRINTFREQ=","StatementOptionHelp":{"#cdata":"Syntax: LOGFREQ=number | PRINTFREQ=number \n          \nSpecifies how often information is printed in the node log. The value of number can be any nonnegative\ninteger up to the largest four-byte signed integer, which is 2\u00b3\u00b9 - 1. The default value is 100. If number\nis set to 0, then the node log is disabled. If number is positive, then an entry is made in the node log at\nthe first node, at the last node, and at intervals dictated by the value of number. An entry is also made\neach time a better integer solution is found."},"StatementOptionType":"V"},{"StatementOptionName":"LOGLEVEL=|PRINTLEVEL2=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE \nSyntax: PRINTLEVEL2=NONE | BASIC | MODERATE | AGGRESSIVE\n          \nControls the amount of information displayed in the SAS log by the solver, from a short description of\npresolve information and summary to details at each node. \n\nThe default value is MODERATE."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"BASIC","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all solver-related messages in the SAS log.","@ToolTip2":"Displays a solver summary after stopping.","@ToolTip3":"Prints a solver summary and a node log by using the interval dictated by the LOGFREQ= option.","@ToolTip4":"Prints a detailed solver summary and a node log by using the interval dictated by the LOGFREQ= option."}},{"StatementOptionName":"MAXNODES=","StatementOptionHelp":{"#cdata":"Syntax: MAXNODES=number \n          \nSpecifies the maximum number of branch-and-bound nodes to be processed. The value of number can\nbe any nonnegative integer up to the largest four-byte signed integer, which is 2\u00b3\u00b9 - 1. The default\nvalue is 2\u00b3\u00b9 - 1."},"StatementOptionType":"V"},{"StatementOptionName":"MAXSOLS=","StatementOptionHelp":{"#cdata":"Syntax: MAXSOLS=number \n          \nSpecifies a stopping criterion. If number solutions have been found, then the procedure stops. The\nvalue of number can be any positive integer up to the largest four-byte signed integer, which is 2\u00b3\u00b9 - 1.\nThe default value is 2\u00b3\u00b9 - 1."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=t \n          \nSpecifies an upper limit of t seconds of time for reading in the data and performing the optimization\nprocess. The value of the TIMETYPE= option determines the type of units used. If you do not specify\nthis option, the procedure does not stop based on the amount of time elapsed. The value of t can be\nany positive number; the default value is the positive number that has the largest absolute value that\ncan be represented in your operating environment."},"StatementOptionType":"V"},{"StatementOptionName":"OPTTOL=","StatementOptionHelp":{"#cdata":"Syntax: OPTTOL=number \n          \nSpecifies the tolerance used to determine the optimality of nodes in the branch-and-bound tree. The\nvalue of number can be any value between (and including) 1E\u20134 and 1E\u20139. The default is 1E\u20136."},"StatementOptionType":"V"},{"StatementOptionName":"PRINTLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: PRINTLEVEL=0 | 1 | 2 \n          \nSpecifies whether a summary of the problem and solution should be printed. If PRINTLEVEL=1, then\nthe ODS (Output Delivery System) tables ProblemSummary, SolutionSummary, and PerformanceInfo\nare produced and printed. If PRINTLEVEL=2, then these tables are produced and printed along with\nan additional table called ProblemStatistics. If PRINTLEVEL=0, then no ODS tables are produced or\nprinted. The default value is 1."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"0","@Value2":"1","@Value3":"2"},"StatementOptionToolTips":{"@ToolTip1":"Does not produce or print any Output Delivery System (ODS) tables.","@ToolTip2":"Produces and prints the following ODS tables: ProblemSummary and SolutionSummary.","@ToolTip3":"Produces and prints the following ODS tables: ProblemSummary, SolutionSummary, ProblemStatistics,  and Timing table."}},{"StatementOptionName":"PROBE=","StatementOptionHelp":{"#cdata":"Syntax: AUTOMATIC | NONE | MODERATE | AGGRESSIVE\n          \nSpecifies the probing strategy.\n\nBy default, PROBE=AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Uses the probing strategy determined by PROC OPTMILP","@ToolTip2":"Disables probing","@ToolTip3":"Uses the probing moderately","@ToolTip4":"Uses the probing aggressively"}},{"StatementOptionName":"RELOBJGAP=","StatementOptionHelp":{"#cdata":"Syntax: RELOBJGAP=number \n          \nSpecifies a stopping criterion based on the best integer objective (BestInteger) and the objective of the\nbest remaining node (BestBound). The relative objective gap is equal to \n\n  | BestInteger - BestBound | / (1E-10 + | BestBound |)\n\nWhen this value becomes smaller than the specified gap size number, the procedure stops. The value\nof number can be any nonnegative number; the default value is 1E\u20134."},"StatementOptionType":"V"},{"StatementOptionName":"SCALE=","StatementOptionHelp":{"#cdata":"Syntax: SCALE=number | string \n          \nIndicates whether to scale the problem matrix. SCALE= can take either of the values AUTOMATIC\n(\u20131) and NONE (0). SCALE=AUTOMATIC scales the matrix as determined by PROC OPTMILP;\nSCALE=NONE disables scaling. The default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"AUTOMATIC"},"StatementOptionToolTips":{"@ToolTip1":"Disables scaling","@ToolTip2":"Scales the matrix as determined by PROC OPTMILP"}},{"StatementOptionName":"TARGET=","StatementOptionHelp":{"#cdata":"Syntax: TARGET=number \n          \nSpecifies a stopping criterion for minimization (maximization) problems. If the best integer objective\nis better than or equal to number, the procedure stops. The value of number can be any number; the\ndefault value is the negative (positive) number that has the largest absolute value representable in your\noperating environment."},"StatementOptionType":"V"},{"StatementOptionName":"TIMETYPE=","StatementOptionHelp":{"#cdata":"Syntax: TIMETYPE=number | string \n          \nSpecifies whether CPU time or real time is used for the MAXTIME= option and the _OROPTMILP_\nmacro variable in a PROC OPTMILP call. \n\nThe default value of the TIMETYPE= option depends on the values of the NTHREADS= and NODES=\noptions in the PERFORMANCE statement."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"CPU","@Value2":"REAL"},"StatementOptionToolTips":{"@ToolTip1":"Specifies units of CPU time.","@ToolTip2":"Specifies units of real time."}},{"StatementOptionName":"HEURISTICS=","StatementOptionHelp":{"#cdata":"Syntax: HEURISTICS=number | string \n          \nControls the level of primal heuristics applied by PROC OPTMILP. This level determines how frequently\nprimal heuristics are applied during the branch-and-bound tree search. It also affects the maximum\nnumber of iterations allowed in iterative heuristics. Some computationally expensive heuristics might\nbe disabled by the solver at less aggressive levels. \n\nSetting HEURISTICS=NONE does not disable the heuristics that repair an infeasible input solution that is\nspecified in a PRIMALIN= data set.\n\nThe default value of the HEURISTICS= option is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"BASIC","@Value4":"MODERATE","@Value5":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Apply default level of heuristics, similar to MODERATE.","@ToolTip2":"Disable all primal heuristics.","@ToolTip3":"Apply basic primal heuristics at low frequency.","@ToolTip4":"Apply most primal heuristics at moderate frequency.","@ToolTip5":"Apply all primal heuristics at high frequency."}},{"StatementOptionName":"CONFLICTSEARCH=","StatementOptionHelp":{"#cdata":"Specifies the level of conflict search performed by PROC OPTMILP. Conflict search is used to find\nclauses resulting from infeasible subproblems that arise in the search tree. \n\nThe default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Performs conflict search based on a strategy determined by PROC OPTMILP","@ToolTip2":"Disables conflict search","@ToolTip3":"Performs a moderate conflict search","@ToolTip4":"Performs an aggressive conflict search"}},{"StatementOptionName":"NODESEL=","StatementOptionHelp":{"#cdata":"Syntax: NODESEL=number | string \n          \nSpecifies the node selection strategy string or its corresponding value number:\n\n\u20131 AUTOMATIC -- Uses automatic node selection\n0 BESTBOUND -- Chooses the node with the best relaxed objective (best-bound-first strategy)\n1 BESTESTIMATE -- Chooses the node with the best estimate of the integer objective value (best-estimate-first strategy)\n2 DEPTH -- Chooses the most recently created node (depthfirst strategy)\n\nThe default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"BESTBOUND","@Value3":"BESTESTIMATE","@Value4":"DEPTH"},"StatementOptionToolTips":{"@ToolTip1":"Use automatic node selection.","@ToolTip2":"Choose the node with the best relaxed objective (best-bound-first strategy).","@ToolTip3":"Choose the node with the best estimate of the integer objective value (best-estimate-first strategy).","@ToolTip4":"Choose the most recently created node (depth-first strategy)."}},{"StatementOptionName":"PRIORITY=","StatementOptionHelp":{"#cdata":"Indicates whether to use specified branching priorities for integer variables. PRIORITY=0 ignores\nvariable priorities; PRIORITY=1 uses priorities when they exist. The default value is 1."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"0","@Value2":"1"},"StatementOptionToolTips":{"@ToolTip1":"Ignores variable priorities.","@ToolTip2":"Uses priorities when they exist. This is the default."}},{"StatementOptionName":"STRONGITER=","StatementOptionHelp":{"#cdata":"Syntax: STRONGITER=number | AUTOMATIC \n          \nSpecifies the number of simplex iterations performed for each variable in the candidate list when using\nthe strong branching variable selection strategy. The value of number can be any positive integer up to\nthe largest four-byte signed integer, which is 2\u00b3\u00b9 - 1. If you specify the keyword AUTOMATIC or the\nvalue \u20131, PROC OPTMILP uses the default value; this value is calculated automatically."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"<number>","@Value2":"AUTOMATIC"},"StatementOptionToolTips":{"@ToolTip1":"Replace <number> with any positive integer up to the largest four-byte signed integer, which is 2\u00b3\u00b9 - 1.","@ToolTip2":"Tells PROC OPTMILP to use the default value; this value is calculated automatically."}},{"StatementOptionName":"STRONGLEN=","StatementOptionHelp":{"#cdata":"Syntax: STRONGLEN=number | AUTOMATIC \n          \nSpecifies the number of candidates used when performing the strong branching variable selection\nstrategy. The value of number can be any positive integer up to the largest four-byte signed integer,\nwhich is 2\u00b3\u00b9 - 1. If you specify the keyword AUTOMATIC or the value \u20131, PROC OPTMILP uses\nthe default value; this value is calculated automatically."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"<number>","@Value2":"AUTOMATIC"},"StatementOptionToolTips":{"@ToolTip1":"Replace <number> with any positive integer up to the largest four-byte signed integer, which is 2\u00b3\u00b9 - 1.","@ToolTip2":"Tells PROC OPTMILP to use the default value; this value is calculated automatically."}},{"StatementOptionName":"VARSEL=","StatementOptionHelp":{"#cdata":"Specifies the rule for selecting the branching variable. \n          \nThe default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"MAXINFEAS","@Value3":"MININFEAS","@Value4":"PSEUDO","@Value5":"STRONG"},"StatementOptionToolTips":{"@ToolTip1":"Use automatic branching variable selection.","@ToolTip2":"Choose the variable with maximum infeasibility.","@ToolTip3":"Choose the variable with minimum infeasibility.","@ToolTip4":"Choose a branching variable based on pseudocost.","@ToolTip5":"Use strong branching variable selection strategy."}},{"StatementOptionName":"ALLCUTS=","StatementOptionHelp":{"#cdata":"Provides a shorthand way of setting all the cuts-related options in one setting. In other words, \nALLCUTS=num is equivalent to setting each of the individual cuts parameters to the same value num."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTCLIQUE=","StatementOptionHelp":{"#cdata":"Specifies the level of clique cuts generated by PROC OPTMILP. \n      \nThe CUTCLIQUE= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTFLOWCOVER=","StatementOptionHelp":{"#cdata":"Specifies the level of flow cover cuts generated by PROC OPTMILP. \n      \nThe CUTFLOWCOVER= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTFLOWPATH=","StatementOptionHelp":{"#cdata":"Specifies the level of flow path cuts generated by PROC OPTMILP. \n      \nThe CUTFLOWPATH= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTGOMORY=","StatementOptionHelp":{"#cdata":"Specifies the level of Gomory cuts generated by PROC OPTMILP. \n      \nThe CUTGOMORY= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTGUB=","StatementOptionHelp":{"#cdata":"Specifies the level of generalized upper bound (GUB) cover cuts generated by PROC OPTMILP. \n      \nThe CUTGUB= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTIMPLIED=","StatementOptionHelp":{"#cdata":"Specifies the level of implied bound cuts generated by PROC OPTMILP. \n      \nThe CUTIMPLIED= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTKNAPSACK=","StatementOptionHelp":{"#cdata":"Specifies the level of knapsack cover cuts generated by PROC OPTMILP. \n      \nThe CUTKNAPSACK= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTLAP=","StatementOptionHelp":{"#cdata":"Specifies the level of lift-and-project (LAP) cuts generated by PROC OPTMILP."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTMILIFTED=","StatementOptionHelp":{"#cdata":"Specifies the level of mixed lifted 0-1 cuts that are generated by PROC OPTMILP. \\\n      \nThe CUTMILIFTED= option overrides the ALLCUTS=option. The default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTMIR=","StatementOptionHelp":{"#cdata":"Specifies the level of mixed integer rounding (MIR) cuts generated by PROC OPTMILP. \n      \nThe CUTMIR= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTSFACTOR=","StatementOptionHelp":{"#cdata":"[Syntax: CUTSFACTOR=m] \n      \nSpecifies a row multiplier factor for cuts. The number of cuts added is limited to num times the \noriginal number of rows. The value of num can be any nonnegative number less than or equal to 100; \nthe default value is 3.0."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTSTRATEGY=|CUTS=","StatementOptionHelp":{"#cdata":"[Syntax: CUTSTRATEGY=number | string ] \n      \nSpecifies the overall aggressiveness of the cut generation in the solver. Setting a nondefault value\nadjusts a number of cut parameters such that the cut generation is basic, moderate, or aggressive\ncompared to the default value."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTZEROHALF=","StatementOptionHelp":{"#cdata":"[Syntax: CUTZEROHALF=number | string] \n      \nSpecifies the level of zero-half cuts that are generated by PROC OPTMILP. \n\nThe CUTZEROHALF= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}}]}},{"StatementName":"DECOMPSUBPROB|DECOMPOSITIONSUBPROB|SUBPROB","StatementHelp":{"#cdata":"Syntax: DECOMPSUBPROB|DECOMPOSITIONSUBPROB|SUBPROB < options > ;\n\nThe DECOMPSUBPROB|DECOMPOSITIONSUBPROB|SUBPROB statement controls the subproblem. \n\nThe default is AUTOMATIC."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ALGORITHM=|SOLVER=|SOL=","StatementOptionHelp":{"#cdata":"Syntax: ALGORITHM=option | SOLVER=option | SOL=option \n\n[Used with LP and MILP Algorithms]\n\nSpecifies an LP solver."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"PRIMAL","@Value2":"DUAL","@Value3":"NETWORK","@Value4":"INTERIORPOINT","@Value5":"CONCURRENT"},"StatementOptionToolTips":{"@ToolTip1":"Uses primal simplex solver.","@ToolTip2":"Uses dual simplex solver.","@ToolTip3":"Uses network simplex solver.","@ToolTip4":"Uses interior point solver.","@ToolTip5":"Uses several different algorithms in parallel."}},{"StatementOptionName":"INITPRESOLVER=|INITPRESOL=","StatementOptionHelp":{"#cdata":"Syntax: INITPRESOLVER=number | string\nINITPRESOL=number | string\n\n[Used with LP and MILP Algorithms]\n\nSpecifies, for the first master solve only, presolve conditions."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC|-1","@Value2":"NONE|0","@Value3":"BASIC|1","@Value4":"MODERATE|2","@Value5":"AGGRESSIVE|3"},"StatementOptionToolTips":{"@ToolTip1":"Applies the default level of presolve processing.","@ToolTip2":"Disables presolver.","@ToolTip3":"Performs minimal presolve processing.","@ToolTip4":"Applies a higher level of presolve processing.","@ToolTip5":"Applies the highest level of presolve processing."}},{"StatementOptionName":"FEASTOL=","StatementOptionHelp":{"#cdata":"Syntax: FEASTOL=\u03f5 \n \n[Used with LP and MILP Algorithms]\n \nSpecifies the feasibility tolerance \u03f5 \u0404 [1E\u20139, 1E\u20134] for determining the feasibility of a variable value.\nThe default value is 1E\u20136."},"StatementOptionType":"V"},{"StatementOptionName":"LOGLEVEL=|PRINTLEVEL2=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE\nSyntax: PRINTLEVEL2=NONE | BASIC | MODERATE | AGGRESSIVE\n\nControls the amount of information displayed in the SAS log by the solver, from a short description of\npresolve information and summary to details at each node. \n\nThe default value is MODERATE."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"BASIC","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all solver-related messages in the SAS log.","@ToolTip2":"Displays a solver summary after stopping.","@ToolTip3":"Prints a solver summary and a node log by using the interval dictated by the LOGFREQ= option.","@ToolTip4":"Prints a detailed solver summary and a node log by using the interval dictated by the LOGFREQ= option."}},{"StatementOptionName":"MAXITER=","StatementOptionHelp":{"#cdata":"Syntax: MAXITER=k \n\n[Used with LP Algorithm]\n\nSpecifies the maximum number of iterations. The value k can be any integer between one and the\nlargest four-byte signed integer, which is 2\u00b3\u00b9 - 1. If you do not specify this option, the procedure\ndoes not stop based on the number of iterations performed. For network simplex, this iteration limit\ncorresponds to the solver called after network simplex (either primal or dual simplex)."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=t \n \n[Used with LP and MILP Algorithms]\n\nSpecifies an upper limit of t seconds of time for reading in the data and performing the optimization\nprocess. The value of the TIMETYPE= option determines the type of units used. If you do not specify\nthis option, the procedure does not stop based on the amount of time elapsed. The value of t can be\nany positive number; the default value is the positive number that has the largest absolute value that\ncan be represented in your operating environment."},"StatementOptionType":"V"},{"StatementOptionName":"OPTTOL=","StatementOptionHelp":{"#cdata":"Syntax: OPTTOL=\u03f5 \n\n[Used with LP and MILP Algorithms]\n\nSpecifies the optimality tolerance \u03f5 \u0404[1E\u20139, 1E\u20134] for declaring optimality. The default value is 1E\u20136."},"StatementOptionType":"V"},{"StatementOptionName":"PRINTLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: PRINTLEVEL=0 | 1 | 2\n \nSpecifies whether a summary of the problem and solution should be printed. If PRINTLEVEL=1, then\nthe ODS (Output Delivery System) tables ProblemSummary, SolutionSummary, and PerformanceInfo\nare produced and printed. If PRINTLEVEL=2, then these tables are produced and printed along with\nan additional table called ProblemStatistics. If PRINTLEVEL=0, then no ODS tables are produced or\nprinted. The default value is 1."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"0","@Value2":"1","@Value3":"2"},"StatementOptionToolTips":{"@ToolTip1":"If PRINTLEVEL=0, then no ODS tables are produced or printed.","@ToolTip2":"If PRINTLEVEL=1, then the ODS (Output Delivery System) tables ProblemSummary, SolutionSummary,  and PerformanceInfo are produced and printed.","@ToolTip3":"If PRINTLEVEL=2, then these tables are produced and printed along with an additional table  called ProblemStatistics."}},{"StatementOptionName":"TIMETYPE=","StatementOptionHelp":{"#cdata":"Syntax: TIMETYPE=number | string \n          \n[Used with LP and MILP Algorithms]\n\nSpecifies whether CPU time or real time is used for the MAXTIME= option and the _OROPTLP_\nmacro variable in a PROC OPTLP call or _OROPTMILP_ macro variable in a PROC OPTMILP call."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"CPU","@Value2":"REAL"},"StatementOptionToolTips":{"@ToolTip1":"Specifies units of CPU time.","@ToolTip2":"Specifies units of real time."}},{"StatementOptionName":"BASIS=","StatementOptionHelp":{"#cdata":"Syntax: BASIS=number | string \n          \n[Used with LP Algorithm]\n          \nSpecifies the following options for generating an initial basis:\n\n0 CRASH -- Generate an initial basis by using crash techniques (Maros 2003). The procedure creates \n  a triangular basic matrix consisting of both decision variables and slack variables.\n1 SLACK -- Generate an initial basis by using all slack variables.\n2 WARMSTART -- Start the primal and dual simplex solvers with a userspecified initial basis. The \n  PRIMALIN= and DUALIN= data sets are required to specify an initial basis.\n\nThe default option for the primal simplex solver is CRASH (0). The default option for the dual simplex\nsolver is SLACK(1). For network simplex, this option has no effect."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"CRASH","@Value2":"SLACK","@Value3":"WARMSTART"},"StatementOptionToolTips":{"@ToolTip1":"Generate an initial basis by using crash techniques (Maros 2003). The procedure creates  a triangular basic matrix consisting of both decision variables and slack variables.","@ToolTip2":"Generate an initial basis by using all slack variables.","@ToolTip3":"Start the primal and dual simplex solvers with a userspecified initial basis. The  PRIMALIN= and DUALIN= data sets are required to specify an initial basis."}},{"StatementOptionName":"PRICETYPE=","StatementOptionHelp":{"#cdata":"Syntax: PRICETYPE=number | string \n\n[Used with LP Algorithm]\n\nSpecifies a pricing strategy for the primal and dual simplex solvers. \n\nThe default pricing strategy for the primal simplex solver is HYBRID (0) and for the dual simplex\nsolver is STEEPESTEDGE (4). For the network simplex solver, this option applies only to the solver\nspecified by the ALGORITHM2= option."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"HYBRID","@Value2":"PARTIAL","@Value3":"FULL","@Value4":"DEVEX","@Value5":"STEEPESTEDGE"},"StatementOptionToolTips":{"@ToolTip1":"Use a hybrid of Devex and steepest-edge pricing strategies. Available for the primal simplex solver only.","@ToolTip2":"Use Dantzig\u2019s rule on a queue of decision variables. Optionally, you can specify QUEUESIZE=. Available for the primal simplex solver only.","@ToolTip3":"Use Dantzig\u2019s rule on all decision variables.","@ToolTip4":"Use Devex pricing strategy.","@ToolTip5":"Use steepest-edge pricing strategy."}},{"StatementOptionName":"QUEUESIZE=","StatementOptionHelp":{"#cdata":"Syntax: QUEUESIZE=k \n\n[Used with LP Algorithm]\n\nSpecifies the queue size k \u0404 [\u008c1, n]\u008d, where n is the number of decision variables. This queue is used for\nfinding an entering variable in the simplex iteration. The default value is chosen adaptively based on\nthe number of decision variables. This option is used only when PRICETYPE=PARTIAL."},"StatementOptionType":"V"},{"StatementOptionName":"SCALE=","StatementOptionHelp":{"#cdata":"Syntax: SCALE=number | string \n\n[Used with LP and MILP Algorithms]\n\nSpecifies one of the following scaling options: NONE(0), AUTOMATIC(-1). \n\nThe default option is AUTOMATIC (\u20131)."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"AUTOMATIC"},"StatementOptionToolTips":{"@ToolTip1":"Disable scaling.","@ToolTip2":"Automatically apply scaling procedure if necessary."}},{"StatementOptionName":"CROSSOVER=","StatementOptionHelp":{"#cdata":"Syntax: CROSSOVER=number | string \n          \n[Used with LP Algorithm]\n\nSpecifies whether to convert the interior point solution to a basic simplex solution. If the interior point\nalgorithm terminates with a solution, the crossover algorithm uses the interior point solution to create\nan initial basic solution. After performing primal fixing and dual fixing, the crossover algorithm calls a\nsimplex algorithm to locate an optimal basic solution."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"OFF","@Value2":"ON"},"StatementOptionToolTips":{"@ToolTip1":"Do not convert the interior point solution to a basic simplex solution.","@ToolTip2":"Convert the interior point solution to a basic simplex solution."}},{"StatementOptionName":"STOP_DG=","StatementOptionHelp":{"#cdata":"Syntax: STOP_DG=\u03b4 \n\n[Used with LP Algorithm]\n\nSpecifies the desired relative duality gap \u03b4 \u0404[1E\u20139, 1E\u20134]. This is the relative difference between the\nprimal and dual objective function values and is the primary solution quality parameter. The default\nvalue is 1E\u20136."},"StatementOptionType":"V"},{"StatementOptionName":"STOP_DI=","StatementOptionHelp":{"#cdata":"Syntax: STOP_DI= \u03b2\n          \n[Used with LP Algorithm]\n\nSpecifies the maximum allowed relative dual constraints violation \u03b2 \u0404[1E\u20139, 1E\u20134]. The default value\nis 1E\u20136."},"StatementOptionType":"V"},{"StatementOptionName":"STOP_PI=","StatementOptionHelp":{"#cdata":"Syntax: STOP_PI= \u03b1\n\n[Used with LP Algorithm]\n\nSpecifies the maximum allowed relative bound and primal constraints violation \u03b1 \u0404[1E\u20139, 1E\u20134]. The\ndefault value is 1E\u20136."},"StatementOptionType":"V"},{"StatementOptionName":"ABSOBJGAP=","StatementOptionHelp":{"#cdata":"Syntax: ABSOBJGAP=number \n\n[Used with MILP Algorithm]\n\nSpecifies a stopping criterion for the continuous bound of the decomposition. When the absolute\ndifference between the master objective and the best dual bound falls below the value of number, the\ndecomposition algorithm stops adding columns. The value of number can be any nonnegative number.\nThe default value is the value of the OPTTOL= main solver option."},"StatementOptionType":"V"},{"StatementOptionName":"CUTOFF=","StatementOptionHelp":{"#cdata":"Syntax: CUTOFF=number \n          \n[Used with MILP Algorithm]\n\nCuts off any nodes in a minimization (maximization) problem with an objective value above (below)\nnumber. The value of number can be any number; the default value is the positive (negative) number\nthat has the largest absolute value that can be represented in your operating environment."},"StatementOptionType":"V"},{"StatementOptionName":"EMPHASIS=","StatementOptionHelp":{"#cdata":"Syntax: EMPHASIS=number | string \n\n[Used with MILP Algorithm]\n\nSpecifies a search emphasis string or its corresponding value number:\n\n0 BALANCE -- Performs a balanced search\n1 OPTIMAL -- Emphasizes optimality over feasibility\n2 FEASIBLE -- Emphasizes feasibility over optimality\n\nThe default value is BALANCE."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"BALANCE","@Value2":"OPTIMAL","@Value3":"FEASIBLE"},"StatementOptionToolTips":{"@ToolTip1":"Performs a balanced search","@ToolTip2":"Emphasizes optimality over feasibility","@ToolTip3":"Emphasizes feasibility over optimality"}},{"StatementOptionName":"INTTOL=","StatementOptionHelp":{"#cdata":"Syntax: INTTOL=number \n          \n[Used with MILP Algorithm]\n\nSpecifies the amount by which an integer variable value can differ from an integer and still be considered\ninteger feasible. The value of number can be any number between 0.0 and 1.0; the default value is\n1E\u20135. PROC OPTMILP attempts to find an optimal solution with integer infeasibility less than number.\nIf you assign a value smaller than 1E\u201310 to number and the best solution found by PROC OPTMILP\nhas integer infeasibility between number and 1E\u201310, then PROC OPTMILP ends with a solution status\nof OPTIMAL_COND."},"StatementOptionType":"V"},{"StatementOptionName":"MAXNODES=","StatementOptionHelp":{"#cdata":"Syntax: MAXNODES=number \n          \n[Used with MILP Algorithm]\n\nSpecifies the maximum number of branch-and-bound nodes to be processed. The value of number can\nbe any nonnegative integer up to the largest four-byte signed integer, which is 2\u00b3\u00b9 - 1. The default\nvalue is 2\u00b3\u00b9 - 1."},"StatementOptionType":"V"},{"StatementOptionName":"MAXSOLS=","StatementOptionHelp":{"#cdata":"Syntax: MAXSOLS=number           \n\n[Used with MILP Algorithm]\n\nSpecifies a stopping criterion. If number solutions have been found, then the procedure stops. The\nvalue of number can be any positive integer up to the largest four-byte signed integer, which is 2\u00b3\u00b9 - 1.\nThe default value is 2\u00b3\u00b9 - 1."},"StatementOptionType":"V"},{"StatementOptionName":"PROBE=","StatementOptionHelp":{"#cdata":"Syntax: PROBE=number | string \n          \n[Used with MILP Algorithm]\n\nSpecifies a probing string or its corresponding value number:\n\n\u20131 AUTOMATIC -- Uses the probing strategy determined by PROC OPTMILP\n0 NONE -- Disables probing\n1 MODERATE -- Uses the probing moderately\n2 AGGRESSIVE -- Uses the probing aggressively \n\nThe default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC|-1","@Value2":"NONE|0","@Value3":"MODERATE|1","@Value4":"AGGRESSIVE|2"},"StatementOptionToolTips":{"@ToolTip1":"Uses the probing strategy determined by PROC OPTMILP","@ToolTip2":"Disables probing","@ToolTip3":"Uses the probing moderately","@ToolTip4":"Uses the probing aggressively"}},{"StatementOptionName":"RELOBJGAP=","StatementOptionHelp":{"#cdata":"Syntax: RELOBJGAP=number \n          \n[Used with MILP Algorithm]\n\nSpecifies a stopping criterion based on the best integer objective (BestInteger) and the objective of the\nbest remaining node (BestBound). The relative objective gap is equal to \n\n  | BestInteger - BestBound | / (1E-10 + | BestBound |)\n\nWhen this value becomes smaller than the specified gap size number, the procedure stops. The value\nof number can be any nonnegative number; the default value is 1E\u20134."},"StatementOptionType":"V"},{"StatementOptionName":"TARGET=","StatementOptionHelp":{"#cdata":"Syntax: TARGET=number \n          \n[Used with MILP Algorithm]\n\nSpecifies a stopping criterion for minimization (maximization) problems. If the best integer objective\nis better than or equal to number, the procedure stops. The value of number can be any number; the\ndefault value is the negative (positive) number that has the largest absolute value representable in your\noperating environment."},"StatementOptionType":"V"},{"StatementOptionName":"HEURISTICS=","StatementOptionHelp":{"#cdata":"Syntax: HEURISTICS=number | string \n          \n[Used with MILP Algorithm]\n\nControls the level of primal heuristics applied by PROC OPTMILP. This level determines how frequently\nprimal heuristics are applied during the branch-and-bound tree search. It also affects the maximum\nnumber of iterations allowed in iterative heuristics. Some computationally expensive heuristics might\nbe disabled by the solver at less aggressive levels. \n\nSetting HEURISTICS=NONE does not disable the heuristics that repair an infeasible input solution that is\nspecified in a PRIMALIN= data set.\n\nThe default value of the HEURISTICS= option is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"BASIC","@Value4":"MODERATE","@Value5":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Apply default level of heuristics, similar to MODERATE.","@ToolTip2":"Disable all primal heuristics.","@ToolTip3":"Apply basic primal heuristics at low frequency.","@ToolTip4":"Apply most primal heuristics at moderate frequency.","@ToolTip5":"Apply all primal heuristics at high frequency."}},{"StatementOptionName":"CONFLICTSEARCH=","StatementOptionHelp":{"#cdata":"[Used with MILP Algorithm]\n          \nSpecifies the level of conflict search performed by PROC OPTMILP. Conflict search is used to find\nclauses resulting from infeasible subproblems that arise in the search tree. \n\nThe default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Performs conflict search based on a strategy determined by PROC OPTMILP","@ToolTip2":"Disables conflict search","@ToolTip3":"Performs a moderate conflict search","@ToolTip4":"Performs an aggressive conflict search"}},{"StatementOptionName":"NODESEL=","StatementOptionHelp":{"#cdata":"Syntax: NODESEL=number | string \n\n[Used with MILP Algorithm]\n\nSpecifies the node selection strategy string or its corresponding value number:\n\n\u20131 AUTOMATIC -- Uses automatic node selection\n0 BESTBOUND -- Chooses the node with the best relaxed objective (best-bound-first strategy)\n1 BESTESTIMATE -- Chooses the node with the best estimate of the integer objective value (best-estimate-first strategy)\n2 DEPTH -- Chooses the most recently created node (depthfirst strategy)\n\nThe default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"BESTBOUND","@Value3":"BESTESTIMATE","@Value4":"DEPTH"},"StatementOptionToolTips":{"@ToolTip1":"Use automatic node selection.","@ToolTip2":"Choose the node with the best relaxed objective (best-bound-first strategy).","@ToolTip3":"Choose the node with the best estimate of the integer objective value (best-estimate-first strategy).","@ToolTip4":"Choose the most recently created node (depth-first strategy)."}},{"StatementOptionName":"PRIMALIN=|PIN=","StatementOptionHelp":{"#cdata":"Syntax: PRIMALIN=number | string\nPIN=number | string\n\n[Used with MILP Algorithm]\n\nSpecifies (for MILP problems only) whether the MILP solver is to use the values of the previous best\nsolution\u2019s variables as a starting solution (warm start). If the MILP solver finds that the input solution is\nfeasible, then the input solution provides an incumbent solution and a bound for the branch-and-bound\nalgorithm. If the solution is not feasible, the MILP solver tries to repair it. When it is difficult to\nfind a good integer-feasible solution for a problem, warm start can reduce solution time significantly."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"OFF","@Value2":"ON"},"StatementOptionToolTips":{"@ToolTip1":"Ignores the previous solution.","@ToolTip2":"Starts from the previous solution."}},{"StatementOptionName":"STRONGLEN=","StatementOptionHelp":{"#cdata":"Syntax: STRONGLEN=number | AUTOMATIC \n          \n[Used with MILP Algorithm]\n\nSpecifies the number of candidates used when performing the strong branching variable selection\nstrategy. The value of number can be any positive integer up to the largest four-byte signed integer,\nwhich is 2\u00b3\u00b9 - 1. If you specify the keyword AUTOMATIC or the value \u20131, PROC OPTMILP uses\nthe default value; this value is calculated automatically."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"<number>","@Value2":"AUTOMATIC"},"StatementOptionToolTips":{"@ToolTip1":"Replace <number> with any positive integer up to the largest four-byte signed integer, which is 2\u00b3\u00b9 - 1.","@ToolTip2":"Tells PROC OPTMILP to use the default value; this value is calculated automatically."}},{"StatementOptionName":"VARSEL=","StatementOptionHelp":{"#cdata":"Specifies the rule for selecting the branching variable. \n          \n[Used with MILP Algorithm]\n\nThe default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"MAXINFEAS","@Value3":"MININFEAS","@Value4":"PSEUDO","@Value5":"STRONG"},"StatementOptionToolTips":{"@ToolTip1":"Use automatic branching variable selection.","@ToolTip2":"Choose the variable with maximum infeasibility.","@ToolTip3":"Choose the variable with minimum infeasibility.","@ToolTip4":"Choose a branching variable based on pseudocost.","@ToolTip5":"Use strong branching variable selection strategy."}},{"StatementOptionName":"ALLCUTS=","StatementOptionHelp":{"#cdata":"[Used with MILP Algorithm]\n          \nProvides a shorthand way of setting all the cuts-related options in one setting. In other words, \nALLCUTS=num is equivalent to setting each of the individual cuts parameters to the same value num."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTCLIQUE=","StatementOptionHelp":{"#cdata":"[Used with MILP Algorithm] \n          \nSpecifies the level of clique cuts generated by PROC OPTMILP. \n      \nThe CUTCLIQUE= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTFLOWCOVER=","StatementOptionHelp":{"#cdata":"[Used with MILP Algorithm] \n          \nSpecifies the level of flow cover cuts generated by PROC OPTMILP. \n      \nThe CUTFLOWCOVER= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTFLOWPATH=","StatementOptionHelp":{"#cdata":"[Used with MILP Algorithm] \n          \nSpecifies the level of flow path cuts generated by PROC OPTMILP. \n      \nThe CUTFLOWPATH= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTGOMORY=","StatementOptionHelp":{"#cdata":"[Used with MILP Algorithm] \n          \nSpecifies the level of Gomory cuts generated by PROC OPTMILP. \n      \nThe CUTGOMORY= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTGUB=","StatementOptionHelp":{"#cdata":"[Used with MILP Algorithm] \n          \nSpecifies the level of generalized upper bound (GUB) cover cuts generated by PROC OPTMILP. \n      \nThe CUTGUB= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTIMPLIED=","StatementOptionHelp":{"#cdata":"[Used with MILP Algorithm] \n          \nSpecifies the level of implied bound cuts generated by PROC OPTMILP. \n      \nThe CUTIMPLIED= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTKNAPSACK=","StatementOptionHelp":{"#cdata":"[Used with MILP Algorithm] \n          \nSpecifies the level of knapsack cover cuts generated by PROC OPTMILP. \n      \nThe CUTKNAPSACK= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTLAP=","StatementOptionHelp":{"#cdata":" \n          \nSpecifies the level of lift-and-project (LAP) cuts generated by PROC OPTMILP."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTMILIFTED=","StatementOptionHelp":{"#cdata":"[Used with MILP Algorithm] \n          \nSpecifies the level of mixed lifted 0-1 cuts that are generated by PROC OPTMILP. \\\n      \nThe CUTMILIFTED= option overrides the ALLCUTS=option. The default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTMIR=","StatementOptionHelp":{"#cdata":"[Used with MILP Algorithm] \n          \nSpecifies the level of mixed integer rounding (MIR) cuts generated by PROC OPTMILP. \n      \nThe CUTMIR= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTSFACTOR=","StatementOptionHelp":{"#cdata":"[Used with MILP Algorithm] \n      \nSpecifies a row multiplier factor for cuts. The number of cuts added is limited to num times the \noriginal number of rows. The value of num can be any nonnegative number less than or equal to 100; \nthe default value is 3.0."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTSTRATEGY=|CUTS=","StatementOptionHelp":{"#cdata":"[Syntax: CUTSTRATEGY=number | string ] \n      \n[Used with MILP Algorithm]\n\nSpecifies the overall aggressiveness of the cut generation in the solver. Setting a nondefault value\nadjusts a number of cut parameters such that the cut generation is basic, moderate, or aggressive\ncompared to the default value."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTZEROHALF=","StatementOptionHelp":{"#cdata":"[Syntax: CUTZEROHALF=number | string] \n\n[Used with MILP Algorithm]      \n\nSpecifies the level of zero-half cuts that are generated by PROC OPTMILP. \n\nThe CUTZEROHALF= option overrides the ALLCUTS= option. The default value is AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by PROC OPTMILP.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}}],"#comment":{}}},{"StatementName":"TUNER","StatementHelp":{"#cdata":"Syntax: TUNER < tuner-options > ; \n      \nThe TUNER statement invokes the OPTMILP option tuner. The option tuner is a tool that enables you to\nexplore alternative (and potentially better) option configurations for your optimization problems."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"GOAL=","StatementOptionHelp":{"#cdata":"Syntax: GOAL=number | string \n          \nSpecifies a goal for the option tuner. \n\nEvery attempt to solve a tuning problem with an option configuration is counted toward the measure\nspecified by the GOAL= option. \n\nThe default is GEOMEAN. If only one problem is used for option tuning, then GOAL=GEOMEAN\nand GOAL=SUM are equivalent."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"GEOMEAN","@Value2":"SUM"},"StatementOptionToolTips":{"@ToolTip1":"Minimizes the geometric mean of the solution times of the tuning problems","@ToolTip2":"Minimizes the sum of the solution times of the tuning problems"}},{"StatementOptionName":"MAXCONFIGS=","StatementOptionHelp":{"#cdata":"Syntax: MAXCONFIGS=number \n          \nSpecifies the maximum number of option configurations that the tuner can evaluate in each problem\nin the PROBLEMS= data set. The value of number can be any nonnegative integer up to the largest\nfour-byte signed integer, which is 2\u00b3\u00b9 - 1. The default is 2\u00b3\u00b9 - 1."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=number \n          \nSpecifies the maximum time allowed for the tuner to evaluate option configurations in tuning problems.\nThe default is 36,000 seconds. \n\nIt is recommended that you specify a value of number large enough so that the tuner can run several\ndifferent option configurations. This value depends on two quantities: the number of tuning problems\nand the OPTMILP procedure\u2019s average run time for the tuning problems. To prevent the procedure\nfrom spending too much time running a single configuration in a single problem, it is recommended\nthat you limit the time the procedure spends solving each combination of problem and configuration.\nYou can do this by specifying the MAXTIME= option in the PROC OPTMILP statement. If you prefer\nnot to stop the option tuner based on elapsed time, you can specify the MAXCONFIGS= option."},"StatementOptionType":"V"},{"StatementOptionName":"OPTIONMODE=","StatementOptionHelp":{"#cdata":"Syntax: OPTIONMODE=number | string \n          \nSpecifies which set of options to tune."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"USER","@Value4":"FULL"},"StatementOptionToolTips":{"@ToolTip1":"Uses an option set determined by the tuner","@ToolTip2":"Solves the problems specified by the PROBLEMS= option without tuning any OPTMILP options","@ToolTip3":"Uses the option set specified by the OPTIONVALUES= option","@ToolTip4":" Uses the full set of solver options that are available for tuning"}},{"StatementOptionName":"OPTIONVALUES=|OPTVALS=","StatementOptionHelp":{"#cdata":"Syntax: OPTIONVALUES=SAS-data-set | OPTVALS=SAS-data-set \n          \nSpecifies an input data set that contains a list of options to be tuned and ranges of values over which\neach option should be tuned. You can specify an initial tuning value for each option in the list. If you\ndo not specify a range for a tuning option, the tuner uses the default range of that option. If you do\nnot specify an initial value for a tuning option, the tuner uses the default value of that option. If the\noption\u2019s default value is not in the specified tuning range, the tuner uses the first (smallest) value in the\ntuning range. If the data set that is specified by the OPTIONVALUES= option is not found, a default\nset of options is used."},"StatementOptionType":"V"},{"StatementOptionName":"LOGFREQ=","StatementOptionHelp":{"#cdata":"Syntax: LOGFREQ=number \n          \nSpecifies how often tuning information is printed in the log. The value of number represents the number\nof problems solved by the tuner between log updates. The value of number can be any nonnegative\ninteger. Specifying LOGFREQ=0 disables log updates. The default is 1."},"StatementOptionType":"V"},{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=number | string \n          \nControls the amount of information that the tuner displays in the SAS log. \n\nThe default is MODERATE."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"BASIC","@Value3":"MODERATE"},"StatementOptionToolTips":{"@ToolTip1":"Disables tuner-related messages in the SAS log","@ToolTip2":"Displays a tuner summary after stopping","@ToolTip3":"Prints a tuner summary and a tuning log by using the interval dictated by the LOGFREQ= option"}},{"StatementOptionName":"PROBLEMS=|PROBS=","StatementOptionHelp":{"#cdata":"Syntax: PROBLEMS=SAS-data-set | PROBS=SAS-data-set \n          \nSpecifies the input data set that contains a list of MILP problems to be used for option tuning. This\nlist includes the name of each problem, its library location, and (optionally) its objective sense. \n\nThe tuning problems should be stored in MPS-format SAS data sets. To perform option tuning on a single \nproblem, you can omit the PROBLEMS= option in the TUNER statement and specify the DATA= option in\nthe PROC OPTMILP statement."},"StatementOptionType":"V"},{"StatementOptionName":"TUNEROUT=|TOUT=","StatementOptionHelp":{"#cdata":"Syntax: TUNEROUT=SAS-data-set | TOUT=SAS-data-set \n          \nSpecifies the output data set that contains detailed results for each tuning problem over all the option\nconfigurations that are evaluated."},"StatementOptionType":"V"}]}}]}}}