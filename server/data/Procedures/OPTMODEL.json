{"Procedure":{"Name":"OPTMODEL","#comment":{},"ProductGroup":"SAS/OR","ProcedureHelp":{"#cdata":"Syntax: PROC OPTMODEL options ; \n\n    Declaration Statements...\n    Programming Statements...\n    parameter = expression ; (Assignment) \n    ...\n\nThe OPTMODEL procedure comprises the powerful OPTMODEL modeling language and state-of-the-art \nsolvers for several classes of mathematical programming problems:\n\n    Linear Programming (LP)\n    Mixed Integer Linear Programming (MILP)\n    Quadratic Programming (QP) (experimental) \n    Nonlinear Programming, Unconstrained (NLPU)\n    General Nonlinear Programming (NLPC) \n    General Nonlinear Programming (SQP) \n    General Nonlinear Programming (IPNLP)"},"ProcedureOptions":{"ProcedureOption":[{"ProcedureOptionName":"CDIGITS=","ProcedureOptionHelp":{"#cdata":"[Syntax: CDIGITS=number] \n      \nSpecifies the expected number of decimal digits of accuracy for nonlinear constraints. The value can\nbe fractional. PROC OPTMODEL uses this option to choose a step length when numeric derivative\napproximations are required to evaluate the Jacobian of nonlinear constraints. The default value\ndepends on your operating environment. It is assumed that constraint values are accurate to the limits\nof machine precision."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"ERRORLIMIT=","ProcedureOptionHelp":{"#cdata":"Syntax: ERRORLIMIT=number | NONE] \n      \nSpecifies the maximum number of error messages that can be displayed. Specifying a value of number\nin the range 1 to 2\u00b3\u00b9-1 sets a specific limit. Specifying ERRORLIMIT=NONE removes any existing limit. \n\nNOTE: Some errors abort processing immediately."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"<number>","@Value2":"NONE"},"ProcedureOptionToolTips":{"@ToolTip1":"Replace <number> with an actual number in the range 1 to 2\u00b3\u00b9-1 to set a specific limit.","@ToolTip2":"Specifying ERRORLIMIT=NONE removes any existing limit."}},{"ProcedureOptionName":"FD=","ProcedureOptionHelp":{"#cdata":"Selects the method used to approximate numeric derivatives when analytic derivatives are \nunavailable. Most solvers require the derivatives of the objective and constraints. \n\nThe methods available are as follows: \n\n  FD=FORWARD use forward differences\n  FD=CENTRAL use central differences\n  \nThe default value is FORWARD"},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"FORWARD","@Value2":"CENTRAL"},"ProcedureOptionToolTips":{"@ToolTip1":"Uses forward differences","@ToolTip2":"Uses central differences"}},{"ProcedureOptionName":"FDIGITS=","ProcedureOptionHelp":{"#cdata":"[Syntax: FDIGITS=number] \n      \nSpecifies the expected number of decimal digits of accuracy for the objective function. \nThe value can be fractional."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"FORCEFD=","ProcedureOptionHelp":{"#cdata":"[Syntax: FORCEFD=ALL | CON | NONE | OBJ]\n      \nForces PROC OPTMODEL to use finite differences instead of analytic derivatives for the specified \nset of nonlinear expressions. This option can be useful with FCMP functions to provide more control \nover derivative computation.\n\nBy default, FORCEFD=NONE."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"ALL","@Value2":"CON","@Value3":"NONE","@Value4":"OBJ"},"ProcedureOptionToolTips":{"@ToolTip1":"Restricts all derivative computations to use finite differences. ","@ToolTip2":"Restricts derivative computations for the nonlinear constraint expressions and any IMPVAR expressions  they reference to use finite differences.","@ToolTip3":"Requests analytic derivatives where they are available. ","@ToolTip4":"Restricts derivative computations for the objective and any IMPVAR expressions it references to use finite differences. "}},{"ProcedureOptionName":"FORCEPRESOLVE=","ProcedureOptionHelp":{"#cdata":"[Syntax: FORCEPRESOLVE=number | string \n      \nspecifies whether PROC OPTMODEL can use the OPTMODEL presolver with the CLP, LP, MILP, and QP solvers. \nBy default, the OPTMODEL presolver is disabled when PROC OPTMODEL solves linear problems or problems \nwith predicates, or when the CLP, LP, MILP, or QP solver is specified in the SOLVE statement. Table 5.4 \nshows the valid values for this option. \n\nTable 5.4: Values for the FORCEPRESOLVE= Option\n\nnumber string Description\n0       OFF   Restores the default behavior.\n1       ON    Enables PROC OPTMODEL to use the OPTMODEL presolver when the CLP, LP, MILP, or QP solver is specified in the SOLVE statement. \n\nBy default, FORCEPRESOLVE=0."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"INITVAR","ProcedureOptionHelp":{"#cdata":"Selects to pass initial values for variables to the solver when the SOLVE statement is executed."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"NOINITVAR","ProcedureOptionHelp":{"#cdata":"Causes the solver to be invoked without any specific initial values for variables."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"INTFUZZ=","ProcedureOptionHelp":{"#cdata":"[Syntax: INTFUZZ=number] \n      \nSpecifies the tolerance for rounding the bounds on integer and binary variables to \ninteger values."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"MAXLABLEN=","ProcedureOptionHelp":{"#cdata":"[Syntax: MAXLABLEN=number] \n      \nSpecifies the maximum length for MPS row and column labels. The allowed range is 8 to 256, \nwith 32 as the default."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"MISSCHECK","ProcedureOptionHelp":{"#cdata":"Requests that a message be produced each time PROC OPTMODEL evaluates an arithmetic operation \nor built-in function that has missing value operands (except when the operation or function \nspecifically supports missing values)."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"NOMISSCHECK","ProcedureOptionHelp":{"#cdata":"Turns off detailed checking of missing values in expressions. This is the default."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"MSGLIMIT=","ProcedureOptionHelp":{"#cdata":"Syntax: MSGLIMIT=number | NONE] \n      \nSpecifies the maximum number of non-error messages that can be displayed, including notes and\nwarnings. Specifying a value of number in the range 1 to 2\u00b3\u00b9-1 sets a specific limit. \nSpecifying ERRORLIMIT=NONE removes any existing limit."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"<number>","@Value2":"NONE"},"ProcedureOptionToolTips":{"@ToolTip1":"Replace <number> with an actual number in the range 1 to 2\u00b3\u00b9-1 to set a specific limit.","@ToolTip2":"Specifying ERRORLIMIT=NONE removes any existing limit."}},{"ProcedureOptionName":"PDIGITS=","ProcedureOptionHelp":{"#cdata":"[Syntax: PDIGITS=number] \n      \nRequests that the PRINT statement display num significant digits for numeric columns for which \nno format is specified. The value can range from 1 to 9. The default is 5."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"PMATRIX=","ProcedureOptionHelp":{"#cdata":"[Syntax: PMATRIX=number] \n      \nAdjusts the density evaluation of a two-dimensional array to affect how it is displayed. \nThe value num scales the total number of nonempty array elements and is used by the PRINT \nstatement to evaluate whether a two-dimensional array is \"sparse\" or \"dense\"."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"PRESOLVER=","ProcedureOptionHelp":{"#cdata":"Specifies a presolve option."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"NONE","@Value2":"AUTOMATIC","@Value3":"BASIC","@Value4":"MODERATE","@Value5":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Specifies to disable the presolver.","@ToolTip2":"Specifies to apply presolver using default setting.","@ToolTip3":"Specifies to perform minimal processing, only substituting fixed variables and removing empty  feasible constraints.","@ToolTip4":"Specifies to apply a higher level of presolve processing..","@ToolTip5":"Specifies to apply the highest level of presolve processing."}},{"ProcedureOptionName":"PRESTOL=","ProcedureOptionHelp":{"#cdata":"[Syntax: PRESTOL=number] \n      \nProvides a tolerance so that slightly infeasible constraints can be eliminated by the OPTMODEL presolver."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"PRINTLEVEL=","ProcedureOptionHelp":{"#cdata":"Controls the level of listing output during a SOLVE command."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"0","@Value2":"1","@Value3":"2"},"ProcedureOptionToolTips":{"@ToolTip1":"Disable all tables.","@ToolTip2":"Print Problem Summary and Solution Summary.","@ToolTip3":"Print Problem Summary, Solution Summary, Methods of Derivative Computation (for NLP solvers),  Solver Options, Optimization Statistics and solver-specific ODS tables."}},{"ProcedureOptionName":"PWIDTH=","ProcedureOptionHelp":{"#cdata":"[Syntax: PWIDTH=number] \n      \nSets the width used by the PRINT statement to display numeric columns when no format is specified. \nThe smallest value num can take is the value of the PDIGITS= option plus 7; the largest value num \ncan take is 16. The default value is equal to the value of the PDIGITS= option plus 7."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"VARFUZZ=","ProcedureOptionHelp":{"#cdata":"[Syntax: VARFUZZ=number] \n      \nSpecifies the smallest difference that is permitted by the OPTMODEL presolver between the upper and \nlower bounds of an unfixed variable."},"ProcedureOptionType":"V"}]},"ProcedureStatements":{"ProcedureStatement":[{"StatementName":"CONSTRAINT|CON","StatementHelp":{"#cdata":"Syntax: CONSTRAINT constraint [, ...constraint];\nCON constraint [, ...constraint];\n\nThe constraint declaration defines one or more constraints on expressions in terms of the \noptimization variables. You can specify multiple constraint declaration statements. Constraints \ncan have an upper bound, a lower bound, or both bounds. The allowed forms are as follows: \n\n  [ name [ { index-set } ] : ] expression = expression \n  [ name [ { index-set } ] : ] expression relation expression \n  [ name [ { index-set } ] : ] bound relation body relation bound \n\nwhere:\n  name defines the name for the constraint. \n  relation is the \u2264 or \u2265 operator.\n  index-set declares a family of equality/inequality/range constraints\n  expression is any valid SAS expression\n  bound defines the lower/upper bound \n  body refers to a body expression"},"StatementOptions":null},{"StatementName":"IMPVAR","StatementHelp":{"#cdata":"Syntax: IMPVAR impvar-decl [, ...impvar-decl] ; \n      \nThe IMPVAR statement declares one or more names that refer to optimization expressions \nin the model. The declared name is called an implicit variable. An implicit variable is \nuseful for structuring models so that complex expressions do not need to be repeated each \ntime they are used. The value of an implicit variable needs to be computed only once instead \n'of at each place where the original expression is used, which helps reduce computational \noverhead. Implicit variables are evaluated without intervention from the solver. \n\nMultiple IMPVAR statements are allowed. The names of implicit variables must be distinct \nfrom other model declarations, such as variables and constraints. Implicit variables can \nbe used in model expressions in the same places where ordinary variables are allowed. \n\nThis is the syntax for an impvar-decl: \n\n  name [ { index-set } ] = expression ; \n  \nEach impvar-decl declares a name for an implicit variable. The name can be followed by \nan index-set specification to declare a family of implicit variables. The expression \nreferenced by the name follows. Dummy parameters declared in the index-set specification \ncan be used in the expression. The expression can reference other model components, \nincluding variables and other implicit variables."},"StatementOptions":null},{"StatementName":"MAX|MAXIMIZE","StatementHelp":{"#cdata":"Syntax: MAX name = expression;\n\nThe MAX or MIN declaration specifies an objective for the solver. The name names the objective \nfunction for later reference. The solver maximizes an objective specified with the MAX keyword."},"StatementOptions":null},{"StatementName":"MIN|MINIMIZE","StatementHelp":{"#cdata":"Syntax: MIN name = expression;\n\nThe MIN declaration specifies an objective for the solver. The name names the objective function \nfor later reference. The solver minimizes an objective specified with the MIN keyword."},"StatementOptions":null},{"StatementName":"NUMBER|NUM","StatementHelp":{"#cdata":"Syntax: NUMBER parameter-decl [, ...parameter-decl] ;\n\nDeclaration of parameters that have a NUMBER type."},"StatementOptions":{"StatementOption":{"StatementOptionName":"INIT","StatementOptionHelp":{"#cdata":"[Syntax: INIT expression] \n          \nSpecifies a default value that is used when a parameter value is required but no other value \nhas been supplied."},"StatementOptionType":"S"}}},{"StatementName":"PROBLEM","StatementHelp":{"#cdata":"Syntax: PROBLEM name [ { index-set } ] [  problem-id ] [  problem-items ] ; \n      \nProblems are declared with the PROBLEM declaration. Problem declarations track an \nobjective, a set of included variables and constraints, and some status information \nthat is associated with the variables and constraints. The problem name can optionally \nbe followed by an index-set to create a family of problems. When a problem is first \nused (via the USE PROBLEM statement), the specifications from the optional FROM and \nINCLUDE clauses create the initial set of included variables, constraints, and the \nproblem objective. An empty problem is created if neither clause is specified. The \nclauses are applied only when the problem is first used with the USE PROBLEM statement."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"FROM","StatementOptionHelp":{"#cdata":"Specifies an existing problem from which to copy the included symbols. The problem-id \nis an identifier expression. The dropped and fixed status for these symbols in the\nspecified problem is also copied."},"StatementOptionType":"V"},{"StatementOptionName":"INCLUDE","StatementOptionHelp":{"#cdata":"Specifies a list of variables, constraints, and objectives to include in the problem. \nThese items are included with default status (unfixed and undropped) which overrides \nthe status from the FROM clause, if it exists. Each item is specified with one of the \nfollowing forms: \n\n  identifier-expression \n  includes the specified items in the problem. The identifier-expression can be a symbol \n  name or an array symbol with explicit index. If an array symbol is used without an index, \n  then all array elements are included. \n\n  { index-set } identifier-expression \n  includes the specified subset of items in the problem. The item specified by the identifier-\n  expression is added to the problem for each member of the index-set. The dummy parameters from \n  the index-set can be used in the indexing of the identifier-expression. If the identifier-\n  expression is an array symbol without indexing, then the index-set provides the indices for \n  the included locations."},"StatementOptionType":"V"}]}},{"StatementName":"STRING|STR","StatementHelp":{"#cdata":"Syntax: STRING parameter-decl [, ...parameter-decl] ;\n\nDeclaration of parameters that have a STRING type."},"StatementOptions":{"StatementOption":{"StatementOptionName":"INIT","StatementOptionHelp":{"#cdata":"[Syntax: INIT expression] \n          \nSpecifies a default value that is used when a parameter value is required but no other value \nhas been supplied."},"StatementOptionType":"S"}}},{"StatementName":"SET","StatementHelp":{"#cdata":"Syntax: SET [ <scalar-type, ...scalar-type >] parameter-decl [, ...parameter-decl] ;\n\nDeclaration of parameters that have a SET type."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"INIT","StatementOptionHelp":{"#cdata":"[Syntax: INIT expression] \n          \nSpecifies a default value that is used when a parameter value is required but no other value \nhas been supplied."},"StatementOptionType":"S"},{"StatementOptionName":"NUMBER|NUM","StatementOptionHelp":{"#cdata":"[Number type declaration"},"StatementOptionType":"S"},{"StatementOptionName":"STRING|STR","StatementOptionHelp":{"#cdata":"[String type declaration"},"StatementOptionType":"S"}]}},{"StatementName":"VAR","StatementHelp":{"#cdata":"Syntax: VAR var-decl [, ...var-decl];\n\nThe VAR statement declares one or more optimization variables. Multiple VAR statements are \npermitted. A variable is not allowed to have the same name as a parameter or constraint."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"INIT","StatementOptionHelp":{"#cdata":"[Syntax: INIT expression] \n          \nSets an initial value for the variable. The expression is used only the first time the value is \nrequired. If no initial value is specified, then 0 is used by default."},"StatementOptionType":"S"},{"StatementOptionName":"INTEGER","StatementOptionHelp":{"#cdata":"Requests that the solver assign the variable an integer value."},"StatementOptionType":"S"},{"StatementOptionName":"BINARY","StatementOptionHelp":{"#cdata":"Requests that the solver assign the variable a value of either 0 or 1."},"StatementOptionType":"S"}]}},{"StatementName":"CLOSEFILE","StatementHelp":{"#cdata":"Syntax: CLOSEFILE file-specification(s);\n\nThe CLOSEFILE statement closes files that were opened by the FILE statement. Each file is specified \nby a logical name, a physical filename in quotation marks, or an expression enclosed in parentheses \nthat evaluates to a physical filename."},"StatementOptions":null},{"StatementName":"CONTINUE","StatementHelp":{"#cdata":"Syntax: CONTINUE ;\n\nThe CONTINUE statement terminates the current iteration of the loop statement (iterative DO, \nDO UNTIL, DO WHILE, or FOR) that immediately contains the CONTINUE statement. Execution resumes \nat the start of the loop after checking WHILE or UNTIL tests. The FOR or iterative DO loops apply \nnew iteration values."},"StatementOptions":null},{"StatementName":"CALL","StatementHelp":{"#cdata":"Syntax: CALL name ( argument-1 [, ...argument-n] );\n\nThe CALL statement invokes the named library subroutine. The values that are determined for \neach argument expression are passed to the subroutine when the subroutine is invoked. The \nsubroutine can update the values of PROC OPTMODEL parameters and variables when an argument \nis an identifier-expression."},"StatementOptions":null},{"StatementName":"COFOR","StatementHelp":{"#cdata":"Syntax: COFOR { index-set } statement; \n\nThe COFOR statement executes its statement for each member of the specified index-set , similar to how the \nFOR statement executes. However, in a COFOR statement, PROC OPTMODEL can execute the SOLVE statement concurrently \nwith other statements. The execution of the COFOR substatement is interleaved between loop iterations so that \nother iterations can be processed while an iteration waits for a SOLVE statement to complete. Multiple solvers \ncan run concurrently. This interleaving is managed so that in many cases a FOR loop can be replaced by a COFOR \nloop to achieve concurrency with minimal or no other changes to the code."},"StatementOptions":null},{"StatementName":"CREATE DATA","StatementHelp":{"#cdata":"Syntax: CREATE DATA SAS-data-set FROM [ [ key-column(s) ] [ =key-set ] ] column(s);\n\nThe CREATE DATA statement creates a new SAS data set and copies data into it from PROC OPTMODEL \nparameters and variables. \n\nThe arguments to the CREATE DATA statement are as follows: \n\nSAS-data-set\n  specifies the output data set name and options. You can specify the data set name and options directly \n  or as the string value of an expression enclosed in parentheses. \n\nkey-columns\n  declares index values and their corresponding data set variables. The values are used to index array locations in columns. \n\nkey-set\n  specifies a set of index values for the key-columns. \n\ncolumns\n  specifies data set variables as well as the PROC OPTMODEL source data for the variables."},"StatementOptions":{"StatementOption":{"StatementOptionName":"FROM","StatementOptionHelp":{"#cdata":"[Syntax: FROM [[ key-column(s) ] [ =key-set ] ] column(s) ] \n          \nKeyword for specifying the source columns from which the data is created."},"StatementOptionType":"S"}}},{"StatementName":"DO","StatementHelp":{"#cdata":"Syntax: DO ; statement(s) ; END;\n    | DO name = specification-1 [, ...specification-n] ; statement(s) ; END;\n    | DO WHILE ( logic-expression ) ; statement(s) ; END;\n    | DO UNTIL ( logic-expression ) ; statement(s) ; END;\n\nThe DO statement groups a sequence of statements together as a single statement."},"StatementOptions":null},{"StatementName":"DO UNTIL","StatementHelp":{"#cdata":"Syntax: DO UNTIL ( logic-expression ) ; statement(s) ; END;\n\nThe DO UNTIL loop executes the specified sequence of statements repeatedly until the logic-expression,\nevaluated after the statements, returns true (a nonmissing nonzero value)."},"StatementOptions":null},{"StatementName":"DO WHILE","StatementHelp":{"#cdata":"Syntax: DO WHILE ( logic-expression ) ; statement(s) ; END;\n\nThe DO WHILE loop executes the specified sequence of statements repeatedly as long as the\nlogic-expression, evaluated before the statements, returns true (a nonmissing nonzero value)."},"StatementOptions":null},{"StatementName":"END","StatementHelp":{"#cdata":"Syntax: END;\n\nEnds DO group processing."},"StatementOptions":null},{"StatementName":"DROP","StatementHelp":{"#cdata":"Syntax: DROP identifier-expression;\n\nThe DROP statement causes the solver to ignore the specified constraint, constraint array, \nor constraint array location. The identifier-expression specifies the dropped constraint."},"StatementOptions":null},{"StatementName":"EXPAND","StatementHelp":{"#cdata":"Syntax: EXPAND [identifier-expression] [ / options];\n\nThe EXPAND statement prints the specified constraint, variable, or objective declaration expressions \nafter expanding aggregation operators, substituting the current value for parameters and indices, \nand resolving constant subexpressions. Identifier-expression is the name of a variable, objective, \nor constraint."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"SOLVE","StatementOptionHelp":{"#cdata":"Causes the EXPAND statement to print the variables, objectives, and constraints in the same form \nthat would be seen by the solver if a SOLVE statement were executed."},"StatementOptionType":"S"},{"StatementOptionName":"VAR","StatementOptionHelp":{"#cdata":"Requests the output of unfixed variables."},"StatementOptionType":"S"},{"StatementOptionName":"FIX","StatementOptionHelp":{"#cdata":"Requests the output of fixed variables. These variables might have been fixed by the FIX statement \n(or by the presolver if the SOLVE option is specified)."},"StatementOptionType":"S"},{"StatementOptionName":"OBJECTIVE|OBJ","StatementOptionHelp":{"#cdata":"Requests the output of objectives. Only the most recent objective seen in a MAX or MIN declaration \nor specified in a SOLVE statement is considered when the SOLVE option is used."},"StatementOptionType":"S"},{"StatementOptionName":"CONSTRAINT|CON","StatementOptionHelp":{"#cdata":"Requests the output of undropped constraints."},"StatementOptionType":"S"},{"StatementOptionName":"IIS","StatementOptionHelp":{"#cdata":"Restricts the display to items found in the irreducible infeasible set (IIS) after the most recent \nSOLVE performed by the LP solver with the IIS=ON option."},"StatementOptionType":"S"},{"StatementOptionName":"IMPVAR","StatementOptionHelp":{"#cdata":"Requests the output of implicit variables referenced in the current problem."},"StatementOptionType":"S"},{"StatementOptionName":"OMITTED","StatementOptionHelp":{"#cdata":"Requests the output of variables that are referenced by problem equations but were not included in the \ncurrent USE PROBLEM instance. The OPTMODEL procedure omits these variables from the generated problem."},"StatementOptionType":"S"}]}},{"StatementName":"FILE","StatementHelp":{"#cdata":"Syntax: FILE file-specification [LRECL=value];\n\nThe FILE statement selects the current output file for the PUT statement."},"StatementOptions":{"StatementOption":{"StatementOptionName":"LRECL=","StatementOptionHelp":{"#cdata":"[Syntax: LRECL=value] \n          \nSets the line length of the output file. If the option is omitted, then the line length defaults \nto 256 characters."},"StatementOptionType":"V"}}},{"StatementName":"FIX","StatementHelp":{"#cdata":"Syntax: FIX identifier-list [ =( expression ) ];\n\nThe FIX statement causes the solver to treat a list of variables, variable arrays, or variable array \nlocations as fixed in value. The identifier-list consists of one or more variable names separated by \nspaces. Each member of the identifier-list is fixed to the same expression."},"StatementOptions":null},{"StatementName":"FOR","StatementHelp":{"#cdata":"Syntax: FOR { index-set } statement ; \n      \nThe FOR statement executes its substatement for each member of the specified index-set. The index set can\ndeclare local dummy parameters. You can reference the value of these parameters in the substatement. \n\nCAUTION: Avoid modifying the parameters that are used by the FOR statement index set from within the\nsubstatement. The set value that is used for the left-most index set item is not affected by such changes.\nHowever, the effect of parameter changes on later index set items cannot be predicted."},"StatementOptions":null},{"StatementName":"IF","StatementHelp":{"#cdata":"Executes a SAS statement for observations that meet specific conditions. \n\nSyntax: \n(1) IF expression THEN statement; \n    <ELSE statement;> \n(2) IF condition;"},"StatementOptions":{"StatementOption":[{"StatementOptionName":"THEN","StatementOptionHelp":{"#cdata":"If the conditions that are specified in the IF clause are met, the IF-THEN statement executes a SAS \nstatement for observations that are read from a SAS data set, for records in an external file, or \nfor computed values."},"StatementOptionType":"S"},{"StatementOptionName":"DO","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct."},"StatementOptionType":"S"},{"StatementOptionName":"WHEN","StatementOptionHelp":{"#cdata":"WHEN statement in an IF-THEN-WHEN construct."},"StatementOptionType":"S"},{"StatementOptionName":"OUTPUT","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct."},"StatementOptionType":"S"},{"StatementOptionName":"GO TO|GOTO","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct. \n          \nSyntax: ... GO TO label; | ... GOTO label;\n      \nJumps to a new statement."},"StatementOptionType":"S"},{"StatementOptionName":"PUT","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct."},"StatementOptionType":"S"},{"StatementOptionName":"STOP","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct. \n          \nStops execution of the current DATA step."},"StatementOptionType":"S"},{"StatementOptionName":"SET","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct.\n          \nSyntax: SET <SAS-data-set(s) <(data-set-options(s) )>>; \n      \nReads an observation from one or more SAS data sets."},"StatementOptionType":"S"},{"StatementOptionName":"NOT","StatementOptionType":"S"},{"StatementOptionName":"OR","StatementOptionType":"S"},{"StatementOptionName":"AND","StatementOptionType":"S"}],"#comment":{}}},{"StatementName":"ELSE","StatementHelp":{"#cdata":"If the condition in a IF-THEN statement is false and an ELSE statement is present, then the ELSE \naction is carried out."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"THEN","StatementOptionHelp":{"#cdata":"If the conditions that are specified in the IF clause are met, the IF-THEN statement executes a SAS \nstatement for observations that are read from a SAS data set, for records in an external file, or \nfor computed values."},"StatementOptionType":"S"},{"StatementOptionName":"IF","StatementOptionHelp":{"#cdata":"Executes a SAS statement for observations that meet specific conditions."},"StatementOptionType":"S"},{"StatementOptionName":"DO","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN-ELSE construct."},"StatementOptionType":"S"},{"StatementOptionName":"OUTPUT","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN-ELSE construct."},"StatementOptionType":"S"},{"StatementOptionName":"NOT","StatementOptionType":"S"},{"StatementOptionName":"OR","StatementOptionType":"S"},{"StatementOptionName":"AND","StatementOptionType":"S"}],"#comment":{}}},{"StatementName":"LEAVE","StatementHelp":{"#cdata":"Syntax: LEAVE ;\n      \nThe LEAVE statement terminates the execution of the entire loop body (iterative DO, DO UNTIL, \nDO WHILE, or FOR) that immediately contains the LEAVE statement. Execution resumes at the \nstatement that follows the loop."},"StatementOptions":null},{"StatementName":"PERFORMANCE","StatementHelp":{"#cdata":"Syntax: PERFORMANCE < performance-options > ;\n      \nThe PERFORMANCE statement defines performance parameters for multithreaded and distributed \ncomputing, passes variables about the distributed computing environment, and requests detailed \nresults about the performance characteristics of a High-Performance Analytics procedure.\n\nWith the PERFORMANCE statement, you can also control whether the HPNLIN procedure executes \nin SMP or MPP mode."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"DETAILS","StatementOptionHelp":{"#cdata":"Requests that the procedure produce the Timing ODS table. This table shows a breakdown of the time\nused in each step of the procedure."},"StatementOptionType":"S"},{"StatementOptionName":"NTHREADS=","StatementOptionHelp":{"#cdata":"Syntax: NTHREADS=number | CPUCOUNT\n          \nSpecifies the number of threads that a procedure can use. It overrides the SAS system option THREADS\n| NOTHREADS. The value of number can be any integer between 1 and 256 inclusive. The default\nvalue is CPUCOUNT, which sets the thread count to the number that is determined by the SAS system\noption CPUCOUNT=.\n\nSetting the NTHREADS= option to a number greater than the actual number of available cores might\nresult in reduced performance. Specifying a high NTHREADS= value does not guarantee shorter\nsolution time; the actual change in solution time depends on the computing hardware and the scalability\nof the underlying algorithms in the specified procedure. In some circumstances, a procedure might use\nfewer threads than the specified value of the NTHREADS= option because the procedure\u2019s internal\nalgorithms have determined that a smaller number is preferable."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"<num>","@Value2":"CPUCOUNT"},"StatementOptionToolTips":{"@ToolTip1":"Replace <num> with an actual number. The value of number can be any integer between 1 and 256  inclusive. The default value is CPUCOUNT, which sets the thread count to the number that is determined  by the SAS system option CPUCOUNT=.","@ToolTip2":"The default value is CPUCOUNT, which sets the thread count to the number that is determined by the  SAS system option CPUCOUNT="}},{"StatementOptionName":"PARALLELMODE=","StatementOptionHelp":{"#cdata":"Syntax: PARALLELMODE=number | string \n          \nSpecifies the parallel processing mode. This mode determines the solution results that are obtained\nfrom running the same model with the same option values on the same platform multiple times."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"DETERMINISTIC|0","@Value2":"NONDETERMINISTIC|1"},"StatementOptionToolTips":{"@ToolTip1":"Requires algorithms to produce the same results every time.","@ToolTip2":"Permits algorithms to produce different solution results. This mode requires less synchronization and might attain better performance than DETERMINISTIC mode."}}]}},{"StatementName":"PRINT","StatementHelp":{"#cdata":"Syntax: PRINT print-item(s);\n\nThe PRINT statement outputs string and numeric data in tabular form. The statement specifies a list \nof arrays or other data items to print. Multiple items can be output together as data columns in \nthe same table."},"StatementOptions":{"StatementOption":{"StatementOptionName":"_PAGE_","StatementOptionHelp":{"#cdata":"Specifies a page break."},"StatementOptionType":"S"}}},{"StatementName":"PUT","StatementHelp":{"#cdata":"Syntax: PUT [ put-item(s) ] [ @ | @@ ];\n\nThe PUT statement writes text data to the current output file. The syntax of the PUT statement in \nPROC OPTMODEL is similar to the syntax of the PROC IML and DATA step PUT statements."},"StatementOptions":{"StatementOption":{"StatementOptionName":"_PAGE_","StatementOptionHelp":{"#cdata":"Outputs any pending line data and moves to the top of the next page."},"StatementOptionType":"S"}}},{"StatementName":"READ DATA","StatementHelp":{"#cdata":"Syntax: READ DATA SAS-data-set  NOMISS  INTO   set-name =  [ read-key-columns ]  read-columns ;\n\nThe READ DATA statement reads data from a SAS data set into PROC OPTMODEL parameter and \nvariable locations. The arguments to the READ DATA statement are as follows: \n\n\nSAS-data-set\n  specifies the input data set name and options. You can specify the data set name and options directly \n  or as the string value of an expression enclosed in parentheses. \n\nset-name\n  specifies a set parameter in which to save the set of observation key values read from the input data set. \n\nread-key-columns\n  provide the index values for array destinations. \n\nread-columns\n  specify the data values to read and the destination locations."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"NOMISS","StatementOptionHelp":{"#cdata":"Exclude missing values."},"StatementOptionType":"RS"},{"StatementOptionName":"INTO","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"S"},{"StatementOptionName":"TRIM|TR","StatementOptionHelp":{"#cdata":"Removes leading and trailing blanks from the data set value. This is the default behavior."},"StatementOptionType":"S"},{"StatementOptionName":"LTRIM|LT","StatementOptionHelp":{"#cdata":"Removes only leading blanks from the data set value."},"StatementOptionType":"S"},{"StatementOptionName":"RTRIM|RT","StatementOptionHelp":{"#cdata":"Removes only trailing blanks from the data set value."},"StatementOptionType":"V"},{"StatementOptionName":"NOTRIM|NT","StatementOptionHelp":{"#cdata":"Copies the data set value with no changes."},"StatementOptionType":"S"}]}},{"StatementName":"RESET OPTIONS|RESET OPTION","StatementHelp":{"#cdata":"Syntax: RESET OPTIONS option(s);\n\nThe RESET OPTIONS statement sets PROC OPTMODEL option values or restores them to their defaults. \nOptions can be specified by using the same syntax as in the PROC OPTMODEL statement. The RESET \nOPTIONS statement provides two extensions to the option syntax. If an option normally requires \na value (specified with an equal sign (=) operator), then specifying the option name alone resets \nit to its default value. You can also specify an expression enclosed in parentheses in place\nof a literal value."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"CDIGITS=","StatementOptionHelp":{"#cdata":"[Syntax: CDIGITS=number] \n          \nSpecifies the expected number of decimal digits of accuracy for nonlinear constraints. The value \ncan be fractional."},"StatementOptionType":"V"},{"StatementOptionName":"FD=","StatementOptionHelp":{"#cdata":"Selects the method used to approximate numeric derivatives when analytic derivatives are unavailable."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"FORWARD","@Value2":"CENTRAL"},"StatementOptionToolTips":{"@ToolTip1":"Use forward differences","@ToolTip2":"Use central differences"}},{"StatementOptionName":"ERRORLIMIT=","StatementOptionHelp":{"#cdata":"Syntax: ERRORLIMIT=number | NONE] \n      \nSpecifies the maximum number of error messages that can be displayed. Specifying a value of number\nin the range 1 to 2\u00b3\u00b9-1 sets a specific limit. Specifying ERRORLIMIT=NONE removes any existing limit. \n\nNOTE: Some errors abort processing immediately."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"<number>","@Value2":"NONE"},"StatementOptionToolTips":{"@ToolTip1":"Replace <number> with an actual number in the range 1 to 2\u00b3\u00b9-1 to set a specific limit.","@ToolTip2":"Specifying ERRORLIMIT=NONE removes any existing limit."}},{"StatementOptionName":"FDIGITS=","StatementOptionHelp":{"#cdata":"[Syntax: FDIGITS=number] \n          \nSpecifies the expected number of decimal digits of accuracy for the objective function. \nThe value can be fractional."},"StatementOptionType":"V"},{"StatementOptionName":"FORCEFD=","StatementOptionHelp":{"#cdata":"[Syntax: FORCEFD=ALL | CON | NONE | OBJ]\n      \n  Forces PROC OPTMODEL to use finite differences instead of analytic derivatives for the specified \n  set of nonlinear expressions. This option can be useful with FCMP functions to provide more control \n  over derivative computation.\n\n  By default, FORCEFD=NONE."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"ALL","@Value2":"CON","@Value3":"NONE","@Value4":"OBJ"},"StatementOptionToolTips":{"@ToolTip1":"Restricts all derivative computations to use finite differences. ","@ToolTip2":"Restricts derivative computations for the nonlinear constraint expressions and any IMPVAR expressions    they reference to use finite differences.","@ToolTip3":"Requests analytic derivatives where they are available. ","@ToolTip4":"Restricts derivative computations for the objective and any IMPVAR expressions it references to use finite differences. "}},{"StatementOptionName":"FORCEPRESOLVE=","StatementOptionHelp":{"#cdata":"[Syntax: FORCEPRESOLVE=number | string \n      \n  specifies whether PROC OPTMODEL can use the OPTMODEL presolver with the CLP, LP, MILP, and QP solvers. \n  By default, the OPTMODEL presolver is disabled when PROC OPTMODEL solves linear problems or problems \n  with predicates, or when the CLP, LP, MILP, or QP solver is specified in the SOLVE statement. Table 5.4 \n  shows the valid values for this option. \n\n  Table 5.4: Values for the FORCEPRESOLVE= Option\n\n  number string Description\n  0       OFF   Restores the default behavior.\n  1       ON    Enables PROC OPTMODEL to use the OPTMODEL presolver when the CLP, LP, MILP, or QP solver is specified in the SOLVE statement. \n\n  By default, FORCEPRESOLVE=0."},"StatementOptionType":"V"},{"StatementOptionName":"INITVAR","StatementOptionHelp":{"#cdata":"Selects to pass initial values for variables to the solver when the SOLVE statement is executed."},"StatementOptionType":"S"},{"StatementOptionName":"NOINITVAR","StatementOptionHelp":{"#cdata":"Causes the solver to be invoked without any specific initial values for variables."},"StatementOptionType":"S"},{"StatementOptionName":"INTFUZZ=","StatementOptionHelp":{"#cdata":"[Syntax: INTFUZZ=number] \n          \nSpecifies the tolerance for rounding the bounds on integer and binary variables to integer values."},"StatementOptionType":"V"},{"StatementOptionName":"MAXLABLEN=","StatementOptionHelp":{"#cdata":"[Syntax: MAXLABLEN=number] \n          \nSpecifies the maximum length for MPS row and column labels. The allowed range is 8 to 256, \nwith 32 as the default."},"StatementOptionType":"V"},{"StatementOptionName":"MSGLIMIT=","StatementOptionHelp":{"#cdata":"Syntax: MSGLIMIT=number | NONE] \n      \nSpecifies the maximum number of non-error messages that can be displayed, including notes and\nwarnings. Specifying a value of number in the range 1 to 2\u00b3\u00b9-1 sets a specific limit. \nSpecifying ERRORLIMIT=NONE removes any existing limit."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"<number>","@Value2":"NONE"},"StatementOptionToolTips":{"@ToolTip1":"Replace <number> with an actual number in the range 1 to 2\u00b3\u00b9-1 to set a specific limit.","@ToolTip2":"Specifying ERRORLIMIT=NONE removes any existing limit."}},{"StatementOptionName":"MISSCHECK","StatementOptionHelp":{"#cdata":"Requests that a message be produced each time PROC OPTMODEL evaluates an arithmetic operation \nor built-in function that has missing value operands (except when the operation or function \nspecifically supports missing values)."},"StatementOptionType":"S"},{"StatementOptionName":"NOMISSCHECK","StatementOptionHelp":{"#cdata":"Turns off detailed checking of missing values in expressions. This is the default."},"StatementOptionType":"S"},{"StatementOptionName":"PDIGITS=","StatementOptionHelp":{"#cdata":"[Syntax: PDIGITS=number] \n          \nRequests that the PRINT statement display num significant digits for numeric columns for which \nno format is specified. The value can range from 1 to 9. The default is 5."},"StatementOptionType":"V"},{"StatementOptionName":"PMATRIX=","StatementOptionHelp":{"#cdata":"[Syntax: PMATRIX=number] \n          \nAdjusts the density evaluation of a two-dimensional array to affect how it is displayed. The value \nnum scales the total number of nonempty array elements and is used by the PRINT statement to evaluate \nwhether a two-dimensional array is \"sparse\" or \"dense\"."},"StatementOptionType":"V"},{"StatementOptionName":"PRESOLVER=","StatementOptionHelp":{"#cdata":"Specifies a presolve option."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"AUTOMATIC","@Value3":"BASIC","@Value4":"MODERATE","@Value5":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Disable presolver.","@ToolTip2":"Apply presolver using default setting.","@ToolTip3":"Perform minimal processing, only substituting fixed variables and removing empty feasible constraints.","@ToolTip4":"Apply a higher level of presolve processing..","@ToolTip5":"Apply the highest level of presolve processing."}},{"StatementOptionName":"PRESTOL=","StatementOptionHelp":{"#cdata":"[Syntax: PRESTOL=number] \n          \nProvides a tolerance so that slightly infeasible constraints can be eliminated by the \nOPTMODEL presolver."},"StatementOptionType":"V"},{"StatementOptionName":"PRINTLEVEL=","StatementOptionHelp":{"#cdata":"Controls the level of listing output during a SOLVE command."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"0","@Value2":"1","@Value3":"2"},"StatementOptionToolTips":{"@ToolTip1":"Disable all tables.","@ToolTip2":"Print Problem Summary and Solution Summary.","@ToolTip3":"Print Problem Summary, Solution Summary, Methods of Derivative Computation (for NLP solvers), Solver Options,  Optimization Statistics and solver-specific ODS tables."}},{"StatementOptionName":"PWIDTH=","StatementOptionHelp":{"#cdata":"[Syntax: PWIDTH=number] \n          \nSets the width used by the PRINT statement to display numeric columns when no format is specified. \nThe smallest value num can take is the value of the PDIGITS= option plus 7; the largest value num \ncan take is 16. The default value is equal to the value of the\nPDIGITS= option plus 7."},"StatementOptionType":"V"},{"StatementOptionName":"VARFUZZ=","StatementOptionHelp":{"#cdata":"[Syntax: VARFUZZ=number] \n          \nSpecifies the smallest difference that is permitted by the OPTMODEL presolver between the upper \nand lower bounds of an unfixed variable."},"StatementOptionType":"V"}]}},{"StatementName":"RESTORE","StatementHelp":{"#cdata":"Syntax: RESTORE identifier-expression;\n\nThe RESTORE statement adds a constraint, constraint array, or constraint array location that \nwas dropped by the DROP statement back into the solver model. Identifier-expression specifies \nthe constraint. An entire constraint array is restored if the identifier-expression omits the \nindex from an array name."},"StatementOptions":null},{"StatementName":"SAVE MPS","StatementHelp":{"#cdata":"Syntax: SAVE MPS SAS-data-set \u008c ( OBJECTIVE | OBJ ) name \u008d ;\n\nThe SAVE MPS statement saves the structure and coefficients for a linear programming model into \na SAS data set. This data set can be used as input data for the OPTLP or OPTMILP procedure. \n\nNOTE: The OPTMODEL presolver is automatically bypassed so that the statement saves the original model \nwithout eliminating fixed variables, tightening bounds, and so on. The SAS-data-set argument specifies \nthe output data set name and options. The generated data set contains observations that define different \nparts of the linear program.\n\nVariables, constraints, and objectives are referenced in the data set by using label text from the corresponding\n.label suffix value. The default text is based on the name in the model. Labels are limited by default to 32 \ncharacters and are abbreviated to fit. You can change the maximum length for labels by using the MAXLABLEN= option. \nWhen needed, a programmatically generated number is added to labels to avoid duplication.\n\nThe current problem objective is included in the data set. If the OBJECTIVE keyword is used, then the\nproblem objective becomes the specified objective."},"StatementOptions":null},{"StatementName":"SAVE QPS","StatementHelp":{"#cdata":"Syntax: SAVE QPS SAS-data-set \u008c[( OBJECTIVE j OBJ ) name ][(NOOBJECTIVE|NOOBJ)]\u008d ;\n\nThe SAVE QPS statement saves the structure and coefficients for a quadratic programming model into \na SAS data set. This data set can be used as input data for the OPTQP procedure. \n\nNOTE: The OPTMODEL presolver is automatically bypassed so that the statement saves the original model \nwithout eliminating fixed variables, tightening bounds, and so on. The SAS-data-set argument specifies \nthe output data set name and options. The generated data set contains observations that define different \nparts of the quadratic program.\n\nVariables, constraints, and objectives are referenced in the data set by using label text from the corresponding\n.label suffix value. The default text is based on the name in the model. Labels are limited by default to 32 \ncharacters and are abbreviated to fit. You can change the maximum length for labels by using the MAXLABLEN= option. \nWhen needed, a programmatically generated number is added to labels to avoid duplication.\n\nIf the OBJECTIVE keyword is used, the objective name becomes the current problem objective. If the NOOBJECTIVE \nkeyword is used or the current problem does not have an objective, then the data set includes a default constant \nzero objective. Otherwise, the current problem objective is included in the data set. The quadratic coefficients \nof the objective function appear in the QSECTION section of the output data set."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"OBJECTIVE|OBJ","StatementOptionHelp":{"#cdata":"If the OBJECTIVE keyword is used, the objective name becomes the current problem objective."},"StatementOptionType":"RS"},{"StatementOptionName":"NOOBJECTIVE|NOOBJ","StatementOptionHelp":{"#cdata":"If the NOOBJECTIVE keyword is used or the current problem does not have an objective, then the data \nset includes a default constant zero objective. Otherwise, the current problem objective is included \nin the data set."},"StatementOptionType":"RS"}]}},{"StatementName":"SOLVE","StatementHelp":{"#cdata":"Syntax: SOLVE [ WITH solver ] [ (OBJECTIVE|OBJ) name ]  [ (NOOBJECTIVE|NOOBJ) name ] [RELAXINT] [ / options ];\n\nThe SOLVE statement invokes a PROC OPTMODEL solver. \n\nsolver\n  selects the named solver: LP, MILP, QP, or NLP. If no WITH clause is specified, then a solver \n  is chosen automatically, depending on the problem type. \n  \n name\n  specifies the objective to use. This sets the current objective for the problem. You can\n  abbreviate the OBJECTIVE keyword as OBJ. If this argument is not specified, then the\n  problem objective is unchanged.\nRELAXINT requests that any integral variables be relaxed to be continuous. RELAXINT can be used\n  with linear and nonlinear problems in addition to any solver.\noptions specifies solver options. You can specify solver options directly only when you use the\n  WITH clause. A list of the options available with the solver is provided in the individual\n  chapters that describe each solver."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"WITH","StatementOptionHelp":{"#cdata":"A keyword used when specifying the name of the solver to use."},"StatementOptionType":"RS"},{"StatementOptionName":"RELAXINT","StatementOptionHelp":{"#cdata":"Requests that any integral variables be relaxed to be continuous. RELAXINT can be used \nwith linear and nonlinear problems in addition to any solver."},"StatementOptionType":"RS"},{"StatementOptionName":"OBJECTIVE|OBJ","StatementOptionHelp":{"#cdata":"A keyword used when specifying the name of the objective to use."},"StatementOptionType":"RS"},{"StatementOptionName":"NOOBJECTIVE|NOOBJ","StatementOptionHelp":{"#cdata":"Requests that the solver ignore the current objective for the problem and use a constant zero \nobjective instead. This keyword enables the solver to process the current model as a feasibility \nproblem."},"StatementOptionType":"RS"},{"StatementOptionName":"CLP","StatementOptionHelp":{"#cdata":"Solver for Constraint Programming using constraint propagation and backtracking search algorithm"},"StatementOptionType":"RS"},{"StatementOptionName":"LP","StatementOptionHelp":{"#cdata":"Solver for Linear Programming using dual simplex algorithm."},"StatementOptionType":"RS"},{"StatementOptionName":"MILP","StatementOptionHelp":{"#cdata":"Solver for Mixed Integer Linear Programming using branch-and-cut algorithm."},"StatementOptionType":"RS"},{"StatementOptionName":"QP","StatementOptionHelp":{"#cdata":"Solver for Quadratic Programming."},"StatementOptionType":"RS"},{"StatementOptionName":"NLP","StatementOptionHelp":{"#cdata":"The sparse nonlinear programming (NLP) solver is a component of the OPTMODEL procedure that can solve\noptimization problems containing both nonlinear equality and inequality constraints."},"StatementOptionType":"RS"},{"StatementOptionName":"NLPC","StatementOptionHelp":{"#cdata":"Solver for General Nonlinear Programming."},"StatementOptionType":"RS"},{"StatementOptionName":"NLPU","StatementOptionHelp":{"#cdata":"Solver for Nonlinear Programming, Unconstrained."},"StatementOptionType":"RS"},{"StatementOptionName":"SQP","StatementOptionHelp":{"#cdata":"Solver for General Nonlinear Programming."},"StatementOptionType":"RS"},{"StatementOptionName":"IPNLP","StatementOptionHelp":{"#cdata":"Solver for General Nonlinear Programming."},"StatementOptionType":"RS"}]}},{"StatementName":"STOP","StatementHelp":{"#cdata":"Syntax: STOP ;\n\nThe STOP statement halts the execution of all statements that contain it, including DO statements \nand other control or looping statements. Execution continues with the next top-level source statement."},"StatementOptions":null},{"StatementName":"UNFIX","StatementHelp":{"#cdata":"Syntax: UNFIX identifier-list [ =( expression ) ];\n\nThe UNFIX statement reverses the effect of FIX statements."},"StatementOptions":null},{"StatementName":"SOLVE WITH LP","StatementHelp":{"#cdata":"Syntax: SOLVE WITH LP < / options > ; \n      \nStatement for specifying and solving linear programs (LPs)."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"RELAXINT","StatementOptionHelp":{"#cdata":"Requests that any integral variables be relaxed to be continuous. RELAXINT can be used \nwith linear and nonlinear problems in addition to any solver."},"StatementOptionType":"RS"},{"StatementOptionName":"OBJECTIVE|OBJ","StatementOptionHelp":{"#cdata":"A keyword used when specifying the name of the objective to use."},"StatementOptionType":"RS"},{"StatementOptionName":"NOOBJECTIVE|NOOBJ","StatementOptionHelp":{"#cdata":"Requests that the solver ignore the current objective for the problem and use a constant zero \nobjective instead. This keyword enables the solver to process the current model as a feasibility \nproblem."},"StatementOptionType":"RS"},{"StatementOptionName":"FEASTOL=","StatementOptionHelp":{"#cdata":"[Syntax: FEASTOL=\u03b5] \n          \nSpecifies the feasibility tolerance for determining the feasibility of a variable value. \nThe default value is 1E-6."},"StatementOptionType":"V"},{"StatementOptionName":"LOGFREQ=|PRINTFREQ=","StatementOptionHelp":{"#cdata":"[Syntax: LOGFREQ=|PRINTFREQ=k] \n          \nSpecifies that the printing of the solution progress to the iteration log is to occur after every \nk iterations."},"StatementOptionType":"V"},{"StatementOptionName":"LOGLEVEL=|PRINTFREQ2=","StatementOptionHelp":{"#cdata":"[Syntax: LOGLEVEL=0|1|2|3  LOGLEVEL=NONE|BASIC|MODERATE|AGGRESSIVE ]\n\nControls the amount of information displayed in the SAS log by the LP solver, from a short description \nof presolve information and summary to details at each iteration.\n\nThe default value is MODERATE."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"BASIC","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all solver-related messages to SAS log.","@ToolTip2":"Displays a solver summary after stopping.","@ToolTip3":"Prints a solver summary and an iteration log by using the interval dictated by the LOGFREQ= option.","@ToolTip4":"Prints a detailed solver summary and an iteration log by using the interval dictated by the LOGFREQ= option."}},{"StatementOptionName":"MAXITER=","StatementOptionHelp":{"#cdata":"[Syntax: MAXITER=k] \n          \nSpecifies the maximum number of iterations."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"[Syntax: MAXTIME=k] \n          \nSpecifies an upper limit of k seconds of real time for reading in the data and performing the \noptimization process."},"StatementOptionType":"V"},{"StatementOptionName":"OPTTOL=","StatementOptionHelp":{"#cdata":"[Syntax: OPTTOL=\u03b5] \n          \nSpecifies the optimality tolerance for declaring optimality. The default value is 1E-6."},"StatementOptionType":"V"},{"StatementOptionName":"TIMETYPE=","StatementOptionHelp":{"#cdata":"[Syntax: TIMETYPE=0| 1   TIMETYPE=CPU|REAL ]\n\nSpecifies the units of time used by the MAXTIME= option and reported by the PRESOLVE_TIME and \nSOLUTION_TIME terms in the _OROPTMODEL_ macro variable."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"CPU","@Value2":"REAL"},"StatementOptionToolTips":{"@ToolTip1":"Uses CPU time. This is the default.","@ToolTip2":"Uses real time."}},{"StatementOptionName":"PRESOLVER=","StatementOptionHelp":{"#cdata":"Specifies a presolve option."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"AUTOMATIC","@Value3":"BASIC","@Value4":"MODERATE","@Value5":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Disable presolver.","@ToolTip2":"Apply presolver by using default setting.","@ToolTip3":"Perform basic presolve like removing empty rows, columns, and fixed variables.","@ToolTip4":"Perform basic presolve and apply other inexpensive presolve techniques.","@ToolTip5":"Perform moderate presolve and apply other aggressive (but expensive) presolve techniques."}},{"StatementOptionName":"DUALIZE=","StatementOptionHelp":{"#cdata":"[Syntax: DUALIZE=-1|0|1   DUALIZE=AUTOMATIC|OFF|ON ]\n\nControls the dualization of the problem."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"OFF","@Value3":"ON"},"StatementOptionToolTips":{"@ToolTip1":"The presolver uses a heuristic to decide whether to dualize the problem or not.","@ToolTip2":"Disables dualization. The optimization problem is solved in the form that you specify.","@ToolTip3":"The presolver formulates the dual of the linear optimization problem."}},{"StatementOptionName":"BASIS=","StatementOptionHelp":{"#cdata":"[Syntax: BASIS=0|1|2  BASIC=CRASH|SLACK|WARMSTART ] \n          \nSpecifies one of three available options for generating an initial basis.\n\n[For simplex algorithm only]"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"CRASH","@Value2":"SLACK","@Value3":"WARMSTART"},"StatementOptionToolTips":{"@ToolTip1":"Generate an initial basis by using crash techniques (Maros 2003). The procedure creates a triangular basic matrix  consisting of both decision variables and slack variables. This is the default setting.","@ToolTip2":"Generate an initial basis by using all slack variables.","@ToolTip3":"Start the simplex solvers with a user-specified initial basis. The PRIMALIN= and DUALIN= data sets are required  to specify an initial basis."}},{"StatementOptionName":"PRICETYPE=","StatementOptionHelp":{"#cdata":"[Syntax: PRICETYPE=0|1|2|3|4  PRICETYPE=HYBRID|PARTIAL|FULL|DEVEX|STEEPESTEDGE ]\n          \nSpecifies one of 5 available pricing strategies for the simplex solvers.\n\n[For simplex algorithm only]"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"HYBRID","@Value2":"PARTIAL","@Value3":"FULL","@Value4":"DEVEX","@Value5":"STEEPESTEDGE"},"StatementOptionToolTips":{"@ToolTip1":"Use a hybrid of Devex and steepest-edge pricing strategies. Available for the primal simplex  solver only.","@ToolTip2":"Use the Dantzig's rule on a queue of decision variables. Optionally, you can specify QUEUESIZE=.  Available for the primal simplex solver only.","@ToolTip3":"Use the Dantzig's rule on all decision variables.","@ToolTip4":"Use Devex pricing strategy.","@ToolTip5":"Use steepest-edge pricing strategy."}},{"StatementOptionName":"QUEUESIZE=","StatementOptionHelp":{"#cdata":"[Syntax: QUEUESIZE=k] \n          \nSpecifies the queue size. The default value is chosen adaptively based on the number of decision \nvariables. This option is used only when PRICETYPE=PARTIAL.\n\n[For simplex algorithm only]"},"StatementOptionType":"V"},{"StatementOptionName":"SCALE=","StatementOptionHelp":{"#cdata":"[Syntax: SCALE=0|-1  SCALE= NONE|AUTOMATIC ]\n          \nSpecifies a scaling option.\n\n[For simplex algorithm only]"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"AUTOMATIC"},"StatementOptionToolTips":{"@ToolTip1":"Disable scaling.","@ToolTip2":"Automatically apply scaling procedure if necessary."}},{"StatementOptionName":"SEED=","StatementOptionHelp":{"#cdata":"[Syntax: SEED=number ]\n\nSpecifies the initial seed for the random number generator.\n\n[For simplex algorithm only]]"},"StatementOptionType":"V"},{"StatementOptionName":"IIS=","StatementOptionHelp":{"#cdata":"[Syntax: IIS=number | string \n\nSpecifies whether the LP solver attempts to identify a set of constraints and variables that form an irreducible\ninfeasible set (IIS)."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"OFF","@Value2":"ON"},"StatementOptionToolTips":{"@ToolTip1":"Disables IIS detection. This is the default.","@ToolTip2":"Enables IIS detection."}},{"StatementOptionName":"ALGORITHM=|SOLVER=|SOL=","StatementOptionHelp":{"#cdata":"[Syntax: ALGORITHM=option | SOLVER=option | SOL=option ]\n          \nSpecifies an LP algorithm."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"PRIMAL","@Value2":"DUAL","@Value3":"NETWORK","@Value4":"INTERIORPOINT","@Value5":"CONCURRENT"},"StatementOptionToolTips":{"@ToolTip1":"Uses primal simplex algorithm.","@ToolTip2":"Uses dual simplex algorithm.","@ToolTip3":"Uses network simplex algorithm.","@ToolTip4":"Uses interior point algorithm.","@ToolTip5":"Uses several different algorithms in parallel."}},{"StatementOptionName":"ALGORITHM2=|SOLVER2=|SOL2=","StatementOptionHelp":{"#cdata":"[Syntax: ALGORITHM2=option | SOLVER2=option ]\n          \nSpecifies an LP algorithm if ALGORITHM=NETWORK (NS):."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"PRIMAL","@Value2":"DUAL"},"StatementOptionToolTips":{"@ToolTip1":"Uses primal simplex algorithm (after network simplex).","@ToolTip2":"Uses dual simplex algorithm (after network simplex)."}},{"StatementOptionName":"CROSSOVER=","StatementOptionHelp":{"#cdata":"[Syntax: CROSSOVER=number | string ]\n\nSpecifies whether to convert the interior point solution to a basic simplex solution.\n\n[For interior point algorithm only]"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"OFF","@Value2":"ON"},"StatementOptionToolTips":{"@ToolTip1":"Disable crossover. ","@ToolTip2":"Apply the crossover algorithm to the interior point solution."}},{"StatementOptionName":"STOP_DG=","StatementOptionHelp":{"#cdata":"[Syntax: STOP_DG=\u03b4] \n          \nSpecifies the desired relative duality gap, \u03b4 \u03f5 [1E\u20139, 1E\u20134]. This is the relative difference between \nthe primal and dual objective function values and is the primary solution quality parameter. The default\nvalue is 1E\u20136.\n\n[For interior point algorithm only]"},"StatementOptionType":"V"},{"StatementOptionName":"STOP_DI=","StatementOptionHelp":{"#cdata":"[Syntax: STOP_DI=\u03b2] \n          \nSpecifies the maximum allowed relative dual constraints violation, \u03b2 \u03f5 [1E\u20139, 1E\u20134].\nThe default value is 1E\u20136.\n\n[For interior point algorithm only]"},"StatementOptionType":"V"},{"StatementOptionName":"STOP_PI=","StatementOptionHelp":{"#cdata":"[Syntax: STOP_PI=\u03b1] \n          \nSpecifies the maximum allowed relative bound and primal constraints violation, \u03b1 \u03f5 [1E\u20139, 1E\u20134].\nThe default value is 1E\u20136.\n\n[For interior point algorithm only]"},"StatementOptionType":"V"},{"StatementOptionName":"DECOMP=","StatementOptionHelp":{"#cdata":"[Syntax: DECOMP=(options) ]\n\nEnables the decomposition algorithm and specifies overall control options for the algorithm.\n\n[For decomposition algorithm only]"},"StatementOptionType":"V","SubOptionsKeywords":"\n            |BLOCKS=|ABSOBJGAP=|COMPRESSFREQ=|HYBRID=|INITVARS=|LOGLEVEL=|MAXBLOCKS=|\n            |MAXCOLSPASS=|MAXTIME=|METHOD=|NBLOCKS=|NTHREADS=|RELOBJGAP=|LOGFREQ=|\n            |MASTER_IP_BEG=|MASTER_IP_END=|MASTER_IP_FREQ=|MAXITER=|\n          "},{"StatementOptionName":"DECOMPMASTER=","StatementOptionHelp":{"#cdata":"[Syntax: DECOMPMASTER=(options) ]\n\nSpecifies options for the master problem.\n\n[For decomposition algorithm only]"},"StatementOptionType":"V","SubOptionsKeywords":"\n            |BLOCKS=|ABSOBJGAP=|COMPRESSFREQ=|HYBRID=|INITVARS=|LOGLEVEL=|MAXBLOCKS=|\n            |MAXCOLSPASS=|MAXTIME=|METHOD=|NBLOCKS=|NTHREADS=|RELOBJGAP=|LOGFREQ=|\n            |MASTER_IP_BEG=|MASTER_IP_END=|MASTER_IP_FREQ=|MAXITER=|INITPRESOLVER=|\n            |INITPRESOL=|\n          "},{"StatementOptionName":"DECOMPMASTERIP=","StatementOptionHelp":{"#cdata":"[Syntax: DECOMPMASTERIP=(options) ]\n\nSpecifies options for the (restricted) master problem solved as a MILP with the current set of columns \nin an effort to obtain an integer feasible solution.\n\n[For decomposition algorithm only]"},"StatementOptionType":"V","SubOptionsKeywords":"\n            |BLOCKS=|ABSOBJGAP=|COMPRESSFREQ=|HYBRID=|INITVARS=|LOGLEVEL=|MAXBLOCKS=|\n            |MAXCOLSPASS=|MAXTIME=|METHOD=|NBLOCKS=|NTHREADS=|RELOBJGAP=|LOGFREQ=|\n            |MASTER_IP_BEG=|MASTER_IP_END=|MASTER_IP_FREQ=|MAXITER=|\n          "},{"StatementOptionName":"DECOMPSUBPROB=","StatementOptionHelp":{"#cdata":"[Syntax: DECOMPSUBPROB=(options) ]\n\nSpecifies option for the subproblem.\n\n[For decomposition algorithm only]"},"StatementOptionType":"V","SubOptionsKeywords":"\n            |BLOCKS=|ABSOBJGAP=|COMPRESSFREQ=|HYBRID=|INITVARS=|LOGLEVEL=|MAXBLOCKS=|\n            |MAXCOLSPASS=|MAXTIME=|METHOD=|NBLOCKS=|NTHREADS=|RELOBJGAP=|LOGFREQ=|\n            |MASTER_IP_BEG=|MASTER_IP_END=|MASTER_IP_FREQ=|MAXITER=|\n          "}],"#comment":[{},{},{},{},{},{}]}},{"StatementName":"SOLVE WITH MILP","StatementHelp":{"#cdata":"Syntax: SOLVE WITH MILP < / options > ; \n      \nStatement for specifying and solving mixed integer linear programs (MILPs)."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"RELAXINT","StatementOptionHelp":{"#cdata":"Requests that any integral variables be relaxed to be continuous. RELAXINT can be used \nwith linear and nonlinear problems in addition to any solver."},"StatementOptionType":"RS"},{"StatementOptionName":"OBJECTIVE|OBJ","StatementOptionHelp":{"#cdata":"A keyword used when specifying the name of the objective to use."},"StatementOptionType":"RS"},{"StatementOptionName":"NOOBJECTIVE|NOOBJ","StatementOptionHelp":{"#cdata":"Requests that the solver ignore the current objective for the problem and use a constant zero \nobjective instead. This keyword enables the solver to process the current model as a feasibility \nproblem."},"StatementOptionType":"RS"},{"StatementOptionName":"ABSOBJGAP=","StatementOptionHelp":{"#cdata":"[Syntax: ABSOBJGAP=number] \n          \nSpecifies a stopping criterion. When the absolute difference between the best integer objective \nand the objective of the best node remaining falls below the value of num, the procedure stops. \nThe value of num can be any positive number; the default value is 1E-6."},"StatementOptionType":"V"},{"StatementOptionName":"CUTOFF=","StatementOptionHelp":{"#cdata":"[Syntax: CUTOFF=number] \n          \nCuts off any nodes in a minimization (maximization) problem with an objective value above (below) num. \nThe value of num can be any number; the default value is the positive (negative) number that has the \nlargest absolute value representable in your operating environment."},"StatementOptionType":"V"},{"StatementOptionName":"EMPHASIS=","StatementOptionHelp":{"#cdata":"[Syntax: EMPHASIS=0|1|2 EMPHASIS=BALANCE|OPTIMAL|FEASIBLE ]  \n          \nSpecifies a search emphasis option."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"BALANCE","@Value2":"OPTIMAL","@Value3":"FEASIBLE"},"StatementOptionToolTips":{"@ToolTip1":"Perform a balanced search.","@ToolTip2":"Emphasize optimality over feasibility.","@ToolTip3":"Emphasize feasibility over optimality."}},{"StatementOptionName":"FEASTOL=","StatementOptionHelp":{"#cdata":"[Syntax: FEASTOL=number ]\n\nSpecifies the tolerance that the MILP solver uses to check the feasibility of a solution."},"StatementOptionType":"V"},{"StatementOptionName":"INTTOL=","StatementOptionHelp":{"#cdata":"[Syntax: INTTOL=number] \n          \nSpecifies the amount by which an integer variable value can differ from an integer and still be \nconsidered integer feasible. The value of num can be any number between 0.0 and 1.0; the default \nvalue is 1E-5."},"StatementOptionType":"V"},{"StatementOptionName":"LOGFREQ=|PRINTFREQ=","StatementOptionHelp":{"#cdata":"[Syntax: LOGFREQ=|PRINTFREQ=number] \n          \nSpecifies how often information is printed in the node log. The value of number can be any nonnegative \ninteger up to the largest four-byte signed integer, which is 2\u00b3\u00b9-1."},"StatementOptionType":"V"},{"StatementOptionName":"LOGLEVEL=|PRINTLEVEL2=","StatementOptionHelp":{"#cdata":"[Syntax: LOGLEVEL=number | string   PRINTLEVEL2=number | string\n          \nControls the amount of information displayed in the SAS log by the MILP solver, from a short \ndescription of presolve information and summary to details at each node."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"BASIC","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Turn off all solver-related messages in SAS log.","@ToolTip2":"Display a solver summary after stopping.","@ToolTip3":"Print a solver summary and a node log by using the interval dictated by the PRINTFREQ= option.","@ToolTip4":"Print a detailed solver summary and a node log by using the interval dictated by the PRINTFREQ= option."}},{"StatementOptionName":"MAXNODES=","StatementOptionHelp":{"#cdata":"[Syntax: MAXNODES=number] \n          \nSpecifies the maximum number of branch-and-bound nodes to be processed. The value of num can \nbe any nonnegative integer up to the largest four-byte signed integer, which is 2\u00b3\u00b9-1. \nThe default value is 2\u00b3\u00b9-1."},"StatementOptionType":"V"},{"StatementOptionName":"MAXSOLS=","StatementOptionHelp":{"#cdata":"[Syntax: MAXSOLS=number] \n          \nSpecifies a stopping criterion. If num solutions have been found, then the procedure stops. \nThe value of num can be any positive integer up to the largest four-byte signed integer, \nwhich is 2\u00b3\u00b9-1. The default value is 2\u00b3\u00b9-1."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"[Syntax: MAXTIME=k] \n          \nSpecifies the maximum time allowed for the MILP solver to find a solution."},"StatementOptionType":"V"},{"StatementOptionName":"OPTTOL=","StatementOptionHelp":{"#cdata":"[Syntax: OPTTOL=number ]\n          \nSpecifies the tolerance used to determine the optimality of nodes in the branch-and-bound tree. \nThe value of number can be any value between (and including) 1E\u20134 and 1E\u20139. The default is 1E\u20136."},"StatementOptionType":"V"},{"StatementOptionName":"PROBE=","StatementOptionHelp":{"#cdata":"Specifies a probing option."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Probing strategy determined by the MILP solver.","@ToolTip2":"Disable probing.","@ToolTip3":"Use probing moderately.","@ToolTip4":"Use probing aggressively."}},{"StatementOptionName":"RELOBJGAP=","StatementOptionHelp":{"#cdata":"[Syntax: RELOBJGAP=number] \n          \nSpecifies a stopping criterion based on the best integer objective (BestInteger) and the objective \nof the best remaining node (BestBound)."},"StatementOptionType":"V"},{"StatementOptionName":"SCALE=","StatementOptionHelp":{"#cdata":"Indicates whether or not to scale the problem matrix."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"AUTOMATIC"},"StatementOptionToolTips":{"@ToolTip1":"Disables scaling.","@ToolTip2":"Scales the matrix as determined by the MILP solver. This is the default."}},{"StatementOptionName":"SEED=","StatementOptionHelp":{"#cdata":"[Syntax: SEED=number ]\n\nSpecifies the initial seed of the random number generator."},"StatementOptionType":"V"},{"StatementOptionName":"TARGET=","StatementOptionHelp":{"#cdata":"[Syntax: TARGET=number] \n          \nSpecifies a stopping criterion for minimization (maximization) problems. If the best integer \nobjective is better than or equal to num, the procedure stops. The value of num can be any \nnumber; the default value is the negative (positive) number that has the largest absolute \nvalue representable in your operating environment."},"StatementOptionType":"V"},{"StatementOptionName":"TIMETYPE=","StatementOptionHelp":{"#cdata":"Specifies the measurement of time used by the MILP solver."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"CPU","@Value2":"REAL"},"StatementOptionToolTips":{"@ToolTip1":"Uses CPU time. This is the default.","@ToolTip2":"Uses real time."}},{"StatementOptionName":"ALLCUTS=","StatementOptionHelp":{"#cdata":"[Syntax: ALLCUTS=number | string ]\n          \nProvides a shorthand way of setting all the cuts-related options in one setting. In other words, \nALLCUTS=num is equivalent to setting each of the individual cuts parameters to the same value num."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by the MILP solver.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTCLIQUE=","StatementOptionHelp":{"#cdata":"Specifies the level of clique cuts generated by the MILP solver."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by the MILP solver.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTFLOWCOVER=","StatementOptionHelp":{"#cdata":"Specifies the level of flow cover cuts generated by the MILP solver."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by the MILP solver.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTFLOWPATH=","StatementOptionHelp":{"#cdata":"Specifies the level of flow path cuts generated by the MILP solver."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by the MILP solver.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTGOMORY=","StatementOptionHelp":{"#cdata":"Specifies the level of Gomory cuts generated by the MILP solver."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by the MILP solver.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTGUB=","StatementOptionHelp":{"#cdata":"Specifies the level of generalized upper bound (GUB) cover cuts generated by the MILP solver."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by the MILP solver.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTIMPLIED=","StatementOptionHelp":{"#cdata":"Specifies the level of implied bound cuts generated by the MILP solver."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by the MILP solver.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTKNAPSACK=","StatementOptionHelp":{"#cdata":"Specifies the level of knapsack cover cuts generated by the MILP solver."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by the MILP solver.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTLAP=","StatementOptionHelp":{"#cdata":"Specifies the level of lift-and-project (LAP) cuts generated by the MILP solver."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by the MILP solver.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTMILIFTED=","StatementOptionHelp":{"#cdata":"[Syntax: CUTMILIFTED=number | string ]\n          \nSpecifies the level of mixed lifted 0-1 cuts that are generated by the MILP solver."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by the MILP solver.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTMIR=","StatementOptionHelp":{"#cdata":"Specifies the level of mixed integer rounding (MIR) cuts generated by the MILP solver."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by the MILP solver.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTMULTICOMMODITY=","StatementOptionHelp":{"#cdata":"[Syntax: CUTMULTICOMMODITY=number | string ] \n\nSpecifies the level of multicommodity network flow cuts that are generated by the MILP solver."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by the MILP solver.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTSFACTOR=","StatementOptionHelp":{"#cdata":"[Syntax: CUTSFACTOR=m] \n          \nSpecifies a row multiplier factor for cuts. The number of cuts added is limited to num times the \noriginal number of rows. The value of num can be any nonnegative number less than or equal to 100; \nthe default value is 3.0."},"StatementOptionType":"V"},{"StatementOptionName":"CUTSTRATEGY=|CUTS=","StatementOptionHelp":{"#cdata":"[Syntax: CUTSTRATEGY=number | string  CUTS=number | string ]\n\nSpecifies the overall aggressiveness of the cut generation in the solver. Setting a nondefault value \nadjusts a number of cut parameters such that the cut generation is basic, moderate, or aggressive \ncompared to the default value."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by the MILP solver.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"CUTZEROHALF=","StatementOptionHelp":{"#cdata":"[Syntax: CUTZEROHALF=number | string ] \n\nSpecifies the level of zero-half cuts that are generated by the MILP solver."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by the MILP solver.","@ToolTip2":"Disable generation of cutting planes.","@ToolTip3":"Use a moderate cut strategy.","@ToolTip4":"Use an aggressive cut strategy."}},{"StatementOptionName":"HEURISTICS=","StatementOptionHelp":{"#cdata":"Enables the user to control the level of primal heuristics applied by the MILP solver."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"BASIC","@Value4":"MODERATE","@Value5":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Apply default level of heuristics, similar to MODERATE.","@ToolTip2":"Disable all primal heuristics.","@ToolTip3":"Apply basic primal heuristics at low frequency.","@ToolTip4":"Apply most primal heuristics at moderate frequency.","@ToolTip5":"Apply all primal heuristics at high frequency."}},{"StatementOptionName":"CONFLICTSEARCH=","StatementOptionHelp":{"#cdata":"[Syntax: CONFLICTSEARCH=number | string ]\n\nSpecifies the level of conflict search performed by the MILP solver."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Performs conflict search based on a strategy determined by the MILP solver","@ToolTip2":"Disables conflict search ","@ToolTip3":"Performs a moderate conflict search","@ToolTip4":"Performs an aggressive conflict search"}},{"StatementOptionName":"NODESEL=","StatementOptionHelp":{"#cdata":"[Syntax: NODESEL=number | string ]\n\nSpecifies the node selection strategy string or its corresponding value number.\n          \nSpecifies the node selection strategy option."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"BESTBOUND","@Value3":"BESTESTIMATE","@Value4":"DEPTH"},"StatementOptionToolTips":{"@ToolTip1":"Use automatic node selection.","@ToolTip2":"Choose the node with the best relaxed objective (best-bound-first strategy).","@ToolTip3":"Choose the node with the best estimate of the integer objective value  (best-estimate-first strategy).","@ToolTip4":"Choose the most recently created node (depth-first strategy)."}},{"StatementOptionName":"PRIORITY=","StatementOptionHelp":{"#cdata":"[Syntax: PRIORITY=0 | 1 ]\n \nIndicates whether to use specified branching priorities for integer variables."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"0","@Value2":"1"},"StatementOptionToolTips":{"@ToolTip1":"Ignores variable priorities.","@ToolTip2":"Uses priorities when they exist. This is the default."}},{"StatementOptionName":"RESTARTS=","StatementOptionHelp":{"#cdata":"[Syntax: RESTARTS=number | string ]\n\nSpecifies the strategy for restarting the processing of the root node."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"BASIC","@Value4":"MODERATE","@Value5":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Uses a restarting strategy determined by the MILP solver","@ToolTip2":"Disables restarting","@ToolTip3":"Uses a basic restarting strategy","@ToolTip4":"Uses a moderate restarting strategy","@ToolTip5":"Uses an aggressive restarting strategy"}},{"StatementOptionName":"STRONGITER=","StatementOptionHelp":{"#cdata":"[Syntax: STRONGITER=number | AUTOMATIC ] \n          \nSpecifies the number of simplex iterations performed for each variable in the candidate list when \nusing the strong branching variable selection strategy. The value of num can be any positive number \nup to the largest four-byte signed integer, which is 2^31 - 1. If you specify the keyword AUTOMATIC \nor the value \u20131, the MILP solver uses the default value; this value is calculated automatically."},"StatementOptionType":"V"},{"StatementOptionName":"STRONGLEN=","StatementOptionHelp":{"#cdata":"[Syntax: STRONGLEN=number | AUTOMATIC ] \n          \nSpecifies the number of candidates used when the strong branching variable selection strategy is performed. \nThe value of number can be any positive integer up to the largest four-byte signed integer, which is 2^31 - 1. \nIf you specify the keyword AUTOMATIC or the value \u20131, the MILP solver uses the default value; this value is \ncalculated automatically."},"StatementOptionType":"V"},{"StatementOptionName":"SYMMETRY=","StatementOptionHelp":{"#cdata":"[Syntax: SYMMETRY=-1|0|1|2|3  SYMMETRY=AUTOMATIC|NONE|BASIC|MODERATE|AGGRESSIVE]\n\nSpecifies the level of symmetry detection. Symmetry detection identifies groups of equivalent decision variables \nand uses this information to solve the problem more efficiently.\n"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"BASIC","@Value4":"MODERATE","@Value5":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Performs symmetry detection based on a strategy that is determined by the MILP solver","@ToolTip2":"Disables symmetry detection","@ToolTip3":"Performs a basic symmetry detection","@ToolTip4":"Performs a moderate symmetry detection","@ToolTip5":"Performs an aggressive symmetry detection"}},{"StatementOptionName":"VARSEL=","StatementOptionHelp":{"#cdata":"[Syntax: VARSEL=-1|0|1|2|3|string ]\n          \nSpecifies the rule for selecting the branching variable."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"MAXINFEAS","@Value3":"MININFEAS","@Value4":"PSEUDO","@Value5":"STRONG"},"StatementOptionToolTips":{"@ToolTip1":"Use automatic branching variable selection.","@ToolTip2":"Choose the variable with maximum infeasibility.","@ToolTip3":"Choose the variable with minimum infeasibility.","@ToolTip4":"Choose a branching variable based on pseudocost.","@ToolTip5":"Use strong branching variable selection strategy."}},{"StatementOptionName":"PRESOLVER=","StatementOptionHelp":{"#cdata":"Specifies a presolve option."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"AUTOMATIC","@Value3":"BASIC","@Value4":"MODERATE","@Value5":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Disable presolver.","@ToolTip2":"Apply the default level of presolve processing.","@ToolTip3":"Perform minimal presolve processing.","@ToolTip4":"Apply a higher level of presolve processing.","@ToolTip5":"Apply the highest level of presolve processing."}},{"StatementOptionName":"PRIMALIN","StatementOptionHelp":{"#cdata":"Enables you to input an integer feasible solution in PROC OPTMODEL before invoking the MILP solver. \nAdding the PRIMALIN option to the SOLVE statement requests that the MILP solver use the current \nvariable values as a starting integer feasible solution (warm start). If the MILP solver finds that \nthe input solution is valid, then the input solution provides an incumbent solution and a bound for \nthe branch-and-bound algorithm. If the solution is not valid, then the PRIMALIN data are ignored."},"StatementOptionType":"V"},{"StatementOptionName":"DECOMP=","StatementOptionHelp":{"#cdata":"[Syntax: DECOMP=(options) ]\n\nEnables the decomposition algorithm and specifies overall control options for the algorithm.\n\n[For decomposition algorithm only]"},"StatementOptionType":"V","SubOptionsKeywords":"\n            |BLOCKS=|ABSOBJGAP=|COMPRESSFREQ=|HYBRID=|INITVARS=|LOGLEVEL=|MAXBLOCKS=|\n            |MAXCOLSPASS=|MAXTIME=|METHOD=|NBLOCKS=|NTHREADS=|RELOBJGAP=|LOGFREQ=|\n            |MASTER_IP_BEG=|MASTER_IP_END=|MASTER_IP_FREQ=|MAXITER=|\n          "},{"StatementOptionName":"DECOMPMASTER=","StatementOptionHelp":{"#cdata":"[Syntax: DECOMPMASTER=(options) ]\n\nSpecifies options for the master problem.\n\n[For decomposition algorithm only]"},"StatementOptionType":"V","SubOptionsKeywords":"\n            |BLOCKS=|ABSOBJGAP=|COMPRESSFREQ=|HYBRID=|INITVARS=|LOGLEVEL=|MAXBLOCKS=|\n            |MAXCOLSPASS=|MAXTIME=|METHOD=|NBLOCKS=|NTHREADS=|RELOBJGAP=|LOGFREQ=|\n            |MASTER_IP_BEG=|MASTER_IP_END=|MASTER_IP_FREQ=|MAXITER=|INITPRESOLVER=|\n            |INITPRESOL=|\n          "},{"StatementOptionName":"DECOMPMASTERIP=","StatementOptionHelp":{"#cdata":"[Syntax: DECOMPMASTERIP=(options) ]\n\nSpecifies options for the (restricted) master problem solved as a MILP with the current set of columns \nin an effort to obtain an integer feasible solution.\n\n[For decomposition algorithm only]"},"StatementOptionType":"V","SubOptionsKeywords":"\n            |BLOCKS=|ABSOBJGAP=|COMPRESSFREQ=|HYBRID=|INITVARS=|LOGLEVEL=|MAXBLOCKS=|\n            |MAXCOLSPASS=|MAXTIME=|METHOD=|NBLOCKS=|NTHREADS=|RELOBJGAP=|LOGFREQ=|\n            |MASTER_IP_BEG=|MASTER_IP_END=|MASTER_IP_FREQ=|MAXITER=|\n          "},{"StatementOptionName":"DECOMPSUBPROB=","StatementOptionHelp":{"#cdata":"[Syntax: DECOMPSUBPROB=(options) ]\n\nSpecifies option for the subproblem.\n\n[For decomposition algorithm only]"},"StatementOptionType":"V","SubOptionsKeywords":"\n            |BLOCKS=|ABSOBJGAP=|COMPRESSFREQ=|HYBRID=|INITVARS=|LOGLEVEL=|MAXBLOCKS=|\n            |MAXCOLSPASS=|MAXTIME=|METHOD=|NBLOCKS=|NTHREADS=|RELOBJGAP=|LOGFREQ=|\n            |MASTER_IP_BEG=|MASTER_IP_END=|MASTER_IP_FREQ=|MAXITER=|\n          "}],"#comment":[{},{},{},{},{},{},{}]}},{"StatementName":"SOLVE WITH QP","StatementHelp":{"#cdata":"Syntax: SOLVE WITH QP < / options > ; \n      \nStatement for specifying and solving quadratic programs."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"RELAXINT","StatementOptionHelp":{"#cdata":"Requests that any integral variables be relaxed to be continuous. RELAXINT can be used \nwith linear and nonlinear problems in addition to any solver."},"StatementOptionType":"RS"},{"StatementOptionName":"OBJECTIVE|OBJ","StatementOptionHelp":{"#cdata":"A keyword used when specifying the name of the objective to use."},"StatementOptionType":"RS"},{"StatementOptionName":"NOOBJECTIVE|NOOBJ","StatementOptionHelp":{"#cdata":"Requests that the solver ignore the current objective for the problem and use a constant zero \nobjective instead. This keyword enables the solver to process the current model as a feasibility \nproblem."},"StatementOptionType":"RS"},{"StatementOptionName":"IIS=","StatementOptionHelp":{"#cdata":"IIS=number | string \n\nSpecifies whether the NLP solver attempts to identify a set of linear constraints and variables that form \nan irreducible infeasible set (IIS). \n\nThe default is OFF."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"OFF","@Value2":"ON"},"StatementOptionToolTips":{"@ToolTip1":"Disables IIS detection.","@ToolTip2":"Enables IIS detection."}},{"StatementOptionName":"LOGFREQ=|PRINTFREQ=","StatementOptionHelp":{"#cdata":"[Syntax: LOGFREQ=|PRINTFREQ=k] \n          \nSpecifies that the printing of the solution progress to the iteration log is to occur after every \nk iterations."},"StatementOptionType":"V"},{"StatementOptionName":"MAXITER=","StatementOptionHelp":{"#cdata":"[Syntax: MAXITER=k] \n          \nSpecifies the maximum number of iterations."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"[Syntax: MAXTIME=k] \n          \nSpecifies an upper limit of k seconds of real time for the optimization process."},"StatementOptionType":"V"},{"StatementOptionName":"PRESOLVER=|PRESOL=","StatementOptionHelp":{"#cdata":"[Syntax: PRESOLVER=number | string   PRESOL=number | string ] \n          \nSpecifies one of the following presolve options: \n\nnumber string       Description\n 0      NONE        Disables presolver.\n\u20131      AUTOMATIC   Applies presolver by using default setting.\n \n"},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"AUTOMATIC"},"StatementOptionToolTips":{"@ToolTip1":"Disable presolver.","@ToolTip2":"Apply presolver by using default setting."}},{"StatementOptionName":"STOP_DG=","StatementOptionHelp":{"#cdata":"[Syntax: STOP_DG=\u03b4] \n          \nSpecifies the desired relative duality gap, \u03b4 \u03f5 [1E\u20139, 1E\u20134]. This is the relative difference between \nthe primal and dual objective function values and is the primary solution quality parameter. The default\nvalue is 1E\u20136.\n\n[For interior point algorithm only]"},"StatementOptionType":"V"},{"StatementOptionName":"STOP_DI=","StatementOptionHelp":{"#cdata":"[Syntax: STOP_DI=\u03b2] \n          \nSpecifies the maximum allowed relative dual constraints violation, \u03b2 \u03f5 [1E\u20139, 1E\u20134].\nThe default value is 1E\u20136.\n\n[For interior point algorithm only]"},"StatementOptionType":"V"},{"StatementOptionName":"STOP_PI=","StatementOptionHelp":{"#cdata":"[Syntax: STOP_PI=\u03b1] \n          \nSpecifies the maximum allowed relative bound and primal constraints violation, \u03b1 \u03f5 [1E\u20139, 1E\u20134].\nThe default value is 1E\u20136.\n\n[For interior point algorithm only]"},"StatementOptionType":"V"},{"StatementOptionName":"TIMETYPE=","StatementOptionHelp":{"#cdata":"Syntax: TIMETYPE=number | string \n          \nSpecifies the units of time used by the MAXTIME= option and reported by the PRESOLVE_TIME\nand SOLUTION_TIME terms in the _OROPTMODEL_ macro variable."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"CPU|0","@Value2":"REAL|1"},"StatementOptionToolTips":{"@ToolTip1":"Specifies units of CPU time","@ToolTip2":"Specifies units of real time"}}],"#comment":[{},{},{}]}},{"StatementName":"SOLVE WITH NLPC","StatementHelp":{"#cdata":"Syntax: SOLVE WITH NLPC < / options > ; \n      \nStatement for specifying and solving general nonlinear programming problems."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"RELAXINT","StatementOptionHelp":{"#cdata":"Requests that any integral variables be relaxed to be continuous. RELAXINT can be used \nwith linear and nonlinear problems in addition to any solver."},"StatementOptionType":"RS"},{"StatementOptionName":"OBJECTIVE|OBJ","StatementOptionHelp":{"#cdata":"A keyword used when specifying the name of the objective to use."},"StatementOptionType":"RS"},{"StatementOptionName":"NOOBJECTIVE|NOOBJ","StatementOptionHelp":{"#cdata":"Requests that the solver ignore the current objective for the problem and use a constant zero \nobjective instead. This keyword enables the solver to process the current model as a feasibility \nproblem."},"StatementOptionType":"RS"},{"StatementOptionName":"ABSOPTTOL=","StatementOptionHelp":{"#cdata":"[Syntax: ABSOPTTOL=delta] \n          \nSpecifies the tolerance for the absolute optimality error."},"StatementOptionType":"V"},{"StatementOptionName":"MAXFUNC=","StatementOptionHelp":{"#cdata":"[Syntax: MAXFUNC=N] \n          \nSpecifies that the optimization process stop after a maximum of N function calls."},"StatementOptionType":"V"},{"StatementOptionName":"MAXITER=","StatementOptionHelp":{"#cdata":"[Syntax: MAXITER=N] \n          \nSpecifies that the optimization process stop after a maximum of N iterations."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"[Syntax: MAXTIME=M] \n          \nSpecifies an upper limit of M seconds of real time for the optimization process."},"StatementOptionType":"V"},{"StatementOptionName":"OBJLIMIT=","StatementOptionHelp":{"#cdata":"[Syntax: OBJLIMIT=M] \n          \nSpecifies an upper limit on the magnitude of the objective value. For a minimization problem, \nthe algorithm terminates when the objective value becomes less than -M; for a maximization problem, \\\nthe algorithm stops when the objective value exceeds M."},"StatementOptionType":"V"},{"StatementOptionName":"PRINTFREQ=","StatementOptionHelp":{"#cdata":"[Syntax: PRINTFREQ=j] \n          \nSpecifies that the printing of the solution progress to the iteration log should occur after \nevery j iterations."},"StatementOptionType":"V"},{"StatementOptionName":"RELOPTTOL=","StatementOptionHelp":{"#cdata":"[Syntax: RELOPTTOL=delta] \n          \nSpecifies the tolerance for the relative optimality error."},"StatementOptionType":"V"},{"StatementOptionName":"TECHNIQUE=","StatementOptionHelp":{"#cdata":"Specifies the optimization technique."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"CONGRA","@Value2":"NEWTYP","@Value3":"TRUREG","@Value4":"QUANEW"},"StatementOptionToolTips":{"@ToolTip1":"Uses a conjugate gradient method.","@ToolTip2":"Uses a Newton-type method with line search.","@ToolTip3":"Uses a trust region method.","@ToolTip4":"Uses a quasi-Newton method with the BFGS update. QUANEW is the optimization technique in the NLPC  solver to solve problems with nonlinear constraints."}},{"StatementOptionName":"MAXFEVAL=","StatementOptionHelp":{"#cdata":""},"StatementOptionType":"V"}]}},{"StatementName":"SOLVE WITH NLP","StatementHelp":{"#cdata":"Syntax: SOLVE WITH NLP < / options > ; \n\nwhere options specify the technique name, termination criteria, and how to display the results in the iteration\nlog.\n\nThe sparse nonlinear programming (NLP) solver is a component of the OPTMODEL procedure that can solve\noptimization problems containing both nonlinear equality and inequality constraints."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"RELAXINT","StatementOptionHelp":{"#cdata":"Requests that any integral variables be relaxed to be continuous. RELAXINT can be used \nwith linear and nonlinear problems in addition to any solver."},"StatementOptionType":"RS"},{"StatementOptionName":"OBJECTIVE|OBJ","StatementOptionHelp":{"#cdata":"A keyword used when specifying the name of the objective to use."},"StatementOptionType":"RS"},{"StatementOptionName":"NOOBJECTIVE|NOOBJ","StatementOptionHelp":{"#cdata":"Requests that the solver ignore the current objective for the problem and use a constant zero \nobjective instead. This keyword enables the solver to process the current model as a feasibility \nproblem."},"StatementOptionType":"RS"},{"StatementOptionName":"COVEST=","StatementOptionHelp":{"#cdata":"Syntax: COVEST=(suboptions) ]\n\nRequests that the NLP solver produce a covariance matrix. When this option is applied, the following \nPROC OPTMODEL options are automatically set: PRESOLVER=NONE and SOLTYPE=0. You can specify the following suboptions: \n\nASINGULAR=asing \n  specifies an absolute singularity criterion for measuring the singularity of the Hessian and crossproduct\n  Jacobian and their projected forms, which might have to be inverted to compute the covariance matrix.\nCOV=1|2|3|4|5|6   COV=M|H|J|B|E|U\n  specifies one of six formulas for computing the covariance matrix.\nCOVOUT=parameter \n  specifies the name of the parameter that contains the output covariance matrix. \nCOVSING=covsing \n   specifies a threshold, covsing > 0, that determines whether to consider the eigenvalues of a matrix to be 0.\nMSINGULAR=msing \n    specifies a relative singularity criterion msing > 0 for measuring the singularity of the Hessian \n    and crossproduct Jacobian and their projected forms.\nNDF=ndf \n  specifies a number to be used in calculating the divisor d, which is used in calculating the covariance\n  matrix when VARDEF=DF. \nNTERMS=nterms \n  specifies a number to be used in calculating the scale factor for the covariance matrix.\nSIGSQ=sq \n  specifies a real scalar factor, sq > 0, for computing the covariance matrix.\nVARDEF=DF | N \n  controls how the divisor d is calculated. This divisor is used in calculating the covariance matrix \n  and approximate standard errors."},"StatementOptionType":"V","SubOptionsKeywords":"ASINGULAR=|COV=|COVOUT=|COVSING=|MSINGULAR=|NDF=|NTERMS=|SIGSQ=|VARDEF="},{"StatementOptionName":"MSBNDRANGE=","StatementOptionHelp":{"#cdata":"Syntax: MSBNDRANGE=M \n          \nDefines the range from which each variable can take values during the sampling process. This option\naffects only the sampling process that determines starting points for the local solver. It does not affect\nthe bounds of the original nonlinear optimization problem."},"StatementOptionType":"V"},{"StatementOptionName":"MSDISTTOL=","StatementOptionHelp":{"#cdata":"Syntax: MSDISTTOL=\u03f5\n          \ndefines the tolerance by which two optimal points are considered distinct. Optimal points are considered\ndistinct if the Euclidean distance between them is at least \u03f5. This option is effective only when the\nMULTISTART option is specified. The default is \u03f5=1.0E\u20136."},"StatementOptionType":"V"},{"StatementOptionName":"MSMAXTIME=","StatementOptionHelp":{"#cdata":"Syntax: MSMAXTIME=T \n          \nDefines the maximum allowable time T (in seconds) for the NLP solver to locate the best local\noptimum in multistart mode. The value of the TIMETYPE= option determines the type of units used."},"StatementOptionType":"V"},{"StatementOptionName":"MSMAXSTARTS=","StatementOptionHelp":{"#cdata":"Syntax: MSMAXSTARTS=N \n          \nDefines the maximum number of starting points to be used for local optimization. That is, there will\nbe no more than N local optimization calls in the multistart algorithm. You can specify N to be any\nnonnegative integer. When N = 0, the algorithm uses the default value of this option. In a shared\nmemory computing environment, the default value is 100. In a distributed computing environment, the\ndefault value is a number proportional to the number of threads across all the grid nodes (usually more\nthan 100). This option is effective only when the MULTISTART option is specified."},"StatementOptionType":"V"},{"StatementOptionName":"SEED=","StatementOptionHelp":{"#cdata":"Syntax: SEED=N \n          \nSpecifies a positive integer to be used as the seed for generating random number sequences. You can\nuse this option to replicate results from different runs."},"StatementOptionType":"V"},{"StatementOptionName":"ALGORITHM=|TECHNIQUE=|TECH=|SOLVER=","StatementOptionHelp":{"#cdata":"Specifies the optimization technique to be used to solve the problem."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"INTERIORPOINT","@Value2":"ACTIVESET","@Value3":"CONCURRENT"},"StatementOptionToolTips":{"@ToolTip1":"Uses a primal-dual interior point method. This technique is recommended for both small- and large-scale nonlinear optimization problems. This is the preferred solver if the problem includes a large number of inactive constraints.","@ToolTip2":"Uses a primal-dual active-set method. This technique is recommended for both small- and largescale nonlinear optimization problems. This is the preferred solver if the problem includes only bound constraints or if the optimal active set can be quickly determined by the solver.","@ToolTip3":"Runs the INTERIORPOINT and ACTIVESET techniques in parallel, with one thread using the INTERIORPOINT technique and the other thread using the ACTIVESET technique. The solution is returned by the first method that terminates."}},{"StatementOptionName":"MULTISTART=|MS=","StatementOptionHelp":{"#cdata":"[Syntax: MULTISTART=(suboptions) |  MS=(suboptions) ]\n          \nEnables multistart mode. In this mode, the local solver solves the problem from multiple starting\npoints, possibly finding a better local minimum as a result. This option is disabled by default. \n\nYou can specify the following suboptions: \n BNDRANGE=M \n  defines the range from which each variable can take values during the sampling process.\n DISTTOL=\u025b\n  defines the tolerance by which two optimal points are considered distinct.\n LOGLEVEL=number | PRINTLEVEL=number  \n    defines the amount of information that the multistart algorithm displays in the SAS log. \n MAXTIME=T \n  defines the maximum allowable time T (in seconds) for the NLP solver to locate the best local optimum in multistart mode.\n MAXSTARTS=N \n  defines the maximum number of starting points to be used for local optimization."},"StatementOptionType":"V","SubOptionsKeywords":"BNDRANGE=|DISTTOL=|LOGLEVEL=|PRINTLEVEL=|MAXTIME=|MAXSTARTS="},{"StatementOptionName":"LOGFREQ=|PRINTFREQ=","StatementOptionHelp":{"#cdata":"Syntax: LOGFREQ=N |PRINTFREQ=N\n          \nSpecifies how often the iterations are displayed in the SAS log. N should be an integer between zero\nand the largest four-byte, signed integer, which is 2\u00b3\u00b9 - 1. If N >= 1, the solver prints only those\niterations that are a multiple of N. If N = 0, no iteration is displayed in the log. The default value is 1."},"StatementOptionType":"V"},{"StatementOptionName":"MSLOGLEVEL=|MSPRINTLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: MSLOGLEVEL=number | MSPRINTLEVEL=number \n          \nDefines the amount of information displayed in the SAS log by the MULTISTART option. \n\nThis option is effective only when the MULTISTART option is specified. The default is 2."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"0","@Value2":"1","@Value3":"2","@Value4":"3"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all solver-related messages to SAS log","@ToolTip2":"Displays multistart summary information when the algorithm terminates","@ToolTip3":"Displays multistart iteration log and summary information when the algorithm terminates","@ToolTip4":"Displays the same information as MSLOGLEVEL=2 and might display additional information"}},{"StatementOptionName":"SOLTYPE=","StatementOptionHelp":{"#cdata":"Syntax: SOLTYPE=0 | 1 \n          \nSpecifies whether the NLP solver should return only a solution that is locally optimal. If SOLTYPE=0,\nthe solver returns a locally optimal solution, provided it locates one. If SOLTYPE=1, the solver returns\nthe best feasible solution found, provided its objective value is better than that of the locally optimal\nsolution found. The default is 1."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"0","@Value2":"1"},"StatementOptionToolTips":{"@ToolTip1":"The solver returns a locally optimal solution, provided it locates one.","@ToolTip2":"The solver returns the best feasible solution found, provided its objective value is better  than that of the locally optimal solution found."}},{"StatementOptionName":"FEASTOL=","StatementOptionHelp":{"#cdata":"Syntax: FEASTOL=\u025b\n          \nDefines the feasible tolerance. The solver will exit if the constraint violation is less than FEASTOL and\nthe scaled optimality conditions are less than OPTTOL. The default is \u025b=1E\u20136."},"StatementOptionType":"V"},{"StatementOptionName":"HESSTYPE=","StatementOptionHelp":{"#cdata":"Specifies the type of Hessian to be used by the solver. The valid keywords for this option are FULL\nand PRODUCT. \n\nWhen the solver uses only Hessianvector products to find a search direction, it usually uses much less \nmemory, especially when the problem is large and the Hessian is not sparse. On the other hand, when the \nfull Hessian is used, the algorithm can create a better preconditioner to solve the problem in less CPU \ntime. The default is FULL."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"FULL","@Value2":"PRODUCT"},"StatementOptionToolTips":{"@ToolTip1":"If HESSTYPE=FULL, the solver uses a full Hessian.","@ToolTip2":"If HESSTYPE=PRODUCT, the solver uses only Hessian-vector products, not the full Hessian."}},{"StatementOptionName":"IIS=","StatementOptionHelp":{"#cdata":"IIS=number | string \n\nSpecifies whether the NLP solver attempts to identify a set of linear constraints and variables that form \nan irreducible infeasible set (IIS). \n\nThe default is OFF."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"OFF","@Value2":"ON"},"StatementOptionToolTips":{"@ToolTip1":"Disables IIS detection.","@ToolTip2":"Enables IIS detection."}},{"StatementOptionName":"MAXITER=","StatementOptionHelp":{"#cdata":"Syntax: MAXITER=N \n          \nSpecifies that the solver take at most N major iterations to determine an optimum of the NLP problem.\nThe value of N is an integer between zero and the largest four-byte, signed integer, which is 2\u207f - 1 \n(where n-31). A major iteration in NLP consists of finding a descent direction and a step size along\nwhich the next approximation of the optimum resides. The default is 5,000 iterations."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=t \n          \nSpecifies an upper limit of t units of time for the optimization process, including problem generation\ntime and solution time. The value of the TIMETYPE= option determines the type of units used. If you\ndo not specify the MAXTIME= option, the solver does not stop based on the amount of time elapsed.\nThe value of t can be any positive number; the default value is the positive number that has the largest\nabsolute value that can be represented in your operating environment."},"StatementOptionType":"V"},{"StatementOptionName":"OBJLIMIT=","StatementOptionHelp":{"#cdata":"Syntax: OBJLIMIT=M \n          \nSpecifies an upper limit on the magnitude of the objective value. For a minimization problem, \nthe algorithm terminates when the objective value becomes less than -M; for a maximization problem, \\\nthe algorithm stops when the objective value exceeds M. The algorithm stopping implies that either the\nproblem is unbounded or the algorithm diverges. If optimization were allowed to continue, numerical\ndifficulty might be encountered. The default is M=1E+20. The minimum acceptable value of M is\n1E+8. If the specified value of M is less than 1E+8, the value is reset to the default value 1E+20."},"StatementOptionType":"V"},{"StatementOptionName":"OPTTOL=|RELOPTTOL=","StatementOptionHelp":{"#cdata":"Syntax: OPTTOL=\u03f5 |RELOPTTOL=\u025b \n          \nDefines the measure by which you can decide whether the current iterate is an acceptable approximation\nof a local minimum. The value of this option is a positive real number. The NLP solver determines that\nthe current iterate is a local minimum when the norm of the scaled vector of the optimality conditions\nis less than \u03f5 and the true constraint violation is less than FEASTOL. The default is \u025b=1E\u20136."},"StatementOptionType":"V"},{"StatementOptionName":"TIMETYPE=","StatementOptionHelp":{"#cdata":"Syntax: TIMETYPE=number | string \n          \nSpecifies the units of time used by the MAXTIME= option and reported by the PRESOLVE_TIME\nand SOLUTION_TIME terms in the _OROPTMODEL_ macro variable."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"CPU|0","@Value2":"REAL|1"},"StatementOptionToolTips":{"@ToolTip1":"Specifies units of CPU time","@ToolTip2":"Specifies units of real time"}}]}},{"StatementName":"SOLVE WITH NLPU","StatementHelp":{"#cdata":"Syntax: SOLVE WITH NLPU < / options > ; \n      \nStatement for specifying and solving unconstrained nonlinear programming problems."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"RELAXINT","StatementOptionHelp":{"#cdata":"Requests that any integral variables be relaxed to be continuous. RELAXINT can be used \nwith linear and nonlinear problems in addition to any solver."},"StatementOptionType":"RS"},{"StatementOptionName":"OBJECTIVE|OBJ","StatementOptionHelp":{"#cdata":"A keyword used when specifying the name of the objective to use."},"StatementOptionType":"RS"},{"StatementOptionName":"NOOBJECTIVE|NOOBJ","StatementOptionHelp":{"#cdata":"Requests that the solver ignore the current objective for the problem and use a constant zero \nobjective instead. This keyword enables the solver to process the current model as a feasibility \nproblem."},"StatementOptionType":"RS"},{"StatementOptionName":"LBFGSCORR=","StatementOptionHelp":{"#cdata":"[Syntax: LBFGSCORR=n] \n          \nSpecifies the number of Hessian corrections for the L-BFGS algorithms. The value of n can be \nany integer between 2 and 100. The default value is 7 corrections."},"StatementOptionType":"V"},{"StatementOptionName":"LSARMIJO=","StatementOptionHelp":{"#cdata":"[Syntax: LSARMIJO=c1] \n          \nSpecifies the Armijo parameter c1 for the line-search technique. The default value is 2.0E-3."},"StatementOptionType":"V"},{"StatementOptionName":"LSWOLFE=","StatementOptionHelp":{"#cdata":"[Syntax: LSWOLFE=c2] \n          \nSpecifies the Wolfe parameter c2 for the line-search technique. The default value is 0.7."},"StatementOptionType":"V"},{"StatementOptionName":"LSMAXITER=","StatementOptionHelp":{"#cdata":"[Syntax: MAXITER=N] \n          \nSpecifies the maximum number of line-search iterations within one L-BFGS or conjugate \ngradient method."},"StatementOptionType":"V"},{"StatementOptionName":"MAXITER=","StatementOptionHelp":{"#cdata":"[Syntax: MAXITER=N] \n          \nSpecifies that the optimization process stop after a maximum of N iterations."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"[Syntax: MAXTIME=M] \n          \nSpecifies an upper limit of M seconds of real time for the optimization process."},"StatementOptionType":"V"},{"StatementOptionName":"OPTTOL=","StatementOptionHelp":{"#cdata":"[Syntax: OPTTOL=\u03b5] \n          \nSpecifies the desired tolerance of the relative gradient norm."},"StatementOptionType":"V"},{"StatementOptionName":"OBJLIMIT=","StatementOptionHelp":{"#cdata":"[Syntax: OBJLIMIT=M] \n          \nSpecifies an upper limit on the magnitude of the objective value. For a minimization problem, \nthe algorithm terminates when the objective value becomes less than -M; for a maximization problem, \nthe algorithm stops when the objective value exceeds M."},"StatementOptionType":"V"},{"StatementOptionName":"PRINTFREQ=","StatementOptionHelp":{"#cdata":"[Syntax: PRINTFREQ=j] \n          \nSpecifies that the printing of the solution progress to the iteration log should occur after \nevery j iterations."},"StatementOptionType":"V"},{"StatementOptionName":"TECHNIQUE=","StatementOptionHelp":{"#cdata":"Specifies the optimization technique."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"FLETREEV","@Value2":"LBFGS","@Value3":"POLRIB","@Value4":"CGTR"},"StatementOptionToolTips":{"@ToolTip1":"Uses the Fletcher-Reeves nonlinear conjugate gradient algorithm.","@ToolTip2":"Uses the limited-memory Broyden-Fletcher-Goldfarb-Shanno algorithm.  This is the default solver.","@ToolTip3":"Uses the Polak-Ribi\u00e8re nonlinear conjugate gradient algorithm.","@ToolTip4":"Uses the conjugate gradient method and a trust-region method to solve bound-constrained  optimization problems."}}]}},{"StatementName":"SOLVE WITH SQP","StatementHelp":{"#cdata":"Syntax: SOLVE WITH SQP < / options > ; \n      \nThe sequential quadratic programming (SQP) solver is a component of the OPTMODEL procedure, and it can be used\nfor solving general nonlinear programming (NLP) problems. "},"StatementOptions":{"StatementOption":[{"StatementOptionName":"RELAXINT","StatementOptionHelp":{"#cdata":"Requests that any integral variables be relaxed to be continuous. RELAXINT can be used \nwith linear and nonlinear problems in addition to any solver."},"StatementOptionType":"RS"},{"StatementOptionName":"OBJECTIVE|OBJ","StatementOptionHelp":{"#cdata":"A keyword used when specifying the name of the objective to use."},"StatementOptionType":"RS"},{"StatementOptionName":"NOOBJECTIVE|NOOBJ","StatementOptionHelp":{"#cdata":"Requests that the solver ignore the current objective for the problem and use a constant zero \nobjective instead. This keyword enables the solver to process the current model as a feasibility \nproblem."},"StatementOptionType":"RS"},{"StatementOptionName":"HESCHECK","StatementOptionHelp":{"#cdata":"Specifies that the solver check the second-order optimality of the solution found - i.e., the \nnonnegativity of the projected Hessian of the Lagrangian function at the solution."},"StatementOptionType":"S"},{"StatementOptionName":"NOHESCHECK","StatementOptionHelp":{"#cdata":"Specifies that the solver does not check the second-order optimality of the solution found."},"StatementOptionType":"V"},{"StatementOptionName":"MAXITER=","StatementOptionHelp":{"#cdata":"[Syntax: MAXITER=N] \n          \nSpecifies that the optimization process stop after a maximum of N iterations."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"[Syntax: MAXTIME=r] \n          \nSpecifies an upper limit of r seconds of real time for the optimization process."},"StatementOptionType":"V"},{"StatementOptionName":"PENALTY=","StatementOptionHelp":{"#cdata":"[Syntax: PENALTY=\u03b3] \n          \nSpecifies the rate at which the penalty parameters used in the Lagrangian function are reduced. \nThe default value for the PENALTY= option is 0.75."},"StatementOptionType":"V"},{"StatementOptionName":"OPTTOL=","StatementOptionHelp":{"#cdata":"[Syntax: OPTTOL=\u03b5] \n          \nSpecifies the convergence tolerance for both stationary and complementary conditions. The value \nof this option is a positive real number. The default value is 1E-5."},"StatementOptionType":"V"},{"StatementOptionName":"PRINTFREQ=","StatementOptionHelp":{"#cdata":"[Syntax: PRINTFREQ=j] \n          \nSpecifies that the printing of the solution progress to the iteration log should occur after \nevery j iterations."},"StatementOptionType":"V"},{"StatementOptionName":"FEASTOL=","StatementOptionHelp":{"#cdata":"[Syntax: FEASTOL=\u03b5] \n          \nSpecifies the convergence tolerance for feasibility. The value of this option is a positive \nreal number. The default value is 1E-6."},"StatementOptionType":"V"}]}},{"StatementName":"SOLVE WITH IPNLP","StatementHelp":{"#cdata":"Syntax: SOLVE WITH IPNLP < / options > ; \n      \nThe interior point nonlinear programming (IPNLP) solver component of the OPTMODEL procedure \ncan solve nonlinear programming (NLP) problems that contain both nonlinear equality and \ninequality constraints."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"RELAXINT","StatementOptionHelp":{"#cdata":"Requests that any integral variables be relaxed to be continuous. RELAXINT can be used \nwith linear and nonlinear problems in addition to any solver."},"StatementOptionType":"RS"},{"StatementOptionName":"OBJECTIVE|OBJ","StatementOptionHelp":{"#cdata":"A keyword used when specifying the name of the objective to use."},"StatementOptionType":"RS"},{"StatementOptionName":"NOOBJECTIVE|NOOBJ","StatementOptionHelp":{"#cdata":"Requests that the solver ignore the current objective for the problem and use a constant zero \nobjective instead. This keyword enables the solver to process the current model as a feasibility \nproblem."},"StatementOptionType":"RS"},{"StatementOptionName":"MAXITER=","StatementOptionHelp":{"#cdata":"[Syntax: MAXITER=N] \n          \nSpecifies that the solver take at most N major iterations to determine an optimum of \nthe NLP problem. The value of N is an integer between zero and the largest four-byte, \nsigned integer, which is 2^31-1. A major iteration in IPNLP consists of finding a \ndescent direction and a step size along which the next approximation of the optimum \nwill reside. The default value of N is 5,000 iterations."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"[Syntax: MAXTIME=T] \n          \nSpecifies an upper limit of T seconds of real time for the solver to find a local \noptimum. Note that the time specified by the MAXTIME= option is checked only once \nat the end of each major iteration. The default value is 7,200 seconds (two hours)."},"StatementOptionType":"V"},{"StatementOptionName":"OBJLIMIT=","StatementOptionHelp":{"#cdata":"[Syntax: OBJLIMIT=M] \n          \nSpecifies an upper limit on the magnitude of the objective value. For a minimization problem, \nthe algorithm terminates when the objective value becomes less than -M; for a maximization problem, \nthe algorithm stops when the objective value exceeds M."},"StatementOptionType":"V"},{"StatementOptionName":"OPTOL=|RELOPTOL=","StatementOptionHelp":{"#cdata":"[Syntax: OPTOL=\u0454 |RELOPTOL=\u0454] \n          \nDefines the measure by which you can decide whether the current iterate is an acceptable \napproximation of a local minimum. The value of this option is a positive real number. The \nIPNLP solver determines that the current iterate is a local minimum when the norm of the \nscaled vector of the optimality conditions is less than \u0454. The default value is \u0454=1E\u20136."},"StatementOptionType":"V"},{"StatementOptionName":"TECHNIQUE=|TECH=|SOLVER=","StatementOptionHelp":{"#cdata":"Specifies the optimization technique."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"IPKRYLOV","@Value2":"IPQN"},"StatementOptionToolTips":{"@ToolTip1":"Uses a trust-region interior point method. This technique is recommended for large-scale  optimization problems (that is, problems with many variables and constraints).","@ToolTip2":"Uses a quasi-Newton interior point method. This technique can efficiently solve  small-to-medium size optimization problems (that is, problems that contain up to  1,000 variables and constraints). It is recommended for problems whose second  derivatives are computationally expensive to compute."}}]}},{"StatementName":"SOLVE WITH CLP","StatementHelp":{"#cdata":"Syntax: SOLVE WITH CLP < / options > ; \n      \nThe SOLVE WITH CLP statement invokes the CLP solver."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"RELAXINT","StatementOptionHelp":{"#cdata":"Requests that any integral variables be relaxed to be continuous. RELAXINT can be used \nwith linear and nonlinear problems in addition to any solver."},"StatementOptionType":"RS"},{"StatementOptionName":"OBJECTIVE|OBJ","StatementOptionHelp":{"#cdata":"A keyword used when specifying the name of the objective to use."},"StatementOptionType":"RS"},{"StatementOptionName":"NOOBJECTIVE|NOOBJ","StatementOptionHelp":{"#cdata":"Requests that the solver ignore the current objective for the problem and use a constant zero \nobjective instead. This keyword enables the solver to process the current model as a feasibility \nproblem."},"StatementOptionType":"RS"},{"StatementOptionName":"FINDALLSOLNS|ALLSOLNS|FINDALL","StatementOptionHelp":{"#cdata":"Syntax: FINDALLSOLNS | ALLSOLNS | FINDALL  \n\nAttempts to find all possible solutions to the CSP."},"StatementOptionType":"S"},{"StatementOptionName":"MAXSOLNS=","StatementOptionHelp":{"#cdata":"[Syntax: MAXSOLNS=number]\n\nSpecifies the number of solution attempts to be generated for the CSP. By default, MAXSOLNS=1."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"[Syntax: MAXTIME=number \n\nSpecifies the maximum time to spend calculating results. The type of time (either CPU time or real time) \nis determined by the value of the TIMETYPE= option. The value of number can be any positive number; the \ndefault value is the positive number that has the largest absolute value that can be represented in your \noperating environment."},"StatementOptionType":"V"},{"StatementOptionName":"NOPREPROCESS","StatementOptionHelp":{"#cdata":"[Suppresses any preprocessing that would usually be performed for the problem."},"StatementOptionType":"S"},{"StatementOptionName":"OBJTOL=","StatementOptionHelp":{"#cdata":"[Syntax: OBJTOL=number \n\nSpecifies the tolerance of the objective value. By default, OBJTOL=1E\u20136."},"StatementOptionType":"V"},{"StatementOptionName":"PREPROCESS","StatementOptionHelp":{"#cdata":"[Permits any preprocessing that would usually be performed for the problem."},"StatementOptionType":"S"},{"StatementOptionName":"SHOWPROGRESS","StatementOptionHelp":{"#cdata":"Prints a message to the log whenever a solution is found."},"StatementOptionType":"S"},{"StatementOptionName":"TIMETYPE=","StatementOptionHelp":{"#cdata":"[Syntax: TIMETYPE=number | string ]\n\nSpecifies whether to use CPU time or real time for the MAXTIME= option. The following describes the valid \nvalues of the TIMETYPE= option. \n\nnumber  string  Description \n0         CPU   Specifies units of CPU time \n1         REAL  Specifies units of real time \n\nBy default, TIMETYPE=REAL if the CLP solver is invoked in a PROC OPTMODEL COFOR loop; otherwise, the default \nis TIMETYPE=CPU."},"StatementOptionType":"V"},{"StatementOptionName":"VARASSIGN=","StatementOptionHelp":{"#cdata":"[Syntax: VARASSIGN=string]\n\nSpecifies the variable assignment strategy. You can specify two value selection strategies: \n\n  MAX, which selects the maximum value from the domain of the selected variable \n  MIN, which selects the minimum value from the domain of the selected variable \n\nBy default, VARASSIGN=MIN."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"MAX","@Value2":"MIN"},"StatementOptionToolTips":{"@ToolTip1":"Selects the maximum value from the domain of the selected variable.","@ToolTip2":"Selects the minimum value from the domain of the selected variable."}},{"StatementOptionName":"VARSELECT=","StatementOptionHelp":{"#cdata":"[Syntax: VARSELECT=string ]\n\nSpecifies the variable selection strategy. The strategy could be static, dynamic, or conflict-directed. \nTypically, static strategies exploit information about the initial state of the search, whereas dynamic \nstrategies exploit information about the current state of the search process. Conflict-directed strategies \nexploit information from previous states of the search process as well as the current state (Boussemart \net al. 2004)."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"FIFO","@Value2":"MAXCS","@Value3":"DOMDDEG","@Value4":"DOMDEG","@Value5":"MAXC","@Value6":"MINR","@Value7":"MINRMAXC","@Value8":"DOMWDEG","@Value9":"WDEG"},"StatementOptionToolTips":{"@ToolTip1":"Uses the first-in, first-out ordering of the variables as encountered by the procedure after adjusting for the values in the .priority suffix","@ToolTip2":"Selects the variable that has the maximum number of constraints ","@ToolTip3":"Selects the variable that has the smallest ratio of domain size to dynamic degree ","@ToolTip4":"Selects the variable that has the smallest ratio of domain size to degree ","@ToolTip5":"Selects the variable that has the largest number of active constraints ","@ToolTip6":"Selects the variable that has the smallest range (that is, the minimum value of the upper bound minus the lower bound)","@ToolTip7":"Selects the variable that has the smallest range, breaking ties by selecting one that has the largest number of active constraints","@ToolTip8":"Selects the variable that has the smallest ratio of domain size to weighted degree","@ToolTip9":"Selects the variable that has the largest weighted degree"}}]}},{"StatementName":"SOLVE WITH NETWORK","StatementHelp":{"#cdata":"Syntax: SOLVE WITH NETWORK < / options > ; \n      \nThe SOLVE WITH NETWORK statement invokes the network solver."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"RELAXINT","StatementOptionHelp":{"#cdata":"Requests that any integral variables be relaxed to be continuous. RELAXINT can be used \nwith linear and nonlinear problems in addition to any solver."},"StatementOptionType":"RS"},{"StatementOptionName":"OBJECTIVE|OBJ","StatementOptionHelp":{"#cdata":"A keyword used when specifying the name of the objective to use."},"StatementOptionType":"RS"},{"StatementOptionName":"NOOBJECTIVE|NOOBJ","StatementOptionHelp":{"#cdata":"Requests that the solver ignore the current objective for the problem and use a constant zero \nobjective instead. This keyword enables the solver to process the current model as a feasibility \nproblem."},"StatementOptionType":"RS"},{"StatementOptionName":"GRAPH_DIRECTION=|DIRECTION=","StatementOptionHelp":{"#cdata":"Syntax: GRAPH_DIRECTION=DIRECTED | UNDIRECTED \nSyntax:  DIRECTION=DIRECTED | UNDIRECTED \n\nSpecifies directed or undirected graphs."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"DIRECTED","@Value2":"UNDIRECTED"},"StatementOptionToolTips":{"@ToolTip1":"Requests a directed graph.","@ToolTip2":"Requests an undirected graph."}},{"StatementOptionName":"INCLUDE_SELFLINK","StatementOptionHelp":{"#cdata":"Includes self links in the graph definition\u2014for example, $(i,i)$\u2014when an input graph is read. By default, \nwhen the network solver reads the LINKS= data, it removes all self links."},"StatementOptionType":"S"},{"StatementOptionName":"LOGFREQ=","StatementOptionHelp":{"#cdata":"[Syntax: LOGFREQ=number ]\n\nControls the frequency with which an algorithm reports progress from its underlying solver. This setting \nis recognized by the traveling salesman problem and minimum-cost flow algorithms. You can set number to 0\nto turn off log updates from underlying algorithms."},"StatementOptionType":"V"},{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"[Syntax: LOGLEVEL=number | string ]\n\nControls the amount of information that is displayed in the SAS log. This setting sets the log level for all algorithms.\nThe following describes the valid values of the this option. \n\nnumber    string      Description \n0         NONE        Turns off all procedure-related messages in the SAS log \n1         BASIC       Displays a basic summary of the input, output, and algorithmic processing  \n2         MODERATE    Displays a summary of the input, output, and algorithmic processing \n3         AGGRESSIVE  Displays a detailed summary of the input, output, and algorithmic processing \n\nBy default, TIMETYPE=REAL if the CLP solver is invoked in a PROC OPTMODEL COFOR loop; otherwise, the default \nis TIMETYPE=CPU."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"[Syntax: MAXTIME=number \n\nSpecifies the maximum time to spend calculating results. The type of time (either CPU time or real time) \nis determined by the value of the TIMETYPE= option. The value of number can be any positive number; the \ndefault value is the positive number that has the largest absolute value that can be represented in your \noperating environment."},"StatementOptionType":"V"},{"StatementOptionName":"TIMETYPE=","StatementOptionHelp":{"#cdata":"[Syntax: TIMETYPE=number | string ]\n\nSpecifies whether to use CPU time or real time for the MAXTIME= option. The following describes the valid \nvalues of the TIMETYPE= option. \n\nnumber  string  Description \n0         CPU   Specifies units of CPU time \n1         REAL  Specifies units of real time \n\nBy default, TIMETYPE=REAL if the CLP solver is invoked in a PROC OPTMODEL COFOR loop; otherwise, the default \nis TIMETYPE=CPU."},"StatementOptionType":"V"},{"StatementOptionName":"LINKS=","StatementOptionHelp":{"#cdata":"[Syntax: LINKS=( suboptions ) \n\nGroups link-indexed data. You can specify the following suboptions:  \n\nINCLUDE=set-name \n names a set of links to include in the graph definition even if no weights or bounds are available for them.\n\nLOWER=array-name \n specifies the flow lower bound for each link. The array must be numeric, and it must be indexed over a subset \n of the inks of the graph. \n\nUPPER=array-name \n specifies the flow upper bound for each link. The array must be numeric, and it must be indexed over a subset \n of the links of the graph. \n\nWEIGHT=array-name \n specifies link weights. The array must be numeric, and it must be indexed over a subset of the links of the \n graph. If you specify this suboption, then any link that does not appear in the index set of the WEIGHT= array \n has weight 0. If you do not specify this suboption, then every link has weight 1."},"StatementOptionType":"V","SubOptionsKeywords":"INCLUDE=|LOWER=|UPPER=|WEIGHT="},{"StatementOptionName":"NODES=","StatementOptionHelp":{"#cdata":"[Syntax: NODES=( suboptions ) ] \n\n\nGroups node-indexed data. You can specify the following suboptions: \n\nINCLUDE=set-name \n names a set of nodes to include in the graph definition even if no weights are available for them.  \n\nWEIGHT=array-name \n specifies node weights. The array must be numeric, and it must be indexed over a subset of the nodes \n of the graph. \n\nWEIGHT2=array-name \n specifies node supply upper bounds in the minimum-cost network flow problem. The array must be numeric, \n and it must be indexed over a subset of the nodes of the graph."},"StatementOptionType":"V","SubOptionsKeywords":"INCLUDE=|WEIGHT=|WEIGHT2="},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"[Syntax: OUT=( suboptions ) ]\n\nSpecifies the output sets or arrays for each algorithm. You can specify the following suboptions:\n\nARTPOINTS=set-name \n specifies the output set for articulation points. \nASSIGNMENTS=set-name \n specifies the output set for linear assignment. \nBICONCOMP=array-name \n specifies the array to contain the biconnected component of each link. This suboption is used \n with the BICONCOMP algorithm option. \nCLIQUES=set-name \n specifies the output set for cliques. Each tuple of the set represents clique ID and node ID. \n This suboption is used with the CLIQUE algorithm option. \nCONCOMP=array-name \n specifies the output array for connected components. This suboption is used with the CONCOMP algorithm option. \nCUTSETS=set-name \n specifies the output set for the cut-sets for minimum cuts. Each tuple of the set represents the cut ID, \n the tail node ID, and the head node ID. This suboption is used with the MINCUT algorithm option. \nCYCLES=set-name \n specifies the output set for cycles. Each tuple of the set represents a cycle ID, the order within that cycle, \n and the node ID. This suboption is used with the CYCLE algorithm option. \nFLOW=array-name \n specifies the output array for the flow on each link. This suboption is used with the MINCOSTFLOW algorithm option. \nFOREST=set-name \n specifies the output set for the minimum spanning tree (forest). This suboption is used with the MINSPANTREE algorithm option. \nLINKS=set-name \n specifies the output set for the links that remain after the SUBGRAPH= option is applied.\nNODES=set-name \n specifies the output set for the nodes that remain after the SUBGRAPH= option is applied.\nORDER=array-name \n specifies the numeric array to contain the position of each node within the optimal tour. This suboption is used with the TSP algorithm option. \nPARTITIONS=set-name \n specifies the output set for the partitions for minimum cuts. \nSPPATHS=set-name \n specifies the set to contain the link sequence for each path.\nSPWEIGHTS=array-name \n specifies the numeric array to contain the path weight for each source and sink node pair. This suboption is used with the SHORTPATH algorithm option. \nTOUR=set-name \n specifies the output set for the tour in the traveling salesman problem. This suboption is used with the TSP algorithm option. \nTRANSCL=set-name \n specifies the set to contain the pairs (u,v) of nodes where v is reachable from u. This suboption is used with the TRANSITIVE_CLOSURE algorithm option."},"StatementOptionType":"V","SubOptionsKeywords":"ARTPOINTS=|ASSIGNMENTS=|BICONCOMP=|CLIQUES=|CONCOMP=|CUTSETS=|CYCLES=|FLOW=|FOREST=|LINKS=|NODES=|ORDER=|PARTITIONS=|SPPATHS=|TOUR=|SPWEIGHTS=|TRANSCL="},{"StatementOptionName":"SUBGRAPH=","StatementOptionHelp":{"#cdata":"[Syntax: SUBGRAPH=( suboptions ) ]\n\nSpecifies the input sets that enable you to solve a problem over a subgraph. You can specify the following suboptions: \n\nLINKS=set-name \n specifies the subset of links to use. If you specify a node pair that is not referenced in any of the suboptions \n of the LINKS= option, then the network solver returns an error. \n\nNODES=set-name \n specifies the subset of nodes to use. If you specify a node that is not referenced in any of the suboptions of the\n LINKS= option or the NODES= option, then the network solver returns an error."},"StatementOptionType":"V","SubOptionsKeywords":"LINKS=|NODES="},{"StatementOptionName":"BICONCOMP","StatementOptionHelp":{"#cdata":"[Syntax: BICONCOMP<=() > ]\n\nFinds biconnected components and articulation points of an undirected input graph."},"StatementOptionType":"S|V"},{"StatementOptionName":"CLIQUE","StatementOptionHelp":{"#cdata":"[Syntax: CLIQUE<=( suboption ) > ]\n\nFinds maximal cliques in the input graph. You can specify the following suboption: \n\nMAXCLIQUES=number \n specifies the maximum number of cliques to return. The default is the positive number that has the largest \n absolute value that can be represented in your operating environment."},"StatementOptionType":"S|V","SubOptionsKeywords":"MAXCLIQUES="},{"StatementOptionName":"CONCOMP","StatementOptionHelp":{"#cdata":"[Syntax: CONCOMP<=( suboption ) > ]\n\nFinds the connected components of the input graph. You can specify the following suboption: \n\nALGORITHM=DFS | UNION_FIND \n  specifies the algorithm to use for calculating connected components  \n  \n  DFS\n    Uses the depth-first search algorithm for connected components. \n \n  UNION_FIND \n    Uses the union-find algorithm for connected components. You can use ALGORITHM=UNION_FIND only with \n    undirected graphs."},"StatementOptionType":"S|V","SubOptionsKeywords":"ALGORITHM="},{"StatementOptionName":"CYCLE","StatementOptionHelp":{"#cdata":"[Syntax: CYCLE<=( suboptions ) > ]\n\nFinds the cycles (or the existence of a cycle) in the input graph. You can specify the following suboptions in the CYCLE= option: \n\nMAXCYCLES=number \n specifies the maximum number of cycles to return. \nMAXLENGTH=number \n specifies the maximum number of links to allow in a cycle. \nMAXLINKWEIGHT=number \n specifies the maximum sum of link weights to allow in a cycle. \nMAXNODEWEIGHT=number \n specifies the maximum sum of node weights to allow in a cycle. \nMINLENGTH=number \n specifies the minimum number of links to allow in a cycle. \nMINLINKWEIGHT=number \n specifies the minimum sum of link weights to allow in a cycle. \nMINNODEWEIGHT=number \n specifies the minimum sum of node weights to allow in a cycle. \nMODE=ALL_CYCLES | FIRST_CYCLE \n specifies whether to stop after finding the first cycle. \n  ALL_CYCLES Returns all (unique, elementary) cycles found. \n  FIRST_CYCLE Returns the first cycle found."},"StatementOptionType":"V","SubOptionsKeywords":"MAXCYCLES=|MAXLENGTH=|MAXLINKWEIGHT=|MAXNODEWEIGHT=|MINLENGTH=|MINLINKWEIGHT=|MINNODEWEIGHT=|MODE="},{"StatementOptionName":"LINEAR_ASSIGNMENT","StatementOptionHelp":{"#cdata":"[Syntax: LINEAR_ASSIGNMENT<=() > ] LAP<=() >  \n\nSolves the minimal-cost linear assignment problem. In graph terms, this problem is also known as the minimum \nlink-weighted matching problem on a bipartite directed graph. The input data (the cost matrix) is defined as \na directed graph by specifying the LINKS= option in the SOLVE WITH NETWORK statement, where the costs are defined \nas link weights. Internally, the graph is treated as a bipartite directed graph."},"StatementOptionType":"S|V","SubOptionsKeywords":"LAP"},{"StatementOptionName":"MINCOSTFLOW","StatementOptionHelp":{"#cdata":"[Syntax: MINCOSTFLOW<=() > MCF<=() > ]\n\nSolves the minimum-cost network flow problem. \n"},"StatementOptionType":"S|V","SubOptionsKeywords":"MCF"},{"StatementOptionName":"MINCUT","StatementOptionHelp":{"#cdata":"[Syntax: MINCUT<=( suboptions ) > ]\n\nFinds the minimum link-weighted cut of an input graph. You can specify the following suboptions in the MINCUT= option: \n\nMAXNUMCUTS=number \n specifies the maximum number of cuts to return from the algorithm. The minimal cut and any others found \n during the search, up to number, are returned. By default, MAXNUMCUTS=1. \n\nMAXWEIGHT=number \n specifies the maximum weight of the cuts to return from the algorithm. Only cuts that have weight less \n than or equal to number are returned. The default is the positive number that has the largest absolute value that can be represented in your operating environment. \n"},"StatementOptionType":"S|V","SubOptionsKeywords":"MAXNUMCUTS=|MAXWEIGHT="},{"StatementOptionName":"MINSPANTREE","StatementOptionHelp":{"#cdata":"[Syntax: MINSPANTREE<=() > MST<=() > ]\n\nSolves the minimum link-weighted spanning tree problem on an input graph."},"StatementOptionType":"S|V","SubOptionsKeywords":"MST"},{"StatementOptionName":"SHORTPATH","StatementOptionHelp":{"#cdata":"[Syntax: SHORTPATH<=( suboptions ) > ]\n\nCalculates shortest paths between sets of nodes on the input graph. You can specify the following suboptions: \n\nPATHS=ALL | LONGEST | SHORTEST \n specifies the type of output for shortest paths results.\n \n  ALL \n    Outputs shortest paths for all pairs of source-sinks. \n  LONGEST  \n    Outputs shortest paths for the source-sink pair that has the longest (finite) length. \n  SHORTEST \n    Outputs shortest paths for the source-sink pair that has the shortest length.\n    \n  By default, SHORTPATH=ALL.\n  \nSINK=set-name  \n specifies the set of sink nodes. \nSOURCE=set-name  \n specifies the set of source nodes. \nUSEWEIGHT=YES | NO \n specifies whether to use weights in calculating shortest paths."},"StatementOptionType":"S|V","SubOptionsKeywords":"PATHS=|SINK=|SOURCE=|USEWEIGHT="},{"StatementOptionName":"TRANSITIVE_CLOSURE","StatementOptionHelp":{"#cdata":"[Syntax: TRANSITIVE_CLOSURE<=() > TRANSCL<=() > ]\n\nCalculates the transitive closure of an input graph."},"StatementOptionType":"S|V","SubOptionsKeywords":"TRANSCL"},{"StatementOptionName":"TSP","StatementOptionHelp":{"#cdata":"[Syntax: TSP<=( suboptions ) > ]\n\nSolves the traveling salesman problem. The algorithm that is used to solve this problem is built around \nthe same method as is used in PROC OPTMILP: a branch-and-cut algorithm. Many of the following suboptions \nare the same as those described for the OPTMILP procedure in the SAS/OR User's Guide: Mathematical Programming. \n\nYou can specify the following suboptions: \n\n  ABSOBJGAP=number \n    specifies a stopping criterion.\n  CONFLICTSEARCH=-1|0|1|2  CONFLICTSEARCH=AUTOMATIC|NONE|MODERATE|AGGRESSIVE\n   specifies the level of conflict search that the network solver performs.\n  CUTOFF=number \n    cuts off any branch-and-bound nodes in a minimization problem that has an objective value that is greater than number. \n  CUTSTRATEGY=-1|0|1|2  CUTSTRATEGY=AUTOMATIC|NONE|MODERATE|AGGRESSIVE\n    specifies the level of cutting planes to be generated by the network solver.\n  EMPHASIS=0|1|2  EMPHASIS=BALANCE|OPTIMAL|FEASIBLE\n    specifies a search emphasis option.\n  HEURISTICS=-1|0|1|2|3  HEURISTICS=AUTOMATIC|NONEBASIC||MODERATE|AGGRESSIVE \n    controls the level of initial and primal heuristics that the network solver applies. \n  MAXNODES=number \n    specifies the maximum number of branch-and-bound nodes to be processed. The value of number can be any \n    nonnegative integer up to the largest four-byte signed integer.\n  MAXSOLS=number \n    specifies the maximum number of feasible tours to be identified. \n  MILP=0|1  MILP=ON|OFF\n    specifies whether to use a mixed integer linear programming (MILP) solver for solving the traveling salesman problem. \n  NODESEL=-1|0|1|2  NODESEL=AUTOMATIC|BESTBOUND|BESTESTIMATE|DEPTH\n    specifies the branch-and-bound node selection strategy option.\n  PROBE=-1|0|1|2  PROBE=AUTOMATIC|NONE|MODERATE|AGGRESSIVE \n    specifies a probing option.\n  RELOBJGAP=number \n    specifies a stopping criterion that is based on the best integer objective (BestInteger) and the \n    objective of the best remaining node (BestBound). The value of number can be any nonnegative number.\n  STRONGITER=number | AUTOMATIC \n    specifies the number of simplex iterations that the network solver performs for each variable in the \n    candidate list when it uses the strong branching variable selection strategy.\n  STRONGLEN=number | AUTOMATIC \n    specifies the number of candidates that the network solver considers when it uses the strong branching \n    variable selection strategy.\n  TARGET=number \n    specifies a stopping criterion for minimization problems.\n  VARSEL=-1|0|1|2|3   VARSEL=AUTOMATIC|MAXINFEAS|MININFEAS|PSEUDO|STRONG\n    specifies the rule for selecting the branching variable."},"StatementOptionType":"S|V","SubOptionsKeywords":"ABSOBJGAP=|CONFLICTSEARCH=|CUTOFF=|CUTSTRATEGY=|EMPHASIS=|HEURISTICS=|MAXNODES=|MAXSOLS=|MILP=|NODESEL=|PROBE=|RELOBJGAP=|STRONGITER=|STRONGLEN=|TARGET=|VARSEL="}],"#comment":[{},{},{}]}},{"StatementName":"SUBMIT","StatementHelp":{"#cdata":"Syntax: SUBMIT arguments \u008c / options \u008d ;\n  SAS statements ;\nENDSUBMIT ;\n  \nThe SUBMIT statement allows SAS code to be executed before PROC OPTMODEL processing continues.\nFor example, you can use the SUBMIT statement to invoke other SAS procedures to perform analysis or to\ndisplay results. \n\nThe arguments list specifies macro variables to initialize in the SUBMIT block environment before the\nSUBMIT block is executed. List items are separated by spaces. Each of the arguments takes one of the\nfollowing forms:\n\n  name\n    copies the value of the PROC OPTMODEL parameter name to the macro variable that\n    has the same name.\n  name = identifier-expression\n    copies the value of the PROC OPTMODEL parameter specified by identifier-expression\n    to the macro variable name.\n  name = number | \u201cstring\u201d | \u2018string\u2019\n    copies the value of the specified number or string constant to the macro variable name.\n  name = ( expression )\n    copies the result of evaluating expression to the macro variable name."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"OK=","StatementOptionHelp":{"#cdata":"Syntax: OK = identifier-expression \n          \nspecifies a PROC OPTMODEL numeric parameter location, identifier-expression, that\nis updated to indicate the success of the SUBMIT block execution. The location is set\nto 1 if execution is successful or 0 if errors are detected. PROC OPTMODEL continues\nexecution when the SUBMIT block encounters errors only if the OK= option is specified."},"StatementOptionType":"V"},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT[=] output-argument | (output-arguments)\n          \nspecifies a single output-argument for retrieving macro variable values from the SUBMIT\nblock environment after each execution of the block, or a list of space-delimited output-arguments \nfor retrieving macro variable values from the SUBMIT block environment after the block is executed. \n\nEach output-argument item specifies a macro variable to copy out of the SUBMIT block environment after\nthe block is executed. Each item takes one of the following two forms:\n\n  identifier-expression\n    copies the macro variable specified by the name portion of the identifier-expression into\n    the PROC OPTMODEL parameter location specified by identifier-expression.\n  identifier-expression = name\n    copies the macro variable specified by name into the PROC OPTMODEL parameter\n    location specified by identifier-expression."},"StatementOptionType":"S|V"}]}},{"StatementName":"PROFILE","StatementHelp":{"#cdata":"Syntax: "},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ON","StatementOptionHelp":{"#cdata":"Enables the profiler. Data are collected until the profiler is disabled or PROC OPTMODEL terminates. \nThe profiler is also enabled when no mode is specified in a PROFILE statement."},"StatementOptionType":"S"},{"StatementOptionName":"OFF","StatementOptionHelp":{"#cdata":"Disables the profiler. Note that the profiler is disabled when PROC OPTMODEL begins execution."},"StatementOptionType":"S"},{"StatementOptionName":"PRINT","StatementOptionHelp":{"#cdata":"Prints the current accumulated profiler data. Items for declarations and statements are displayed \nin a table in descending order of their net time. Accumulated data are printed automatically when \nPROC OPTMODEL terminates."},"StatementOptionType":"S"},{"StatementOptionName":"PERCENT=","StatementOptionHelp":{"#cdata":"Syntax: PERCENT=number \n\nRestricts the output for PROFILE PRINT to items whose net times account for at least the specified \npercentage of total profiled time, (total time x number) / 100. Items that \nhave smaller times are aggregated into a single item at the end of the table. You can set this option\nbefore the display of profile data, and it does not affect the data collection. The value of number \ncan range from 0 to 100. The default value is 1."},"StatementOptionType":"V"},{"StatementOptionName":"RESET","StatementOptionHelp":{"#cdata":"Discards accumulated profiler data when the PROFILE statement completes execution. Accumulated data \nare retained until they are explicitly reset. "},"StatementOptionType":"S"},{"StatementOptionName":"STMTDEPTH=","StatementOptionHelp":{"#cdata":"Syntax: STMTDEPTH=number | ALL \n\nAllows collection of profiler data for nested statements. With the default option, STMTDEPTH=1, profiler \ndata are collected only for top-level statements. The elapsed time for nested statement timing is included \nin the top-level statement timing. For example, time for a top-level FOR statement would include the execution \nof its substatement. Use the STMTDEPTH= option to profile the nested statements individually. The value number \nspecifies the maximum nesting depth at which to profile statements individually. The nesting depth of a top-level\nstatement is 1. Otherwise the nesting depth of a statement is one more than the nesting depth of the statement \nthat encloses it, such as a DO , IF , or FOR statement."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"<number>","@Value2":"ALL"},"StatementOptionToolTips":{"@ToolTip1":"Replace <num> with an actual number. The value of number can be any integer between 1 and 256  inclusive. The default value is CPUCOUNT, which sets the thread count to the number that is determined  by the SAS system option CPUCOUNT=.","@ToolTip2":"The default value is CPUCOUNT, which sets the thread count to the number that is determined by the  SAS system option CPUCOUNT="}}]}},{"StatementName":"ENDSUBMIT","StatementHelp":{"#cdata":"Ends a SUBMIT block."},"StatementOptions":null},{"StatementName":"USE PROBLEM","StatementHelp":{"#cdata":"Syntax: USE PROBLEM identifier-expression ; \n      \nThe USE PROBLEM programming statement makes the problem specified by the identifier-expression \nbe the current problem. If the problem has not been previously used, the problem is created using \nthe PROBLEM declaration corresponding to the name. The problem must have been previously declared."},"StatementOptions":null}],"#comment":{}}}}