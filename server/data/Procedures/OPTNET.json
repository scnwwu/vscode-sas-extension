{"Procedure":{"#comment":{},"Name":"OPTNET","ProductGroup":"SAS/OR","ProcedureHelp":{"#cdata":"Syntax: PROC OPTNET options ;\n    DATA_LINKS_VAR < options >;\n    DATA_MATRIX_VAR <column1,column2,...>;\n    DATA_NODES_VAR < options >;\n    BICONCOMP < option >;\n    CLIQUE < options >;\n    CONCOMP < options >;\n    CYCLE < options >;\n    LINEAR_ASSIGNMENT < options >;\n    MINCOSTFLOW < options >;\n    MINCUT < options >;\n    MINSPANTREE < options >;\n    SHORTPATH < options >;\n    TRANSITIVE_CLOSURE < options >;\n    TSP < options >;\n    PERFORMANCE < options >;\n\nYou can use the OPTNET procedure to analyze relationships between entities. These relationships \nare typically defined by using a graph. A graph G = (N,A) is defined over a set N of nodes and \na set A of arcs. A node is an abstract representation of some entity (or object), and an arc defines \nsome relationship (or connection) between two nodes. The terms node and vertex are often interchanged \nin describing an entity. The term arc is often interchanged with the term edge or link when describing \na connection."},"ProcedureOptions":{"ProcedureOption":[{"ProcedureOptionName":"DATA_LINKS=|LINKS=","ProcedureOptionHelp":{"#cdata":"Syntax: DATA_LINKS=SAS-data-set | LINKS=SAS-data-set \n      \nSpecifies the input data set that contains the graph link information, where the links \nare defined as a list."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"DATA_MATRIX=|MATRIX=","ProcedureOptionHelp":{"#cdata":"Syntax: DATA_MATRIX=SAS-data-set | MATRIX=SAS-data-set \n      \nSpecifies the input data set that contains the matrix to be processed. This is a generic \nmatrix (as opposed to an adjacency matrix which defines an underlying graph)."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"DATA_NODES=|NODES=","ProcedureOptionHelp":{"#cdata":"Syntax: DATA_NODES=SAS-data-set | NODES=SAS-data-set \n      \nSpecifies the input data set that contains the graph node information."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"DATA_NODES_SUB=|NODES_SUB=","ProcedureOptionHelp":{"#cdata":"Syntax: DATA_NODES_SUB=SAS-data-set | NODES_SUB=SAS-data-set \n      \nSpecifies the input data set that contains the graph node subset information."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"GRAPH_DIRECTION=|DIRECTION=","ProcedureOptionHelp":{"#cdata":"Syntax: GRAPH_DIRECTION=|DIRECTION=DIRECTED | UNDIRECTED \n\nSpecifies whether the input graph should be considered directed or undirected."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"DIRECTED","@Value2":"UNDIRECTED"},"ProcedureOptionToolTips":{"@ToolTip1":"Specifies the graph as directed.","@ToolTip2":"Specifies the graph as undirected."}},{"ProcedureOptionName":"GRAPH_INTERNAL_FORMAT=|INTERNAL_FORMAT=","ProcedureOptionHelp":{"#cdata":"Syntax: GRAPH_INTERNAL_FORMAT=THIN | FULL \nINTERNAL_FORMAT=THIN | FULL\n\n"},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"THIN","@Value2":"FULL"},"ProcedureOptionToolTips":{"@ToolTip1":"Stores the graph in thin format. This option can improve performance in some cases both by  reducing memory and by simplifying the construction of the internal data structures. The  thin format causes PROC OPTNET to skip the removal of duplicate links when it reads in  the graph. So this option should be used with caution. For some algorithms, the thin format  is not allowed and this option is ignored. The THIN option can often be helpful when you do  calculations that are decomposed by subgraph.","@ToolTip2":"Stores the graph in standard (full) format. This is the default."}},{"ProcedureOptionName":"INCLUDE_SELFLINK","ProcedureOptionHelp":{"#cdata":"Includes self links\u2014for example, (i,i)\u2014when an input graph is read. By default, when PROC OPTNET \nreads the DATA_LINKS= data set, it removes all self links."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"LOGLEVEL=","ProcedureOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE | 0 | 1 | 2 | 3\n      \nControls the amount of information that is displayed in the SAS log. Each algorithm has \nits own specific log level. This setting sets the log level for all algorithms except \nthose for which you specify the LOGLEVEL= option in the algorithm statement. \n\nThe default is BASIC."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"NONE","@Value2":"BASIC","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Turns off all procedure-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the input, output, and algorithmic processing","@ToolTip3":"Displays a summary of the input, output, and algorithmic processing","@ToolTip4":"Displays a detailed summary of the input, output, and algorithmic processing"}},{"ProcedureOptionName":"OUT_LINKS=","ProcedureOptionHelp":{"#cdata":"Syntax: OUT_LINKS=SAS-data-set \n      \nSpecifies the output data set to contain the graph link information along with any results \nfrom the various algorithms that calculate metrics on links."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"OUT_NODES=","ProcedureOptionHelp":{"#cdata":"Syntax: OUT_NODES=SAS-data-set \n      \nSpecifies the output data set to contain the graph node information along with any results \nfrom the various algorithms that calculate metrics on nodes."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"STANDARDIZED_LABELS","ProcedureOptionHelp":{"#cdata":"Specifies that the input graph data are in a standardized format."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"TIMETYPE=","ProcedureOptionHelp":{"#cdata":"Syntax: TIMETYPE=\"CPU\"|\"REAL\" | TIMETYPE=0|1\n      \nSpecifies whether CPU time or real time is used for each algorithm\u2019s MAXTIME= option (where applicable).\n\nBy default, TIMETYPE=CPU."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"CPU","@Value2":"REAL"},"ProcedureOptionToolTips":{"@ToolTip1":"Specifies units of CPU time.","@ToolTip2":"Specifies units of real time."}}]},"ProcedureStatements":{"ProcedureStatement":[{"StatementName":"BICONCOMP","StatementHelp":{"#cdata":"Syntax: BICONCOMP < options > ; \n\nThe BICONCOMP statement requests that PROC OPTNET find biconnected components and \narticulation points of an undirected input graph."},"StatementOptions":{"StatementOption":{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"BASIC","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing","@ToolTip4":"Displays a detailed summary of the algorithmic processing"}}}},{"StatementName":"CLIQUE","StatementHelp":{"#cdata":"Syntax: CLIQUE < options >;\n      \nThe CLIQUE statement invokes an algorithm that finds maximal cliques in the input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"BASIC","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing","@ToolTip4":"Displays a detailed summary of the algorithmic processing"}},{"StatementOptionName":"MAXCLIQUES=","StatementOptionHelp":{"#cdata":"Syntax: MAXCLIQUES=number | ALL \n          \nSpecifies the maximum number of cliques to return during clique enumeration. You can specify either \na number (which can be any 32-bit integer greater than or equal to 1) or ALL (which represents the \nmaximum that can be represented by a 32-bit integer). By default, MAXCLIQUES=1."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=number \n          \nSpecifies the maximum amount of time to spend finding cliques. The type of time (either CPU time \nor real time) is determined by the value of the TIMETYPE= option in the PROC OPTNETWORK statement. \nThe default is the largest number that can be represented by a double."},"StatementOptionType":"V"},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=CAS-libref.data-table \n          \nSpecifies the output data table to contain the maximal cliques. CAS-libref.data-table is a two-level \nname, where CAS-libref refers to the caslib and session identifier, and data-table specifies the name \nof the output data table."},"StatementOptionType":"V"}]}},{"StatementName":"CONCOMP","StatementHelp":{"#cdata":"Syntax: CONCOMP < options > ; \n\nThe CONCOMP statement invokes an algorithm that finds the connected components of the input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ALGORITHM=","StatementOptionHelp":{"#cdata":"Syntax: ALGORITHM=DFS | UNION_FIND \n          \nSpecifies the algorithm to use for calculating connected components."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"DFS","@Value2":"UNION_FIND"},"StatementOptionToolTips":{"@ToolTip1":"Uses the depth-first search algorithm for connected components. This value cannot be used  when you specify GRAPH_INTERNAL_FORMAT=THIN in the PROC OPTNET statement.","@ToolTip2":"Uses the union-find algorithm for connected components. You can specify this value with  either the THIN or FULL value for the GRAPH_INTERNAL_FORMAT option in the PROC OPTNET  statement. This value can be faster than DFS when used with GRAPH_INTERNAL_FORMAT=THIN;  however, you can use it only with undirected graphs."}},{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"BASIC","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing","@ToolTip4":"Displays a detailed summary of the algorithmic processing"}}]}},{"StatementName":"CYCLE","StatementHelp":{"#cdata":"Syntax: CYCLE < options > ; \n\nThe CYCLE statement invokes an algorithm that finds the cycles (or the existence of a cycle) \nin the input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"BASIC","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing","@ToolTip4":"Displays a detailed summary of the algorithmic processing"}},{"StatementOptionName":"MAXCYCLES=","StatementOptionHelp":{"#cdata":"Syntax: MAXCYCLES=number\n          \nSpecifies the maximum number of cycles to return. The default is the positive number that has the \nlargest absolute value representable in your operating environment. This option works only when you \nalso specify MODE=ALL_CYCLES."},"StatementOptionType":"V"},{"StatementOptionName":"MAXLENGTH=","StatementOptionHelp":{"#cdata":"Syntax: MAXLENGTH=number \n          \nSpecifies the maximum number of links to allow in a cycle. Any cycle whose length is greater than number \nis removed from the results. The default is the positive number that has the largest absolute value that \ncan be represented in your operating environment. By default, nothing is removed from the results. This \noption works only when you also specify MODE=ALL_CYCLES."},"StatementOptionType":"V"},{"StatementOptionName":"MAXLINKWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MAXLINKWEIGHT=number \n          \nSpecifies the maximum sum of link weights to allow in a cycle. Any cycle whose sum of link weights \nis greater than number is removed from the results. The default is the positive number that has the \nlargest absolute value that can be represented in your operating environment. By default, nothing \nis filtered. This option works only when you also specify MODE=ALL_CYCLES."},"StatementOptionType":"V"},{"StatementOptionName":"MAXNODEWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MAXNODEWEIGHT=number \n          \nSpecifies the maximum sum of node weights to allow in a cycle. Any cycle whose sum of node weights \nis greater than number is removed from the results. The default is the positive number that has the \nlargest absolute value that can be represented in your operating environment. By default, nothing \nis filtered. This option works only when you also specify MODE=ALL_CYCLES."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=number \n          \nSpecifies  the maximum amount of time to spend finding cycles. The type of time (either CPU time \nor real time) is determined by the value of the TIMETYPE= option. The value of number can be any \npositive number; the default value is the positive number that has the largest absolute value that \ncan be represented in your operating environment. This option works only when you also specify \nMODE=ALL_CYCLES."},"StatementOptionType":"V"},{"StatementOptionName":"MINLENGTH=","StatementOptionHelp":{"#cdata":"Syntax: MINLENGTH=number \n          \nSpecifies  the maximum amount of time to spend finding cycles. The type of time (either CPU time \nor real time) is determined by the value of the TIMETYPE= option. The value of number can be any \npositive number; the default value is the positive number that has the largest absolute value that \ncan be represented in your operating environment. This option works only when you also specify \nMODE=ALL_CYCLES."},"StatementOptionType":"V"},{"StatementOptionName":"MINLINKWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MINLINKWEIGHT=number \n          \nSpecifies the minimum sum of link weights to allow in a cycle. Any cycle whose sum of link weights \nis less than number is removed from the results. The default is the negative number that has the \nlargest absolute value that can be represented in your operating environment. By default, nothing \nis filtered. This option works only when you also specify MODE=ALL_CYCLES."},"StatementOptionType":"V"},{"StatementOptionName":"MINNODEWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MINNODEWEIGHT=number \n          \nSpecifies the minimum sum of node weights to allow in a cycle. Any cycle whose sum of node weights \nis less than number is removed from the results. The default is the negative number that has the \nlargest absolute value that can be represented in your operating environment. By default, nothing \nis filtered. This option works only when you also specify MODE=ALL_CYCLES."},"StatementOptionType":"V"},{"StatementOptionName":"MODE=","StatementOptionHelp":{"#cdata":"Syntax: MODE=option \n          \nSpecifies the mode for processing cycles."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"ALL_CYCLES","@Value2":"FIRST_CYCLE"},"StatementOptionToolTips":{"@ToolTip1":"Returns all (unique, elementary) cycles found.","@ToolTip2":"Returns the first cycle found."}},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=SAS-data-set \n          \nSpecifies the output data set to contain the cycles found. "},"StatementOptionType":"V"}]}},{"StatementName":"DATA_LINKS_VAR|LINKS_VAR","StatementHelp":{"#cdata":"Syntax: DATA_LINKS_VAR < options > ; \n\n  LINKS_VAR < options > ; \n\nThe DATA_LINKS_VAR statement enables you to explicitly define the data set variable names \nfor PROC OPTNET to use when it reads the data set that is specified in the DATA_LINKS= \noption in the PROC OPTNET statement."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"FROM=","StatementOptionHelp":{"#cdata":"Syntax: FROM=column \n          \nSpecifies the data set variable name for from nodes. The value of column can be numeric or character."},"StatementOptionType":"V"},{"StatementOptionName":"LOWER=","StatementOptionHelp":{"#cdata":"Syntax: LOWER=column \n          \nSpecifies the data set variable name for link flow lower bounds. The value of column must be numeric."},"StatementOptionType":"V"},{"StatementOptionName":"TO=","StatementOptionHelp":{"#cdata":"Syntax: TO=column \n          \nSpecifies the data set variable name for to node. The value of column can be numeric or character."},"StatementOptionType":"V"},{"StatementOptionName":"UPPER=","StatementOptionHelp":{"#cdata":"Syntax: UPPER=column \n          \nSpecifies the data set variable name for link flow upper bounds. The value of column must be numeric."},"StatementOptionType":"V"},{"StatementOptionName":"WEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT=column \n          \nSpecifies the data set variable name for link weights. The value of column must be numeric."},"StatementOptionType":"V"}]}},{"StatementName":"DATA_MATRIX_VAR|MATRIX_VAR","StatementHelp":{"#cdata":"Syntax: DATA_MATRIX_VAR column1 <,column2,...> ; \n\n  MATRIX_VAR column1 <,column2,...> ; \n\nThe DATA_MATRIX_VAR statement enables you to explicitly define the data set variable names for \nPROC OPTNET to use when it reads the data set that is specified in the DATA_MATRIX= option in \nthe PROC OPTNET statement. The format of the matrix input data set is defined in the section \nMatrix Input Data. The value of each column variable must be numeric."},"StatementOptions":null},{"StatementName":"DATA_NODES_VAR|NODES_VAR","StatementHelp":{"#cdata":"Syntax: DATA_NODES_VAR < options > ; \n\n  NODES_VAR < options > ; \n\nThe DATA_NODES_VAR statement enables you to explicitly define the data set variable names \nfor PROC OPTNET to use when it reads the data set that is specified in the DATA_NODES= \noption in the PROC OPTNET statement."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"NODE=","StatementOptionHelp":{"#cdata":"Syntax: NODE=column \n          \nSpecifies the data set variable name for the nodes. The value of column can be numeric or character."},"StatementOptionType":"V"},{"StatementOptionName":"WEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT=column \n          \nSpecifies the data set variable name for node weights. The value of column must be numeric."},"StatementOptionType":"V"},{"StatementOptionName":"WEIGHT2=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT2=column \n          \nSpecifies the data set variable name for auxiliary node weights. The value of column \nmust be numeric."},"StatementOptionType":"V"}]}},{"StatementName":"LINEAR_ASSIGNMENT|LAP","StatementHelp":{"#cdata":"Syntax: LINEAR_ASSIGNMENT | LAP < options > ; \n\nThe LINEAR_ASSIGNMENT statement invokes an algorithm that solves the minimal-cost linear \nassignment problem. In graph terms, this problem is also known as the minimum link-weighted \nmatching problem on a bipartite graph. The input data (the cost matrix) is typically defined \nin the input data set that is specified in the DATA_MATRIX= option in the PROC OPTNET \nstatement. The data can also be defined as a directed graph by specifying the DATA_LINKS= \noption in the PROC OPTNET statement, where the costs are defined as link weights."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ID=","StatementOptionHelp":{"#cdata":"Syntax: ID=(column1 <,column2,...>) \n          \nSpecifies the data set variable names that identify the matrix rows (from nodes). The \ninformation in these columns is carried to the output data set that is specified in the \nOUT= option. The value of each column variable can be numeric or character."},"StatementOptionType":"V"},{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"BASIC","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing","@ToolTip4":"Displays a detailed summary of the algorithmic processing"}},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=SAS-data-set \n          \nSpecifies the output data set to contain the solution to the linear assignment problem."},"StatementOptionType":"V"},{"StatementOptionName":"WEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT=(column1 <,column2,...>) \n          \nSpecifies the data set variable names for the cost matrix. The value of each column \nvariable must be numeric. If this option is not specified, the matrix is assumed to \nbe defined by all of the numeric variables in the data set (excluding those specified \nin the ID= option)."},"StatementOptionType":"V"}]}},{"StatementName":"MINCOSTFLOW|MCF","StatementHelp":{"#cdata":"Syntax: MINCOSTFLOW < options >;\n\nSyntax: MCF < options >;\n\nThe MINCOSTFLOW statement invokes an algorithm that solves the minimum-cost network flow problem \non an input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"LOGFREQ=","StatementOptionHelp":{"#cdata":"Syntax: LOGFREQ=number \n          \nControls the frequency for displaying iteration logs for minimum-cost network flow calculations \nthat use the network simplex algorithm. For graphs that contain one component, this option displays \nprogress every number of simplex iterations; the default is 10,000. For graphs that contain multiple \ncomponents, when you also specify LOGLEVEL=MODERATE, this option displays progress after processing \nevery number of components; the default is based on the number of components. When you also specify \nLOGLEVEL=AGGRESSIVE, the simplex iteration log for each component is displayed with a frequency of \nnumber."},"StatementOptionType":"V"},{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"BASIC","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing","@ToolTip4":"Displays a detailed summary of the algorithmic processing"}},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=number \n          \nSpecifies the maximum amount of time to spend calculating minimum-cost network flows. The type \nof time (either CPU time or real time) is determined by the value of the TIMETYPE= option in the \nPROC OPTNETWORK statement. The default is the largest number that can be represented by a double."},"StatementOptionType":"V"}]}},{"StatementName":"MINCUT","StatementHelp":{"#cdata":"Syntax: MINCUT < options > ; \n\nThe MINCUT statement invokes an algorithm that finds the minimum link-weighted cut of an input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"BASIC","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing","@ToolTip4":"Displays a detailed summary of the algorithmic processing"}},{"StatementOptionName":"MAXNUMCUTS=","StatementOptionHelp":{"#cdata":"Syntax: MAXNUMCUTS=num \n          \nSpecifies the maximum number of cuts to return from the algorithm. The minimal cut and \nany others found during the search, up to num, are returned. The default is 1."},"StatementOptionType":"V"},{"StatementOptionName":"MAXWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MAXWEIGHT=num \n          \nSpecifies the maximum weight of the cuts to return from the algorithm. Only cuts that \nhave weight less than or equal to num are returned. The default is the positive number \nthat has the largest absolute value representable in your operating environment."},"StatementOptionType":"V"},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=SAS-data-set \n          \nSpecifies the output data set to contain the solution to the minimum cut problem."},"StatementOptionType":"V"}]}},{"StatementName":"MINSPANTREE|MST","StatementHelp":{"#cdata":"Syntax: MINSPANTREE | MST < options > ; \n\nThe MINSPANTREE statement invokes an algorithm that solves the minimum link-weighted \nspanning tree problem on an input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE|0","@Value2":"BASIC|1","@Value3":"MODERATE|2","@Value4":"AGGRESSIVE|3"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing","@ToolTip4":"Displays a detailed summary of the algorithmic processing"}},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=SAS-data-set \n          \nSpecifies the output data set to contain the solution to the minimum link-weighted \nspanning tree problem."},"StatementOptionType":"V"}]}},{"StatementName":"PERFORMANCE","StatementHelp":{"#cdata":"Syntax: PERFORMANCE <performance-options>;\n\nThe PERFORMANCE statement specifies performance options for multithreaded computing and requests \ndetailed results about the performance characteristics of the OPTNET procedure."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"DETAILS","StatementOptionHelp":{"#cdata":"Requests that PROC OPTNET produce the Timing ODS table, which shows a breakdown of the time used in each step of the procedure."},"StatementOptionType":"S"},{"StatementOptionName":"NTHREADS=","StatementOptionHelp":{"#cdata":"Syntax: NTHREADS=number | CPUCOUNT\n          \nSpecifies the number of threads that PROC OPTNET can use. This option overrides the SAS system \noption THREADS | NOTHREADS. The value of number can be any integer between 1 and 256, inclusive. \nThe default value is CPUCOUNT, which sets the thread count to the number determined by the SAS \nsystem option CPUCOUNT=."},"StatementOptionType":"V"}]}},{"StatementName":"SHORTPATH","StatementHelp":{"#cdata":"Syntax: SHORTPATH < options > ; \n\nThe SHORTPATH statement invokes an algorithm that calculates shortest paths between sets \nof nodes on the input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"LOGFREQ=","StatementOptionHelp":{"#cdata":"Syntax: LOGFREQ=number\n          \nDisplays iteration logs for shortest path calculations every number nodes. The value of number can \nbe any integer greater than or equal to 1. The default is determined automatically based on the size \nof the graph. Setting this value too low can hurt performance on large-scale graphs."},"StatementOptionType":"V"},{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log. \n\nThe default is the value that is specified by the LOGLEVEL= option in the PROC OPTNET \nstatement (or BASIC if that option is not specified)."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"BASIC","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing including a progress log using the  interval dictated by the LOGFREQ option","@ToolTip4":"Displays a detailed summary of the algorithmic processing including a progress log using  the interval dictated by the LOGFREQ option"}},{"StatementOptionName":"OUT_PATHS=|OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT_PATHS | OUT==SAS-data-set \n          \nSpecifies the output data set to contain the shortest paths."},"StatementOptionType":"V"},{"StatementOptionName":"OUT_WEIGHTS=","StatementOptionHelp":{"#cdata":"Syntax: OUT_WEIGHTS=SAS-data-set \n          \nSpecifies the output data set to contain the shortest path summaries."},"StatementOptionType":"V"},{"StatementOptionName":"PATHS=","StatementOptionHelp":{"#cdata":"Syntax: PATHS=ALL | SHORTEST | LONGEST \n          \nSpecifies the type of output to produce in the output data set that is specified in the OUT_PATHS= option."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"ALL","@Value2":"SHORTEST","@Value3":"LONGEST"},"StatementOptionToolTips":{"@ToolTip1":"Outputs shortest paths for all pairs of source-sinks. This is the default.","@ToolTip2":"Outputs shortest paths for the source-sink pair with the longest (finite) length. If other  source-sink pairs (up to 100) have equally long length, they are also output.","@ToolTip3":"Outputs shortest paths for the source-sink pair with the shortest length. If other  source-sink pairs (up to 100) have equally short length, they are also output."}},{"StatementOptionName":"SINK=","StatementOptionHelp":{"#cdata":"Syntax: SINK=sink-node \n          \nSpecifies the sink node for shortest paths calculations. This setting overrides the use \nof the variable sink in the data set that is specified by the DATA_NODES_SUB= option in \nthe PROC OPTNET statement."},"StatementOptionType":"V"},{"StatementOptionName":"SOURCE=","StatementOptionHelp":{"#cdata":"Syntax: SOURCE=source-node \n          \nSpecifies the source node for shortest paths calculations. This setting overrides the use \nof the variable source in the data set that is specified by the DATA_NODES_SUB= option in \nthe PROC OPTNET statement."},"StatementOptionType":"V"},{"StatementOptionName":"USEWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: USEWEIGHT=YES | NO \n          \nSpecifies whether to use link weights (if they exist) in calculating shortest paths."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"YES","@Value2":"NO"},"StatementOptionToolTips":{"@ToolTip1":"Uses weights (if they exist) in shortest path calculations. This is the default.","@ToolTip2":"Does not use weights in shortest path calculations."}},{"StatementOptionName":"WEIGHT2=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT2=column \n          \nSpecifies the data set variable name for the auxiliary link weights. The value of column \nmust be numeric."},"StatementOptionType":"V"}]}},{"StatementName":"TRANSITIVE_CLOSURE|TRANSCL","StatementHelp":{"#cdata":"Syntax: TRANSITIVE_CLOSURE | TRANSCL < options > ; \n\nThe TRANSITIVE_CLOSURE statement invokes an algorithm that calculates the transitive \nclosure of an input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information that is displayed in the SAS log. \n\nThe default is the value that is specified by the LOGLEVEL= option in the PROC OPTNET \nstatement (or BASIC if that option is not specified)."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"BASIC","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all algorithm-related messages in the SAS log","@ToolTip2":"Displays a basic summary of the algorithmic processing","@ToolTip3":"Displays a summary of the algorithmic processing","@ToolTip4":"Displays a detailed summary of the algorithmic processing"}},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=SAS-data-set \n          \nSpecifies the output data set to contain the transitive closure results."},"StatementOptionType":"V"}]}},{"StatementName":"TSP","StatementHelp":{"#cdata":"Syntax: TSP < options > ; \n\nThe TSP statement invokes an algorithm that solves the traveling salesman problem. \n\nThe traveling salesman problem is described in the section Traveling Salesman Problem. \nThe algorithm that is used to solve this problem is built around the same method as is \nused in PROC OPTMILP: a branch-and-cut algorithm."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ABSOBJGAP=","StatementOptionHelp":{"#cdata":"Syntax: ABSOBJGAP=num  \n          \nSpecifies a stopping criterion. When the absolute difference between the best integer \nobjective and the objective of the best remaining branch-and-bound node becomes less \nthan the value of num, the procedure stops. The value of num can be any nonnegative \nnumber; the default value is 1E\u20136."},"StatementOptionType":"V"},{"StatementOptionName":"CONFLICTSEARCH=","StatementOptionHelp":{"#cdata":"[Syntax: CONFLICTSEARCH=number | string ]\n\nSpecifies  the level of conflict search that PROC OPTNET performs."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Performs conflict search based on a strategy determined by PROC OPTNET","@ToolTip2":"Disables conflict search ","@ToolTip3":"Performs a moderate conflict search","@ToolTip4":"Performs an aggressive conflict search"}},{"StatementOptionName":"CUTOFF=","StatementOptionHelp":{"#cdata":"Syntax: CUTOFF=number\n          \nCuts off any branch-and-bound nodes in a minimization problem with an objective value \nthat is greater than num. The value of num can be any number; the default value is the \npositive number that has the largest absolute value that can be represented in your \noperating environment."},"StatementOptionType":"V"},{"StatementOptionName":"CUTSTRATEGY=","StatementOptionHelp":{"#cdata":"Syntax: CUTSTRATEGY=number | string\n          \nSpecifies the level of mixed integer linear programming cutting planes to be generated by PROC OPTNET. \nTSP-specific cutting planes are always generated.\n\nBy default, CUTSTRATEGY=NONE."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generates cutting planes based on a strategy determined by the mixed integer linear programming solver","@ToolTip2":"Disables generation of mixed integer linear programming cutting planes (some TSP-specific cutting planes are still active for validity)","@ToolTip3":"Uses a moderate cut strategy","@ToolTip4":"Uses an aggressive cut strategy"}},{"StatementOptionName":"EMPHASIS=","StatementOptionHelp":{"#cdata":"Syntax: EMPHASIS=number | string \n          \nSpecifies a search emphasis option."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"BALANCE","@Value2":"OPTIMAL","@Value3":"FEASIBLE"},"StatementOptionToolTips":{"@ToolTip1":"Performs a balanced search.","@ToolTip2":"Emphasizes optimality over feasibility.","@ToolTip3":"Emphasizes feasibility over optimality."}},{"StatementOptionName":"HEURISTICS=","StatementOptionHelp":{"#cdata":"Syntax: HEURISTICS=number | string\n          \nControls the level of initial and primal heuristics that PROC OPTNET applies.\n\nBy default, HEURISTICS=AUTOMATIC."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"BASIC","@Value4":"MODERATE","@Value5":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Applies the default level of heuristics","@ToolTip2":"Disables all initial and primal heuristics","@ToolTip3":"Applies basic intial and primal heuristics at low frequency","@ToolTip4":"Applies most intial and primal heuristics at moderate frequency","@ToolTip5":"Applies all intitial primal heuristics at high frequency"}},{"StatementOptionName":"LOGFREQ=","StatementOptionHelp":{"#cdata":"Syntax: LOGFREQ=num \n          \nSpecifies how often to print information in the branch-and-bound node log. The value of num \ncan be any nonnegative integer up to the largest four-byte signed integer, which is 2\u00b3\u00b9 - 1. \nThe default value is 100. If num is set to 0, then the node log is disabled. If num is positive, \nthen an entry is made in the node log at the first node, at the last node, and at intervals that \nare dictated by the value of num. An entry is also made each time a better integer solution is found."},"StatementOptionType":"V"},{"StatementOptionName":"LOGLEVEL=","StatementOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | 0 | BASIC | 1 | MODERATE | 2 | AGGRESSIVE | 3 \n          \nControls the amount of information displayed in the SAS log by the solver, from a short \ndescription of presolve information and summary to details at each branch-and-bound node. \n\nThe default value is MODERATE."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"NONE","@Value2":"BASIC","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Turns off all solver-related messages in the SAS log","@ToolTip2":"Displays a solver summary after stopping","@ToolTip3":"Prints a solver summary and a node log by using the interval dictated by the LOGFREQ= option","@ToolTip4":"Prints a detailed solver summary and a node log by using the interval dictated by the  LOGFREQ= option"}},{"StatementOptionName":"MAXNODES=","StatementOptionHelp":{"#cdata":"Syntax: MAXNODES=number\n          \nSpecifies the maximum number of branch-and-bound nodes to be processed. The value of number \ncan be any nonnegative integer up to the largest four-byte signed integer, which is 2\u00b3\u00b9 - 1. \n\nThe default value is 2\u00b3\u00b9 - 1."},"StatementOptionType":"V"},{"StatementOptionName":"MAXSOLS=","StatementOptionHelp":{"#cdata":"Syntax: MAXSOLS=num \n          \nSpecifies a stopping criterion. If num solutions have been found, then the procedure stops. \nThe value of num can be any positive integer up to the largest four-byte signed integer, which \nis 2\u00b3\u00b9 - 1. The default value is 2\u00b3\u00b9 - 1."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=num \n          \nSpecifies the maximum amount of time to spend solving the traveling salesman problem. The \ntype of time (either CPU time or real time) is determined by the value of the TIMETYPE= \noption. The value of num can be any positive number; the default value is the positive \nnumber that has the largest absolute value that can be represented in your operating \nenvironment."},"StatementOptionType":"V"},{"StatementOptionName":"MILP=","StatementOptionHelp":{"#cdata":"Syntax: MILP=number | string \n          \nSpecifies whether to use a mixed-integer linear programming (MILP) solver for solving the \ntraveling salesman problem. The MILP solver attempts to find the overall best TSP tour by \nusing a branch-and-bound based algorithm. This algorithm can be expensive for large-scale \nproblems. If MILP=OFF, then PROC OPTNET uses its initial heuristics to find a feasible, \nbut not necessarily optimal, tour as quickly as possible."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"ON","@Value2":"OFF"},"StatementOptionToolTips":{"@ToolTip1":"Uses a mixed-integer linear programming","@ToolTip2":"Does not use a mixed-integer linear programming solver"}},{"StatementOptionName":"NODESEL=","StatementOptionHelp":{"#cdata":"Syntax: NODESEL=number | string\n          \nSpecifies the branch-and-bound node selection strategy option."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC|","@Value2":"BESTBOUND","@Value3":"BESTESTIMATE","@Value4":"DEPTH"},"StatementOptionToolTips":{"@ToolTip1":"Uses automatic node select","@ToolTip2":"Chooses the node with the best relaxed objective (best-bound-first strategy)","@ToolTip3":"Chooses the node with the best estimate of the integer objective value (best-estimate-first strategy)","@ToolTip4":"Chooses the most recently created node (depth-first strategy)"}},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=SAS-data-set  \n          \nSpecifies the output data set to contain the solution to the traveling salesman problem."},"StatementOptionType":"V"},{"StatementOptionName":"PROBE=","StatementOptionHelp":{"#cdata":"Syntax: PROBE=number | string\n          \nSpecifies a probing option."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Uses an automatic probing strategy","@ToolTip2":"Disables probing","@ToolTip3":"Uses the probing moderately","@ToolTip4":"Uses the probing aggressively"}},{"StatementOptionName":"RELOBJGAP=","StatementOptionHelp":{"#cdata":"Syntax: RELOBJGAP=number\n          \nSpecifies a stopping criterion that is based on the best integer objective (BestInteger) \nand the objective of the best remaining node (BestBound)."},"StatementOptionType":"V"},{"StatementOptionName":"STRONGITER=","StatementOptionHelp":{"#cdata":"Syntax: STRONGITER=number | AUTOMATIC\n          \nSpecifies the number of simplex iterations that PROC OPTNET performs for each variable in the \ncandidate list when it uses the strong branching variable selection strategy. The value of number \ncan be any positive integer up to the largest four-byte signed integer, which is 2\u00b3\u00b9 - 1.\nIf you specify the keyword AUTOMATIC or the value \u20131, PROC OPTNET uses the default value, which \nit calculates automatically."},"StatementOptionType":"V"},{"StatementOptionName":"STRONGLEN=","StatementOptionHelp":{"#cdata":"Syntax: STRONGLEN=number | AUTOMATIC \n          \nSpecifies the number of candidates that PROC OPTNET considers when it uses the strong branching \nvariable selection strategy. The value of number can be any positive integer up to the largest \nfour-byte signed integer, which is 2\u00b3\u00b9 - 1. If you specify the keyword AUTOMATIC or the value \u20131, \nPROC OPTNET uses the default value, which it calculates automatically."},"StatementOptionType":"V"},{"StatementOptionName":"TARGET=","StatementOptionHelp":{"#cdata":"Syntax: TARGET=number\n          \nSpecifies a stopping criterion for minimization (maximization) problems. If the best integer \nobjective is better than or equal to num, the procedure stops. The value of num can be any \nnumber; the default is the negative (positive) number that has the largest absolute value \nthat can be represented in your operating environment."},"StatementOptionType":"V"},{"StatementOptionName":"VARSEL=","StatementOptionHelp":{"#cdata":"Syntax: VARSEL= AUTOMATIC | -1 | MAXINFEAS | 0 | MININFEAS | 1 | PESUDO | 2 | STRONG | 3\n          \nSpecifies the rule for selecting the branching variable."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":" MAXINFEAS","@Value3":"MININFEAS","@Value4":"PESUDO","@Value5":"STRONG"},"StatementOptionToolTips":{"@ToolTip1":"Uses automatic branching variable selection","@ToolTip2":"Chooses the variable with maximum infeasibility","@ToolTip3":"Chooses the variable with minimum infeasibility","@ToolTip4":"Chooses a branching variable based on pseudocost","@ToolTip5":"Uses strong branching variable selection strategy"}}]}}]}}}