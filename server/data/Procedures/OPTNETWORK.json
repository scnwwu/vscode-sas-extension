{"Procedure":{"Name":"OPTNETWORK","ProductGroup":"SAS OPTIMIZATION","ProcedureHelp":{"#cdata":"Syntax: PROC OPTNETWORK <options>;   \n    BY variables; \n    DISPLAY <table-list> </ options>; \n    DISPLAYOUT table-spec-list </ options>; \n    LINKSVAR <options>; \n    NODESVAR <options>; \n    NODESSUBSETVAR <options>; \n    BICONNECTEDCOMPONENTS ; \n    CLIQUE <options>; \n    CONNECTEDCOMPONENTS <options>; \n    CYCLE <options>; \n    LINEARASSIGNMENT <options>; \n    MINCOSTFLOW <options>; \n    MINCUT <options>; \n    MINSPANTREE <options>; \n    PATH <options>; \n    SHORTESTPATH <options>; \n    SUMMARY <options>; \n    TRANSITIVECLOSURE <options>; \n    TSP < options >;\n    \nThe OPTNETWORK procedure includes a number of graph theory and network optimization algorithms \nthat can augment more generic mathematical optimization approaches. Many practical applications \nof optimization depend on an underlying network. For example, retailers face the problem of \nshipping goods from warehouses to stores in a distribution network to satisfy demand at minimum \ncost. Commuters choose routes in a road network to travel from home to work in the shortest amount \nof time."},"ProcedureOptions":{"ProcedureOption":[{"ProcedureOptionName":"DIRECTION=","ProcedureOptionHelp":{"#cdata":"Syntax: DIRECTION=DIRECTED | UNDIRECTED \n\nSpecifies whether the input graph should be considered directed or undirected."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"DIRECTED","@Value2":"UNDIRECTED"},"ProcedureOptionToolTips":{"@ToolTip1":"Specifies the graph as directed.","@ToolTip2":"Specifies the graph as undirected."}},{"ProcedureOptionName":"INCLUDESELFLINK","ProcedureOptionHelp":{"#cdata":"Includes self-links, such as (i,i), when an input graph is read. By default, when PROC OPTNETWORK \nreads the LINKS= data table, it removes all self-links."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"INDEXOFFSET=","ProcedureOptionHelp":{"#cdata":"Syntax: INDEXOFFSET=number \n      \nSpecifies the index offset for identifiers in the log and results output data tables. For example, \nif three cycles are found in cycle enumeration, they are labeled cycles 1, 2, and 3 by default. \nIf INDEXOFFSET=4, they are labeled cycles 4, 5, and 6. The value of number must be an integer \ngreater than or equal to 0. By default, INDEXOFFSET=1."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"LINKS=","ProcedureOptionHelp":{"#cdata":"Syntax: LINKS=CAS-libref.data-table \n      \nSpecifies the input data table that contains the graph link information. CAS-libref.data-table \nis a two-level name, where CAS-libref refers to the caslib and session identifier, and data-table \nspecifies the name of the input data table."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"LOGFREQUENCYTIME=|LOGFREQTIME=","ProcedureOptionHelp":{"#cdata":"Syntax: LOGFREQTIME=number | LOGFREQUENCYTIME=number \n      \nControls the frequency, in number of seconds, for displaying iteration logs for some algorithms. \nThis option is useful for computationally intensive algorithms. Setting this value too low can \nhurt algorithm performance. The value of number can be any integer greater than or equal to 1. \n\nBy default, LOGFREQTIME=5."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"LOGLEVEL=","ProcedureOptionHelp":{"#cdata":"Syntax: LOGLEVEL=NONE | BASIC | MODERATE | AGGRESSIVE \n      \nControls the amount of information that is displayed in the SAS log. \n\nBy default, LOGLEVEL=BASIC."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"NONE","@Value2":"BASIC","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"ProcedureOptionToolTips":{"@ToolTip1":"Turns off all procedure-related messages in the SAS log. ","@ToolTip2":"Displays a brief summary of the algorithmic processing. ","@ToolTip3":"Displays a moderately detailed summary of the input, output, and algorithmic processing.","@ToolTip4":"Displays a more detailed summary of the input, output, and algorithmic processing."}},{"ProcedureOptionName":"NODES=","ProcedureOptionHelp":{"#cdata":"Syntax: NODES=CAS-libref.data-table \n      \nSpecifies the input data table that contains the graph node information. \n\nCAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session \nidentifier, and data-table specifies the name of the input data table."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"NODESSUBSET=","ProcedureOptionHelp":{"#cdata":"Syntax: NODESSUBSET=CAS-libref.data-table \n      \nSpecifies the input data table that contains the graph node subset information. \n\nCAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session \nidentifier, and data-table specifies the name of the input data table."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"NTHREADS=","ProcedureOptionHelp":{"#cdata":"Syntax: NTHREADS=number \n      \nSpecifies the maximum number of threads to use for multithreaded processing. Some of the algorithms \ncan take advantage of multicore machines and can run faster when number is greater than 1. Algorithms \nthat cannot take advantage of this option use only one thread even if number is greater than 1. For \ndistributed execution, number specifies the maximum number of threads to use on each machine. The \nvalue of number can be any integer between 1 and 256, inclusive. The default is the number of cores \non the machine that executes the process or the number of cores permissible based on your installation \n(whichever is less). The number of simultaneously active CPUs is limited by your installation and \nlicense configuration."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"OUTLINKS=","ProcedureOptionHelp":{"#cdata":"Syntax: OUTLINKS=CAS-libref.data-table \n      \nSpecifies the output data table to contain the graph link information along with any results from the \nalgorithms that calculate metrics on links. CAS-libref.data-table is a two-level name, where CAS-libref \nrefers to the caslib and session identifier, and data-table specifies the name of the output data table."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"OUTNODES=","ProcedureOptionHelp":{"#cdata":"Syntax: OUTNODES=CAS-libref.data-table \n      \nSpecifies the output data table to contain the graph node information along with any results from \nthe algorithms that calculate metrics on nodes. CAS-libref.data-table is a two-level name, where \nCAS-libref refers to the caslib and session identifier, and data-table specifies the name of the\noutput data table."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"STANDARDIZEDLABELS","ProcedureOptionHelp":{"#cdata":"Specifies that the input graph data are in a standardized format."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"TIMETYPE=","ProcedureOptionHelp":{"#cdata":"Syntax: TIMETYPE=CPU | REAL \n      \nSpecifies whether CPU time or real time is used for each algorithm\u2019s MAXTIME= option (where applicable).\n\nBy default, TIMETYPE=REAL."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"CPU","@Value2":"REAL"},"ProcedureOptionToolTips":{"@ToolTip1":"Specifies units of CPU time. The time restriction is applied per processing machine (not across all machines).","@ToolTip2":"Specifies units of real time."}}]},"ProcedureStatements":{"ProcedureStatement":[{"StatementName":"BICONNECTEDCOMPONENTS","StatementHelp":{"#cdata":"Syntax: BICONNECTEDCOMPONENTS ;\n      \nThe BICONNECTEDCOMPONENTS statement requests that PROC OPTNETWORK find biconnected components and \narticulation points of an undirected input graph."},"StatementOptions":null},{"StatementName":"BY","StatementHelp":{"#cdata":"Syntax: BY variables;\n\nYou can specify a BY statement in PROC OPTNETWORK to obtain separate analyses of observations in groups \nthat are defined by the values of the BY variables. If you specify more than one BY statement, only the \nlast one specified is used.\n\nThe BY statement in PROC OPTNETWORK is not supported when either a nodes or nodes subset data table is \nused. The BY variable must come from the LINKS= data table."},"StatementOptions":null},{"StatementName":"CLIQUE","StatementHelp":{"#cdata":"Syntax: CLIQUE < options >;\n      \nThe CLIQUE statement invokes an algorithm that finds maximal cliques in the input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"MAXCLIQUES=","StatementOptionHelp":{"#cdata":"Syntax: MAXCLIQUES=number | ALL \n          \nSpecifies the maximum number of cliques to return during clique enumeration. You can specify either \na number (which can be any 32-bit integer greater than or equal to 1) or ALL (which represents the \nmaximum that can be represented by a 32-bit integer). By default, MAXCLIQUES=1."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=number \n          \nSpecifies the maximum amount of time to spend finding cliques. The type of time (either CPU time \nor real time) is determined by the value of the TIMETYPE= option in the PROC OPTNETWORK statement. \nThe default is the largest number that can be represented by a double."},"StatementOptionType":"V"},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=CAS-libref.data-table \n          \nSpecifies the output data table to contain the maximal cliques. CAS-libref.data-table is a two-level \nname, where CAS-libref refers to the caslib and session identifier, and data-table specifies the name \nof the output data table."},"StatementOptionType":"V"}]}},{"StatementName":"CONNECTEDCOMPONENTS","StatementHelp":{"#cdata":"Syntax: CONNECTEDCOMPONENTS < options >;\n      \nThe CONNECTEDCOMPONENTS statement invokes an algorithm that finds the connected components of the \ninput graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ALGORITHM=","StatementOptionHelp":{"#cdata":"Syntax: ALGORITHM=AUTOMATIC | DFS | PARALLEL | UNIONFIND \n          \nSpecifies the algorithm to use for calculating connected components. \n\nBy default, ALGORITHM=UNIONFIND for undirected graphs, and ALGORITHM=DFS for directed graphs."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"DFS","@Value3":"PARALLEL","@Value4":"UNIONFIND"},"StatementOptionToolTips":{"@ToolTip1":"Automatically determines the algorithm for connected components.","@ToolTip2":"Uses the depth-first search algorithm for connected components.","@ToolTip3":"Uses the distributed parallel union-find algorithm for connected components. You can specify this  value when the number of machines in your session is greater than 1. You can use this algorithm  only with undirected graphs.","@ToolTip4":"Uses the union-find algorithm for connected components. You can use this algorithm only with  undirected graphs."}},{"StatementOptionName":"INTERNALFORMAT=","StatementOptionHelp":{"#cdata":"Syntax: INTERNALFORMAT=FULL | THIN \n          \nSpecifies the internal graph format for the connected components algorithm to use.\n\nBy default, INTERNALFORMAT=THIN. You cannot use the option INTERNALFORMAT=FULL with ALGORITHM=PARALLEL. \nIf you do, it will reset to the default value of THIN."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"FULL","@Value2":"THIN"},"StatementOptionToolTips":{"@ToolTip1":"Stores the graph in standard (adjacency-list-based) format. ","@ToolTip2":"Stores the graph in thin (simple list of links) format. This option can improve performance in some  cases both by reducing memory and by simplifying the construction of the internal data structures.  This option causes PROC OPTNETWORK to skip the removal of duplicate links when it reads in the graph  (which has no effect on the resulting components)."}}]}},{"StatementName":"CYCLE","StatementHelp":{"#cdata":"Syntax: CYCLE < options > ; \n\nThe CYCLE statement invokes an algorithm that finds the cycles (or the existence of a cycle) \nin the input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ALGORITHM=","StatementOptionHelp":{"#cdata":"Syntax: ALGORITHM=BACKTRACK | BUILD \n          \nSpecifies which algorithm to use in enumerating cycles.\n\nBy default, ALGORITHM=BACKTRACK for MAXLENGTH greater than 20; otherwise, ALGORITHM=BUILD."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"BACKTRACK","@Value2":"BUILD"},"StatementOptionToolTips":{"@ToolTip1":"Uses a backtracking algorithm based on Johnson (1975).","@ToolTip2":"Uses a building algorithm based on Liu and Wang (2006). "}},{"StatementOptionName":"MAXCYCLES=","StatementOptionHelp":{"#cdata":"Syntax: MAXCYCLES=number | ALL \n          \nSpecifies the maximum number of cycles to return during cycle enumeration. You can specify either \na number (which can be any 32-bit integer greater than or equal to 1) or ALL (which represents the \nmaximum that can be represented by a 32-bit integer). By default, MAXCYCLES=1."},"StatementOptionType":"V"},{"StatementOptionName":"MAXLENGTH=","StatementOptionHelp":{"#cdata":"Syntax: MAXLENGTH=number \n          \nSpecifies the maximum number of links in a cycle. Any cycle whose length is greater than number \nis removed from the results. The default is the largest number that can be represented by a 32-bit \ninteger, which causes no cycles to be removed from the results."},"StatementOptionType":"V"},{"StatementOptionName":"MAXLINKWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MAXLINKWEIGHT=number \n          \nSpecifies the maximum sum of link weights in a cycle. Any cycle whose sum of link weights is greater \nthan number is removed from the results. The default is the largest number that can be represented by \na double, which causes no cycles to be removed from the results."},"StatementOptionType":"V"},{"StatementOptionName":"MAXNODEWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MAXNODEWEIGHT=number \n          \nSpecifies the maximum sum of node weights in a cycle. Any cycle whose sum of node weights is greater \nthan number is removed from the results. The default is the largest number that can be represented by \na double, which causes no cycles to be removed from the results."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=number \n          \nSpecifies the maximum amount of time to spend finding cycles. The type of time (either CPU time \nor real time) is determined by the value of the TIMETYPE= option in the PROC OPTNETWORK statement. \nThe default is the largest number that can be represented by a double."},"StatementOptionType":"V"},{"StatementOptionName":"MINLENGTH=","StatementOptionHelp":{"#cdata":"Syntax: MINLENGTH=number \n          \nSpecifies the minimum number of links in a cycle. Any cycle that has fewer links than number \nis removed from the results. By default, MINLENGTH=1 and no cycles are removed from the results."},"StatementOptionType":"V"},{"StatementOptionName":"MINLINKWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MINLINKWEIGHT=number \n          \nSpecifies the minimum sum of link weights in a cycle. Any cycle whose sum of link weights is less \nthan number is removed from the results. The default is the largest (in magnitude) negative number \nthat can be represented by a double, which causes no cycles to be removed from the results."},"StatementOptionType":"V"},{"StatementOptionName":"MINNODEWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MINNODEWEIGHT=number \n          \nSpecifies the minimum sum of node weights in a cycle. Any cycle whose sum of node weights is less \nthan number is removed from the results. The default is the largest (in magnitude) negative number \nthat can be represented by a double, which causes no cycles to be removed from the results."},"StatementOptionType":"V"},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=CAS-libref.data-table \n          \nSpecifies the output data table to contain the cycles found. \n\nCAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session identifier, \nand data-table specifies the name of the output data table."},"StatementOptionType":"V"}]}},{"StatementName":"DISPLAY","StatementHelp":{"#cdata":"Syntax: DISPLAY <table-list> </ options>;\n      \nThe DISPLAY statement enables you to specify a list of display tables to display or exclude. This statement \nis similar to the ODS SELECT, ODS EXCLUDE, and ODS TRACE statements. However, the DISPLAY statement can improve \nperformance when a large number of tables could be generated (such as in BY-group processing). The procedure \nprocesses the DISPLAY statement on a CAS server and thus sends only a subset of ODS tables to the SAS client. \nBecause ODS statements are processed on a SAS client, first all the generated display tables are sent to the \nclient, and then the client creates a subset. \n\nIf you use both DISPLAY and ODS statements together, the DISPLAY statement takes precedence over the ODS \nstatements."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"CASESENSITIVE","StatementOptionHelp":{"#cdata":"Performs a case-sensitive comparison of table names in the table-list to display table names when \ntables are subsetted for display. To preserve case, you must enclose table names in the table-list \nin quotation marks."},"StatementOptionType":"S"},{"StatementOptionName":"EXCLUDE","StatementOptionHelp":{"#cdata":"Displays all display tables except those specified in the table-list."},"StatementOptionType":"S"},{"StatementOptionName":"EXCLUDEALL","StatementOptionHelp":{"#cdata":"Suppresses display of all tables. This option takes precedence over the other options."},"StatementOptionType":"S"},{"StatementOptionName":"TRACE","StatementOptionHelp":{"#cdata":"Displays the display table names, labels, and paths."},"StatementOptionType":"S"}]}},{"StatementName":"DISPLAYOUT","StatementHelp":{"#cdata":"Syntax: DISPLAYOUT table-spec-list < / options > ;\n      \nThe DISPLAYOUT statement enables you to create CAS output tables from your displayed output. This\nstatement is similar to the ODS OUTPUT statement.\n\nThe table-spec-list specifies a list of CAS output tables to create. Each entry in the list has either a key or a\nkey=value format:\n\n  key=value specifies key as the ODS table name, path, or partial pathname, and specifies value as the\n    CAS output table name.\n  key specifies key as the ODS table name and also as the CAS output table name.\n  \nTable names and partial pathnames are discussed under the DISPLAY statement. The DISPLAYOUT\nstatement does not support regular expressions."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"INCLUDEALL","StatementOptionHelp":{"#cdata":"Creates output CAS tables for all display tables. The name of the created output CAS table is the \nsame as the corresponding display table name. If you specify this option, the table-spec-list specification \nis ignored."},"StatementOptionType":"S"},{"StatementOptionName":"NOREPLACE","StatementOptionHelp":{"#cdata":"Does not replace an existing CAS output table of the same name."},"StatementOptionType":"S"},{"StatementOptionName":"REPEATED","StatementOptionHelp":{"#cdata":"Replicates the CAS output tables on all nodes."},"StatementOptionType":"S"}]}},{"StatementName":"LINEARASSIGNMENT|LAP","StatementHelp":{"#cdata":"Syntax: LINEARASSIGNMENT < options >; \nSyntax: LAP < options >;\n      \nThe LINEARASSIGNMENT statement invokes an algorithm that solves the minimal-cost linear assignment \nproblem. In graph terms, this problem is also known as the minimum link-weighted matching problem \non a bipartite graph. You define the input data as a directed graph by specifying the LINKS= option \nin the PROC OPTNETWORK statement, where the costs are defined as link weights. Internally, the graph \nis treated as a bipartite graph in which the from nodes define one part and the to nodes define the \nother part."},"StatementOptions":{"StatementOption":{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=CAS-libref.data-table \n          \nSpecifies the output data table to contain the solution to the linear assignment problem."},"StatementOptionType":"V"}}},{"StatementName":"LINKSVAR","StatementHelp":{"#cdata":"Syntax: LINKSVAR < options >;\n      \nThe LINKSVAR statement enables you to explicitly specify the data variable names for PROC OPTNETWORK \nto use when it reads the data table that you specify in the LINKS= option in the PROC OPTNETWORK \nstatement."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"AUXWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: AUXWEIGHT=column \n          \nSpecifies the name of the data variable for the auxiliary link weights. The value of the column \nvariable must be numeric."},"StatementOptionType":"V"},{"StatementOptionName":"FROM=","StatementOptionHelp":{"#cdata":"Syntax: FROM=column \n          \nSpecifies the name of the data variable for the from nodes. The value of the column variable can \nbe numeric or character."},"StatementOptionType":"V"},{"StatementOptionName":"LOWER=","StatementOptionHelp":{"#cdata":"Syntax: LOWER=column \n          \nSpecifies the name of the data variable for the link lower bounds. The value of the column variable \nmust be numeric."},"StatementOptionType":"V"},{"StatementOptionName":"TO=","StatementOptionHelp":{"#cdata":"Syntax: TO=column \n          \nSpecifies the name of the data variable for the to nodes. The value of the column variable can be \nnumeric or character."},"StatementOptionType":"V"},{"StatementOptionName":"UPPER=","StatementOptionHelp":{"#cdata":"Syntax: UPPER=column \n          \nSpecifies the name of the data variable for the link upper bounds. The value of the column variable \nmust be numeric."},"StatementOptionType":"V"},{"StatementOptionName":"WEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT=column \n      \nSpecifies the name of the data variable for the link weights. The value of the column variable \nmust be numeric."},"StatementOptionType":"V"}]}},{"StatementName":"MINCOSTFLOW|MCF","StatementHelp":{"#cdata":"Syntax: MINCOSTFLOW < options >;\n\nSyntax: MCF < options >;\n\nThe MINCOSTFLOW statement invokes an algorithm that solves the minimum-cost network flow problem \non an input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"INTERNALFORMAT=","StatementOptionHelp":{"#cdata":"Syntax: INTERNALFORMAT=FULL | THIN \n          \nSpecifies the internal graph format for the minimum-cost network flow algorithm to use.\n\nBy default, INTERNALFORMAT=FULL."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"FULL","@Value2":"THIN"},"StatementOptionToolTips":{"@ToolTip1":"Stores the graph in standard (adjacency-list-based) format. ","@ToolTip2":"Stores the graph in thin (simple list of links) format. This option can improve performance in some  cases both by reducing memory and by simplifying the construction of the internal data structures.  This option causes PROC OPTNETWORK to skip the removal of duplicate links when it reads in the graph."}},{"StatementOptionName":"LOGFREQUENCY=|LOGFREQ=","StatementOptionHelp":{"#cdata":"Syntax: LOGFREQ=number | LOGFREQUENCY=number \n          \nControls the frequency for displaying iteration logs for minimum-cost network flow calculations \nthat use the network simplex algorithm. For graphs that contain one component, this option displays \nprogress every number of simplex iterations; the default is 10,000. For graphs that contain multiple \ncomponents, when you also specify LOGLEVEL=MODERATE, this option displays progress after processing \nevery number of components; the default is based on the number of components. When you also specify \nLOGLEVEL=AGGRESSIVE, the simplex iteration log for each component is displayed with a frequency of \nnumber. \n\nThe value of number can be any integer greater than or equal to 1. Setting this value too low can \nurt performance on large-scale graphs. "},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=number \n          \nSpecifies the maximum amount of time to spend calculating minimum-cost network flows. The type \nof time (either CPU time or real time) is determined by the value of the TIMETYPE= option in the \nPROC OPTNETWORK statement. The default is the largest number that can be represented by a double."},"StatementOptionType":"V"}]}},{"StatementName":"MINCUT","StatementHelp":{"#cdata":"Syntax: MINCUT < options >;\n      \nThe MINCUT statement invokes an algorithm that finds the minimum link-weighted cut of an input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"MAXCUTS=","StatementOptionHelp":{"#cdata":"Syntax: MAXCUTS=number \n          \nSpecifies the maximum number of cuts for the algorithm to return. The minimal cut and any others \nthat it finds during the search, up to number, are returned. By default, MAXCUTS=1."},"StatementOptionType":"V"},{"StatementOptionName":"MAXWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MAXWEIGHT=number \n          \nSpecifies the maximum weight of the cuts for the algorithm to return. Only cuts whose weight is less \nthan or equal to number are returned. The default is the largest number that can be represented by a \ndouble."},"StatementOptionType":"V"},{"StatementOptionName":"OUTCUTSETS=|OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUTCUTSETS=CAS-libref.data-table | OUT=CAS-libref.data-table \n          \nSpecifies the output data table to contain the minimum cut sets to the minimum-cut problem."},"StatementOptionType":"V"},{"StatementOptionName":"OUTPARTITIONS=","StatementOptionHelp":{"#cdata":"Syntax: OUTPARTITIONS=CAS-libref.data-table \n          \nSpecifies the output data table to contain the minimum cut partitions to the minimum-cut problem."},"StatementOptionType":"V"}]}},{"StatementName":"MINSPANTREE|MST","StatementHelp":{"#cdata":"Syntax: MINSPANTREE < options >;\nSyntax: MST < options >;\n\nThe MINSPANTREE statement invokes an algorithm that solves the minimum link-weighted spanning tree \nproblem on an input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"INTERNALFORMAT=","StatementOptionHelp":{"#cdata":"Syntax: INTERNALFORMAT=FULL | THIN \n          \nSpecifies the internal graph format for the minimum spanning tree algorithm to use.\n\nBy default, INTERNALFORMAT=THIN."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"FULL","@Value2":"THIN"},"StatementOptionToolTips":{"@ToolTip1":"Stores the graph in standard (adjacency-list-based) format. ","@ToolTip2":"Stores the graph in thin (simple list of links) format. This option can improve performance in some  cases both by reducing memory and by simplifying the construction of the internal data structures.  This option causes PROC OPTNETWORK to skip the removal of duplicate links when it reads in the graph."}},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=CAS-libref.data-table \n          \nSpecifies the output data table to contain the solution to the minimum link-weighted spanning tree problem."},"StatementOptionType":"V"}]}},{"StatementName":"NODESSUBSETVAR","StatementHelp":{"#cdata":"Syntax: NODESSUBSETVAR < options >;\n          \nThe NODESSUBSETVAR statement enables you to explicitly specify the data variable names for \nPROC OPTNETWORK to use when it reads the data table that you specify in the NODESSUBSET= \noption in the PROC OPTNETWORK statement."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"NODE=","StatementOptionHelp":{"#cdata":"Syntax: NODE=column \n          \nSpecifies the name of the data variable for the nodes. The value of the column variable can \nbe numeric or character."},"StatementOptionType":"V"},{"StatementOptionName":"SINK=","StatementOptionHelp":{"#cdata":"Syntax: SINK=column \n          \nSpecifies the name of the data variable for the sink indicator. The value of the column variable \nmust be numeric."},"StatementOptionType":"V"},{"StatementOptionName":"SOURCE=","StatementOptionHelp":{"#cdata":"Syntax: SOURCE=column \n          \nSpecifies the name of the data variable for the source indicator. The value of the column variable \nmust be numeric."},"StatementOptionType":"V"}]}},{"StatementName":"NODESVAR","StatementHelp":{"#cdata":"Syntax: NODESVAR < options >;\n      \nThe NODESVAR statement enables you to explicitly specify the data variable names for PROC OPTNETWORK \nto use when it reads the data table that you specify in the NODES= option in the PROC OPTNETWORK \nstatement."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"LOWER=","StatementOptionHelp":{"#cdata":"Syntax: LOWER=column \n          \nSpecifies the name of the data variable for the node lower bounds. The value of the column variable \nmust be numeric."},"StatementOptionType":"V"},{"StatementOptionName":"NODE=","StatementOptionHelp":{"#cdata":"Syntax: NODE=column \n          \nSpecifies the name of the data variable for the nodes. The value of the column variable can \nbe numeric or character."},"StatementOptionType":"V"},{"StatementOptionName":"UPPER=","StatementOptionHelp":{"#cdata":"Syntax: UPPER=column \n          \nSpecifies the name of the data variable for the node upper bounds. The value of the column variable \nmust be numeric."},"StatementOptionType":"V"},{"StatementOptionName":"WEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: WEIGHT=column \n          \nSpecifies the name of the data variable for the node weights. The value of the column variable must \nbe numeric."},"StatementOptionType":"V"}]}},{"StatementName":"PATH","StatementHelp":{"#cdata":"Syntax: PATH < options >;\n      \nThe PATH statement invokes an algorithm that finds the paths in the input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"INTERNALFORMAT=","StatementOptionHelp":{"#cdata":"Syntax: INTERNALFORMAT=FULL | THIN \n          \nSpecifies the internal graph format for the path enumeration algorithm to use.\n\nBy default, INTERNALFORMAT=THIN."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"FULL","@Value2":"THIN"},"StatementOptionToolTips":{"@ToolTip1":"Stores the graph in standard (adjacency-list-based) format. ","@ToolTip2":"Stores the graph in thin (simple list of links) format. This option can improve performance in some  cases both by reducing memory and by simplifying the construction of the internal data structures.  This option causes PROC OPTNETWORK to skip the removal of duplicate links when it reads in the graph."}},{"StatementOptionName":"MAXLENGTH=","StatementOptionHelp":{"#cdata":"Syntax: MAXLENGTH=number \n          \nSpecifies the maximum number of links in a path. Any path whose length is greater than number \nis removed from the results. The default is the largest number that can be represented by a 32-bit \ninteger, which causes no paths to be removed from the results."},"StatementOptionType":"V"},{"StatementOptionName":"MAXLINKWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MAXLINKWEIGHT=number \n          \nSpecifies the maximum sum of link weights in a path. Any path whose sum of link weights is greater \nthan number is removed from the results. The default is the largest number that can be represented by \na double, which causes no paths to be removed from the results."},"StatementOptionType":"V"},{"StatementOptionName":"MAXNODEWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MAXNODEWEIGHT=number \n          \nSpecifies the maximum sum of node weights in a path. Any path whose sum of node weights is greater \nthan number is removed from the results. The default is the largest number that can be represented by \na double, which causes no paths to be removed from the results."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=number \n          \nSpecifies the maximum amount of time to spend finding paths. The type of time (either CPU time \nor real time) is determined by the value of the TIMETYPE= option in the PROC OPTNETWORK statement. \nThe default is the largest number that can be represented by a double."},"StatementOptionType":"V"},{"StatementOptionName":"MINLENGTH=","StatementOptionHelp":{"#cdata":"Syntax: MINLENGTH=number \n          \nSpecifies the minimum number of links in a path. Any path that has fewer links than number \nis removed from the results. By default, MINLENGTH=1 and no paths are removed from the results."},"StatementOptionType":"V"},{"StatementOptionName":"MINLINKWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MINLINKWEIGHT=number \n          \nSpecifies the minimum sum of link weights in a path. Any path whose sum of link weights is less \nthan number is removed from the results. The default is the largest (in magnitude) negative number \nthat can be represented by a double, which causes no paths to be removed from the results."},"StatementOptionType":"V"},{"StatementOptionName":"MINNODEWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MINNODEWEIGHT=number \n          \nSpecifies the minimum sum of node weights in a path. Any path whose sum of node weights is less \nthan number is removed from the results. The default is the largest (in magnitude) negative number \nthat can be represented by a double, which causes no paths to be removed from the results."},"StatementOptionType":"V"},{"StatementOptionName":"OUTPATHSLINKS=|OUTPATHS=","StatementOptionHelp":{"#cdata":"Syntax: OUTPATHSLINKS=CAS-libref.data-table | OUTPATHS=CAS-libref.data-table \n\nSpecifies the output data table to contain the path links. CAS-libref.data-table is a two-level name, \nwhere CAS-libref refers to the caslib and session identifier, and data-table specifies the name of the \noutput data table."},"StatementOptionType":"V"},{"StatementOptionName":"OUTPATHSNODES=","StatementOptionHelp":"OUTPATHSNODES=<![CDATA[Syntax: OUTPATHSNODES=CAS-libref.data-table \n          \nSpecifies the output data table to contain the path nodes. \n\nCAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session identifier, \nand data-table specifies the name of the output data table.]]>","StatementOptionType":"V"},{"StatementOptionName":"SINK=","StatementOptionHelp":{"#cdata":"Syntax: SINK=sink-node \n          \nSpecifies the sink node for path calculations. This setting overrides the use of the variable sink \nin the data table that you specify in the NODESSUBSET= option in the PROC OPTNETWORK statement."},"StatementOptionType":"V"},{"StatementOptionName":"SOURCE=","StatementOptionHelp":{"#cdata":"Syntax: SOURCE=source-node \n          \nSpecifies the source node for path calculations. This setting overrides the use of the variable source \nin the data table that you specify in the NODESSUBSET= option in the PROC OPTNETWORK statement."},"StatementOptionType":"V"}]}},{"StatementName":"SHORTESTPATH","StatementHelp":{"#cdata":"Syntax: SHORTESTPATH < options >; \n      \nThe SHORTESTPATH statement invokes an algorithm that calculates shortest paths between pairs of \nnodes in the input graph. By default, PROC OPTNETWORK finds a shortest path for each possible \ncombination of source and sink nodes."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"MAXPATHWEIGHT=","StatementOptionHelp":{"#cdata":"Syntax: MAXPATHWEIGHT=number \n          \nSpecifies the maximum path weight. Any shortest path whose sum of link weights is greater than \nnumber is removed from the results. The default is the largest number that can be represented \nby a double, which causes no paths to be removed from the results."},"StatementOptionType":"V"},{"StatementOptionName":"OUTPATHS=|OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUTPATHS=CAS-libref.data-table | OUT=CAS-libref.data-table \n          \nSpecifies the output data table to contain the shortest paths. \n\nCAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session identifier, \nand data-table specifies the name of the output data table."},"StatementOptionType":"V"},{"StatementOptionName":"OUTWEIGHTS=","StatementOptionHelp":{"#cdata":"Syntax: OUTWEIGHTS=CAS-libref.data-table \n          \nSpecifies the output data table to contain the shortest path summaries. \n\nCAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session identifier, \nand data-table specifies the name of the output data table."},"StatementOptionType":"V"},{"StatementOptionName":"SINK=","StatementOptionHelp":{"#cdata":"Syntax: SINK=sink-node \n          \nSpecifies the sink node for shortest path calculations. This setting overrides the use of the variable sink \nin the data table that you specify in the NODESSUBSET= option in the PROC OPTNETWORK statement."},"StatementOptionType":"V"},{"StatementOptionName":"SOURCE=","StatementOptionHelp":{"#cdata":"Syntax: SOURCE=source-node \n          \nSpecifies the source node for shortest path calculations. This setting overrides the use of the variable source \nin the data table that you specify in the NODESSUBSET= option in the PROC OPTNETWORK statement."},"StatementOptionType":"V"}]}},{"StatementName":"SUMMARY","StatementHelp":{"#cdata":"Syntax: SUMMARY < options >;\n      \nThe SUMMARY statement invokes an algorithm that calculates various summary metrics for an input graph."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"BICONNECTEDCOMPONENTS","StatementOptionHelp":{"#cdata":"Calculates information about biconnected components. You can use this option only for an undirected graph."},"StatementOptionType":"S"},{"StatementOptionName":"CONNECTEDCOMPONENTS","StatementOptionHelp":{"#cdata":"Calculates information about connected components."},"StatementOptionType":"S"},{"StatementOptionName":"DIAMETERAPPROX=","StatementOptionHelp":{"#cdata":"Syntax: DIAMETERAPPROX=WEIGHT | UNWEIGHT | BOTH \n          \nCalculates information about the approximate diameter and specifies which type of calculation \nto perform. Use this option when calculating the exact diameter (by calculating all shortest \npaths) is too computationally expensive."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"WEIGHT","@Value2":"UNWEIGHT","@Value3":"BOTH"},"StatementOptionToolTips":{"@ToolTip1":"Calculates the approximate diameter by using the weighted graph.","@ToolTip2":"Calculates the approximate diameter by using the unweighted graph.","@ToolTip3":"Calculates the approximate diameter by using both the weighted and unweighted graphs."}},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=CAS-libref.data-table \n          \nSpecifies the output data table to contain the summary results. \n\nCAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session \nidentifier, and data-table specifies the name of the output data table."},"StatementOptionType":"V"},{"StatementOptionName":"SHORTESTPATH=","StatementOptionHelp":{"#cdata":"Syntax: SHORTESTPATH=WEIGHT | UNWEIGHT | BOTH \n          \nCalculates information about shortest paths and specifies which type of calculation to perform."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"WEIGHT","@Value2":"UNWEIGHT","@Value3":"BOTH"},"StatementOptionToolTips":{"@ToolTip1":"Calculates shortest paths by using the weighted graph.","@ToolTip2":"Calculates shortest paths by using the unweighted graph.","@ToolTip3":"Calculates shortest paths by using both the weighted and unweighted graphs."}}]}},{"StatementName":"TRANSITIVECLOSURE","StatementHelp":{"#cdata":"Syntax: TRANSITIVECLOSURE < option >;\n      \nThe TRANSITIVECLOSURE statement invokes an algorithm that calculates the transitive closure of an input graph."},"StatementOptions":{"StatementOption":{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=CAS-libref.data-table \n          \nSpecifies the output data table to contain the transitive closure results. \n\nCAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session identifier, \nand data-table specifies the name of the output data table."},"StatementOptionType":"V"}}},{"StatementName":"TSP","StatementHelp":{"#cdata":"Syntax: TSP < options >;\n      \nThe TSP statement invokes an algorithm that solves the traveling salesman problem, which is described \nin the section Traveling Salesman Problem. The algorithm that is used to solve this problem is built \naround the same method that is used in PROC OPTMILP: a branch-and-cut algorithm."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ABSOBJGAP=|ABSOLUTEOBJECTIVEGAP=","StatementOptionHelp":{"#cdata":"Syntax: ABSOBJGAP=number | ABSOLUTEOBJECTIVEGAP=number \n          \nSpecifies a stopping criterion. When the absolute difference between the best integer objective \nand the objective of the best remaining branch-and-bound node becomes less than the value of \nnumber, the solver stops. The value of number can be any nonnegative number; the default value \nis 1E\u20136."},"StatementOptionType":"V"},{"StatementOptionName":"CUTOFF=","StatementOptionHelp":{"#cdata":"Syntax: CUTOFF=number\n          \nCuts off any branch-and-bound nodes in a minimization problem that has an objective value greater \nthan number. The default is the largest number that can be represented by a double."},"StatementOptionType":"V"},{"StatementOptionName":"CUTSTRATEGY=","StatementOptionHelp":{"#cdata":"[Syntax: CUTSTRATEGY=AUTOMATIC | NONE | MODERATE | AGGRESSIVE \n          \nSpecifies the level of mixed integer linear programming cutting planes to be generated by PROC OPTNETWORK. \nTSP-specific cutting planes are always generated. "},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"MODERATE","@Value4":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Generate cutting planes based on a strategy determined by the mixed integer linear programming solver.","@ToolTip2":"Disables the generation of mixed integer linear programming cutting planes (some TSP-specific cutting  planes are still active for validity).","@ToolTip3":"Uses a moderate cutting strategy. ","@ToolTip4":"Uses an aggressive cutting strategy."}},{"StatementOptionName":"HEURISTICS=","StatementOptionHelp":{"#cdata":"Syntax: HEURISTICS=AUTOMATIC | NONE | BASIC | MODERATE | AGGRESSIVE\n          \ncontrols the level of initial and primal heuristics that PROC OPTNETWORK applies. This level determines how frequently PROC OPTNETWORK applies primal heuristics during the branch-and-bound tree search. It also affects the maximum number of iterations that are allowed in iterative heuristics. Some computationally expensive heuristics might be disabled by the solver at less aggressive levels."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"AUTOMATIC","@Value2":"NONE","@Value3":"BASIC","@Value4":"MODERATE","@Value5":"AGGRESSIVE"},"StatementOptionToolTips":{"@ToolTip1":"Applies the default level of heuristics. ","@ToolTip2":"Disables all initial and primal heuristics. ","@ToolTip3":"Applies basic initial and primal heuristics at low frequency.","@ToolTip4":"Applies most initial and primal heuristics at moderate frequency. ","@ToolTip5":"Applies all initial primal heuristics at high frequency. "}},{"StatementOptionName":"LOGFREQUENCY=|LOGFREQ=","StatementOptionHelp":{"#cdata":"Syntax: LOGFREQ=number | LOGFREQUENCY=number \n          \nSpecifies the time interval (in seconds) for printing information in the node log. The default \nvalue is 5. If number is set to 0, then the node log is disabled. If number is positive, then \nthe root node processing information is printed and, if possible, an entry is made every number \nseconds. An entry is also made each time a better integer solution is found. \n\nThe value of number can be any integer greater than or equal to 0."},"StatementOptionType":"V"},{"StatementOptionName":"MAXNODES=","StatementOptionHelp":{"#cdata":"Syntax: MAXNODES=number \n          \nSpecifies the maximum number of branch-and-bound nodes to be processed. The default is the largest \nnumber that can be represented by a 32-bit integer."},"StatementOptionType":"V"},{"StatementOptionName":"MAXSOLS=","StatementOptionHelp":{"#cdata":"Syntax: MAXSOLS=number \n          \nSpecifies a stopping criterion. If the number of solutions has been found, then the procedure stops. \nThe default is the largest number that can be represented by a 32-bit integer."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"Syntax: MAXTIME=number \n          \nSpecifies the maximum amount of time to spend solving the traveling salesman problem. The type of time \n(either CPU time or real time) is determined by the value of the TIMETYPE= option in the PROC OPTNETWORK \nstatement. The default is the largest number that can be represented by a double."},"StatementOptionType":"V"},{"StatementOptionName":"MILP=","StatementOptionHelp":{"#cdata":"Syntax: MILP=TRUE | FALSE \n          \nSpecifies whether to use a mixed integer linear programming (MILP) solver to solve the traveling salesman \nproblem. The MILP solver attempts to find the overall best TSP tour by using a branch-and-bound-based \nalgorithm. This algorithm can be expensive for large-scale problems. If MILP=FALSE, then PROC OPTNETWORK \nuses its initial heuristics to find a feasible, but not necessarily optimal, tour as quickly as possible.\n\nBy default, MILP=TRUE."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"TRUE","@Value2":"FALSE"},"StatementOptionToolTips":{"@ToolTip1":"Uses a mixed-integer linear programming","@ToolTip2":"Does not use a mixed-integer linear programming solver"}},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=CAS-libref.data-table \n          \nSpecifies the output data table to contain the solution to the traveling salesman problem. \n\nCAS-libref.data-table is a two-level name, where CAS-libref refers to the caslib and session identifier, \nand data-table specifies the name of the output data table."},"StatementOptionType":"V"},{"StatementOptionName":"RELOBJGAP=|RELATIVEOBJECTIVEGAP=","StatementOptionHelp":{"#cdata":"Syntax: RELOBJGAP=number | RELATIVEOBJECTIVEGAP=number \n          \nSpecifies a stopping criterion that is based on the best integer objective (BestInteger) \nand the objective of the best remaining node (BestBound)."},"StatementOptionType":"V"},{"StatementOptionName":"TARGET=","StatementOptionHelp":{"#cdata":"Syntax: TARGET=number \n          \nSpecifies a stopping criterion for minimization problems. If the best integer objective is less \nthan or equal to number, the solver stops. The default is the largest (in magnitude) negative \nnumber that can be represented by a double."},"StatementOptionType":"V"}]}}]}}}