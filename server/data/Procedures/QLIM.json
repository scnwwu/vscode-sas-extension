{"Procedure":{"Name":"QLIM","#comment":{},"ProductGroup":"SAS/ETS","ProcedureHelp":{"#cdata":"Syntax: PROC QLIM options ; \n    BOUNDS bound1 < , bound2 ...> ; \n    BY variables ; \n    CLASS variables ; \n    FREQ variable ; \n    ENDOGENOUS variables ~ options ; \n    HETERO dependent variables ~ exogenous variables / options ; \n    INIT initvalue1 < , initvalue2 ...> ; \n    MODEL dependent variables = regressors / options ; \n    NLOPTIONS options ; \n    OUTPUT options ; \n    RESTRICT restriction1 < , restriction2 ...> ; \n    TEST options ; \n    WEIGHT variable ; \n\nThe QLIM (qualitative and limited dependent variable model) procedure analyzes univariate \nand multivariate limited dependent variable models where dependent variables take discrete \nvalues or dependent variables are observed only in a limited range of values. This procedure \nincludes logit, probit, tobit, selection, and multivariate models. The multivariate model can \ncontain discrete choice and limited endogenous variables as well as continuous endogenous \nvariables. \n\nThe QLIM procedure supports the following models: \n\n  o linear regression model with heteroscedasticity \n  o Box-Cox regression with heteroscedasticity \n  o probit with heteroscedasticity \n  o logit with heteroscedasticity \n  o tobit (censored and truncated) with heteroscedasticity \n  o bivariate probit \n  o bivariate tobit \n  o sample selection and switching regression models \n  o multivariate limited dependent variables \n  o stochastic frontier production and cost models"},"ProcedureOptions":{"ProcedureOption":[{"ProcedureOptionName":"DATA=","ProcedureOptionHelp":{"#cdata":"[Syntax: DATA=SAS-data-set] \n      \nSpecifies the input SAS data set. If the DATA= option is not specified, PROC QLIM uses \nthe most recently created SAS data set. "},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"OUTEST=","ProcedureOptionHelp":{"#cdata":"[Syntax: OUTEST=SAS-data-set] \n      \nWrites the parameter estimates to an output data set."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"COVOUT","ProcedureOptionHelp":{"#cdata":"Writes the covariance matrix for the parameter estimates to the OUTEST= data set. This option \nis valid only if the OUTEST= option is specified."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"CORROUT","ProcedureOptionHelp":{"#cdata":"Writes the correlation matrix for the parameter estimates to the OUTEST= data set. This option \nis valid only if the OUTEST= option is specified."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"NOPRINT","ProcedureOptionHelp":{"#cdata":"Suppresses the normal printed output but does not suppress error listings. If NOPRINT option \nis set, then any other print option is turned off."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"PRINTALL","ProcedureOptionHelp":{"#cdata":"Turns on all the printing-control options. The options set by PRINTALL are COVB and CORRB."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"CORRB","ProcedureOptionHelp":{"#cdata":"Prints the correlation matrix of the parameter estimates."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"COVB","ProcedureOptionHelp":{"#cdata":"Prints the covariance matrix of the parameter estimates."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"ITPRINT","ProcedureOptionHelp":{"#cdata":"Prints the initial parameter estimates, convergence criteria, and all constraints of the \noptimization. At each iteration, objective function value, step size, maximum gradient, \nand slope of search direction are printed as well."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"COVEST=","ProcedureOptionHelp":{"#cdata":"Specifies the method to calculate the covariance matrix of parameter estimates."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"OP","@Value2":"HESSIAN","@Value3":"QML"},"ProcedureOptionToolTips":{"@ToolTip1":"Specifies the covariance from the outer product matrix.","@ToolTip2":"Specifies the covariance from the inverse Hessian matrix.","@ToolTip3":"Specifies the covariance from the outer product and Hessian matrices (the quasi-maximum likelihood estimates)."}},{"ProcedureOptionName":"NDRAW=","ProcedureOptionHelp":{"#cdata":"[Syntax: NDRAW=value] \n      \nSpecifies the number of draws for Monte Carlo integration."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"SEED=","ProcedureOptionHelp":{"#cdata":"[Syntax: SEED=value] \n      \nSpecifies a seed for pseudo-random number generation in Monte Carlo integration."},"ProcedureOptionType":"V"},{"ProcedureOptionName":"METHOD=","ProcedureOptionHelp":{"#cdata":"Specifies the optimization method. If this option is specified, it overwrites the TECH= option \nin NLOPTIONS statement."},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"CONGRA","@Value2":"DBLDOG","@Value3":"NMSIMP","@Value4":"NEWRAP","@Value5":"NRRIDG","@Value6":"QUANEW","@Value7":"TRUREG"},"ProcedureOptionToolTips":{"@ToolTip1":"Performs a conjugate-gradient optimization","@ToolTip2":"Performs a version of double dogleg optimization","@ToolTip3":"Performs a Nelder-Mead simplex optimization","@ToolTip4":"Performs a Newton-Raphson optimization combining a line-search algorithm with ridging","@ToolTip5":"Performs a Newton-Raphson optimization with ridging","@ToolTip6":"Performs a quasi-Newton optimization","@ToolTip7":"Performs a trust region optimization"}}]},"ProcedureStatements":{"ProcedureStatement":[{"StatementName":"BOUNDS","StatementHelp":{"#cdata":"Syntax: BOUNDS bound1 < , bound2 ...> ; \n\nThe BOUNDS statement imposes simple boundary constraints on the parameter estimates. BOUNDS \nstatement constraints refer to the parameters estimated by the QLIM procedure. Any number of \nBOUNDS statements can be specified. \n\nEach bound is composed of parameters and constants and inequality operators. Parameters associated \nwith regressor variables are referred to by the names of the corresponding regressor variables: \n\n  item operator item < operator item < operator item ...> >\n\nEach item is a constant, the name of a parameter, or a list of parameter names. Each operator\nis \u2019<\u2019, \u2019>\u2019, \u2019\u2264\u2019, or \u2019\u2265\u2019."},"StatementOptions":null},{"StatementName":"BY","StatementHelp":{"#cdata":"Syntax: BY variables ; \nA BY statement can be used with PROC QLIM to obtain separate analyses on observations \nin groups defined by the BY variables."},"StatementOptions":null},{"StatementName":"CLASS","StatementHelp":{"#cdata":"Syntax: CLASS variables ; \n\nThe CLASS statement names the classification variables to be used in the analysis. \nClassification variables can be either character or numeric."},"StatementOptions":null},{"StatementName":"FREQ","StatementHelp":{"#cdata":"Syntax: FREQ variable ; \n      \nThe FREQ statement identifies a variable that contains the frequency of occurrence \nof each observation. PROC QLIM treats each observation as if it appears n times, \nwhere n is the value of the FREQ variable for the observation. If it is not an integer, \nthe frequency value is truncated to an integer. If the frequency value is less than 1 \nor missing, the observation is not used in the model fitting. When the FREQ statement \nis not specified, each observation is assigned a frequency of 1. If you specify more \nthan one FREQ statement, then the first FREQ statement is used."},"StatementOptions":null},{"StatementName":"ENDOGENOUS","StatementHelp":{"#cdata":"Syntax: ENDOGENOUS variables ~ options ; \n\nThe ENDOGENOUS statement specifies the type of dependent variables that appear \non the left-hand side of the equation. Endogenous variables listed refer to the \ndependent variables that appear on the left-hand side of the equation. Currently, \nno right-hand side endogeneity is handled in PROC QLIM. All variables appearing \non the right-hand side of the equation are treated as exogenous"},"StatementOptions":{"StatementOption":[{"StatementOptionName":"DISCRETE","StatementOptionHelp":{"#cdata":"[Syntax: DISCRETE <(discrete-options)>] \n          \nSpecifies that the endogenous variables in this statement are discrete. Valid discrete-options \nare as follows: \n\n  ORDER=DATA | FORMATTED | FREQ | INTERNAL \n  specifies the sorting order for the levels of the discrete variables specified in the \n  ENDOGENOUS statement.\n\n  DISTRIBUTION=NORMAL|LOGISTIC \n  DIST=NORMAL|LOGISTIC \n  D=NORMAL|LOGISTIC \n  specifies the cumulative distribution function used to model the response probabilities. \n  Valid values are as follows: \n\n    NORMAL \n    the normal distribution for the probit model \n\n    LOGISTIC \n    the logistic distribution for the logit model"},"StatementOptionType":"V","SubOptionsKeywords":"ORDER=|DISTRIBUTION=|DIST=|D="},{"StatementOptionName":"CENSORED","StatementOptionHelp":{"#cdata":"[Syntax: CENSORED <(censored-options )>] \n          \nSpecifies that the endogenous variables in this statement be censored. Valid censored-options \nare as follows: \n\n  LB=value or variable \n  LOWERBOUND=value or variable \n  specifies the lower bound of the censored variables. If value is missing or the value \n  in variable is missing, no lower bound is set. By default, no lower bound is set. \n\n  UB=value or variable \n  UPPERBOUND=value or variable \n  specifies the upper bound of the censored variables. If value is missing or the value \n  in variable is missing, no upper bound is set. By default, no upper bound is set."},"StatementOptionType":"V","SubOptionsKeywords":"LB=|LOWERBOUND=|UB=|UPPERBOUND="},{"StatementOptionName":"TRUNCATED","StatementOptionHelp":{"#cdata":"[Syntax: CENSORED <(truncated-options )>] \n          \nSpecifies that the endogenous variables in this statement be truncated. Valid truncated-options \nare as follows: \n\n  LB=value or variable \n  LOWERBOUND=value or variable \n  specifies the lower bound of the truncated variables. If value is missing or the value in variable is missing,\n  no lower bound is set. By default, no lower bound is set. \n\n  UB=value or variable \n  UPPERBOUND=value or variable \n  specifies the upper bound of the truncated variables. If value is missing or the value in variable is missing, \n  no upper bound is set. By default, no upper bound is set."},"StatementOptionType":"V","SubOptionsKeywords":"LB=|LOWERBOUND=|UB=|UPPERBOUND="},{"StatementOptionName":"FRONTIER","StatementOptionHelp":{"#cdata":"[Syntax: FRONTIER <(frontier-options )>] \n          \nSpecifies that the endogenous variable in this statement follow a production or cost frontier. \nValid frontier-options are as follows: \n\n  TYPE=HALF | EXPONENTIAL | TRUNCATED\n\n    HALF \n    specifies half-normal model. \n\n    EXPONENTIAL \n    specifies exponential model. \n\n    TRUNCATED \n    specifies truncated normal model. \n\n  PRODUCTION \n  specifies that the model estimated be a production function. \n\n  COST \n  specifies that the model estimated be a cost function."},"StatementOptionType":"V","SubOptionsKeywords":"TYPE=|PRODUCTION|COST"},{"StatementOptionName":"SELECT","StatementOptionHelp":{"#cdata":"[Syntax: SELECT (select-option )] \n          \nSpecifies selection criteria for sample selection model. Select-option specifies the \ncondition for the endogenous variable to be selected. It is written as a variable name, \nfollowed by an equality operator (=) or an inequality operator (<, >, \u2264, \u2265), followed \nby a number: \n\n  variable operator number\n\nThe variable is the endogenous variable that the selection is based on. The operator can \nbe =, <, >, \u2264 , or \u2265. Multiple select-options can be combined with the logic operators: \nAND, OR. The following example illustrates the use of the SELECT option: \n\n   endogenous y1 ~ select(z=0);\n   endogenous y2 ~ select(z=1 or z=2);"},"StatementOptionType":"V"}]}},{"StatementName":"HETERO","StatementHelp":{"#cdata":"Syntax: HETERO dependent variables ~ exogenous variables </ options > ; \n\nThe HETERO statement specifies variables that are related to the heteroscedasticity of the \nresiduals and the way these variables are used to model the error variance."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"LINK=","StatementOptionHelp":{"#cdata":"The functional form can be specified using the LINK= option."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"EXP","@Value2":"LINEAR"},"StatementOptionToolTips":{"@ToolTip1":"Specifies a exponential link function.","@ToolTip2":"Specifies a linear link function."}},{"StatementOptionName":"NOCONST","StatementOptionHelp":{"#cdata":"Specifies that there be no constant in the linear or exponential heteroscedasticity model."},"StatementOptionType":"S"},{"StatementOptionName":"SQUARE","StatementOptionHelp":{"#cdata":"Estimates the model by using the square of linear heteroscedasticity function."},"StatementOptionType":"S"}]}},{"StatementName":"INIT","StatementHelp":{"#cdata":"Syntax: INIT initvalue1 < , initvalue2 ...> ; \n\nThe INIT statement is used to set initial values for parameters in the optimization. \nAny number of INIT statements can be specified. \n\nEach initvalue is written as a parameter or parameter list, followed by an optional \nequality operator (=), followed by a number: \n\n  parameter <=> number"},"StatementOptions":null},{"StatementName":"MODEL","StatementHelp":{"#cdata":"Syntax: MODEL dependent = regressors < / options > ; \n\nThe MODEL statement specifies the dependent variable and independent regressor variables\nfor the regression model."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"LIMIT1=","StatementOptionHelp":{"#cdata":"[Syntax: LIMIT1=value] \n          \nSpecifies the restriction of the threshold value of the first category when the ordinal \nprobit or logit model is estimated. LIMIT1=ZERO is the default option. When LIMIT1=VARYING \nis specified, the threshold value is estimated."},"StatementOptionType":"V"},{"StatementOptionName":"NOINT","StatementOptionHelp":{"#cdata":"Suppresses the intercept parameter."},"StatementOptionType":"S"},{"StatementOptionName":"BOXCOX","StatementOptionHelp":{"#cdata":"[Syntax: BOXCOX (option-list )] \n          \nSpecifies options that are used for Box-Cox regression or regressor transformation. For example, \nthe Box-Cox regression is specified as:\n\n   model y = x1 x2 / boxcox(y=lambda,x1 x2)\n\nThe option-list takes the form variable-list < = varname > separated by \u2019,\u2019. The variable-list \nspecifies that the list of variables have the same Box-Cox transformation; varname specifies \nthe name of this Box-Cox coefficient. If varname is not specified, the coefficient is called \n_Lambdai, where i increments sequentially."},"StatementOptionType":"V"}]}},{"StatementName":"NLOPTIONS","StatementHelp":{"#cdata":"Syntax: NLOPTIONS <options> ; \n\nPROC QLIM uses the be nonlinear optimization (NLO) subsystem to perform nonlinear \noptimization tasks."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ABSCONV=|ABSTOL=","StatementOptionHelp":{"#cdata":"[Syntax: ABSCONV= | ABSTOL=r] \n          \nSpecifies an absolute function convergence criterion. The default value of r is the negative \nsquare root of the largest double-precision value, which serves only as a protection against \noverflows. "},"StatementOptionType":"V"},{"StatementOptionName":"ABSFCONV=|ABSFTOL=","StatementOptionHelp":{"#cdata":"[Syntax: ABSFCONV=r[n] | ABSFTOL=r[n]] \n          \nSpecifies an absolute function convergence criterion. The default value is r=0. The optional \ninteger value n specifies the number of successive iterations for which the criterion must be \nsatisfied before the process can be terminated."},"StatementOptionType":"V"},{"StatementOptionName":"ABSGCONV=|ABSGTOL=","StatementOptionHelp":{"#cdata":"[Syntax: ABSGCONV=r[n] | ABSGTOL=r[n]] \n          \nSpecifies an absolute gradient convergence criterion. The default value is r=1E-5. \nThe optional integer value n specifies the number of successive iterations for which \nthe criterion must be satisfied before the process can be terminated."},"StatementOptionType":"V"},{"StatementOptionName":"ABSXCONV=|ABSXTOL=","StatementOptionHelp":{"#cdata":"[Syntax: ABSXCONV= | ABSXTOL=r[n]] \n          \nSpecifies the absolute parameter convergence criterion. The default is r=1E-8 for the \nNMSIMP technique and r=0 otherwise. The optional integer value n specifies the number of \nsuccessive iterations for which the criterion must be satisfied before the process can \nterminate."},"StatementOptionType":"V"},{"StatementOptionName":"DAMPSTEP=","StatementOptionHelp":{"#cdata":"[Syntax: DAMPSTEP<=r>] \n          \nSpecifies that the initial step length value a\u2070 for each line search (used by the QUANEW, \nHYQUAN, CONGRA, or NEWRAP technique) cannot be larger than r times the step length value used \nin the former iteration. If the DAMPSTEP option is specified but r is not specified, the default \nis r=2. The DAMPSTEP=r option can prevent the line-search algorithm from repeatedly stepping into\nregions where some objective functions are difficult to compute or where they could lead to floating \npoint overflows during the computation of objective functions and their derivatives. The DAMPSTEP=r \noption can save time-costly function calls during the line searches of objective functions that \nresult in very small steps."},"StatementOptionType":"S|V"},{"StatementOptionName":"FCONV=|FTOL=","StatementOptionHelp":{"#cdata":"[Syntax: FCONV= | FTOL=r[n]] \n          \nSpecifies a relative function convergence criterion."},"StatementOptionType":"V"},{"StatementOptionName":"FCONV2=|FTOL2=","StatementOptionHelp":{"#cdata":"[Syntax: FCONV2= | FTOL2=r[n]] \n          \nSpecifies another function convergence criterion."},"StatementOptionType":"V"},{"StatementOptionName":"FSIZE=","StatementOptionHelp":{"#cdata":"[Syntax:FSIZE=r] \n          \nSpecifies the FSIZE parameter of the relative function and relative gradient termination \ncriteria. The default value is r=0."},"StatementOptionType":"V"},{"StatementOptionName":"GCONV=|GTOL=","StatementOptionHelp":{"#cdata":"[Syntax: GCONV=r | GTOL=r] \n          \nSpecifies a relative gradient convergence criterion. The default value is r=1E-8. \nThe optional integer value n specifies the number of successive iterations for which \nthe criterion must be satisfied before the process can terminate."},"StatementOptionType":"V"},{"StatementOptionName":"HESCAL=|HS=","StatementOptionHelp":{"#cdata":"Specifies the scaling version of the Hessian matrix used in NRRIDG, TRUREG, NEWRAP, or \nDBLDOG optimization."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"0","@Value2":"1","@Value3":"2","@Value4":"3"},"StatementOptionToolTips":{"@ToolTip1":"Specifies that no scaling is done.","@ToolTip2":"Specifies the Mor\u00e9 (1978) scaling update","@ToolTip3":"Specifies the Dennis, Gay, and Welsch (1981) scaling update","@ToolTip4":"Specifies that di is reset in each iteration"}},{"StatementOptionName":"INHESSIAN=|INHESS=","StatementOptionHelp":{"#cdata":"[Syntax: INHESSIAN[=r]] \n          \nSpecifies how the initial estimate of the approximate Hessian is defined for the \nquasi-Newton techniques QUANEW and DBLDOG."},"StatementOptionType":"S|V"},{"StatementOptionName":"INSTEP=","StatementOptionHelp":{"#cdata":"[Syntax: INSTEP=r] \n          \nReduces the length of the first trial step during the line search of the first iterations."},"StatementOptionType":"V"},{"StatementOptionName":"LINESEARCH=|LIS=","StatementOptionHelp":{"#cdata":"[Syntax: LINESEARCH= | LIS=i] \n          \n Specifies the line-search method for the CONGRA, QUANEW, and NEWRAP optimization techniques."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"1","@Value2":"2","@Value3":"3","@Value4":"4","@Value5":"5","@Value6":"6","@Value7":"7","@Value8":"8"},"StatementOptionToolTips":{"@ToolTip1":"Specifies a line-search method that needs the same number of function and gradient calls  for cubic interpolation and cubic extrapolation; this method is similar to one used by  the Harwell subroutine library.","@ToolTip2":"Specifies a line-search method that needs more function calls than gradient calls for quadratic  and cubic interpolation and cubic extrapolation; this method is implemented as shown in Fletcher  (1987) and can be modified to an exact line search by using the LSPRECISION= option.","@ToolTip3":"Specifies a line-search method that needs the same number of function and gradient calls for  cubic interpolation and cubic extrapolation; this method is implemented as shown in Fletcher  (1987) and can be modified to an exact line search by using the LSPRECISION= option.","@ToolTip4":"Specifies a line-search method that needs the same number of function and gradient calls for  stepwise extrapolation and cubic interpolation","@ToolTip5":"Specifies a line-search method that is a modified version of LIS=4.","@ToolTip6":"Specifies golden section line search (Polak 1971), which uses only function values for linear  approximation.","@ToolTip7":"Specifies bisection line search (Polak 1971), which uses only function values for linear  approximation.","@ToolTip8":"Specifies Armijo line-search technique (Polak 1971), which uses only function values for  linear approximation."}},{"StatementOptionName":"LSPRECISION=|LSP=","StatementOptionHelp":{"#cdata":"[Syntax: LSPRECISION= | LSP=r] \n          \nSpecifies the degree of accuracy that should be obtained by the line-search algorithms \nLIS=2 and LIS=3. The default LSPRECISION= values are: \n\n  o For TECH=QUANEW UPDATE=DBFGS, BFGS: r = 0.4\n  o For TECH=QUANEW UPDATE=DDFP, DFP: r = 0.06 \n  o For TECH=CONGRA UPDATE=all r = 0.1\n  o For TECH=NEWRAP NO UPDATE: r = 0.9"},"StatementOptionType":"V"},{"StatementOptionName":"MAXFUNC=|MAXFU=","StatementOptionHelp":{"#cdata":"[Syntax: MAXFUNC= | MAXFU=i] \n          \nRequires the number of function calls to be no larger than i. The default values are: \n\n  o For TECH= TRUREG, NRRIDG, NEWRAP: i=125 \n  o For TECH= DBLDOG, QUANEW: i=500 \n  o For TECH= CONGRA: i=1000\n  o For TECH= NMSIMP: i=3000 \n  \nNote that the optimization can terminate only after completing a full iteration. \nTherefore, the number of function calls that is actually performed can exceed the \nnumber that is specified by the MAXFUNC= option."},"StatementOptionType":"V"},{"StatementOptionName":"MAXITER=|MAXIT=","StatementOptionHelp":{"#cdata":"[Syntax: MAXITER= | MAXIT=i[n]] \n          \n Requires the number of iterations to be no larger than i. The default values are: \n \n  o For TECH= TRUREG, NRRIDG, NEWRAP: i=50 \n  o For TECH= QUANEW, DBLDOG: i=200 \n  o For TECH= CONGRA: i=400\n  o For TECH= NMSIMP: i=1000 \n  \nThese default values are also valid when i is specified as a missing value."},"StatementOptionType":"V"},{"StatementOptionName":"MAXSTEP=","StatementOptionHelp":{"#cdata":"[Syntax: MAXSTEP=r[n]] \n          \nSpecifies an upper bound for the step length of the line-search algorithms during \nthe first n iterations."},"StatementOptionType":"V"},{"StatementOptionName":"MAXTIME=","StatementOptionHelp":{"#cdata":"[Syntax: MAXTIME=r] \n          \nRequires the CPU time to be no larger than r. The default value of the MAXTIME= option \nis the largest double floating-point number on your computer. Note that the time specified \nby the MAXTIME= option is checked only once at the end of each iteration. Therefore, the \nactual running time can be much longer than that specified by the MAXTIME= option. The \nactual running time includes the rest of the time needed to finish the iteration and the \ntime needed to generate the output of the results."},"StatementOptionType":"V"},{"StatementOptionName":"MINITER=|MINIT=","StatementOptionHelp":{"#cdata":"[Syntax: MINITER= | MINIT=i] \n          \nSpecifies the minimum number of iterations. The default value is 0. If you request more \niterations than are actually needed for convergence to a stationary point, the optimization \nalgorithms can behave strangely. For example, the effect of rounding errors can prevent the \nalgorithm from continuing for the required number of iterations."},"StatementOptionType":"V"},{"StatementOptionName":"NOPRINT","StatementOptionHelp":{"#cdata":"Suppresses the output."},"StatementOptionType":"S"},{"StatementOptionName":"PALL","StatementOptionHelp":{"#cdata":"[Displays all optional output for optimization."},"StatementOptionType":"S"},{"StatementOptionName":"PHISTORY","StatementOptionHelp":{"#cdata":"Displays the optimization history."},"StatementOptionType":"S"},{"StatementOptionName":"PHISTPARMS","StatementOptionHelp":{"#cdata":"Display parameter estimates in each iteration."},"StatementOptionType":"S"},{"StatementOptionName":"PINIT","StatementOptionHelp":{"#cdata":"Displays the initial values and derivatives (if available)."},"StatementOptionType":"S"},{"StatementOptionName":"PSHORT","StatementOptionHelp":{"#cdata":"Restricts the amount of default output."},"StatementOptionType":"S"},{"StatementOptionName":"PSUMMARY","StatementOptionHelp":{"#cdata":"Restricts the amount of default displayed output to a short form of iteration history and \nnotes, warnings, and errors."},"StatementOptionType":"S"},{"StatementOptionName":"RESTART=|REST=","StatementOptionHelp":{"#cdata":"[Syntax: RESTART= | REST=i > 0] \n          \nSpecifies that the QUANEW or CONGRA algorithm is restarted with a steepest descent/ascent \nsearch direction after, at most, i iterations, i > 0."},"StatementOptionType":"V"},{"StatementOptionName":"SOCKET=","StatementOptionHelp":{"#cdata":"Specifies the fileref that contains the information needed for remote monitoring."},"StatementOptionType":"V"},{"StatementOptionName":"TECHNIQUE=|TECH=","StatementOptionHelp":{"#cdata":"[Syntax: TECHNIQUE= | TECH=name] \n          \nSpecifies the optimization technique."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"CONGRA","@Value2":"DBLDOG","@Value3":"NMSIMP","@Value4":"NEWRAP","@Value5":"NRRIDG","@Value6":"QUANEW","@Value7":"TRUREG","@Value8":"NONE"},"StatementOptionToolTips":{"@ToolTip1":"Chooses one of four different conjugate-gradient optimization algorithms, which can be more  precisely defined with the UPDATE= option and modified with the LINESEARCH= option.","@ToolTip2":"Performs a version of double-dogleg optimization, which uses the gradient to update an approximation  of the Cholesky factor of the Hessian.","@ToolTip3":"Performs a Nelder-Mead simplex optimization.","@ToolTip4":"Performs a usually stable but, for large problems, memory- and time-consuming Newton-Raphson  optimization technique. The algorithm combines a line-search algorithm with ridging, and it  can be modified with the LINESEARCH= option.","@ToolTip5":"Performs a usually stable but, for large problems, memory- and time-consuming Newton-Raphson  optimization technique. This algorithm does not perform a line search.","@ToolTip6":"Chooses one of four different quasi-Newton optimization algorithms that can be more precisely  defined with the UPDATE= option and modified with the LINESEARCH= option.","@ToolTip7":"Performs a usually very stable but, for large problems, memory- and time-consuming trust-region  optimization technique. The algorithm is implemented similar to Gay (1983) and Mor\u00e9 and Sorensen  (1983).","@ToolTip8":"Does not perform any optimization. This option is similar to METHOD=NONE, but TECH=NONE also  computes and displays residuals and goodness of fit statistics."}},{"StatementOptionName":"UPDATE=|UPD=","StatementOptionHelp":{"#cdata":"Specifies the update method for the quasi-Newton, double-dogleg, or conjugate-gradient \noptimization technique."},"StatementOptionType":"V","StatementOptionValues":{"@Value1":"BFGS","@Value2":"DBFGS","@Value3":"DDFP","@Value4":"DFP","@Value5":"PB","@Value6":"FR","@Value7":"PR","@Value8":"CD"},"StatementOptionToolTips":{"@ToolTip1":"Performs the original Broyden, Fletcher, Goldfarb, and Shanno (BFGS) update of the inverse  Hessian matrix.","@ToolTip2":"Performs the dual BFGS update of the Cholesky factor of the Hessian matrix. This is the  default update method.","@ToolTip3":"Performs the dual Davidon, Fletcher, and Powell (DFP) update of the Cholesky factor of  the Hessian matrix.","@ToolTip4":"Performs the original DFP update of the inverse Hessian matrix.","@ToolTip5":"Performs the automatic restart update method of Powell (1977) and Beale (1972).","@ToolTip6":"Performs the Fletcher-Reeves update (Fletcher 1987).","@ToolTip7":"Performs the Polak-Ribiere update (Fletcher 1987).","@ToolTip8":"Performs a conjugate-descent update of Fletcher (1987)."}},{"StatementOptionName":"XCONV=|XTOL=","StatementOptionHelp":{"#cdata":"[Syntax: XCONV= | XTOL=r[n]] \n          \nSpecifies the relative parameter convergence criterion. For all techniques except NMSIMP, \ntermination requires a small relative parameter change in subsequent iterations. The default \nvalue is r=1E-8 for the NMSIMP technique and r=0 otherwise. The optional integer value n \nspecifies the number of successive iterations for which the criterion must be satisfied \nbefore the process can be terminated. "},"StatementOptionType":"V"},{"StatementOptionName":"XSIZE=","StatementOptionHelp":{"#cdata":"[Syntax: XSIZE=r > 0] \n          \nSpecifies the XSIZE parameter of the relative parameter termination criterion. The default \nvalue is r=0."},"StatementOptionType":"V"}]}},{"StatementName":"OUTPUT","StatementHelp":{"#cdata":"Syntax: OUTPUT <OUT=SAS-data-set> <output-options> ; \n\nThe OUTPUT statement creates a new SAS data set containing all variables in the input data set and,\noptionally, the estimates of x'\u03b2, predicted value, residual, marginal effects, probability, standard\ndeviation of the error, expected value, conditional expected value, and inverse Mills ratio. When the \nresponse values are missing for the observation, all output estimates except residual are still computed \nas long as none of the explanatory variables is missing. This enables you to compute these statistics\nfor prediction. You can specify only one OUTPUT statement."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"[Syntax: OUT=SAS-data-set] \n          \nNames the output data set."},"StatementOptionType":"DV"},{"StatementOptionName":"CONDITIONAL","StatementOptionHelp":{"#cdata":"Output estimates of conditional expected values of continuous endogenous"},"StatementOptionType":"S"},{"StatementOptionName":"ERRSTD","StatementOptionHelp":{"#cdata":"Output estimates of \u03c3-j, the standard deviation of the error term. "},"StatementOptionType":"S"},{"StatementOptionName":"EXPECTED","StatementOptionHelp":{"#cdata":"Output estimates of expected values of continuous endogenous variables."},"StatementOptionType":"S"},{"StatementOptionName":"MARGINAL","StatementOptionHelp":{"#cdata":"Output marginal effects."},"StatementOptionType":"S"},{"StatementOptionName":"MILLS","StatementOptionHelp":{"#cdata":"Output estimates of inverse Mills ratios of censored or truncated continuous, binary discrete, \nand selection endogenous variables."},"StatementOptionType":"S"},{"StatementOptionName":"PREDICTED","StatementOptionHelp":{"#cdata":"Output estimates of predicted endogenous variables."},"StatementOptionType":"S"},{"StatementOptionName":"PROB","StatementOptionHelp":{"#cdata":"Output estimates of probability of discrete endogenous variables taking the current observed \nresponses."},"StatementOptionType":"S"},{"StatementOptionName":"PROBALL","StatementOptionHelp":{"#cdata":"Output estimates of probability of discrete endogenous variables for all possible responses."},"StatementOptionType":"S"},{"StatementOptionName":"RESIDUAL","StatementOptionHelp":{"#cdata":"Output estimates of residuals of continuous endogenous variables."},"StatementOptionType":"S"},{"StatementOptionName":"XBETA","StatementOptionHelp":{"#cdata":"Output estimates of x'\u03b2."},"StatementOptionType":"S"},{"StatementOptionName":"TE1","StatementOptionHelp":{"#cdata":"Outputs estimates of technical efficiency for each producer in the stochastic frontier \nmodel suggested by Battese and Coelli (1988)."},"StatementOptionType":"V"},{"StatementOptionName":"TE2","StatementOptionHelp":{"#cdata":"Outputs estimates of technical efficiency for each producer in the stochastic frontier \nmodel suggested by Jondrow et al. (1982)."},"StatementOptionType":"V"}]}},{"StatementName":"RESTRICT","StatementHelp":{"#cdata":"Syntax: RESTRICT restriction1 <, restriction2 ...> ; \n\nThe RESTRICT statement is used to impose linear restrictions on the parameter estimates. Any number\nof RESTRICT statements can be specified, but the number of restrictions imposed is limited by the\nnumber of regressors. \n\nEach restriction is written as an expression, followed by an equality operator (=) or an inequality\noperator (<, >, \u2264, \u2265), followed by a second expression: \n\n  expression operator expression\n\nThe operator can be =, <, >, \u2264 , or \u2265. The operator and second expression are optional."},"StatementOptions":null},{"StatementName":"TEST","StatementHelp":{"#cdata":"Syntax: <label:> TEST <string:> equation [,equation...] / options ; \n\nThe TEST statement performs Wald, Lagrange multiplier, and likelihood ratio tests of linear \nhypotheses about the regression parameters in the preceding MODEL statement. Each equation \nspecifies a linear hypothesis to be tested. All hypotheses in one TEST statement are tested \njointly. Variable names in the equations must correspond to regressors in the preceding MODEL \nstatement, and each name represents the coefficient of the corresponding regressor. The keyword \nINTERCEPT refers to the coefficient of the intercept."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ALL","StatementOptionHelp":{"#cdata":"Requests Wald, Lagrange multiplier, and likelihood ratio tests."},"StatementOptionType":"S"},{"StatementOptionName":"WALD","StatementOptionHelp":{"#cdata":"Requests the Wald test."},"StatementOptionType":"S"},{"StatementOptionName":"LM","StatementOptionHelp":{"#cdata":"Requests the Lagrange multiplier test."},"StatementOptionType":"S"},{"StatementOptionName":"LR","StatementOptionHelp":{"#cdata":"Requests the likelihood ratio test."},"StatementOptionType":"S"}]}},{"StatementName":"WEIGHT","StatementHelp":{"#cdata":"Syntax: WEIGHT variable ; \n\nThe WEIGHT statement specifies a variable to supply weighting values to use for each \nobservation in estimating parameters. The log likelihood for each observation is multiplied \nby the corresponding weight variable value. \n\nIf the weight of an observation is nonpositive, that observation is not used in the estimation."},"StatementOptions":null}]}}}