{"Procedure":{"Name":"SSM","ProductGroup":"SAS/ETS","ProcedureHelp":{"#cdata":"Syntax: PROC SSM <options>;\n    BY variables;\n    COMPONENT name = (variables)* state </ options>;\n    DEPLAG name(response-variable) lag-term1 <lag-term2 \u2026> ;\n    EVAL name = expression </ options>;\n    ID variable <option>;\n    IRREGULAR name <options>;\n    MODEL response = variables </ options>;\n    OUTPUT <options>;\n    PARMS variables </ options> ;\n    STATE name(dim)<options>;\n    TREND name(type)<options>;\n    Programming statements ;\n    \nState space models (SSMs) are used for analyzing continuous response variables that are recorded \nsequentially according to a numeric indexing variable. In many cases, the indexing variable is time \nand the observations are collected at regular time intervals\u2014for example, hourly, weekly, or monthly. \nIn such cases, the resulting data are called time series data. In other cases, the indexing variable \nmight not be time or the observations might not be equally spaced according to the indexing variable. \nThese more general types of sequential data are called longitudinal data. Because of their sequential \nnature, these types of data exhibit some characteristic features. For example, chronologically closer \nmeasurements tend to be highly correlated while measurements farther apart are essentially uncorrelated. \nData can be trending in a particular direction and can have seasonal or other periodic patterns. SSMs \nare specially designed to model such sequential data. They apply to both univariate and multivariate \nresponse situations and can easily incorporate predictor (independent variable) information when it \nis available.\n\nThe SSM procedure performs state space modeling of univariate and multivariate time series and \nlongitudinal data."},"ProcedureOptions":{"ProcedureOption":[{"ProcedureOptionName":"BREAKPEAKS","ProcedureOptionHelp":{"#cdata":"Prints an alternate form of the break summary tables when the CHECKBREAK option is used in the STATE \nor TREND statement or when the MAXSHOCK option is used in the OUTPUT statement. In this alternate \nform, the summary tables report the significant peaks of the shock statistics curves."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"DATA=","ProcedureOptionHelp":{"#cdata":"Syntax: DATA=SAS-data-set\n      \nSpecifies the name of the SAS data set that contains the variables needed for the analysis. \nIf you do not specify this option, PROC SSM uses the most recently created SAS data set."},"ProcedureOptionType":"DV"},{"ProcedureOptionName":"NOPRINT","ProcedureOptionHelp":{"#cdata":"Turns off all the printing and plotting for the procedure. Any subsequent print options are ignored."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"PLOTS=","ProcedureOptionHelp":{"#cdata":"Syntax: PLOTS <(global-plot-options)> = plot-request <(options)> \nSyntax: PLOTS<(global-plot-options)> = ( plot-request <(options)> <\u2026plot-request <(options)> > )\n      \nControls the plots produced with ODS Graphics. When you specify only one plot-request, you can omit the parentheses around it.\n\nThe following global-plot-option is supported:\n\nUNPACK\n  displays each graph separately. (By default, some graphs can appear together in a single panel.)"},"ProcedureOptionType":"V","ProcedureOptionValues":{"@Value1":"ALL","@Value2":"AO","@Value3":"MAXSHOCK","@Value4":"NONE","@Value5":"RESIDUAL"},"ProcedureOptionToolTips":{"@ToolTip1":"Produces all plots appropriate for the particular analysis.","@ToolTip2":"Syntax: AO< (prediction-error-plot-options)>                                 Produces the prediction error plots\u2014one for each response variable. You can specify the following  prediction-error-plot-options:    NORMAL     produces a summary panel of the prediction error diagnostics, which consist of the following:        o histogram of prediction errors        o normal quantile plot of prediction errors    STD     produces a scatter plot of standardized prediction errors against time.","@ToolTip3":"Produces a scatter plot of maximal state shock statistics against time.","@ToolTip4":"Suppresses all plots.","@ToolTip5":"Syntax: RESIDUAL <(residual-plot-options)>                                 Produces the residuals plots\u2014one for each response variable. You can specify the following residual-plot-options:    NORMAL     produces a summary panel of the residual diagnostics, which consist of the following:        o histogram of residuals        o normal quantile plot of residuals    STD     produces a scatter plot of standardized residuals against time."},"SubOptionsKeywords":"UNPACK|NORMAL|STD"},{"ProcedureOptionName":"PRINTALL","ProcedureOptionHelp":{"#cdata":"Turns on all the printing options for the procedure. All subsequent NOPRINT options in the procedure are ignored."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"STATEINFO","ProcedureOptionHelp":{"#cdata":"Prints two tables that provide information about the composition of the state vector in terms of the \ncomponents specified in the model. One table describes the composition of state \u03b1t, and the other table \ndescribes the diffuse vector \u03b4 and the regressors, which are part of the initial condition specification \u03b11."},"ProcedureOptionType":"S"},{"ProcedureOptionName":"OPTIMIZER","ProcedureOptionHelp":{"#cdata":"Syntax: OPTIMIZER( <TECHNIQUE=technique> <MAXITER=integer>)\n      \nSpecifies options that are associated with the optimizer used in the maximum likelihood parameter estimation. \nThe default settings of the optimization process are adequate in most problems. However, in some cases it \nmight be useful to change the optimization technique or to change the maximum number of iterations. \n\nYou can specify one of the following techniques:\n\n  ACTIVESET\n  corresponds to the active-set method.\n\n  DBLDOG\n  corresponds to the double-dogleg method.\n\n  INTERIORPOINT\n  corresponds to the primal-dual interior point method.\n\n  NEWRAP\n  corresponds to the Newton-Raphson method.\n\n  QUANEW\n  corresponds to the (dual) quasi-Newton method.\n\n  TRUREG\n  corresponds to the trust region method.\n\nThe default technique is TRUREG."},"ProcedureOptionType":"V","SubOptionsKeywords":"TECHNIQUE=|MAXITER="},{"ProcedureOptionName":"ZSPARSE","ProcedureOptionHelp":{"#cdata":"Enables the exploitation of the sparsity of the \u0396t matrices in the observation equation during the modeling \ncalculations (see the section State Space Model and Notation for further information). The use of this \noption can improve the computational efficiency of models that have a large state dimension and sparse \u0396t \nmatrices\u2014that is, many of their elements are zero. You should use the ZSPARSE option only when the state \ndimension is sufficiently large (at least 30) and a good percentage (at least 50%) of \u0396t entries are zero; \notherwise, the computational efficiency can in fact degrade. \n\nExample:\n\n proc ssm data=Cigar plots=residual zsparse;"},"ProcedureOptionType":"S"}]},"ProcedureStatements":{"ProcedureStatement":[{"StatementName":"BY","StatementHelp":{"#cdata":"Syntax: BY variables; \n\nA BY statement can be used in the SSM procedure to process a data set in groups of observations that \nare defined by the BY variables. The model specified by using the MODEL and other statements is applied \nto all the groups defined by the BY variables. When a BY statement appears, the procedure expects the \ninput data set to be sorted in order of the BY variables. The BY variables are one or more variables \nin the input data set. The BY variables cannot be used in the model specification; in particular, \nthey cannot be used as response variables or regressors in a MODEL statement."},"StatementOptions":null},{"StatementName":"COMPONENT","StatementHelp":{"#cdata":"Syntax: COMPONENT name = (var1 var2 \u2026| number1 number2 \u2026) * state </ options> ;\n\nSyntax: COMPONENT name = state[ integer ] </ options>;\n\nSyntax: COMPONENT name = (Variable | Number)* state[ integer ] </ options>;\n\nThe COMPONENT statement specifies a component (a linear combination of state elements), named name. \nYou can use name later as a term in the right-hand side of the MODEL statement, which defines the \nobservation equation. The estimate of name is output to the OUT= data set that is specified in the \nOUTPUT statement. In addition, you can print the component estimate by using the PRINT= option."},"StatementOptions":{"StatementOption":{"StatementOptionName":"PRINT=","StatementOptionHelp":{"#cdata":"Syntax: PRINT=FILTER | SMOOTH \nSyntax: PRINT=(<FILTER> <SMOOTH>)\n\nRequests printing of the filtered or smoothed estimate of the specified component."},"StatementOptionValues":{"@Value1":"FILTER","@Value2":"SMOOTH"},"StatementOptionToolTips":{"@ToolTip1":"Requests printing of the filtered estimate of the specified component.","@ToolTip2":"Requests printing of the smoothed estimate of the specified component."},"StatementOptionType":"V","SubOptionsKeywords":"FILTER|SMOOTH"}}},{"StatementName":"DEPLAG","StatementHelp":{"#cdata":"Syntax: DEPLAG name(response-variable) lag-term1 <lag-term2 \u2026> ;\n\nThe DEPLAG statement defines a term, named name, that consists of a linear combination of lagged \nresponse variables. You can use name later as a right-hand-side term in the MODEL statement for \nthe response variable, as specified in name(response-variable). For a multivariate model, a \nseparate DEPLAG statement is needed for each MODEL statement that has a right-hand-side term \nthat involves lagged response variables. The linear combination of lagged response variables \nis specified by using one or more lag-terms. Each lag-term specifies the lags that are associated \nwith one of the response variables.\n\nA lag-term is specified in one of the following forms:\n\nlag-response-variable(LAGS=maximum-lag) \nlag-response-variable(LAGS=(integer1 integer2 \u2026)) \nlag-response-variable(LAGS=maximum-lag COEFF=(number1 number2 \u2026) | (variable1 variable2 \u2026)) \nlag-response-variable(LAGS=(integer1 integer2 \u2026) COEFF=(number1 number2 \u2026) | (variable1 variable2 \u2026))"},"StatementOptions":null},{"StatementName":"EVAL","StatementHelp":{"#cdata":"Syntax: EVAL name = number1*variable1 + number2*variable2 + \u2026</ options> ;\n\nThe EVAL statement defines a linear combination, named name, of the terms used in the right-hand \nside of a MODEL statement. You can specify any variables (for example, predictor variables and \nnames of components) in the expression of the EVAL statement; however, you cannot specify in this \nexpression any observation disturbances that are specified by the IRREGULAR statement and any model \nterms that are specified by the DEPLAG statement. Suppose C1 and C2 are two components (defined by \nCOMPONENT statements elsewhere in the program), T1 is a trend component, and X1 is a regression \nvariable used in a model. The following are valid examples of the EVAL statement:\n\n eval e1 = c1 - c2;\n eval e2 = t1 + c1 + x1;\n eval e2 = t1 + 2*c1 - 1.5*x1;"},"StatementOptions":{"StatementOption":{"StatementOptionName":"PRINT=","StatementOptionHelp":{"#cdata":"Syntax: PRINT=FILTER | SMOOTH \nSyntax: PRINT=(<FILTER> <SMOOTH>)\n\nRequests printing of the filtered or smoothed estimate of the specified linear combination."},"StatementOptionValues":{"@Value1":"FILTER","@Value2":"SMOOTH"},"StatementOptionToolTips":{"@ToolTip1":"Requests printing of the filtered estimateof the specified linear combination.","@ToolTip2":"Requests printing of the smoothed estimate of the specified linear combination."},"StatementOptionType":"V","SubOptionsKeywords":"FILTER|SMOOTH"}}},{"StatementName":"ID","StatementHelp":{"#cdata":"Syntax: ID variable <option> ;\n\nThe ID statement names a numeric variable to associate a sequence value\u2014usually related to a time \nstamp\u2014to the observations in the input data set. The observations within a BY group must be ordered \nin ascending order by the ID variable. Often the ID variable\u2019s values are SAS date, time, or datetime \nvalues, and each observation within a BY group has a unique ID value. Generally, however, the ID \nvariable can be any numeric variable, and there can be multiple observations with the same ID value. \nIf the ID values are SAS date, time, or datetime values, you can specify the associated unit of \ntime\u2014for example, day, week or month\u2014by using the INTERVAL= option. If an ID statement is not \nspecified, the observation number, with respect to the BY group, is used as the time ID. Whenever \nan ID variable is specified, a variable, _ID_DELTA_, is automatically created that can be used as \nany input data set variable in the programming statements. _ID_DELTA_ contains the distance between \ntwo successive ID values. The first _ID_DELTA_ value is arbitrarily taken as one. If the INTERVAL= \noption is specified, the distance between the ID values is measured in terms of the number of intervals; \ntherefore, for regularly spaced data, _ID_DELTA_ is identically equal to one."},"StatementOptions":{"StatementOption":{"StatementOptionName":"INTERVAL=","StatementOptionHelp":{"#cdata":"Syntax: INTERVAL=value\n          \nSpecifies the unit of time interval that is used for measuring the ID values. INTERVAL=value \nis used in conjunction with the ID variable to check that the input data are in the proper order."},"StatementOptionType":"V"}}},{"StatementName":"IRREGULAR","StatementHelp":{"#cdata":"Syntax: IRREGULAR name <options> ;\n\nThe IRREGULAR statement specifies a one-dimensional white noise component, which can be used to \nspecify the observation error in a MODEL statement."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"PRINT=","StatementOptionHelp":{"#cdata":"Syntax: PRINT=SMOOTH\n          \nRequests printing of the smoothed estimate of the specified irregular component."},"StatementOptionType":"V"},{"StatementOptionName":"VARIANCE=","StatementOptionHelp":{"#cdata":"Syntax: VARIANCE=variable | number\n          \nSpecifies the variance of the white noise. Any nonnegative value, including 0, is permissible. \nIf the variable contains unknown parameters, they are estimated from the data. Similarly, if \nthe VARIANCE= option is not specified, the variance is estimated from the data."},"StatementOptionType":"V"}]}},{"StatementName":"MODEL","StatementHelp":{"#cdata":"Syntax: MODEL response = variables </ options>;\n\nA MODEL statement specifies an observation equation that describes a response variable as a sum \nof regression effects and components that are defined in the program. The response variable must \nbe a numeric variable from the input data set. The variables used in the right-hand side of the \nmodel expression can be numeric variables from the input data set, numeric variables defined by \nusing programming statements, or names of components that are specified in the COMPONENT, DEPLAG, \nTREND, or IRREGULAR statements.\n\nFor a multivariate model, a separate MODEL statement is needed for each of the response variables. \nIn this case, the observation errors, which are specified in an IRREGULAR statement, must be \ndifferent in each MODEL statement."},"StatementOptions":{"StatementOption":{"StatementOptionName":"PRINT=","StatementOptionHelp":{"#cdata":"Syntax: PRINT=FILTER | SMOOTH \nSyntax: PRINT=(<FILTER> <SMOOTH>)\n\nRequests printing of the filtered or smoothed estimate of the specified response variable. The filtered \nestimate is produced during the filtering phase, and the smoothed estimate is produced by the smoothing \nphase of the Kalman filter and smoother algorithm. The filtered estimate is also called the one-step-ahead \nforecast of the response variable. The smoothed estimate corresponds to the full-sample prediction of the \nresponse variable. Since the full-sample prediction of a nonmissing response value is that value itself, \nfull-sample predictions are printed only for the missing response values."},"StatementOptionValues":{"@Value1":"FILTER","@Value2":"SMOOTH"},"StatementOptionToolTips":{"@ToolTip1":"Requests printing of the filtered estimateof the specified linear combination.","@ToolTip2":"Requests printing of the smoothed estimate of the specified linear combination."},"StatementOptionType":"V","SubOptionsKeywords":"FILTER|SMOOTH"}}},{"StatementName":"OUTPUT","StatementHelp":{"#cdata":"Syntax: OUTPUT <options> ;\n\nThe OUTPUT statement creates an optional output data set and also provides options to control certain \naspects of the procedure output. If the OUT= option is specified, then an output data set is created \nto store estimates of the model components and series forecasts. If the OUT= option is omitted, then \nno data set is created by the OUTPUT statement. Other options in the OUTPUT statement produce additional \ninformation in the printed output generated by the procedure. For example, the AO and BREAK options \ncontrol the search for additive outliers and structural breaks in the data, respectively."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"AO","StatementOptionHelp":{"#cdata":"Syntax: AO(<ALPHA=number> <MAXNUM=number> <MAXPCT=number>)\n          \nControls the additive outlier search (see the section Delete-One Cross Validation and the Additive \nOutlier Detection for more information). The ALPHA= suboption specifies the significance level for \nreporting the outliers. The default is ALPHA=0.05. The MAXNUM= suboption limits the number of outliers \nto search. The default is MAXNUM=5. The MAXPCT= suboption is similar to the MAXNUM= suboption. In the\nMAXPCT= option you can limit the number of outliers to search for according to a percentage of the \nseries length. The default is MAXPCT=1. When you specify both of these options, the lesser of the \ntwo search numbers is used."},"StatementOptionType":"S","SubOptionsKeywords":"MAXNUM=|MAXPCT="},{"StatementOptionName":"ALPHA=","StatementOptionHelp":{"#cdata":"Syntax: ALPHA=number\n          \nSpecifies the significance level of the forecast confidence intervals. For example, ALPHA=0.05, \nwhich is the default, results in a 95% confidence interval."},"StatementOptionType":"V","SubOptionsKeywords":null},{"StatementOptionName":"BREAK","StatementOptionHelp":{"#cdata":"Syntax: BREAK(<ALPHA=number> <MAXNUM=number> <MAXPCT=number>)\n          \nControls the structural break search (for more information, see the section Structural Breaks in the \nState Evolution). In order for this option to have any effect, the CHECKBREAK option in one of the \nSTATE or TREND statements, or the MAXSHOCK option in the OUTPUT statement, must be turned on. The \nALPHA= suboption specifies the significance level for reporting the breaks. The default is ALPHA=0.05. \nThe MAXNUM= suboption limits the number of breaks to search. The default is MAXNUM=5. The MAXPCT= \nsuboption is similar to the MAXNUM= suboption. In the MAXPCT= option, you can limit the number of \nbreaks to search for according to a percentage of the number of distinct time points in the data. \nThe default is MAXPCT=1. When you specify both of these options, the lesser of the two search numbers \nis used."},"StatementOptionType":"S","SubOptionsKeywords":"MAXNUM=|MAXPCT="},{"StatementOptionName":"MAXSHOCK","StatementOptionHelp":{"#cdata":"Causes the computation of the maximal state shock chi-square statistic at each distinct time point \nin the input data set. These statistics are output to the data set that is specified in the OUT= \noption. A time series plot of these statistics is produced if the PLOTS=MAXSHOCK option is specified \nin the PROC SSM statement. These statistics are useful for detecting structural breaks in the state \nevolution process. This option can be computationally expensive for a model with large state size."},"StatementOptionType":"S"},{"StatementOptionName":"OUT=","StatementOptionHelp":{"#cdata":"Syntax: OUT=SAS-data-set\n          \nSpecifies an output data set for the forecasts. The output data set contains the ID variable (if specified), \nthe response variables, the one-step-ahead and out-of-sample response variable forecasts, the forecast \nconfidence intervals, the smoothed values of the response series, and the one-step-ahead and smoothed \nestimates of the model components\u2014including expressions that are defined by using the EVAL statement."},"StatementOptionType":"V"},{"StatementOptionName":"PDV","StatementOptionHelp":{"#cdata":"Causes the inclusion of the variables (variables in the program data vector) that are defined by using \nthe programming statements in the SSM procedure in the OUT= data set. The parameters defined by the \nPARMS statement are also included. The output data set contains the values of these variables evaluated \nfor all the rows in the input data set that is specified in the DATA= option. The parameters in the PARMS \nstatement contain their estimated values."},"StatementOptionType":"S"},{"StatementOptionName":"PRESS","StatementOptionHelp":{"#cdata":"Prints the prediction error sum of squares (PRESS) and the generalized cross validation error sum of \nsquares (GCV). The PRESS table also reports the number of summands that are used in these sums of \nsquares."},"StatementOptionType":"S"}]}},{"StatementName":"PARMS","StatementHelp":{"#cdata":"Syntax: PARMS variable<=number> variable<=number> < / options> ;\n\nThe PARMS statement declares the parameters of a model and optionally sets their initial values. \nYou can also specify the lower and upper limits of their validity range. The parameters declared \nby using the PARMS statement are called named parameters throughout this chapter. A model can \nhave additional parameters: any unspecified quantity in the model specification becomes part \nof the parameter vector."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"LOWER=","StatementOptionHelp":{"#cdata":"Syntax: LOWER=(number1 number2 \u2026) | LOWER=(number)\n          \nSpecifies the lower bounds for the specified parameters. The list can contain exactly one number, \nwhich is taken to be the lower bound for all the listed parameters in the statement, or it must \ncontain as many values as the number of parameters specified. A missing value, denoted by ., \nis a permissible value, which signifies that the parameter has no lower bound."},"StatementOptionType":"V"},{"StatementOptionName":"UPPER=","StatementOptionHelp":{"#cdata":"Syntax: UPPER=(number1 number2 \u2026) | UPPER=(number)\n          \nSpecifies the upper bounds for the specified parameters. The list can contain exactly one number, \nwhich is taken to be the upper bound for all the listed parameters in the statement, or it must \ncontain as many values as the number of parameters specified. A missing value, denoted by ., \nis a permissible value, which signifies that the parameter has no upper bound."},"StatementOptionType":"V"}]}},{"StatementName":"STATE","StatementHelp":{"#cdata":"Syntax: STATE name (dim)<options>;\n\nThe STATE statement specifies a subsection of \u03b1t, the overall state vector at time t. It is assumed \nthat the subsections that are specified by using different STATE statements are mutually independent."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"A1","StatementOptionHelp":{"#cdata":"Syntax: A1(nd)\n          \nSpecifies that the last nd elements of the state subsection be treated as diffuse. This becomes \nthe dimension of the relevant subsection of the diffuse vector \u03b4."},"StatementOptionType":"S"},{"StatementOptionName":"CHECKBREAK","StatementOptionHelp":{"#cdata":"Syntax: CHECKBREAK<( ELEMENTWISE | OVERALL)>\n          \nTurns on the checking of breaks for this state subsection. The ELEMENTWISE suboption requests the \nelementwise checking of any unexpected change in the state subsection as it evolves from one time \npoint to the next. The OVERALL suboption requests a similar check for the entire state subsection\u2014that \nis, in this case the change is measured as a multidimensional change. The ELEMENTWISE suboption is the \ndefault. Unless the PRINT=BREAKDETAIL option is specified, only a summary of the most significant \nbreaks is produced. If the PRINT=BREAKDETAIL is specified, tables that contain the break significance \nstatistics at every distinct time point are produced\u2014one for the ELEMENTWISE suboption and one for the \nOVERALL suboption."},"StatementOptionType":"S","SubOptionsKeywords":"ELEMENTWISE|OVERALL"},{"StatementOptionName":"COV","StatementOptionHelp":{"#cdata":"Syntax: COV( D ) <= (var1 var2 \u2026) | (number1 number2 \u2026)> \nSyntax: COV( G ) <= (var1 var2 \u2026) | (number1 number2 \u2026)> \nSyntax: COV( I ) <= (variable) | (number)> \nSyntax: COV( RANK=integer )\n\nSpecifies the relevant block of the disturbance covariance Qt (for t >= 2) in the transition equation. As with \nthe T option, the absence of this option signifies that this Q-block consists of only zeros. The structure \nof the Q-block is also similarly specified. However, the following differences exist:\n\no The list that is specified to form the covariance must result in a symmetric, positive semidefinite matrix.\n\no You can specify a rank constraint on the Q-block by specifying COV(RANK=integer), where the specified \n  integer must lie between 1 and dim. A rank constraint is permissible only for the general form and only \n  when its elements are not specified by using a list.\n\no The convention of treating unset variables as structural zeros, which is used in specifying sparsity \n  of the T-block, is not used in the Q-block specification. Whenever you explicitly specify the entries \n  of the Q-block by specifying a list of variables in parentheses, all variables in the list must evaluate \n  to nonmissing values."},"StatementOptionType":"S|V","SubOptionsKeywords":"RANK="},{"StatementOptionName":"COV1","StatementOptionHelp":{"#cdata":"Syntax: COV1( D ) <= (var1 var2 \u2026) | (number1 number2 \u2026)> \nSyntax: COV1( G ) <= (var1 var2 \u2026) | (number1 number2 \u2026)> \nSyntax: COV1( I ) <= (variable) | (number)> \nSyntax: COV1( RANK=integer )\n\nSpecifies the relevant block of the initial state covariance Q1. The different options in this case \nhave the same meaning as the options of the COV option. However, the following differences exist:\n\no If the elements of Q1 are specified by a list of variables in parentheses, then these variables must \n  evaluate to constant values. In particular, they can depend on parameters that are specified by the \n  PARMS statements; however, they cannot depend on any of the input data columns.\n\no If the initial condition is partially diffuse (that is, the diffuse dimension nd specified in the \n  A1 option is nonzero), the last nd rows and columns of the matrix specified in COV1 are taken to be \n  zero. Moreover, if the elements of Q1 are specified by a list, its number of elements must correspond \n  to a matrix of dimension (dim \u2013 nd)."},"StatementOptionType":"S|V","SubOptionsKeywords":"RANK="},{"StatementOptionName":"PRINT=","StatementOptionHelp":{"#cdata":"Syntax: PRINT=AR | BREAKDETAIL | COV | COV1 | MA | T \nSyntax: PRINT=(<AR> <BREAKDETAIL> <COV> <COV1> <MA> <T> )\n\nRequests printing of the respective system matrices and the printing of the break statistics at each \ndistinct time point. You can specify PRINT=AR or PRINT=MA only if you specify the TYPE=VARMA option. \nIf any of these matrices are time-varying, the matrix that corresponds to the first time instance is \nprinted. For the BREAKDETAIL suboption to have any effect, the CHECKBREAK option must be turned on. \nIf TYPE= option is used, the result of PRINT=COV can be different than the matrix supplied in the \nCOV= option."},"StatementOptionValues":{"@Value1":"AR","@Value2":"BREAKDETAIL","@Value3":"COV","@Value4":"COV1","@Value5":"MA","@Value6":"T"},"StatementOptionToolTips":{"@ToolTip1":"Specify this option only if you specify the TYPE=VARMA option.","@ToolTip2":"For this option to take effect, the CHECKBREAK option must be turned on.","@ToolTip3":"If TYPE= option is used, the result of PRINT=COV can be different than the matrix supplied in the  COV= option.","@ToolTip4":"If TYPE= option is used, the result of PRINT=COV can be different than the matrix supplied in the  COV= option.","@ToolTip5":"Specify this option only if you specify the TYPE=VARMA option.","@ToolTip6":"Requests printing of the break statistics at each distinct time point."},"StatementOptionType":"V","SubOptionsKeywords":"FILTER|SMOOTH"},{"StatementOptionName":"SINPUT=","StatementOptionHelp":{"#cdata":"Syntax: SINPUT = (var1 var2 \u2026) | (number1 number2 \u2026)\n          \nSpecifies the relevant dim-dimensional block of the state input vector Ct. The absence of this option \nsignifies that this block of the Ct vector consists of only zeros. If the elements of Ct are specified \nby a list of variables in parentheses, then these variables must be independent of unknown parameters. \nIn particular, they cannot be functions of parameters that are defined by the PARMS statements."},"StatementOptionType":"V"},{"StatementOptionName":"T","StatementOptionHelp":{"#cdata":"Syntax: T( D ) <= (var1 var2 \u2026) | (number1 number2 \u2026)> \nSyntax: T( G ) <= (var1 var2 \u2026) | (number1 number2 \u2026)> \nSyntax: T( I ) <= (variable) | (number)>\n\nSpecifies the relevant block of the transition matrix Tt. The absence of this option signifies that \nthis block consists of only zeros. You can specify the structure of the T-block by specifying T(I) \nfor the identity form, T(D) for the diagonal form, and T(G) for a general unstructured form. In addition, \nyou can explicitly specify the entries of the T-block by specifying a list of numbers in parentheses, \nor by specifying in parentheses a list of variables that are defined by using the programming statements. \nThe unspecified elements of the T-block are included in the list of parameters to be estimated from the \ndata. If the elements of the T-block are supplied by a list in parentheses, the number of elements in the \nlist depends on its structure."},"StatementOptionType":"S|V"},{"StatementOptionName":"TYPE=","StatementOptionHelp":{"#cdata":"Syntax: TYPE=WN \nTYPE=RW \nTYPE=LL <(SLOPECOV(I | D | G)   <= (var1, var2, \u2026) | (number1, number2, \u2026)> )> \nTYPE=LL (SLOPECOV( RANK=integer) ) \nTYPE=SEASON (LENGTH=integer    <DROPH=number-list>    <KEEPH=number-list> ) \nTYPE=CYCLE <( <CT>    <RHO=variable | number>   <PERIOD=variable | number> )> \nTYPE=VARMA ( <p <(I | D)> =integer>   <q<(D)>=integer> )\n\nSpecifies a state subsection that corresponds to the specified type. You can specify either a number \nor a variable for the RHO= and PERIOD= suboptions."},"StatementOptionValues":{"@Value1":"RW","@Value2":"LL","@Value3":"SEASON","@Value4":"CYCLE","@Value5":"VARMA"},"StatementOptionToolTips":{"@ToolTip1":"dim-variate random walk","@ToolTip2":"Syntax: TYPE=LL <(SLOPECOV(I | D | G)   <= (var1, var2, \u2026) | (number1, number2, \u2026)> )> Syntax: LL (SLOPECOV( RANK=integer) )  dim-variate local linear","@ToolTip3":"Syntax: SEASON (LENGTH=integer    <DROPH=number-list>    <KEEPH=number-list> )                                      dim-variate season","@ToolTip4":"Syntax: CYCLE <( <CT>    <RHO=variable | number>   <PERIOD=variable | number> )>                                     dim-variate cycle","@ToolTip5":"Syntax: VARMA ( <p <(I | D)> =integer>   <q<(D)> =integer> )                                     dim-variate VARMA"},"StatementOptionType":"V","SubOptionsKeywords":"SLOPECOV|RANK=|LENGTH=|DROPH=|KEEPH=|CT|RHO=|PERIOD="},{"StatementOptionName":"W","StatementOptionHelp":{"#cdata":"Syntax: W(D)= (var1 var2 \u2026) | (number1 number2 \u2026) \nW(G)= (var1 var2 \u2026) | (number1 number2 \u2026) \nW(I) <= (variable) | (number) >\n\nSpecifies the relevant block of the design matrix Wt in the transition equation. The W-block is of\ndimension sdim x sg, where sdim denotes the actual dimension of the state subsection (which can be \nthe same as dim, the nominal dimension, or different if the TYPE= option is used) and sg denotes the \ndesired size of the subsection of the overall state regression vector . The absence of this option \nsignifies that the state equation does not contain any regression effects."},"StatementOptionType":"V"}]}},{"StatementName":"TREND","StatementHelp":{"#cdata":"Syntax: TREND name (type)<options>;\n\nThe TREND statement defines a term in the model that follows a stochastic pattern of a certain predefined \ntype. The options in the TREND statement enable you to specify a wide variety of commonly used stochastic \npatterns. Each TREND statement in effect stands for a special pair of STATE and COMPONENT statements. You \ncan specify more than one TREND statement. Each separate TREND statement defines a component that is assumed \nto be independent of all other component specifications in the model. Very often the TREND statement is used \nto specify a component that captures the time-varying level of the data. However, in many cases it is also \nused to define components of a more general nature; for example, it can be used to define a noise component \nthat follows a stationary ARMA model."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"AR=","StatementOptionHelp":{"#cdata":"Syntax: AR= \u03c61 \u03c62 \u2026\u03c6p\n          \nLists the values of the coefficients of the nonseasonal autoregressive polynomial."},"StatementOptionType":"V"},{"StatementOptionName":"CHECKBREAK","StatementOptionHelp":{"#cdata":"Syntax: CHECKBREAK<( ELEMENTWISE | OVERALL)>\n          \nTurns on the checking of breaks for this trend component. The ELEMENTWISE suboption requests the \nelementwise checking of any unexpected change in the state subsection that is associated with the \ntrend component. The OVERALL suboption requests a similar check for the entire state subsection\u2014that \nis, in this case the change is measured as a multidimensional change. The ELEMENTWISE suboption is \nthe default. Unless the PRINT=BREAKDETAIL option is specified, only a summary of the most significant \nbreaks is produced. If the PRINT=BREAKDETAIL is specified, tables that contain the break significance \nstatistics at every distinct time point are produced\u2014one for the ELEMENTWISE suboption and one for the \nOVERALL suboption. If the CROSS= option is specified and the CROSS= list contains more than one variable, \nthe OVERALL suboption considers subsections that are associated with each CROSS= variable separately."},"StatementOptionType":"S","SubOptionsKeywords":"ELEMENTWISE|OVERALL"},{"StatementOptionName":"CROSS=","StatementOptionHelp":{"#cdata":"Syntax: CROSS=(var1, var2, \u2026) | CROSS(MATCHPARM)=(var1, var2, \u2026)\n\nCreates a linear combination of one or more independent trend components that is based on the variables \nin the list. If the parameters of the trend are specified by options such as the LEVELVAR= option or the \nPHI= option, these parameters are shared by these constituent trends."},"StatementOptionType":"V","SubOptionsKeywords":"MATCHPARM"},{"StatementOptionName":"LEVELVAR=","StatementOptionHelp":{"#cdata":"Syntax: LEVELVAR=variable | number\n          \nSpecifies the disturbance variance parameter for all the trend types."},"StatementOptionType":"V"},{"StatementOptionName":"NODIFFUSE","StatementOptionHelp":{"#cdata":"Causes the diffuse elements in the initial state of the state subsection underlying the trend component \nto be treated as nondiffuse. This option is applicable to all trend types except ARIMA. For the ARIMA \ntrend type, this option is ignored even if the nonseasonal or seasonal differencing orders are nonzero. \nThe diffuse elements are assumed to be independent, zero-mean, Gaussian variables. Their variances become \npart of the parameter vector and are estimated by using the data. This option is useful for creating a trend \ncomponent that can be interpreted as a deviation from an overall trend component (with diffuse initialization), \nwhich is defined separately."},"StatementOptionType":"S"},{"StatementOptionName":"PHI=","StatementOptionHelp":{"#cdata":"Syntax: PHI=variable | number\n          \nSpecifies the value of \u03c6 for trend types DLL, DECAY, DECAY(OU), GROWTH, and GROWTH(OU). For the type DLL, \nthe specified value must be between 0.0 and 1.0. For types DECAY and DECAY(OU), \u03c6 must be strictly negative. \nFor types GROWTH and GROWTH(OU), \u03c6 must be strictly positive. If variable contains unknown parameters, they \nare estimated from the data. Similarly, if the PHI= option is not specified, \u03c6 is estimated from the data."},"StatementOptionType":"V"},{"StatementOptionName":"PRINT=","StatementOptionHelp":{"#cdata":"Syntax: PRINT=BREAKDETAIL | COV | COV1 | FILTER | SMOOTH | T \nSyntax: PRINT= (<BREAKDETAIL> <COV> <COV1> <FILTER> <SMOOTH> <T> )\n\nRequests printing of the respective system matrices of the state equation that underlies the specified \ntrend, the printing of its filtered and smoothed estimates, and the printing of the break statistics at \neach distinct time point. For the BREAKDETAIL suboption to have any effect, the CHECKBREAK option must \nbe turned on. If any of these matrices are time-varying, the matrix that corresponds to the first time \ninstance is printed."},"StatementOptionValues":{"@Value1":"BREAKDETAIL","@Value2":"COV","@Value3":"COV1","@Value4":"FILTER","@Value5":"SMOOTH","@Value6":"T"},"StatementOptionToolTips":{"@ToolTip1":"For this option to take effect, the CHECKBREAK option must be turned on.","@ToolTip2":"If TYPE= option is used, the result of PRINT=COV can be different than the matrix supplied in the  COV= option.","@ToolTip3":"If TYPE= option is used, the result of PRINT=COV1 can be different than the matrix supplied in the  COV1= option.","@ToolTip4":"Requests printing of the filtered estimate of the respective system matrices of the state equation that underlies the specified  trend.","@ToolTip5":"Requests printing of the smoothed estimate of the respective system matrices of the state equation that underlies the specified  trend.","@ToolTip6":"Requests printing of the  the printing of the break statistics at each distinct time point."},"StatementOptionType":"V","SubOptionsKeywords":"FILTER|SMOOTH"},{"StatementOptionName":"SAR=","StatementOptionHelp":{"#cdata":"Syntax: SAR= \u03a61 \u03a62 \u2026\u03a6p\n          \nLists the values of the coefficients of the seasonal autoregressive polynomial."},"StatementOptionType":"V"},{"StatementOptionName":"SMA=","StatementOptionHelp":{"#cdata":"Syntax: SMA= \u03b81 \u03b82 \u2026\u03b8q\n          \nLists the values of the coefficients of the seasonal moving average polynomial."},"StatementOptionType":"V"},{"StatementOptionName":"SLOPEVAR=","StatementOptionHelp":{"#cdata":"Syntax: SLOPEVAR=variable | number\n          \nSpecifies the second disturbance variance parameter for trend types LL and DLL. Any nonnegative value, \nincluding 0, is permissible. If variable contains unknown parameters, they are estimated from the data."},"StatementOptionType":"V"}]}},{"StatementName":"ARRAY","StatementHelp":{"#cdata":"Syntax: ARRAY specification <...> ;\n      \nAn ARRAY specification is in a form as follows: \n\n    name[dimension](variables) \n\nThe ARRAY statement is used to associate a name with a list of variables. Each of \nthe variables in the variable list must be defined using a VAR statement. The ARRAY \nstatement is required when you are specifying a constraint by FOREACH statement."},"StatementOptions":null},{"StatementName":"ABORT","StatementHelp":{"#cdata":"Syntax: ABORT <ABEND | CANCEL <FILE> | RETURN | > <n> <NOLIST>; \n      \nStops executing the current DATA step, SAS job, or SAS session."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"ABEND","StatementOptionHelp":{"#cdata":"Causes abnormal termination of the current SAS job or session. Results depend on the method \nof operation: \n\no batch mode and noninteractive mode \n\n  o stops processing immediately\n  o sends an error message to the SAS log that states that execution was terminated by the ABEND option \n    of the ABORT macro statement\n  o does not execute any subsequent statements or check syntax\n  o returns control to the operating environment; further action is based on how your operating environment \n    and your site treat jobs that end abnormally.\n\no windowing environment and interactive line mode \n\n  o causes your windowing environment and interactive line mode to stop processing immediately \n    and return you to your operating environment."},"StatementOptionType":"S"},{"StatementOptionName":"CANCEL","StatementOptionHelp":{"#cdata":"Causes the cancellation of the current submitted statements. The results depend on the method \nof operation:\n\no batch mode and noninteractive mode\n\n  o The entire SAS program and SAS system are terminated.\n  o The error message is written to the SAS log.\n\no windowing environment and interactive line mode \n\n  o It only clears the current submitted program.\n  o Other subsequent submitted programs are not affected.\n  o The error message is written to the SAS log.\n\no workspace server and stored process server \n\n  o It only clears currently submitted program.\n  o Other subsequent submit calls are not affected.\n  o The error message is written to the SAS log.\n\no SAS IntrNet application server \n\n  o A separate execution is created for each request. The execution submits the request code. A CANCEL \n    argument in the request code clears the current submitted code but does not terminate the execution \n    of the SAS session."},"StatementOptionType":"S"},{"StatementOptionName":"CANCEL FILE","StatementOptionHelp":{"#cdata":"Causes only the contents of the autoexec file or %INCLUDE file to be cleared by the %ABORT statement. \nOther submitted source statements will be executed after the autoexec or %INCLUDE file."},"StatementOptionType":"S"},{"StatementOptionName":"RETURN","StatementOptionHelp":{"#cdata":"Causes abnormal termination of the current SAS job or session. Results depend on the method \nof operation: \n\no batch mode and noninteractive mode \n\n  o stops processing immediately\n  o sends an error message to the SAS log that states that execution was terminated by the RETURN option \n    in the ABORT macro statement\n  o does not execute any subsequent statements or check syntax\n  o returns control to the operating environment with a condition code indicating an error.\n\no windowing environment and interactive line mode \n\n  o causes your windowing environment and interactive line mode to stop processing immediately \n    and return you to your operating environment."},"StatementOptionType":"S"},{"StatementOptionName":"NOLIST","StatementOptionHelp":{"#cdata":"suppresses the output of all variables to the SAS log."},"StatementOptionType":"S"}]}},{"StatementName":"CALL","StatementHelp":{"#cdata":"Syntax: CALL routine(parameter-1<, ...parameter-n>);  \n      \nInvokes a SAS CALL routine."},"StatementOptions":null},{"StatementName":"DELETE","StatementHelp":{"#cdata":"Syntax: DELETE; \n      \nStops processing the current observation."},"StatementOptions":null},{"StatementName":"DO","StatementHelp":{"#cdata":"Specifies a group of statements to be executed as a unit.\n      \nSyntax: \n(1) DO; \n...more SAS statements...  \nEND;  \n\n(2) DO index-variable=specification-1 <, ... specification-n>; \n... more SAS statements ...  \nEND;  \n\n(3) DO UNTIL (expression); \n...more SAS statements...  \nEND \n\n(4) DO WHILE (expression); \n...more SAS statements...  \nEND;"},"StatementOptions":{"StatementOption":[{"StatementOptionName":"UNTIL","StatementOptionHelp":{"#cdata":"Executes statements in a DO loop repetitively until a condition is true.\n          \nSyntax: \nDO UNTIL (expression); \n...more SAS statements...  \nEND"},"StatementOptionType":"S"},{"StatementOptionName":"WHILE","StatementOptionHelp":{"#cdata":"Executes statements in a DO-loop repetitively while a condition is true. \n          \nSyntax: \nDO WHILE (expression); \n...more SAS statements...  \nEND;"},"StatementOptionType":"S"},{"StatementOptionName":"OVER","StatementOptionType":"S"},{"StatementOptionName":"TO","StatementOptionHelp":{"#cdata":"Separates the start and stop integers or expressions that control the number of times the \nportion of the DATA step between the iterative DO and END statements is processed."},"StatementOptionType":"S"},{"StatementOptionName":"BY","StatementOptionHelp":{"#cdata":"Precedes an increment integer (other than 0) or an expression that generates an integer to be \nadded to the value of the index variable in each iteration of the DO loop."},"StatementOptionType":"S"}]}},{"StatementName":"END","StatementHelp":{"#cdata":"Syntax: END; \n      \nEnds a DO group or SELECT group processing."},"StatementOptions":null},{"StatementName":"GOTO","StatementHelp":{"#cdata":"Syntax: GOTO label;\n      \nJumps to a new statement."},"StatementOptions":null},{"StatementName":"IF","StatementHelp":{"#cdata":"Executes a SAS statement for observations that meet specific conditions. \n\nSyntax: \n(1) IF expression THEN statement; \n    <ELSE statement;> \n(2) IF condition;"},"StatementOptions":{"StatementOption":[{"StatementOptionName":"THEN","StatementOptionHelp":{"#cdata":"If the conditions that are specified in the IF clause are met, the IF-THEN statement executes a SAS \nstatement for observations that are read from a SAS data set, for records in an external file, or \nfor computed values."},"StatementOptionType":"S"},{"StatementOptionName":"DO","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct."},"StatementOptionType":"S"},{"StatementOptionName":"WHEN","StatementOptionHelp":{"#cdata":"WHEN statement in an IF-THEN-WHEN construct."},"StatementOptionType":"S"},{"StatementOptionName":"OUTPUT","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct."},"StatementOptionType":"S"},{"StatementOptionName":"GO TO|GOTO","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct. \n          \nSyntax: ... GO TO label; | ... GOTO label;\n      \nJumps to a new statement."},"StatementOptionType":"S"},{"StatementOptionName":"PUT","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct."},"StatementOptionType":"S"},{"StatementOptionName":"STOP","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct. \n          \nStops execution of the current DATA step."},"StatementOptionType":"S"},{"StatementOptionName":"SET","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN construct.\n          \nSyntax: SET <SAS-data-set(s) <(data-set-options(s) )>>; \n      \nReads an observation from one or more SAS data sets."},"StatementOptionType":"S"},{"StatementOptionName":"NOT","StatementOptionType":"S"},{"StatementOptionName":"OR","StatementOptionType":"S"},{"StatementOptionName":"AND","StatementOptionType":"S"}],"#comment":{}}},{"StatementName":"ELSE","StatementHelp":{"#cdata":"If the condition in a IF-THEN statement is false and an ELSE statement is present, then the ELSE \naction is carried out."},"StatementOptions":{"StatementOption":[{"StatementOptionName":"THEN","StatementOptionHelp":{"#cdata":"If the conditions that are specified in the IF clause are met, the IF-THEN statement executes a SAS \nstatement for observations that are read from a SAS data set, for records in an external file, or \nfor computed values."},"StatementOptionType":"S"},{"StatementOptionName":"IF","StatementOptionHelp":{"#cdata":"Executes a SAS statement for observations that meet specific conditions."},"StatementOptionType":"S"},{"StatementOptionName":"DO","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN-ELSE construct."},"StatementOptionType":"S"},{"StatementOptionName":"OUTPUT","StatementOptionHelp":{"#cdata":"Action statement in an IF-THEN-ELSE construct."},"StatementOptionType":"S"},{"StatementOptionName":"NOT","StatementOptionType":"S"},{"StatementOptionName":"OR","StatementOptionType":"S"},{"StatementOptionName":"AND","StatementOptionType":"S"}],"#comment":{}}},{"StatementName":"LINK","StatementHelp":{"#cdata":"Syntax: LINK statement-label; \n      \nDirects program execution immediately to the statement label that is specified and, if followed \nby a RETURN statement, returns execution to the statement that follows the LINK statement."},"StatementOptions":null},{"StatementName":"RETURN","StatementHelp":{"#cdata":"Syntax: RETURN; \n      \nStops executing statements at the current point in the DATA step and returns to a predetermined \npoint in the step."},"StatementOptions":null},{"StatementName":"SELECT","StatementHelp":{"#cdata":"Executes one of several statements or groups of statements.\n      \nSyntax: \nSELECT <(select-expression)>;  \n  WHEN-1 (when-expression-1 <..., when-expression-n>) statement;  \n    <... WHEN-n (when-expression-1 <..., when-expression-n>) statement;>  \n      <OTHERWISE statement;> \nEND;"},"StatementOptions":null},{"StatementName":"WHEN","StatementHelp":{"#cdata":"SELECT groups contain WHEN statements that identify SAS statements that are executed when a particular \ncondition is true. Use at least one WHEN statement in a SELECT group.\n      \nSyntax: WHEN-1 (when-expression-1 <..., when-expression-n>) statement; "},"StatementOptions":{"StatementOption":{"StatementOptionName":"DO","StatementOptionType":"S"}}},{"StatementName":"OTHERWISE","StatementHelp":{"#cdata":"An optional OTHERWISE statement specifies a statement to be executed if no WHEN condition is met. \nAn END statement ends a SELECT group.\n\n      \nSyntax: \n  <... WHEN-n (when-expression-1 <..., when-expression-n>) statement;>  \n    <OTHERWISE statement;>"},"StatementOptions":null},{"StatementName":"STOP","StatementHelp":{"#cdata":"Syntax: STOP ;\n\nThe STOP statement halts the execution of all statements that contain it, including \nDO statements and other control or looping statements. Execution continues with the \nnext top-level source statement."},"StatementOptions":null},{"StatementName":"PUT","StatementHelp":{"#cdata":"Syntax: PUT print-item ...< @ > < @@ > ;\n\nThe PUT statement writes text data to the current output file."},"StatementOptions":{"StatementOption":{"StatementOptionName":"_PAGE_","StatementOptionHelp":{"#cdata":"Outputs any pending line data and moves to the top of the next page."},"StatementOptionType":"S"}}}],"#comment":{}}}}