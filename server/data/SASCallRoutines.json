{"Keywords":{"Keyword":[{"Name":"PRXCHANGE","Type":"CALL_ROUTINE","Help":{"#cdata":"Performs a pattern-matching replacement."}},{"Name":"PRXDEBUG","Type":"CALL_ROUTINE","Help":{"#cdata":"Enables Perl regular expressions in a DATA step to send debug output to the SAS log."}},{"Name":"PRXFREE","Type":"CALL_ROUTINE","Help":{"#cdata":"Frees unneeded memory that was allocated for a Perl regular expression."}},{"Name":"PRXNEXT","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns the position and length of a substring that matches a pattern and iterates \nover multiple matches within one string."}},{"Name":"PRXPOSN","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns the start position and length for a capture buffer."}},{"Name":"PRXSUBSTR","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns the position and length of a substring that matches a pattern."}},{"Name":"RXCHANGE","Type":"CALL_ROUTINE","Help":{"#cdata":"Changes one or more substrings that match a pattern."}},{"Name":"RXFREE","Type":"CALL_ROUTINE","Help":{"#cdata":"Frees memory allocated by other regular expression (RX) functions and routines."}},{"Name":"RXSUBSTR","Type":"CALL_ROUTINE","Help":{"#cdata":"Finds the position, length, and score of a substring that matches a pattern."}},{"Name":"CATS","Type":"CALL_ROUTINE","Help":{"#cdata":"Concatenates character strings and removes leading and trailing blanks."}},{"Name":"CATT","Type":"CALL_ROUTINE","Help":{"#cdata":"Concatenates character strings and removes trailing blanks."}},{"Name":"CATX","Type":"CALL_ROUTINE","Help":{"#cdata":"Concatenates character strings, removes leading and trailing blanks, and inserts separators."}},{"Name":"COMPCOST","Type":"CALL_ROUTINE","Help":{"#cdata":"Sets the costs of operations for later use by the COMPGED function."}},{"Name":"MISSING","Type":"CALL_ROUTINE","Help":{"#cdata":"Assigns a missing value to the specified character or numeric variables.."}},{"Name":"SCAN","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns the position and length of a given word from a character expression."}},{"Name":"SCANQ","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns the position and length of a given word from a character expression, and \nignores delimiters that are enclosed in quotation marks."}},{"Name":"MODULE","Type":"CALL_ROUTINE","Help":{"#cdata":"Calls the external routine without any return code. \n    \nInteraction:\nWhen a SAS server is in a locked-down state, the CALL MODULE routine does not execute. \n\nSyntax: CALL MODULE(<control-string,> module-name <, argument-1, ..., argument-n>);\n\nRequired Argument:\nmodule-name - is the name of the external module to use.\n\nOptional Arguments:\ncontrol-string\n  is an optional control string whose first character must be an asterisk (*), followed by any \n  combination of the following characters:\n    I\n    prints the hexadecimal representations of all arguments to the CALL MODULE routine. You can use \n    this option to help diagnose problems that are caused by incorrect arguments or attribute tables. \n    If you specify the I option, the E option is implied.\n    E\n    prints detailed error messages. Without the E option (or the I option, which supersedes it), \n    the only error message that the CALL MODULE routine generates is \"Invalid argument to function,\" \n    which is usually not enough information to determine the cause of the error. The E option is \n    useful for a production environment, whereas the I option is preferable for a development or \n    debugging environment.\n    H\n    provides brief information about the syntax of the CALL MODULE routine, the attribute file format, \n  and suggested SAS formats and informats. \n\nargument - is one or more arguments to pass to the requested routine."}},{"Name":"EXECUTE","Type":"CALL_ROUTINE","Help":{"#cdata":"Resolves an argument and issues the resolved value for execution ."}},{"Name":"SYMPUT","Type":"CALL_ROUTINE","Help":{"#cdata":"Assigns DATA step information to a macro variable."}},{"Name":"SYMPUTX","Type":"CALL_ROUTINE","Help":{"#cdata":"Assigns a value to a macro variable and removes both leading and trailing blanks."}},{"Name":"ALLPERM","Type":"CALL_ROUTINE","Help":{"#cdata":"Generates all permutations of the values of several variables ."}},{"Name":"LOGISTIC","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns the logistic value."}},{"Name":"SOFTMAX","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns the softmax value."}},{"Name":"STDIZE","Type":"CALL_ROUTINE","Help":{"#cdata":"Standardizes the values of one or more variables."}},{"Name":"TANH","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns the hyperbolic tangent."}},{"Name":"RANBIN","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns a random variate from a binomial distribution."}},{"Name":"RANCAU","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns a random variate from a Cauchy distribution."}},{"Name":"RANEXP","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns a random variate from an exponential distribution."}},{"Name":"RANGAM","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns a random variate from a gamma distribution."}},{"Name":"RANNOR","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns a random variate from a normal distribution."}},{"Name":"RANPERK","Type":"CALL_ROUTINE","Help":{"#cdata":"Randomly permutes the values of the arguments, and returns a permutation of \nk out of n values."}},{"Name":"RANPERM","Type":"CALL_ROUTINE","Help":{"#cdata":"Randomly permutes the values of the arguments."}},{"Name":"RANPOI","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns a random variate from a Poisson distribution."}},{"Name":"RANTBL","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns a random variate from a tabled probability distribution ."}},{"Name":"RANTRI","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns a random variate from a triangular distribution."}},{"Name":"RANUNI","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns a random variate from a uniform distribution."}},{"Name":"STREAMINIT","Type":"CALL_ROUTINE","Help":{"#cdata":"Specifies a seed value to use for subsequent random number generation by the RAND function ."}},{"Name":"POKE","Type":"CALL_ROUTINE","Help":{"#cdata":"Writes a value directly into memory on a 32-bit platform . \n    \nInteraction:\nWhen a SAS server is in a locked-down state, the CALL POKE routine does not execute. \n\nSyntax: CALL POKE(source, pointer <, length> <, floating-point>);\n\nRequired Arguments:\nsource\n  specifies a constant, variable, or expression that contains a value to write into memory \npointer\n  specifies a numeric expression that contains the virtual address of the data that the CALL POKE routine alters.\n\nOptional Arguments:\nlength\n  specifies a numeric constant, variable, or expression that contains the number of bytes to write from the source \n  to the address that is indicated by pointer. If you omit length, the action that the CALL POKE routine takes depends \n  on whether source is a character value or a numeric value:\n    \u2022If source is a character value, the CALL POKE routine copies the entire value of source to the specified memory location.\n    \u2022If source is a numeric value, the CALL POKE routine converts source to a long integer and writes into memory the number \n      of bytes that constitute a pointer.\n\n  z/OS Specifics\n  Under z/OS, pointers are 3 or 4 bytes long, depending on the situation. \n\nfloating-point\n  specifies that the value of source is stored as a floating-point number. The value of floating-point can be any number."}},{"Name":"POKELONG","Type":"CALL_ROUTINE","Help":{"#cdata":"Writes a value directly into memory on 32-bit and 64-bit platforms. \n    \nInteraction:\nWhen a SAS server is in a locked-down state, the CALL POKELONG routine does not execute. \n\nSyntax: CALL POKELONG(source, pointer <, length> <, floating-point>);\nRequired Arguments:\nsource\n  specifies a character constant, variable, or expression that contains a value to write into memory. \npointer\n  specifies a character string that contains the virtual address of the data that the CALL POKELONG routine alters.\n\nOptional Arguments:\nlength\n  specifies a numeric SAS expression that contains the number of bytes to write from the source to the address \n  that is indicated by the pointer. If you omit length, the CALL POKELONG routine copies the entire value of \n  source to the specified memory location. \nfloating-point\n  specifies that the value of source is stored as a floating-point number. The value of floating-point can be any number."}},{"Name":"SLEEP","Type":"CALL_ROUTINE","Help":{"#cdata":"Suspends the execution of a program that invokes this call routine for a specified \nperiod of time."}},{"Name":"SYSTEM","Type":"CALL_ROUTINE","Help":{"#cdata":"Submits an operating environment command for execution."}},{"Name":"LABEL","Type":"CALL_ROUTINE","Help":{"#cdata":"Assigns a variable label to a specified character variable."}},{"Name":"SET","Type":"CALL_ROUTINE","Help":{"#cdata":"Links SAS data set variables to DATA step or macro variables that have the same \nname and data type."}},{"Name":"VNAME","Type":"CALL_ROUTINE","Help":{"#cdata":"Assigns a variable name as the value of a specified variable."}},{"Name":"VNEXT","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns the name, type, and length of a variable that is used in a DATA step."}},{"Name":"ALLCOMB","Type":"CALL_ROUTINE","Help":{"#cdata":"Generates all combinations of the values of n variables taken k at a time in a \nminimal change order."}},{"Name":"ALLCOMBI","Type":"CALL_ROUTINE","Help":{"#cdata":"Generates all combinations of the indices of n objects taken k at a time in a \nminimal change order."}},{"Name":"GRAYCODE","Type":"CALL_ROUTINE","Help":{"#cdata":"Generates all subsets of n items in a minimal change order."}},{"Name":"IS8601_CONVERT","Type":"CALL_ROUTINE","Help":{"#cdata":"Converts an ISO 8601 interval to datetime and duration values, or converts datetime \nand duration values to an ISO 8601 interval. \n\nSyntax: CALL IS8601_CONVERT(convert-from, convert-to, <from-variables>, <to-variables>,<date-time-replacements>);"}},{"Name":"LEXCOMB","Type":"CALL_ROUTINE","Help":{"#cdata":"Generates all distinct combinations of the non-missing values of n variables taken \nk at a time in lexicographic order."}},{"Name":"LEXCOMBI","Type":"CALL_ROUTINE","Help":{"#cdata":"Generates all combinations of the indices of n objects taken k at a time in \nlexicographic order."}},{"Name":"LEXPERK","Type":"CALL_ROUTINE","Help":{"#cdata":"Generates all distinct permutations of the non-missing values of n variables taken \nk at a time in lexicographic order."}},{"Name":"LEXPERM","Type":"CALL_ROUTINE","Help":{"#cdata":"Generates all distinct permutations of the non-missing values of several variables \nin lexicographic order."}},{"Name":"SORTC","Type":"CALL_ROUTINE","Help":{"#cdata":"Sorts the values of character arguments."}},{"Name":"SORTN","Type":"CALL_ROUTINE","Help":{"#cdata":"Sorts the values of numeric arguments."}},{"Name":"DQSCHEMEAPPLY","Type":"CALL_ROUTINE","Help":{"#cdata":"Applies a scheme and returns a transformed value and a transformation flag."}},{"Name":"DQPARSE","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns a parsed character value and a status flag."}},{"Name":"DEFINE","Type":"CALL_ROUTINE","Help":{"#cdata":"Sets the value of an attribute for a particular column in the current row."}},{"Name":"INSERT_CATALOG","Type":"CALL_ROUTINE","Help":{"#cdata":"Inserts a SAS catalog into a package. \n    \nSyntax: \nCALL INSERT_CATALOG(packageId, libname, memname, desc, nameValue, rc); "}},{"Name":"INSERT_DATASET","Type":"CALL_ROUTINE","Help":{"#cdata":"Inserts a SAS data set into a package. \n    \nSyntax:\nCALL INSERT_DATASET(packageId, libname, memname, desc, nameValue, rc <, properties, propValue1, ...propValueN>); "}},{"Name":"INSERT_FDB","Type":"CALL_ROUTINE","Help":{"#cdata":"Inserts a financial database into a package. \n    \nSyntax: \nCALL INSERT_FDB(packageId, libname, memname, desc, nameValue, rc);"}},{"Name":"INSERT_FILE","Type":"CALL_ROUTINE","Help":{"#cdata":"Inserts a file into a package. \n    \nSyntax \nCALL INSERT_FILE(packageId, filename, filetype, mimeType, desc, nameValue, rc<, properties, propValue1, ...propValueN>);"}},{"Name":"INSERT_HTML","Type":"CALL_ROUTINE","Help":{"#cdata":"Inserts HTML files into a package. \n    \nSyntax:\nCALL INSERT_HTML(packageId, body, bodyUrl, frame, frameUrl, contents, contentsUrl, page, pageUrl, desc, nameValue, rc<, properties, propValue1, ...propValueN>);"}},{"Name":"INSERT_MDDB","Type":"CALL_ROUTINE","Help":{"#cdata":"Inserts a SAS multidimensional database into a package. \n    \nSyntax:\nCALL INSERT_MDDB(packageId, libname, memname, desc, nameValue, rc);"}},{"Name":"INSERT_PACKAGE","Type":"CALL_ROUTINE","Help":{"#cdata":"Inserts a package into another package."}},{"Name":"INSERT_REF","Type":"CALL_ROUTINE","Help":{"#cdata":"Inserts a reference into a package. \n    \nSyntax:  \nCALL INSERT_REF(packageId, referenceType, reference, desc, nameValue, rc);"}},{"Name":"INSERT_SQLVIEW","Type":"CALL_ROUTINE","Help":{"#cdata":"Inserts a PROC SQL view into a package. \n    \nSyntax \nCALL INSERT_SQLVIEW(packageId, libname, memname, desc, nameValue, rc);"}},{"Name":"INSERT_VIEWER","Type":"CALL_ROUTINE","Help":{"#cdata":"Inserts a viewer into a package. \n    \nSyntax: \nCALL INSERT_VIEWER(packageId, filename, mimeType, desc, nameValue, rc<, properties, propValue1, ...propValueN>);"}},{"Name":"PACKAGE_BEGIN","Type":"CALL_ROUTINE","Help":{"#cdata":"Initializes a package and returns a unique package identifier. \n    \nSyntax: \nCALL PACKAGE_BEGIN(packageId, desc, nameValue, rc<, properties, propValue1, ...propValueN>);"}},{"Name":"PACKAGE_END","Type":"CALL_ROUTINE","Help":{"#cdata":"Frees the resources that are associated with a package. \n   \nSyntax \nCALL PACKAGE_END(packageId, rc);"}},{"Name":"PACKAGE_PUBLISH","Type":"CALL_ROUTINE","Help":{"#cdata":"Publishes the specified package. The method of publication depends on the type of delivery transport."}},{"Name":"COMPANION_NEXT","Type":"CALL_ROUTINE","Help":{"#cdata":"Retrieves the next companion HTML file in the ODS HTML set. \n    \nSyntax \nCALL COMPANION_NEXT(entryId, path, filename, url, rc <, properties, propValue1, ...propValueN>);"}},{"Name":"ENTRY_FIRST","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns header information for the first entry in a package. \n    \nSyntax: \nCALL ENTRY_FIRST(packageId, entryId, entryType, userSpecString, desc, nameValue, rc<, properties, propValue1, ...propValueN>);"}},{"Name":"ENTRY_NEXT","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns header information from the next entry in a package. \n    \nSyntax: \nCALL ENTRY_NEXT(packageId, entryId, entryType, userSpecString, desc, nameValue, rc<, properties, propValue1, ...propValueN>);"}},{"Name":"PACKAGE_DESTROY","Type":"CALL_ROUTINE","Help":{"#cdata":"Deletes a package. \n    \nSyntax \nCALL PACKAGE_DESTROY(packageId, rc);"}},{"Name":"PACKAGE_FIRST","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns the header information for the first package in the package list. \n    \nSyntax \nCALL PACKAGE_FIRST(pkgListId, packageId, numEntries, desc, dateTime, nameValue, channel, rc<, properties, propValue1, ...propValueN>);"}},{"Name":"PACKAGE_NEXT","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns the header information for the next package in the package list. \n    \nSyntax:\nCALL PACKAGE_NEXT(pkgListId, packageId, numEntries, desc, dateTime, nameValue, channel, rc<, properties, propValue1, ...propValueN>);"}},{"Name":"PACKAGE_TERM","Type":"CALL_ROUTINE","Help":{"#cdata":"Frees all resources associated with the package list identifier. \n    \nSyntax \nCALL PACKAGE_TERM(pkgListId, rc);"}},{"Name":"RETRIEVE_CATALOG","Type":"CALL_ROUTINE","Help":{"#cdata":"Retrieves a catalog from a package. \n    \nSyntax \nCALL RETRIEVE_CATALOG(entryId, libname, memname, rc);"}},{"Name":"RETRIEVE_DATASET","Type":"CALL_ROUTINE","Help":{"#cdata":"This CALL routine retrieves a data set entry from a package. \n    \nSyntax: \nCALL RETRIEVE_DATASET(entryId, libname, memname, rc<, properties, propValue1, ...propValueN>);"}},{"Name":"RETRIEVE_FDB","Type":"CALL_ROUTINE","Help":{"#cdata":"Retrieves a financial database entry from a package. \n    \nSyntax: \nCALL RETRIEVE_FDB(entryId, libname, memname, rc); "}},{"Name":"RETRIEVE_FILE","Type":"CALL_ROUTINE","Help":{"#cdata":"Retrieves an external binary or text file from a package. \n    \nSyntax: \nCALL RETRIEVE_FILE(entryId, filename, rc);"}},{"Name":"RETRIEVE_HTML","Type":"CALL_ROUTINE","Help":{"#cdata":"Retrieves an HTML entry from a package. \n    \nSyntax: \nCALL RETRIEVE_HTML(entryId, path, body, bodyUrl, frame, frameUrl, contents, contentsUrl, pages, pagesUrl, rc<, properties, propValue1, ...propValueN>);"}},{"Name":"RETRIEVE_MDDB","Type":"CALL_ROUTINE","Help":{"#cdata":"Retrieves an MDDB entry from a package. \n    \nSyntax: \nCALL RETRIEVE_MDDB(entryId, libname, memname, rc);"}},{"Name":"RETRIEVE_NESTED","Type":"CALL_ROUTINE","Help":{"#cdata":"Retrieves the descriptive header information for a nested package entry.\n    \nSyntax: \nCALL RETRIEVE_NESTED(entryId,packageId, numEntries, desc, dateTime, nameValue, rc);"}},{"Name":"RETRIEVE_PACKAGE","Type":"CALL_ROUTINE","Help":{"#cdata":"This CALL routine retrieves descriptive header information for all packages. \n    \nSyntax \nCALL RETRIEVE_PACKAGE(pkgListId, retrievalType, retrievalInfo, totalPackages, rc<, properties, propValue1, propValueN>);"}},{"Name":"RETRIEVE_REF","Type":"CALL_ROUTINE","Help":{"#cdata":"Retrieves a reference from a package. \n    \nSyntax: \nCALL RETRIEVE_REF(entryId, referenceType, reference, rc);"}},{"Name":"RETRIEVE_SQLVIEW","Type":"CALL_ROUTINE","Help":{"#cdata":"Retrieves a PROC SQL view from a package. \n    \nSyntax: \nCALL RETRIEVE_SQLVIEW(entryId, libname, memname, rc);"}},{"Name":"RETRIEVE_VIEWER","Type":"CALL_ROUTINE","Help":{"#cdata":"Retrieves a viewer entry from a package.\n\nSyntax:\nCALL RETRIEVE_VIEWER(entryId, filename, rc<, properties, propValue1, ...propValueN>);"}},{"Name":"RANCOMB","Type":"CALL_ROUTINE","Help":{"#cdata":"Permutes the values of the arguments, and returns a random combination of \nk out of n values.\n\nSyntax: \nCALL RANCOMB(seed, k, variable-1<, variable\u20132, ...> ); \n\nRequired Arguments:\nseed \n  is a numeric variable that contains the random number seed. \nk \n  is the number of values that you want to have in the random combination. \n  variable specifies all numeric variables, or all character variables that have the same length. \n  K values of these variables are randomly permuted."}},{"Name":"ADDMATRIX","Type":"CALL_ROUTINE","Help":{"#cdata":"Performs an elementwise addition of two matrices or a matrix and a scalar.\n\n[Valid for PROC FCMP  only!]\n\nSyntax:\nCALL ADDMATRIX(X, Y, Z); \n\nRequired Arguments:\nX \n  specifies an input matrix with dimensions m x n (that is, X[m, n]) or a scalar. \nY \n  specifies an input matrix with dimensions m x n (that is, Y[m, n]) or a scalar. \nZ \n  specifies an output matrix with dimensions m x n (that is, Z[m, n]), such that Z= X + Y"}},{"Name":"CHOL","Type":"CALL_ROUTINE","Help":{"#cdata":"Calculates the Cholesky decomposition for a given symmetric matrix.\n    \nSyntax: [Valid for PROC FCMP  only!]\nCALL CHOL(X, Y <, validate>); \n\nRequired Arguments:\nX \n  specifies a symmetric positive-definite input matrix with dimensions m x m (that is, X[m, m]). \nY \n  specifies an output matrix with dimensions m x m (that is, Y[m, m]). This variable contains \n  the Cholesky decomposition, such that \n  \n      Z = YY*\n\n  where Y is a lower triangular matrix with strictly positive diagonal entries and Y* denotes the \n  conjugate transpose of Y. \n  Note: If X is not symmetric positive-definite, then Y will be filled with missing values. \n\nOptional Argument:\nvalidate \n  specifies an optional argument that can increase the processing speed by avoiding error checking. \n  The argument can take the following values: \n  \n    0 the matrix X will be checked for symmetry. This is the default if the validate argument is omitted.  \n    1 the matrix is assumed to be symmetric."}},{"Name":"DET","Type":"CALL_ROUTINE","Help":{"#cdata":"Calculates the determinant of a specified matrix that should be square.\n\n[Valid for PROC FCMP  only!]\n\nSyntax:\nCALL DET(X, a); \n\nRequired Arguments:\nX \n  specifies an input matrix with dimensions m x n (that is, X[m, m]). \na \n  specifies the returned determinate value, such that \n  \n    a = |X|"}},{"Name":"DYNAMIC_ARRAY","Type":"CALL_ROUTINE","Help":{"#cdata":"Enables an array that is declared within a function to change size in an efficient manner.\n\n[Valid for PROC FCMP  only!]\n\nSyntax:\nCALL DYNAMIC_ARRAY(array\u2013name, new-dim1\u2013size, ...,, new-dimN-size); \n\nRequired Arguments:\narray-name \n  specifies the name of a temporary array. \nnew-dim-size \n  specifies a new size for the temporary array."}},{"Name":"ELEMMULT","Type":"CALL_ROUTINE","Help":{"#cdata":"Performs an elementwise multiplication of two matrices.\n\nSyntax:\nCALL ELEMMULT(X, Y, Z); \n\nRequired Arguments \nX \n  specifies an input matrix with dimensions m x n (that is, X[m, n]). \nY \n  specifies an input matrix with dimensions m x n (that is, Y[m, n]). \nZ \n  specifies an output matrix with dimensions m x n (that is, Z[m, n])."}},{"Name":"EXPMATRIX","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns a matrix e**tA given the input matrix A and a multiplier t. \n    \n[Valid for PROC FCMP  only!]\n\nSyntax:\nCALL EXPMATRIX(X, t, Y); \n\nRequired Arguments:\nX \n  specifies an input matrix with dimensions m x m (that is, X[m, m]). \nt \n  specifies a double scalar value. \nY \n  specifies an output matrix with dimensions m x m (that is, Y[m, m]), such that \n\n      Y = \u0510**t\u1e8a where \u1e8a is the mean of X"}},{"Name":"FILLMATRIX","Type":"CALL_ROUTINE","Help":{"#cdata":"Replaces all of the element values of the input matrix with the specified value.\n \n[Valid for PROC FCMP  only!]\n\nSyntax:\nCALL FILLMATRIX(X, Y); \n\nRequired Arguments:\nX \n  specifies an input numeric matrix. \nY \n  specifies the numeric value that will fill the matrix."}},{"Name":"IDENTITY","Type":"CALL_ROUTINE","Help":{"#cdata":"Converts the input matrix to an identity matrix.\n\n[Valid for PROC FCMP  only!]\n\nSyntax:\nCALL IDENTITY(X); \n\nRequired Argument:\nX \n  specifies an input matrix with dimensions m x m (that is, X[m, m])."}},{"Name":"INV|INVERSE","Type":"CALL_ROUTINE","Help":{"#cdata":"Calculates a matrix that is the inverse of the provided input matrix that should \nbe a square, non-singular matrix.\n \n[Valid for PROC FCMP  only!] \n\nSyntax:\nCALL INV(X, Y); \n\nRequired Arguments:\nX \n  specifies an input matrix with dimensions m x m (that is, X[m, m]). \nY \n  specifies an output matrix with dimensions m x m (that is, Y[m, m]), such that \n  \n    Y[m.m] = X'[m,m]\n\n  where ' denotes inverse \n  \n    X x Y = Y x X = I\n  \nand I is the identity matrix."}},{"Name":"MULT","Type":"CALL_ROUTINE","Help":{"#cdata":"Calculates the multiplicative product of two input matrices.\n\n[Valid for PROC FCMP  only!]\n\nSyntax:\nCALL MULT(X, Y, Z); \n\nRequired Arguments \nX \n  specifies an input matrix with dimensions m x n (that is, X[m, n]). \nY \n  specifies an input matrix with dimensions n x p (that is, Y[n, p]). \nZ \n  specifies an output matrix with dimensions m x p (that is, Z[m, p]), such that \n\n    Z[m,p] = X[m,n] x Y[n,p]"}},{"Name":"POWER","Type":"CALL_ROUTINE","Help":{"#cdata":"Raises a square matrix to a given scalar value.\n \n[Valid for PROC FCMP  only!]\n\nSyntax:\nCALL POWER(X, a, Y); \n\nRequired Arguments:\nX \n  specifies an input matrix with dimensions m x m (that is, X[m, m]). \na \n  specifies an integer scalar value (power). \nY \n  specifies an output matrix with dimensions m x m (that is, Y[m, m]), such that \n\n    Y = X**a"}},{"Name":"SETNULL","Type":"CALL_ROUTINE","Help":{"#cdata":"Sets a pointer element of a structure to null.\n\n[Valid for PROC FCMP  only!]\n\nSyntax:\nCALL SETNULL(pointer-element); \n\nRequired Argument:\npointer-element \n  is a pointer to a structure."}},{"Name":"STRUCTINDEX","Type":"CALL_ROUTINE","Help":{"#cdata":"Enables you to access each structure element in an array of structures.\n    \nSyntax:\nCALL STRUCTINDEX(struct_array, index, struct_element); \n\nRequired Arguments:\nstruct_array \n  specifies an array.\nindex \n  is a 1\u2013based index as used in most SAS arrays. \nstruct_element \n  points to an element in the array."}},{"Name":"SUBTRACTMATRIX","Type":"CALL_ROUTINE","Help":{"#cdata":"Performs an element-wide subtraction of two matrices or a matrix and a scalar.\n\n[Valid for PROC FCMP  only!]\n\nSyntax:\nCALL SUBTRACTMATRIX(X, Y, Z); \n\nRequired Arguments:\nX \n  specifies an input matrix with dimensions m x n (that is, X[m, n]) or a scalar. \nY \n  specifies an input matrix with dimensions m x n (that is, Y[m, n]) or a scalar. \nZ \n  specifies an output matrix with dimensions m x n (that is, Z[m, n]), such that \n    \n      Z = X - Y"}},{"Name":"TRANSPOSE","Type":"CALL_ROUTINE","Help":{"#cdata":"Returns the transpose of a matrix.\n\n[Valid for PROC FCMP  only!]\n\nSyntax: \nCALL TRANSPOSE(X, Y); \n\nRequired Arguments:\nX \n  specifies an input matrix with dimensions m x n (that is, X[m, n]). \nY \n  specifies an output matrix with dimensions n x m (that is, Y[n, m])"}},{"Name":"ZEROMATRIX","Type":"CALL_ROUTINE","Help":{"#cdata":"Replaces all of the element values of the numeric input matrix with 0.\n    \n[Valid for PROC FCMP  only!]\n\nSyntax:\nCALL ZEROMATRIX(X); \n\nRequired Argument \nX \n  specifies a numeric input matrix."}}],"#comment":[{},{},{},{}]}}